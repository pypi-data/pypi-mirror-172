'''
# CDK Monitoring Constructs

[![NPM version](https://badge.fury.io/js/cdk-monitoring-constructs.svg)](https://badge.fury.io/js/cdk-monitoring-constructs)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/io.github.cdklabs/cdkmonitoringconstructs/badge.svg)](https://maven-badges.herokuapp.com/maven-central/io.github.cdklabs/cdkmonitoringconstructs)
[![PyPI version](https://badge.fury.io/py/cdk-monitoring-constructs.svg)](https://badge.fury.io/py/cdk-monitoring-constructs)
[![NuGet version](https://badge.fury.io/nu/Cdklabs.CdkMonitoringConstructs.svg)](https://badge.fury.io/nu/Cdklabs.CdkMonitoringConstructs)
[![Gitpod Ready-to-Code](https://img.shields.io/badge/Gitpod-ready--to--code-blue?logo=gitpod)](https://gitpod.io/#https://github.com/cdklabs/cdk-monitoring-constructs)
[![Mergify](https://img.shields.io/endpoint.svg?url=https://gh.mergify.io/badges/cdklabs/cdk-monitoring-constructs&style=flat)](https://mergify.io)

Easy-to-use CDK constructs for monitoring your AWS infrastructure.

* Easily add commonly-used alarms using predefined properties
* Generate concise Cloudwatch dashboards that indicate your alarms
* Extend the library with your own extensions or custom metrics
* Consume the library in multiple languages (see below)

## Installation

<details><summary><strong>TypeScript</strong></summary>

> https://www.npmjs.com/package/cdk-monitoring-constructs

In your `package.json`:

```json
{
  "dependencies": {
    "cdk-monitoring-constructs": "^1.0.0",

    // peer dependencies of cdk-monitoring-constructs
    "@aws-cdk/aws-apigatewayv2-alpha": "^2.18.0-alpha.0",
    "@aws-cdk/aws-appsync-alpha": "^2.18.0-alpha.0",
    "@aws-cdk/aws-redshift-alpha": "^2.18.0-alpha.0",
    "@aws-cdk/aws-synthetics-alpha": "^2.18.0-alpha.0",
    "aws-cdk-lib": "^2.18.0",
    "constructs": "^10.0.5"

    // ...your other dependencies...
  }
}
```

</details><details><summary><strong>Java</strong></summary>

See https://mvnrepository.com/artifact/io.github.cdklabs/cdkmonitoringconstructs

</details><details><summary><strong>Python</strong></summary>

See https://pypi.org/project/cdk-monitoring-constructs/

</details><details><summary><strong>C#</strong></summary>

See https://www.nuget.org/packages/Cdklabs.CdkMonitoringConstructs/

</details><details><summary><strong>Golang</strong></summary>

Coming soon!

</details>

## Features

You can browse the documentation at https://constructs.dev/packages/cdk-monitoring-constructs/

| Item | Monitoring | Alarms | Notes |
| ---- | ---------- | ------ | ----- |
| AWS API Gateway (REST API) (`.monitorApiGateway()`) | TPS, latency, errors | Latency, error count/rate, low/high TPS | To see metrics, you have to enable Advanced Monitoring |
| AWS API Gateway V2 (HTTP API) (`.monitorApiGatewayV2HttpApi()`) | TPS, latency, errors | Latency, error count/rate, low/high TPS | To see route level metrics, you have to enable Advanced Monitoring |
| AWS AppSync (GraphQL API) (`.monitorAppSyncApi()`) | TPS, latency, errors | Latency, error count/rate, low/high TPS | |
| AWS Billing (`.monitorBilling()`) | AWS account cost | | [Requires enabling](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/gs_monitor_estimated_charges_with_cloudwatch.html#gs_turning_on_billing_metrics) the **Receive Billing Alerts** option in AWS Console / Billing Preferences |
| AWS Certificate Manager (`.monitorCertificate()`) | Certificate expiration | Days until expiration | |
| AWS CloudFront (`.monitorCloudFrontDistribution()`) | TPS, traffic, latency, errors | Error rate, low/high TPS | |
| AWS CloudWatch Logs (`.monitorLog()`) | Patterns present in the log group | | |
| AWS CloudWatch Synthetics Canary (`.monitorSyntheticsCanary()`) | Latency, error count/rate | Error count/rate, latency | |
| AWS CodeBuild (`.monitorCodeBuildProject()`) | Build counts (total, successful, failed), failed rate, duration | Failed build count/rate, duration | |
| AWS DocumentDB (`.monitorDocumentDbCluster()`) | CPU, throttling, read/write latency, transactions, cursors | CPU | |
| AWS DynamoDB (`.monitorDynamoTable()`) | Read and write capacity provisioned / used | Consumed capacity, throttling, latency, errors | |
| AWS DynamoDB Global Secondary Index (`.monitorDynamoTableGlobalSecondaryIndex()`) | Read and write capacity, indexing progress, throttled events | | |
| AWS EC2 (`.monitorEC2Instances()`) | CPU, disk operations, network | | |
| AWS EC2 Auto Scaling Groups (`.monitorAutoScalingGroup()`) | Group size, instance status | | |
| AWS ECS (`.monitorFargateService()`, `.monitorEc2Service()`, `.monitorSimpleFargateService()`, `monitorSimpleEc2Service()`, `.monitorQueueProcessingFargateService()`, `.monitorQueueProcessingEc2Service()`) | System resources and task health | Unhealthy task count, running tasks count, CPU/memory usage, and bytes processed by load balancer (if any) | Use for ecs-patterns load balanced ec2/fargate constructs (NetworkLoadBalancedEc2Service, NetworkLoadBalancedFargateService, ApplicationLoadBalancedEc2Service, ApplicationLoadBalancedFargateService) |
| AWS ElastiCache (`.monitorElastiCacheCluster()`) | CPU/memory usage, evictions and connections | CPU, memory, items count | |
| AWS Glue (`.monitorGlueJob()`) | Traffic, job status, memory/CPU usage | Failed/killed task count/rate | |
| AWS Kinesis Data Analytics (`.monitorKinesisDataAnalytics`) | Up/Downtime, CPU/memory usage, KPU usage, checkpoint metrics, and garbage collection metrics | Downtime, full restart count | |
| AWS Kinesis Data Stream (`.monitorKinesisDataStream()`) | Put/Get/Incoming Record/s and Throttling | Throttling, throughput, iterator max age | |
| AWS Kinesis Firehose (`.monitorKinesisFirehose()`) | Number of records, requests, latency, throttling | Throttling | |
| AWS Lambda (`.monitorLambdaFunction()`) | Latency, errors, iterator max age | Latency, errors, throttles, iterator max age | Optional Lambda Insights metrics (opt-in) support |
| AWS Load Balancing (`.monitorNetworkLoadBalancer()`, `.monitorFargateApplicationLoadBalancer()`, `.monitorFargateNetworkLoadBalancer()`, `.monitorEc2ApplicationLoadBalancer()`, `.monitorEc2NetworkLoadBalancer()`) | System resources and task health | Unhealthy task count, running tasks count, (for Fargate/Ec2 apps) CPU/memory usage | Use for FargateService or Ec2Service backed by a NetworkLoadBalancer or ApplicationLoadBalancer |
| AWS OpenSearch/Elasticsearch (`.monitorOpenSearchCluster()`, `.monitorElasticsearchCluster()`) | Indexing and search latency, disk/memory/CPU usage | Indexing and search latency, disk/memory/CPU usage, cluster status, KMS keys | |
| AWS RDS (`.monitorRdsCluster()`) | Query duration, connections, latency, disk/CPU usage | Connections, disk and CPU usage | |
| AWS Redshift (`.monitorRedshiftCluster()`) | Query duration, connections, latency, disk/CPU usage | Query duration, connections, disk and CPU usage | |
| AWS S3 Bucket (`.monitorS3Bucket()`) | Bucket size and number of objects | | |
| AWS SecretsManager (`.monitorSecretsManagerSecret()`) | Days since last rotation | Days since last change or rotation | |
| AWS SNS Topic (`.monitorSnsTopic()`) | Message count, size, failed notifications | Failed notifications, min/max published messages | |
| AWS SQS Queue (`.monitorSqsQueue()`, `.monitorSqsQueueWithDlq()`) | Message count, age, size | Message count, age, DLQ incoming messages | |
| AWS Step Functions (`.monitorStepFunction()`, `.monitorStepFunctionActivity()`, `monitorStepFunctionLambdaIntegration()`, `.monitorStepFunctionServiceIntegration()`) | Execution count and breakdown per state | Duration, failed, failed rate, aborted, throttled, timed out executions | |
| AWS Web Application Firewall (`.monitorWebApplicationFirewallAcl()`) | Allowed/blocked requests | | |
| Custom metrics (`.monitorCustom()`) | Addition of custom metrics into the dashboard (each group is a widget) | | Supports anomaly detection |

## Getting started

### Create monitoring stack and facade

*Important note*: **Please, do NOT import anything from the `/dist/lib` package.** This is unsupported and might break any time.

Create an instance of `MonitoringFacade`, which is the main entry point:

```python
export interface MonitoringStackProps extends DeploymentStackProps {
  // ...
}

export class MonitoringStack extends DeploymentStack {
  constructor(parent: App, name: string, props: MonitoringStackProps) {
    super(parent, name, props);

    const monitoring = new MonitoringFacade(this, "Monitoring", {
      // Defaults are provided for these, but they can be customized as desired
      metricFactoryDefaults: { ... },
      alarmFactoryDefaults: { ... },
      dashboardFactory: { ... },
    });

    // Monitor your resources
    monitoring
      .addLargeHeader("Storage")
      .monitorDynamoTable({ /* table1 */ })
      .monitorDynamoTable({ /* table2 */ })
      .monitorDynamoTable({ /* table3 */ })
      // etc.
  }
}
```

### Set up your monitoring

Once the facade is created, you can use it to call methods like `.monitorLambdaFunction()` and chain them together to define your monitors.

You can also use facade methods to add your own widgets, headers of various sizes, and more.

### Customize actions

Alarms should have an action setup, otherwise they are not very useful. Currently, we support notifying an SNS queue.

```python
const onAlarmTopic = new Topic(this, "AlarmTopic");

const monitoring = new MonitoringFacade(this, "Monitoring", {
  // ...other props
  alarmFactoryDefaults: {
    // ....other props
    action: new SnsAlarmActionStrategy({ onAlarmTopic }),
  },
});
```

You can override the default topic for any alarm like this:

```python
monitoring
  .monitorSomething(something, {
    addSomeAlarm: {
      Warning: {
        // ...other props
        threshold: 42,
        actionOverride: new SnsAlarmActionStrategy({ onAlarmTopic }),
      }
    }
  });
```

### Custom metrics

For simply adding some custom metrics, you can use `.monitorCustom()` and specify your own title and metric groups.
Each metric group will be rendered as a single graph widget, and all widgets will be placed next to each other.
All the widgets will have the same size, which is chosen based on the number of groups to maximize dashboard space usage.

Custom metric monitoring can be created for simple metrics, simple metrics with anomaly detection and search metrics.
The first two also support alarming.

Below we are listing a couple of examples. Let us assume that there are three existing metric variables: `m1`, `m2`, `m3`.
They can either be created by hand (`new Metric({...})`) or (preferably) by using `metricFactory` (that can be obtained from facade).
The advantage of using the shared `metricFactory` is that you do not need to worry about period, etc.

```python
// create metrics manually
const m1 = new Metric(/* ... */);
```

```python
const metricFactory = monitoringFacade.createMetricFactory();

// create metrics using metric factory
const m1 = metricFactory.createMetric(/* ... */);
```

#### Example: metric with anomaly detection

In this case, only one metric is supported.
Multiple metrics cannot be rendered with anomaly detection in a single widget due to a CloudWatch limitation.

```python
monitorCustom({
  title: "Metric with anomaly detection",
  metrics: [
    {
      metric: m1,
      anomalyDetectionStandardDeviationToRender: 3
    }
  ]
})
```

Adding an alarm:

```python
monitorCustom({
  title: "Metric with anomaly detection and alarm",
  metrics: [
    {
      metric: m1,
      alarmFriendlyName: "MetricWithAnomalyDetectionAlarm",
      anomalyDetectionStandardDeviationToRender: 3,
      addAlarmOnAnomaly: {
        Warning: {
          standardDeviationForAlarm: 4,
          alarmWhenAboveTheBand: true,
          alarmWhenBelowTheBand: true
        }
      }
    }
  ]
})
```

#### Example: search metrics

```python
monitorCustom({
  title: "Metric search",
  metrics: [
    {
      searchQuery: "My.Prefix.",
      dimensionsMap: {
        FirstDimension: "FirstDimensionValue",
        // Allow any value for the given dimension (pardon the weird typing to satisfy DimensionsMap)
        SecondDimension: undefined as unknown as string
      }
    }
  ]
})
```

Search metric does not support setting an alarm, that is a CloudWatch limitation.

### Custom monitoring segment

If you want even more flexibility, you can create your own Dashboard Segment.

This is a general procedure on how to do it:

1. Extend the `Monitoring` class
2. Override the `widgets()` method (and/or similar ones)
3. Leverage the metric factor and alarm factory, provided by the base class (you can create additional factories, if you will)
4. Add all alarms to `.addAlarm()` so they are visible to the user and being placed on the alarm summary dashboard

Both of these monitoring base classes are dashboard segments, so you can add them to your monitoring by calling `.addSegment()`.

### Monitoring Scopes

With CDK Monitoring Constructs, you can monitor complete CDK construct scopes. It will automatically discover all monitorable resources within the scope (recursively)) and add them to your dashboard.

```python
monitoring.monitorScope(stack);
```

You can also specify default alarms for any specific resource and disable automatic monitoring for it as well.

```python
monitoring.monitorScope(stack, {
  lambda: {
    props: {
      addLatencyP50Alarm: {
        Critical: { maxLatency: Duration.seconds(10) },
      },
    },
  },

  // Some resources that aren't dependent on nodes (e.g. general metrics across instances/account) may be included
  // by default, but can be explicitly disabled.
  billing: { enabled: false },
  ec2: { enabled: false },
  elasticCache: { enabled: false },
});
```

## Contributing/Security

See [CONTRIBUTING](CONTRIBUTING.md) for more information.

## License

This project is licensed under the Apache-2.0 License.
'''
import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import aws_cdk
import aws_cdk.aws_apigateway
import aws_cdk.aws_apigatewayv2_alpha
import aws_cdk.aws_appsync_alpha
import aws_cdk.aws_autoscaling
import aws_cdk.aws_certificatemanager
import aws_cdk.aws_cloudfront
import aws_cdk.aws_cloudwatch
import aws_cdk.aws_cloudwatch_actions
import aws_cdk.aws_codebuild
import aws_cdk.aws_docdb
import aws_cdk.aws_dynamodb
import aws_cdk.aws_ecs
import aws_cdk.aws_ecs_patterns
import aws_cdk.aws_elasticloadbalancingv2
import aws_cdk.aws_elasticsearch
import aws_cdk.aws_lambda
import aws_cdk.aws_opensearchservice
import aws_cdk.aws_rds
import aws_cdk.aws_s3
import aws_cdk.aws_secretsmanager
import aws_cdk.aws_sns
import aws_cdk.aws_sqs
import aws_cdk.aws_stepfunctions
import aws_cdk.aws_synthetics_alpha
import aws_cdk.aws_wafv2
import constructs


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AddAlarmProps",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_description": "alarmDescription",
        "alarm_name_suffix": "alarmNameSuffix",
        "comparison_operator": "comparisonOperator",
        "threshold": "threshold",
        "treat_missing_data": "treatMissingData",
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_dedupe_string_suffix": "alarmDedupeStringSuffix",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "disambiguator": "disambiguator",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "override_annotation_color": "overrideAnnotationColor",
        "override_annotation_label": "overrideAnnotationLabel",
        "override_annotation_visibility": "overrideAnnotationVisibility",
        "period": "period",
        "runbook_link": "runbookLink",
    },
)
class AddAlarmProps:
    def __init__(
        self,
        *,
        alarm_description: builtins.str,
        alarm_name_suffix: builtins.str,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        threshold: jsii.Number,
        treat_missing_data: aws_cdk.aws_cloudwatch.TreatMissingData,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties necessary to create a single alarm and configure it.

        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique.
        :param comparison_operator: (experimental) Comparison operator used to compare actual value against the threshold.
        :param threshold: (experimental) Threshold to alarm on.
        :param treat_missing_data: (experimental) Behaviour in case the metric data is missing.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state.
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones. Default: - undefined (no disambiguator)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - Same as datapointsToAlarm.
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, an artificial composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param override_annotation_color: (experimental) If specified, it modifies the final alarm annotation color. Default: - no override (default color)
        :param override_annotation_label: (experimental) If specified, it modifies the final alarm annotation label. Default: - no override (default label)
        :param override_annotation_visibility: (experimental) If specified, it modifies the final alarm annotation visibility. Default: - no override (default visibility)
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AddAlarmProps.__init__)
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_dedupe_string_suffix", value=alarm_dedupe_string_suffix, expected_type=type_hints["alarm_dedupe_string_suffix"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument override_annotation_color", value=override_annotation_color, expected_type=type_hints["override_annotation_color"])
            check_type(argname="argument override_annotation_label", value=override_annotation_label, expected_type=type_hints["override_annotation_label"])
            check_type(argname="argument override_annotation_visibility", value=override_annotation_visibility, expected_type=type_hints["override_annotation_visibility"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarm_description": alarm_description,
            "alarm_name_suffix": alarm_name_suffix,
            "comparison_operator": comparison_operator,
            "threshold": threshold,
            "treat_missing_data": treat_missing_data,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_dedupe_string_suffix is not None:
            self._values["alarm_dedupe_string_suffix"] = alarm_dedupe_string_suffix
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if override_annotation_color is not None:
            self._values["override_annotation_color"] = override_annotation_color
        if override_annotation_label is not None:
            self._values["override_annotation_label"] = override_annotation_label
        if override_annotation_visibility is not None:
            self._values["override_annotation_visibility"] = override_annotation_visibility
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link

    @builtins.property
    def alarm_description(self) -> builtins.str:
        '''(experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible.

        :stability: experimental
        '''
        result = self._values.get("alarm_description")
        assert result is not None, "Required property 'alarm_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_name_suffix(self) -> builtins.str:
        '''(experimental) Suffix added to base alarm name.

        Alarm names need to be unique.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_suffix")
        assert result is not None, "Required property 'alarm_name_suffix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def comparison_operator(self) -> aws_cdk.aws_cloudwatch.ComparisonOperator:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :stability: experimental
        '''
        result = self._values.get("comparison_operator")
        assert result is not None, "Required property 'comparison_operator' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.ComparisonOperator, result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''(experimental) Threshold to alarm on.

        :stability: experimental
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def treat_missing_data(self) -> aws_cdk.aws_cloudwatch.TreatMissingData:
        '''(experimental) Behaviour in case the metric data is missing.

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data")
        assert result is not None, "Required property 'treat_missing_data' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.TreatMissingData, result)

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default action strategy.

        :default: - default action will be used

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_dedupe_string_suffix(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix.

        This allows you to specify the same dedupe string for a family of alarms.
        Cannot be defined at the same time as alarmDedupeStringOverride.

        :default: - undefined (no suffix)

        :stability: experimental
        '''
        result = self._values.get("alarm_dedupe_string_suffix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''(experimental) Disambiguator is a string that differentiates this alarm from other similar ones.

        :default: - undefined (no disambiguator)

        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - Same as datapointsToAlarm.

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, an artificial composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def override_annotation_color(self) -> typing.Optional[builtins.str]:
        '''(experimental) If specified, it modifies the final alarm annotation color.

        :default: - no override (default color)

        :stability: experimental
        '''
        result = self._values.get("override_annotation_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_annotation_label(self) -> typing.Optional[builtins.str]:
        '''(experimental) If specified, it modifies the final alarm annotation label.

        :default: - no override (default label)

        :stability: experimental
        '''
        result = self._values.get("override_annotation_label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_annotation_visibility(self) -> typing.Optional[builtins.bool]:
        '''(experimental) If specified, it modifies the final alarm annotation visibility.

        :default: - no override (default visibility)

        :stability: experimental
        '''
        result = self._values.get("override_annotation_visibility")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AddCompositeAlarmProps",
    jsii_struct_bases=[],
    name_mapping={
        "disambiguator": "disambiguator",
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_dedupe_string_suffix": "alarmDedupeStringSuffix",
        "alarm_description": "alarmDescription",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "alarm_name_suffix": "alarmNameSuffix",
        "composite_operator": "compositeOperator",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "fill_alarm_range": "fillAlarmRange",
        "runbook_link": "runbookLink",
    },
)
class AddCompositeAlarmProps:
    def __init__(
        self,
        *,
        disambiguator: builtins.str,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        alarm_name_suffix: typing.Optional[builtins.str] = None,
        composite_operator: typing.Optional["CompositeAlarmOperator"] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Properties necessary to create a composite alarm and configure it.

        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible. Default: - no description
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique. Default: - no suffix
        :param composite_operator: (experimental) Logical operator used to aggregate the status individual alarms. Default: - OR
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AddCompositeAlarmProps.__init__)
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_dedupe_string_suffix", value=alarm_dedupe_string_suffix, expected_type=type_hints["alarm_dedupe_string_suffix"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument composite_operator", value=composite_operator, expected_type=type_hints["composite_operator"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
        self._values: typing.Dict[str, typing.Any] = {
            "disambiguator": disambiguator,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_dedupe_string_suffix is not None:
            self._values["alarm_dedupe_string_suffix"] = alarm_dedupe_string_suffix
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if alarm_name_suffix is not None:
            self._values["alarm_name_suffix"] = alarm_name_suffix
        if composite_operator is not None:
            self._values["composite_operator"] = composite_operator
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link

    @builtins.property
    def disambiguator(self) -> builtins.str:
        '''(experimental) Disambiguator is a string that differentiates this alarm from other similar ones.

        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        assert result is not None, "Required property 'disambiguator' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default action strategy.

        :default: - default action will be used

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_dedupe_string_suffix(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix.

        This allows you to specify the same dedupe string for a family of alarms.
        Cannot be defined at the same time as alarmDedupeStringOverride.

        :default: - undefined (no suffix)

        :stability: experimental
        '''
        result = self._values.get("alarm_dedupe_string_suffix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''(experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible.

        :default: - no description

        :stability: experimental
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_suffix(self) -> typing.Optional[builtins.str]:
        '''(experimental) Suffix added to base alarm name.

        Alarm names need to be unique.

        :default: - no suffix

        :stability: experimental
        '''
        result = self._values.get("alarm_name_suffix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def composite_operator(self) -> typing.Optional["CompositeAlarmOperator"]:
        '''(experimental) Logical operator used to aggregate the status individual alarms.

        :default: - OR

        :stability: experimental
        '''
        result = self._values.get("composite_operator")
        return typing.cast(typing.Optional["CompositeAlarmOperator"], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AddCompositeAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AgeAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AgeAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: "AlarmFactory") -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AgeAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addDaysSinceUpdateAlarm")
    def add_days_since_update_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["DaysSinceUpdateThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> "AlarmWithAnnotation":
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AgeAlarmFactory.add_days_since_update_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast("AlarmWithAnnotation", jsii.invoke(self, "addDaysSinceUpdateAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addDaysToExpiryAlarm")
    def add_days_to_expiry_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["DaysToExpiryThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> "AlarmWithAnnotation":
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AgeAlarmFactory.add_days_to_expiry_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast("AlarmWithAnnotation", jsii.invoke(self, "addDaysToExpiryAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addIteratorMaxAgeAlarm")
    def add_iterator_max_age_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxAgeThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> "AlarmWithAnnotation":
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AgeAlarmFactory.add_iterator_max_age_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast("AlarmWithAnnotation", jsii.invoke(self, "addIteratorMaxAgeAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> "AlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("AlarmFactory", jsii.get(self, "alarmFactory"))


class AlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        alarm_scope: constructs.Construct,
        *,
        global_alarm_defaults: typing.Union["AlarmFactoryDefaults", typing.Dict[str, typing.Any]],
        global_metric_defaults: typing.Union["MetricFactoryDefaults", typing.Dict[str, typing.Any]],
        local_alarm_name_prefix: builtins.str,
    ) -> None:
        '''
        :param alarm_scope: -
        :param global_alarm_defaults: 
        :param global_metric_defaults: 
        :param local_alarm_name_prefix: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory.__init__)
            check_type(argname="argument alarm_scope", value=alarm_scope, expected_type=type_hints["alarm_scope"])
        props = AlarmFactoryProps(
            global_alarm_defaults=global_alarm_defaults,
            global_metric_defaults=global_metric_defaults,
            local_alarm_name_prefix=local_alarm_name_prefix,
        )

        jsii.create(self.__class__, self, [alarm_scope, props])

    @jsii.member(jsii_name="addAlarm")
    def add_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        *,
        alarm_description: builtins.str,
        alarm_name_suffix: builtins.str,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        threshold: jsii.Number,
        treat_missing_data: aws_cdk.aws_cloudwatch.TreatMissingData,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> "AlarmWithAnnotation":
        '''
        :param metric: -
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique.
        :param comparison_operator: (experimental) Comparison operator used to compare actual value against the threshold.
        :param threshold: (experimental) Threshold to alarm on.
        :param treat_missing_data: (experimental) Behaviour in case the metric data is missing.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state.
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones. Default: - undefined (no disambiguator)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - Same as datapointsToAlarm.
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, an artificial composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param override_annotation_color: (experimental) If specified, it modifies the final alarm annotation color. Default: - no override (default color)
        :param override_annotation_label: (experimental) If specified, it modifies the final alarm annotation label. Default: - no override (default label)
        :param override_annotation_visibility: (experimental) If specified, it modifies the final alarm annotation visibility. Default: - no override (default visibility)
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory.add_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
        props = AddAlarmProps(
            alarm_description=alarm_description,
            alarm_name_suffix=alarm_name_suffix,
            comparison_operator=comparison_operator,
            threshold=threshold,
            treat_missing_data=treat_missing_data,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            custom_params=custom_params,
            custom_tags=custom_tags,
            datapoints_to_alarm=datapoints_to_alarm,
            dedupe_string_override=dedupe_string_override,
            disambiguator=disambiguator,
            documentation_link=documentation_link,
            evaluate_low_sample_count_percentile=evaluate_low_sample_count_percentile,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            period=period,
            runbook_link=runbook_link,
        )

        return typing.cast("AlarmWithAnnotation", jsii.invoke(self, "addAlarm", [metric, props]))

    @jsii.member(jsii_name="addCompositeAlarm")
    def add_composite_alarm(
        self,
        alarms: typing.Sequence[typing.Union["AlarmWithAnnotation", typing.Dict[str, typing.Any]]],
        *,
        disambiguator: builtins.str,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        alarm_name_suffix: typing.Optional[builtins.str] = None,
        composite_operator: typing.Optional["CompositeAlarmOperator"] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.CompositeAlarm:
        '''
        :param alarms: -
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible. Default: - no description
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique. Default: - no suffix
        :param composite_operator: (experimental) Logical operator used to aggregate the status individual alarms. Default: - OR
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory.add_composite_alarm)
            check_type(argname="argument alarms", value=alarms, expected_type=type_hints["alarms"])
        props = AddCompositeAlarmProps(
            disambiguator=disambiguator,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_description=alarm_description,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            alarm_name_suffix=alarm_name_suffix,
            composite_operator=composite_operator,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            fill_alarm_range=fill_alarm_range,
            runbook_link=runbook_link,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.CompositeAlarm, jsii.invoke(self, "addCompositeAlarm", [alarms, props]))

    @jsii.member(jsii_name="createAnnotation")
    def _create_annotation(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: "IAlarmActionStrategy",
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, jsii.invoke(self, "createAnnotation", [props]))

    @jsii.member(jsii_name="determineActionsEnabled")
    def _determine_actions_enabled(
        self,
        actions_enabled: typing.Optional[builtins.bool] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> builtins.bool:
        '''
        :param actions_enabled: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory._determine_actions_enabled)
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(builtins.bool, jsii.invoke(self, "determineActionsEnabled", [actions_enabled, disambiguator]))

    @jsii.member(jsii_name="determineCompositeAlarmRule")
    def _determine_composite_alarm_rule(
        self,
        alarms: typing.Sequence[typing.Union["AlarmWithAnnotation", typing.Dict[str, typing.Any]]],
        *,
        disambiguator: builtins.str,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        alarm_name_suffix: typing.Optional[builtins.str] = None,
        composite_operator: typing.Optional["CompositeAlarmOperator"] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.IAlarmRule:
        '''
        :param alarms: -
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible. Default: - no description
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique. Default: - no suffix
        :param composite_operator: (experimental) Logical operator used to aggregate the status individual alarms. Default: - OR
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory._determine_composite_alarm_rule)
            check_type(argname="argument alarms", value=alarms, expected_type=type_hints["alarms"])
        props = AddCompositeAlarmProps(
            disambiguator=disambiguator,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_description=alarm_description,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            alarm_name_suffix=alarm_name_suffix,
            composite_operator=composite_operator,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            fill_alarm_range=fill_alarm_range,
            runbook_link=runbook_link,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.IAlarmRule, jsii.invoke(self, "determineCompositeAlarmRule", [alarms, props]))

    @jsii.member(jsii_name="generateDescription")
    def _generate_description(
        self,
        alarm_description: builtins.str,
        alarm_description_override: typing.Optional[builtins.str] = None,
        runbook_link_override: typing.Optional[builtins.str] = None,
        documentation_link_override: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''
        :param alarm_description: -
        :param alarm_description_override: -
        :param runbook_link_override: -
        :param documentation_link_override: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory._generate_description)
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument runbook_link_override", value=runbook_link_override, expected_type=type_hints["runbook_link_override"])
            check_type(argname="argument documentation_link_override", value=documentation_link_override, expected_type=type_hints["documentation_link_override"])
        return typing.cast(builtins.str, jsii.invoke(self, "generateDescription", [alarm_description, alarm_description_override, runbook_link_override, documentation_link_override]))

    @jsii.member(jsii_name="joinDescriptionParts")
    def _join_description_parts(self, *parts: builtins.str) -> builtins.str:
        '''
        :param parts: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactory._join_description_parts)
            check_type(argname="argument parts", value=parts, expected_type=typing.Tuple[type_hints["parts"], ...]) # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(builtins.str, jsii.invoke(self, "joinDescriptionParts", [*parts]))

    @builtins.property
    @jsii.member(jsii_name="alarmNamingStrategy")
    def _alarm_naming_strategy(self) -> "AlarmNamingStrategy":
        '''
        :stability: experimental
        '''
        return typing.cast("AlarmNamingStrategy", jsii.get(self, "alarmNamingStrategy"))

    @builtins.property
    @jsii.member(jsii_name="alarmScope")
    def _alarm_scope(self) -> constructs.Construct:
        '''
        :stability: experimental
        '''
        return typing.cast(constructs.Construct, jsii.get(self, "alarmScope"))

    @builtins.property
    @jsii.member(jsii_name="globalAlarmDefaults")
    def _global_alarm_defaults(self) -> "AlarmFactoryDefaults":
        '''
        :stability: experimental
        '''
        return typing.cast("AlarmFactoryDefaults", jsii.get(self, "globalAlarmDefaults"))

    @builtins.property
    @jsii.member(jsii_name="globalMetricDefaults")
    def _global_metric_defaults(self) -> "MetricFactoryDefaults":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactoryDefaults", jsii.get(self, "globalMetricDefaults"))

    @builtins.property
    @jsii.member(jsii_name="shouldUseDefaultDedupeForError")
    def should_use_default_dedupe_for_error(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "shouldUseDefaultDedupeForError"))

    @builtins.property
    @jsii.member(jsii_name="shouldUseDefaultDedupeForLatency")
    def should_use_default_dedupe_for_latency(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "shouldUseDefaultDedupeForLatency"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmFactoryDefaults",
    jsii_struct_bases=[],
    name_mapping={
        "actions_enabled": "actionsEnabled",
        "alarm_name_prefix": "alarmNamePrefix",
        "action": "action",
        "annotation_strategy": "annotationStrategy",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_processor": "dedupeStringProcessor",
        "documentation_link": "documentationLink",
        "evaluation_periods": "evaluationPeriods",
        "runbook_link": "runbookLink",
        "use_default_dedupe_for_error": "useDefaultDedupeForError",
        "use_default_dedupe_for_latency": "useDefaultDedupeForLatency",
    },
)
class AlarmFactoryDefaults:
    def __init__(
        self,
        *,
        actions_enabled: typing.Union[builtins.bool, typing.Mapping[builtins.str, builtins.bool]],
        alarm_name_prefix: builtins.str,
        action: typing.Optional["IAlarmActionStrategy"] = None,
        annotation_strategy: typing.Optional["IAlarmAnnotationStrategy"] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_processor: typing.Optional["IAlarmDedupeStringProcessor"] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        use_default_dedupe_for_error: typing.Optional[builtins.bool] = None,
        use_default_dedupe_for_latency: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions for either all severities, or per severity.
        :param alarm_name_prefix: (experimental) Global prefix for all alarm names. This should be something unique to avoid collisions with other CTIs. This is ignored if an alarm's dedupeStringOverride is declared.
        :param action: (experimental) Default alarm action used for each alarm, unless it is overridden. Default: - no action.
        :param annotation_strategy: (experimental) Custom strategy to create annotations for alarms. Default: - default annotations
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - 3
        :param dedupe_string_processor: (experimental) Custom strategy to process dedupe strings of the alarms. Default: - default behaviour (no change)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body.
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - Same as datapointsToAlarm.
        :param runbook_link: (experimental) An optional link included in the generated ticket description body.
        :param use_default_dedupe_for_error: (experimental) If this is defined as false and dedupeStringOverride is undefined, the alarm prefix will be part of the dedupe string. This essentially stops the dedupe of different errors together. Default: - undefined (true)
        :param use_default_dedupe_for_latency: (experimental) If this is defined as false and dedupeStringOverride is undefined, the alarm prefix will be part of the dedupe string. This essentially stops the dedupe of different latency issues together. Default: - undefined (true)

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactoryDefaults.__init__)
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_name_prefix", value=alarm_name_prefix, expected_type=type_hints["alarm_name_prefix"])
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument annotation_strategy", value=annotation_strategy, expected_type=type_hints["annotation_strategy"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_processor", value=dedupe_string_processor, expected_type=type_hints["dedupe_string_processor"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument use_default_dedupe_for_error", value=use_default_dedupe_for_error, expected_type=type_hints["use_default_dedupe_for_error"])
            check_type(argname="argument use_default_dedupe_for_latency", value=use_default_dedupe_for_latency, expected_type=type_hints["use_default_dedupe_for_latency"])
        self._values: typing.Dict[str, typing.Any] = {
            "actions_enabled": actions_enabled,
            "alarm_name_prefix": alarm_name_prefix,
        }
        if action is not None:
            self._values["action"] = action
        if annotation_strategy is not None:
            self._values["annotation_strategy"] = annotation_strategy
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_processor is not None:
            self._values["dedupe_string_processor"] = dedupe_string_processor
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if use_default_dedupe_for_error is not None:
            self._values["use_default_dedupe_for_error"] = use_default_dedupe_for_error
        if use_default_dedupe_for_latency is not None:
            self._values["use_default_dedupe_for_latency"] = use_default_dedupe_for_latency

    @builtins.property
    def actions_enabled(
        self,
    ) -> typing.Union[builtins.bool, typing.Mapping[builtins.str, builtins.bool]]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions for either all severities, or per severity.

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        assert result is not None, "Required property 'actions_enabled' is missing"
        return typing.cast(typing.Union[builtins.bool, typing.Mapping[builtins.str, builtins.bool]], result)

    @builtins.property
    def alarm_name_prefix(self) -> builtins.str:
        '''(experimental) Global prefix for all alarm names.

        This should be something unique to avoid collisions with other CTIs.
        This is ignored if an alarm's dedupeStringOverride is declared.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_prefix")
        assert result is not None, "Required property 'alarm_name_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def action(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Default alarm action used for each alarm, unless it is overridden.

        :default: - no action.

        :stability: experimental
        '''
        result = self._values.get("action")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def annotation_strategy(self) -> typing.Optional["IAlarmAnnotationStrategy"]:
        '''(experimental) Custom strategy to create annotations for alarms.

        :default: - default annotations

        :stability: experimental
        '''
        result = self._values.get("annotation_strategy")
        return typing.cast(typing.Optional["IAlarmAnnotationStrategy"], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - 3

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_processor(self) -> typing.Optional["IAlarmDedupeStringProcessor"]:
        '''(experimental) Custom strategy to process dedupe strings of the alarms.

        :default: - default behaviour (no change)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_processor")
        return typing.cast(typing.Optional["IAlarmDedupeStringProcessor"], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - Same as datapointsToAlarm.

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def use_default_dedupe_for_error(self) -> typing.Optional[builtins.bool]:
        '''(experimental) If this is defined as false and dedupeStringOverride is undefined, the alarm prefix will be part of the dedupe string.

        This essentially stops the dedupe of different errors together.

        :default: - undefined (true)

        :stability: experimental
        '''
        result = self._values.get("use_default_dedupe_for_error")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_default_dedupe_for_latency(self) -> typing.Optional[builtins.bool]:
        '''(experimental) If this is defined as false and dedupeStringOverride is undefined, the alarm prefix will be part of the dedupe string.

        This essentially stops the dedupe of different latency issues together.

        :default: - undefined (true)

        :stability: experimental
        '''
        result = self._values.get("use_default_dedupe_for_latency")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmFactoryDefaults(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "global_alarm_defaults": "globalAlarmDefaults",
        "global_metric_defaults": "globalMetricDefaults",
        "local_alarm_name_prefix": "localAlarmNamePrefix",
    },
)
class AlarmFactoryProps:
    def __init__(
        self,
        *,
        global_alarm_defaults: typing.Union[AlarmFactoryDefaults, typing.Dict[str, typing.Any]],
        global_metric_defaults: typing.Union["MetricFactoryDefaults", typing.Dict[str, typing.Any]],
        local_alarm_name_prefix: builtins.str,
    ) -> None:
        '''
        :param global_alarm_defaults: 
        :param global_metric_defaults: 
        :param local_alarm_name_prefix: 

        :stability: experimental
        '''
        if isinstance(global_alarm_defaults, dict):
            global_alarm_defaults = AlarmFactoryDefaults(**global_alarm_defaults)
        if isinstance(global_metric_defaults, dict):
            global_metric_defaults = MetricFactoryDefaults(**global_metric_defaults)
        if __debug__:
            type_hints = typing.get_type_hints(AlarmFactoryProps.__init__)
            check_type(argname="argument global_alarm_defaults", value=global_alarm_defaults, expected_type=type_hints["global_alarm_defaults"])
            check_type(argname="argument global_metric_defaults", value=global_metric_defaults, expected_type=type_hints["global_metric_defaults"])
            check_type(argname="argument local_alarm_name_prefix", value=local_alarm_name_prefix, expected_type=type_hints["local_alarm_name_prefix"])
        self._values: typing.Dict[str, typing.Any] = {
            "global_alarm_defaults": global_alarm_defaults,
            "global_metric_defaults": global_metric_defaults,
            "local_alarm_name_prefix": local_alarm_name_prefix,
        }

    @builtins.property
    def global_alarm_defaults(self) -> AlarmFactoryDefaults:
        '''
        :stability: experimental
        '''
        result = self._values.get("global_alarm_defaults")
        assert result is not None, "Required property 'global_alarm_defaults' is missing"
        return typing.cast(AlarmFactoryDefaults, result)

    @builtins.property
    def global_metric_defaults(self) -> "MetricFactoryDefaults":
        '''
        :stability: experimental
        '''
        result = self._values.get("global_metric_defaults")
        assert result is not None, "Required property 'global_metric_defaults' is missing"
        return typing.cast("MetricFactoryDefaults", result)

    @builtins.property
    def local_alarm_name_prefix(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix")
        assert result is not None, "Required property 'local_alarm_name_prefix' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AlarmMatrixWidget(
    aws_cdk.aws_cloudwatch.AlarmStatusWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AlarmMatrixWidget",
):
    '''(experimental) Wrapper of Alarm Status Widget which auto-calcultes height based on the number of alarms.

    Always takes the maximum width.

    :stability: experimental
    '''

    def __init__(
        self,
        *,
        alarms: typing.Sequence[aws_cdk.aws_cloudwatch.IAlarm],
        height: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarms: (experimental) list of alarms to show.
        :param height: (experimental) desired height. Default: - auto calculated based on alarm number (3 to 8)
        :param title: (experimental) widget title. Default: - no title

        :stability: experimental
        '''
        props = AlarmMatrixWidgetProps(alarms=alarms, height=height, title=title)

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmMatrixWidgetProps",
    jsii_struct_bases=[],
    name_mapping={"alarms": "alarms", "height": "height", "title": "title"},
)
class AlarmMatrixWidgetProps:
    def __init__(
        self,
        *,
        alarms: typing.Sequence[aws_cdk.aws_cloudwatch.IAlarm],
        height: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarms: (experimental) list of alarms to show.
        :param height: (experimental) desired height. Default: - auto calculated based on alarm number (3 to 8)
        :param title: (experimental) widget title. Default: - no title

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmMatrixWidgetProps.__init__)
            check_type(argname="argument alarms", value=alarms, expected_type=type_hints["alarms"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarms": alarms,
        }
        if height is not None:
            self._values["height"] = height
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def alarms(self) -> typing.List[aws_cdk.aws_cloudwatch.IAlarm]:
        '''(experimental) list of alarms to show.

        :stability: experimental
        '''
        result = self._values.get("alarms")
        assert result is not None, "Required property 'alarms' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IAlarm], result)

    @builtins.property
    def height(self) -> typing.Optional[jsii.Number]:
        '''(experimental) desired height.

        :default: - auto calculated based on alarm number (3 to 8)

        :stability: experimental
        '''
        result = self._values.get("height")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''(experimental) widget title.

        :default: - no title

        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmMatrixWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmMetadata",
    jsii_struct_bases=[],
    name_mapping={
        "action": "action",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "dedupe_string": "dedupeString",
        "disambiguator": "disambiguator",
    },
)
class AlarmMetadata:
    def __init__(
        self,
        *,
        action: "IAlarmActionStrategy",
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Metadata of an alarm.

        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmMetadata.__init__)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
        }
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator

    @builtins.property
    def action(self) -> "IAlarmActionStrategy":
        '''
        :stability: experimental
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast("IAlarmActionStrategy", result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmMetadata(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmNamingInput",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_name_suffix": "alarmNameSuffix",
        "alarm_dedupe_string_suffix": "alarmDedupeStringSuffix",
        "alarm_name_override": "alarmNameOverride",
        "dedupe_string_override": "dedupeStringOverride",
        "disambiguator": "disambiguator",
    },
)
class AlarmNamingInput:
    def __init__(
        self,
        *,
        alarm_name_suffix: builtins.str,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm_name_suffix: 
        :param alarm_dedupe_string_suffix: 
        :param alarm_name_override: 
        :param dedupe_string_override: 
        :param disambiguator: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmNamingInput.__init__)
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument alarm_dedupe_string_suffix", value=alarm_dedupe_string_suffix, expected_type=type_hints["alarm_dedupe_string_suffix"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarm_name_suffix": alarm_name_suffix,
        }
        if alarm_dedupe_string_suffix is not None:
            self._values["alarm_dedupe_string_suffix"] = alarm_dedupe_string_suffix
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator

    @builtins.property
    def alarm_name_suffix(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_name_suffix")
        assert result is not None, "Required property 'alarm_name_suffix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_dedupe_string_suffix(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_dedupe_string_suffix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmNamingInput(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AlarmNamingStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AlarmNamingStrategy",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        global_prefix: builtins.str,
        local_prefix: builtins.str,
        dedupe_string_strategy: typing.Optional["IAlarmDedupeStringProcessor"] = None,
    ) -> None:
        '''
        :param global_prefix: -
        :param local_prefix: -
        :param dedupe_string_strategy: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmNamingStrategy.__init__)
            check_type(argname="argument global_prefix", value=global_prefix, expected_type=type_hints["global_prefix"])
            check_type(argname="argument local_prefix", value=local_prefix, expected_type=type_hints["local_prefix"])
            check_type(argname="argument dedupe_string_strategy", value=dedupe_string_strategy, expected_type=type_hints["dedupe_string_strategy"])
        jsii.create(self.__class__, self, [global_prefix, local_prefix, dedupe_string_strategy])

    @jsii.member(jsii_name="getDedupeString")
    def get_dedupe_string(
        self,
        *,
        alarm_name_suffix: builtins.str,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> typing.Optional[builtins.str]:
        '''(experimental) Dedupe string resolved like this: - If "dedupeStringOverride" is defined for an alarm, it will be used as a dedupe string.

        - If "alarmDedupeStringSuffix" from the alarm factory is defined, "GlobalPrefix-LocalPrefix-AlarmDedupeStringSuffix" will be used as a dedupe string.
        - Otherwise, the alarm dedupe string will not be set.
          If a dedupe string strategy is set, it will be used to process the final string.

        :param alarm_name_suffix: 
        :param alarm_dedupe_string_suffix: 
        :param alarm_name_override: 
        :param dedupe_string_override: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmNamingInput(
            alarm_name_suffix=alarm_name_suffix,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_name_override=alarm_name_override,
            dedupe_string_override=dedupe_string_override,
            disambiguator=disambiguator,
        )

        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getDedupeString", [props]))

    @jsii.member(jsii_name="getName")
    def get_name(
        self,
        *,
        alarm_name_suffix: builtins.str,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''(experimental) Alarm name is resolved like this: - If "alarmNameOverride" is defined for an alarm, it will be used as alarm name.

        - Otherwise, the alarm name will be generated by joining: global prefix, local prefix, alarm name suffix, disambiguator.

        :param alarm_name_suffix: 
        :param alarm_dedupe_string_suffix: 
        :param alarm_name_override: 
        :param dedupe_string_override: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmNamingInput(
            alarm_name_suffix=alarm_name_suffix,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_name_override=alarm_name_override,
            dedupe_string_override=dedupe_string_override,
            disambiguator=disambiguator,
        )

        return typing.cast(builtins.str, jsii.invoke(self, "getName", [props]))

    @jsii.member(jsii_name="getWidgetLabel")
    def get_widget_label(
        self,
        *,
        alarm_name_suffix: builtins.str,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''
        :param alarm_name_suffix: 
        :param alarm_dedupe_string_suffix: 
        :param alarm_name_override: 
        :param dedupe_string_override: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmNamingInput(
            alarm_name_suffix=alarm_name_suffix,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_name_override=alarm_name_override,
            dedupe_string_override=dedupe_string_override,
            disambiguator=disambiguator,
        )

        return typing.cast(builtins.str, jsii.invoke(self, "getWidgetLabel", [props]))

    @jsii.member(jsii_name="joinDistinct")
    def _join_distinct(
        self,
        parts: typing.Sequence[builtins.str],
        separator: builtins.str,
    ) -> builtins.str:
        '''
        :param parts: -
        :param separator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmNamingStrategy._join_distinct)
            check_type(argname="argument parts", value=parts, expected_type=type_hints["parts"])
            check_type(argname="argument separator", value=separator, expected_type=type_hints["separator"])
        return typing.cast(builtins.str, jsii.invoke(self, "joinDistinct", [parts, separator]))

    @builtins.property
    @jsii.member(jsii_name="dedupeStringStrategy")
    def _dedupe_string_strategy(self) -> "IAlarmDedupeStringProcessor":
        '''
        :stability: experimental
        '''
        return typing.cast("IAlarmDedupeStringProcessor", jsii.get(self, "dedupeStringStrategy"))

    @builtins.property
    @jsii.member(jsii_name="globalPrefix")
    def _global_prefix(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "globalPrefix"))

    @builtins.property
    @jsii.member(jsii_name="localPrefix")
    def _local_prefix(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "localPrefix"))


class AlarmSummaryMatrixWidget(
    aws_cdk.aws_cloudwatch.ConcreteWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AlarmSummaryMatrixWidget",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        alarm_arns: typing.Sequence[builtins.str],
        height: typing.Optional[jsii.Number] = None,
        region: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        width: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param alarm_arns: 
        :param height: Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.
        :param region: The region the metrics of this graph should be taken from. Default: - Current region
        :param title: Title for the graph. Default: - None
        :param width: Width of the widget, in a grid of 24 units wide. Default: 6

        :stability: experimental
        '''
        props = AlarmSummaryMatrixWidgetProps(
            alarm_arns=alarm_arns,
            height=height,
            region=region,
            title=title,
            width=width,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.List[typing.Any]:
        '''(experimental) Return the widget JSON for use in the dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[typing.Any], jsii.invoke(self, "toJson", []))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "AlarmSummaryMatrixWidgetProps":
        '''
        :stability: experimental
        '''
        return typing.cast("AlarmSummaryMatrixWidgetProps", jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmSummaryMatrixWidgetPropertiesJson",
    jsii_struct_bases=[],
    name_mapping={"alarms": "alarms", "title": "title"},
)
class AlarmSummaryMatrixWidgetPropertiesJson:
    def __init__(
        self,
        *,
        alarms: typing.Sequence[builtins.str],
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarms: 
        :param title: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmSummaryMatrixWidgetPropertiesJson.__init__)
            check_type(argname="argument alarms", value=alarms, expected_type=type_hints["alarms"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarms": alarms,
        }
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def alarms(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarms")
        assert result is not None, "Required property 'alarms' is missing"
        return typing.cast(typing.List[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmSummaryMatrixWidgetPropertiesJson(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmSummaryMatrixWidgetProps",
    jsii_struct_bases=[aws_cdk.aws_cloudwatch.MetricWidgetProps],
    name_mapping={
        "height": "height",
        "region": "region",
        "title": "title",
        "width": "width",
        "alarm_arns": "alarmArns",
    },
)
class AlarmSummaryMatrixWidgetProps(aws_cdk.aws_cloudwatch.MetricWidgetProps):
    def __init__(
        self,
        *,
        height: typing.Optional[jsii.Number] = None,
        region: typing.Optional[builtins.str] = None,
        title: typing.Optional[builtins.str] = None,
        width: typing.Optional[jsii.Number] = None,
        alarm_arns: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param height: Height of the widget. Default: - 6 for Alarm and Graph widgets. 3 for single value widgets where most recent value of a metric is displayed.
        :param region: The region the metrics of this graph should be taken from. Default: - Current region
        :param title: Title for the graph. Default: - None
        :param width: Width of the widget, in a grid of 24 units wide. Default: 6
        :param alarm_arns: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmSummaryMatrixWidgetProps.__init__)
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument alarm_arns", value=alarm_arns, expected_type=type_hints["alarm_arns"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarm_arns": alarm_arns,
        }
        if height is not None:
            self._values["height"] = height
        if region is not None:
            self._values["region"] = region
        if title is not None:
            self._values["title"] = title
        if width is not None:
            self._values["width"] = width

    @builtins.property
    def height(self) -> typing.Optional[jsii.Number]:
        '''Height of the widget.

        :default:

        - 6 for Alarm and Graph widgets.
        3 for single value widgets where most recent value of a metric is displayed.
        '''
        result = self._values.get("height")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''The region the metrics of this graph should be taken from.

        :default: - Current region
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''Title for the graph.

        :default: - None
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def width(self) -> typing.Optional[jsii.Number]:
        '''Width of the widget, in a grid of 24 units wide.

        :default: 6
        '''
        result = self._values.get("width")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_arns(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_arns")
        assert result is not None, "Required property 'alarm_arns' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmSummaryMatrixWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmWithAnnotation",
    jsii_struct_bases=[AlarmMetadata],
    name_mapping={
        "action": "action",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "dedupe_string": "dedupeString",
        "disambiguator": "disambiguator",
        "alarm": "alarm",
        "alarm_description": "alarmDescription",
        "alarm_label": "alarmLabel",
        "alarm_name": "alarmName",
        "alarm_name_suffix": "alarmNameSuffix",
        "alarm_rule_when_alarming": "alarmRuleWhenAlarming",
        "alarm_rule_when_insufficient_data": "alarmRuleWhenInsufficientData",
        "alarm_rule_when_ok": "alarmRuleWhenOk",
        "annotation": "annotation",
    },
)
class AlarmWithAnnotation(AlarmMetadata):
    def __init__(
        self,
        *,
        action: "IAlarmActionStrategy",
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        alarm_description: builtins.str,
        alarm_label: builtins.str,
        alarm_name: builtins.str,
        alarm_name_suffix: builtins.str,
        alarm_rule_when_alarming: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_insufficient_data: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_ok: aws_cdk.aws_cloudwatch.IAlarmRule,
        annotation: typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]],
    ) -> None:
        '''(experimental) Representation of an alarm with additional information.

        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 
        :param alarm: 
        :param alarm_description: 
        :param alarm_label: 
        :param alarm_name: 
        :param alarm_name_suffix: 
        :param alarm_rule_when_alarming: 
        :param alarm_rule_when_insufficient_data: 
        :param alarm_rule_when_ok: 
        :param annotation: 

        :stability: experimental
        '''
        if isinstance(annotation, dict):
            annotation = aws_cdk.aws_cloudwatch.HorizontalAnnotation(**annotation)
        if __debug__:
            type_hints = typing.get_type_hints(AlarmWithAnnotation.__init__)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
            check_type(argname="argument alarm", value=alarm, expected_type=type_hints["alarm"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_label", value=alarm_label, expected_type=type_hints["alarm_label"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument alarm_rule_when_alarming", value=alarm_rule_when_alarming, expected_type=type_hints["alarm_rule_when_alarming"])
            check_type(argname="argument alarm_rule_when_insufficient_data", value=alarm_rule_when_insufficient_data, expected_type=type_hints["alarm_rule_when_insufficient_data"])
            check_type(argname="argument alarm_rule_when_ok", value=alarm_rule_when_ok, expected_type=type_hints["alarm_rule_when_ok"])
            check_type(argname="argument annotation", value=annotation, expected_type=type_hints["annotation"])
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
            "alarm": alarm,
            "alarm_description": alarm_description,
            "alarm_label": alarm_label,
            "alarm_name": alarm_name,
            "alarm_name_suffix": alarm_name_suffix,
            "alarm_rule_when_alarming": alarm_rule_when_alarming,
            "alarm_rule_when_insufficient_data": alarm_rule_when_insufficient_data,
            "alarm_rule_when_ok": alarm_rule_when_ok,
            "annotation": annotation,
        }
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator

    @builtins.property
    def action(self) -> "IAlarmActionStrategy":
        '''
        :stability: experimental
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast("IAlarmActionStrategy", result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm(self) -> aws_cdk.aws_cloudwatch.AlarmBase:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm")
        assert result is not None, "Required property 'alarm' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.AlarmBase, result)

    @builtins.property
    def alarm_description(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_description")
        assert result is not None, "Required property 'alarm_description' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_label(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_label")
        assert result is not None, "Required property 'alarm_label' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_name")
        assert result is not None, "Required property 'alarm_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_name_suffix(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_name_suffix")
        assert result is not None, "Required property 'alarm_name_suffix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_rule_when_alarming(self) -> aws_cdk.aws_cloudwatch.IAlarmRule:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_rule_when_alarming")
        assert result is not None, "Required property 'alarm_rule_when_alarming' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.IAlarmRule, result)

    @builtins.property
    def alarm_rule_when_insufficient_data(self) -> aws_cdk.aws_cloudwatch.IAlarmRule:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_rule_when_insufficient_data")
        assert result is not None, "Required property 'alarm_rule_when_insufficient_data' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.IAlarmRule, result)

    @builtins.property
    def alarm_rule_when_ok(self) -> aws_cdk.aws_cloudwatch.IAlarmRule:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_rule_when_ok")
        assert result is not None, "Required property 'alarm_rule_when_ok' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.IAlarmRule, result)

    @builtins.property
    def annotation(self) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''
        :stability: experimental
        '''
        result = self._values.get("annotation")
        assert result is not None, "Required property 'annotation' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmWithAnnotation(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AnomalyDetectingAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AnomalyDetectingAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AnomalyDetectingAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addAlarmWhenOutOfBand")
    def add_alarm_when_out_of_band(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        alarm_name_suffix: builtins.str,
        disambiguator: builtins.str,
        *,
        alarm_when_above_the_band: builtins.bool,
        alarm_when_below_the_band: builtins.bool,
        standard_deviation_for_alarm: jsii.Number,
        additional_description: typing.Optional[builtins.str] = None,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param alarm_name_suffix: -
        :param disambiguator: -
        :param alarm_when_above_the_band: 
        :param alarm_when_below_the_band: 
        :param standard_deviation_for_alarm: 
        :param additional_description: 
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AnomalyDetectingAlarmFactory.add_alarm_when_out_of_band)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        props = AnomalyDetectionThreshold(
            alarm_when_above_the_band=alarm_when_above_the_band,
            alarm_when_below_the_band=alarm_when_below_the_band,
            standard_deviation_for_alarm=standard_deviation_for_alarm,
            additional_description=additional_description,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            comparison_operator_override=comparison_operator_override,
            custom_params=custom_params,
            custom_tags=custom_tags,
            datapoints_to_alarm=datapoints_to_alarm,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            evaluate_low_sample_count_percentile=evaluate_low_sample_count_percentile,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            period=period,
            runbook_link=runbook_link,
            treat_missing_data_override=treat_missing_data_override,
        )

        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addAlarmWhenOutOfBand", [metric, alarm_name_suffix, disambiguator, props]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class AnomalyDetectionMathExpression(
    aws_cdk.aws_cloudwatch.MathExpression,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AnomalyDetectionMathExpression",
):
    '''(experimental) Captures specific MathExpression for anomaly detection, for which alarm generation is different.

    Added to overcome certain CDK limitations at the time of writing.

    :see: https://github.com/aws/aws-cdk/issues/10540
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        expression: builtins.str,
        using_metrics: typing.Optional[typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric]] = None,
        color: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        search_account: typing.Optional[builtins.str] = None,
        search_region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param expression: The expression defining the metric. When an expression contains a SEARCH function, it cannot be used within an Alarm.
        :param using_metrics: The metrics used in the expression, in a map. The key is the identifier that represents the given metric in the expression, and the value is the actual Metric object. Default: - Empty map.
        :param color: Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - Expression value is used as label
        :param period: The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)
        :param search_account: Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.
        :param search_region: Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MathExpressionProps(
            expression=expression,
            using_metrics=using_metrics,
            color=color,
            label=label,
            period=period,
            search_account=search_account,
            search_region=search_region,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="createAlarm")
    def create_alarm(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        evaluation_periods: jsii.Number,
        threshold: jsii.Number,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.str] = None,
        treat_missing_data: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
    ) -> aws_cdk.aws_cloudwatch.Alarm:
        '''(experimental) Make a new Alarm for this metric.

        Combines both properties that may adjust the metric (aggregation) as well
        as alarm properties.

        :param scope: -
        :param id: -
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold.
        :param threshold: The value against which the specified statistic is compared.
        :param actions_enabled: Whether the actions for this alarm are enabled. Default: true
        :param alarm_description: Description for the alarm. Default: No description
        :param alarm_name: Name of the alarm. Default: Automatically generated name
        :param comparison_operator: Comparison to use to check if metric is breaching. Default: GreaterThanOrEqualToThreshold
        :param datapoints_to_alarm: The number of datapoints that must be breaching to trigger the alarm. This is used only if you are setting an "M out of N" alarm. In that case, this value is the M. For more information, see Evaluating an Alarm in the Amazon CloudWatch User Guide. Default: ``evaluationPeriods``
        :param evaluate_low_sample_count_percentile: Specifies whether to evaluate the data and potentially change the alarm state if there are too few data points to be statistically significant. Used only for alarms that are based on percentiles. Default: - Not configured.
        :param treat_missing_data: Sets how this alarm is to handle missing data points. Default: TreatMissingData.Missing

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AnomalyDetectionMathExpression.create_alarm)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = aws_cdk.aws_cloudwatch.CreateAlarmOptions(
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            actions_enabled=actions_enabled,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluate_low_sample_count_percentile=evaluate_low_sample_count_percentile,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Alarm, jsii.invoke(self, "createAlarm", [scope, id, props]))

    @jsii.member(jsii_name="with")
    def with_(
        self,
        *,
        color: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        search_account: typing.Optional[builtins.str] = None,
        search_region: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.MathExpression:
        '''(experimental) Return a copy of Metric with properties changed.

        All properties except namespace and metricName can be changed.

        :param color: Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - Expression value is used as label
        :param period: The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)
        :param search_account: Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.
        :param search_region: Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MathExpressionOptions(
            color=color,
            label=label,
            period=period,
            search_account=search_account,
            search_region=search_region,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.MathExpression, jsii.invoke(self, "with", [props]))


class ApiGatewayMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ApiGatewayMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        api: aws_cdk.aws_apigateway.RestApiBase,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param api: (experimental) API to monitor (cannot use IRestApi, since it does not provide API name).
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - prod
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = ApiGatewayMetricFactoryProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metric4XXErrorCount")
    def metric4_xx_error_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4XXErrorCount", []))

    @jsii.member(jsii_name="metric4XXErrorRate")
    def metric4_xx_error_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4XXErrorRate", []))

    @jsii.member(jsii_name="metric5XXFaultCount")
    def metric5_xx_fault_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5XXFaultCount", []))

    @jsii.member(jsii_name="metric5XXFaultRate")
    def metric5_xx_fault_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5XXFaultRate", []))

    @jsii.member(jsii_name="metricInvocationCount")
    def metric_invocation_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationCount", []))

    @jsii.member(jsii_name="metricInvocationRate")
    def metric_invocation_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationRate", []))

    @jsii.member(jsii_name="metricLatencyInMillis")
    def metric_latency_in_millis(
        self,
        latency_type: "LatencyType",
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param latency_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMetricFactory.metric_latency_in_millis)
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyInMillis", [latency_type]))

    @jsii.member(jsii_name="metricLatencyP50InMillis")
    def metric_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricLatencyP90InMillis")
    def metric_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricLatencyP99InMillis")
    def metric_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricTps")
    def metric_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricInvocationRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTps", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="fillTpsWithZeroes")
    def _fill_tps_with_zeroes(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "fillTpsWithZeroes"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "api": "api",
        "api_method": "apiMethod",
        "api_resource": "apiResource",
        "api_stage": "apiStage",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class ApiGatewayMetricFactoryProps:
    def __init__(
        self,
        *,
        api: aws_cdk.aws_apigateway.RestApiBase,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param api: (experimental) API to monitor (cannot use IRestApi, since it does not provide API name).
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - prod
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMetricFactoryProps.__init__)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument api_method", value=api_method, expected_type=type_hints["api_method"])
            check_type(argname="argument api_resource", value=api_resource, expected_type=type_hints["api_resource"])
            check_type(argname="argument api_stage", value=api_stage, expected_type=type_hints["api_stage"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if api_method is not None:
            self._values["api_method"] = api_method
        if api_resource is not None:
            self._values["api_resource"] = api_resource
        if api_stage is not None:
            self._values["api_stage"] = api_stage
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def api(self) -> aws_cdk.aws_apigateway.RestApiBase:
        '''(experimental) API to monitor (cannot use IRestApi, since it does not provide API name).

        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_apigateway.RestApiBase, result)

    @builtins.property
    def api_method(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_resource(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_resource")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_stage(self) -> typing.Optional[builtins.str]:
        '''
        :default: - prod

        :stability: experimental
        '''
        result = self._values.get("api_stage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiGatewayV2HttpApiMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ApiGatewayV2HttpApiMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        api: aws_cdk.aws_apigatewayv2_alpha.IHttpApi,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param api: 
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - $default
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = ApiGatewayV2HttpApiMetricFactoryProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metric4xxCount")
    def metric4xx_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4xxCount", []))

    @jsii.member(jsii_name="metric4xxRate")
    def metric4xx_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4xxRate", []))

    @jsii.member(jsii_name="metric5xxCount")
    def metric5xx_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5xxCount", []))

    @jsii.member(jsii_name="metric5xxRate")
    def metric5xx_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5xxRate", []))

    @jsii.member(jsii_name="metricIntegrationLatencyInMillis")
    def metric_integration_latency_in_millis(
        self,
        latency_type: "LatencyType",
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param latency_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMetricFactory.metric_integration_latency_in_millis)
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIntegrationLatencyInMillis", [latency_type]))

    @jsii.member(jsii_name="metricIntegrationLatencyP50InMillis")
    def metric_integration_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricIntegrationLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIntegrationLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricIntegrationLatencyP90InMillis")
    def metric_integration_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricIntegrationLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIntegrationLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricIntegrationLatencyP99InMillis")
    def metric_integration_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricIntegrationLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIntegrationLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricInvocationCount")
    def metric_invocation_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationCount", []))

    @jsii.member(jsii_name="metricInvocationRate")
    def metric_invocation_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationRate", []))

    @jsii.member(jsii_name="metricLatencyInMillis")
    def metric_latency_in_millis(
        self,
        latency_type: "LatencyType",
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param latency_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMetricFactory.metric_latency_in_millis)
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyInMillis", [latency_type]))

    @jsii.member(jsii_name="metricLatencyP50InMillis")
    def metric_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricLatencyP90InMillis")
    def metric_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricLatencyP99InMillis")
    def metric_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricLatencyInMillis instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricTps")
    def metric_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricInvocationRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTps", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="fillTpsWithZeroes")
    def _fill_tps_with_zeroes(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "fillTpsWithZeroes"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayV2HttpApiMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "api": "api",
        "api_method": "apiMethod",
        "api_resource": "apiResource",
        "api_stage": "apiStage",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class ApiGatewayV2HttpApiMetricFactoryProps:
    def __init__(
        self,
        *,
        api: aws_cdk.aws_apigatewayv2_alpha.IHttpApi,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param api: 
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - $default
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMetricFactoryProps.__init__)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument api_method", value=api_method, expected_type=type_hints["api_method"])
            check_type(argname="argument api_resource", value=api_resource, expected_type=type_hints["api_resource"])
            check_type(argname="argument api_stage", value=api_stage, expected_type=type_hints["api_stage"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if api_method is not None:
            self._values["api_method"] = api_method
        if api_resource is not None:
            self._values["api_resource"] = api_resource
        if api_stage is not None:
            self._values["api_stage"] = api_stage
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def api(self) -> aws_cdk.aws_apigatewayv2_alpha.IHttpApi:
        '''
        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_apigatewayv2_alpha.IHttpApi, result)

    @builtins.property
    def api_method(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_resource(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_resource")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_stage(self) -> typing.Optional[builtins.str]:
        '''
        :default: - $default

        :stability: experimental
        '''
        result = self._values.get("api_stage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayV2HttpApiMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AppSyncMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AppSyncMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        api: aws_cdk.aws_appsync_alpha.GraphqlApi,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param api: (experimental) the GraphQL API to monitor.
        :param fill_tps_with_zeroes: (experimental) whether the TPS should be filled with zeroes. Default: - true
        :param rate_computation_method: (experimental) method to compute TPS. Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = AppSyncMetricFactoryProps(
            api=api,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metric4XXErrorCount")
    def metric4_xx_error_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4XXErrorCount", []))

    @jsii.member(jsii_name="metric4XXErrorRate")
    def metric4_xx_error_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4XXErrorRate", []))

    @jsii.member(jsii_name="metric5XXFaultCount")
    def metric5_xx_fault_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5XXFaultCount", []))

    @jsii.member(jsii_name="metric5XXFaultRate")
    def metric5_xx_fault_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5XXFaultRate", []))

    @jsii.member(jsii_name="metricLatencyP50InMillis")
    def metric_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricLatencyP90InMillis")
    def metric_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricLatencyP99InMillis")
    def metric_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricRequestCount")
    def metric_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRequestCount", []))

    @jsii.member(jsii_name="metricRequestRate")
    def metric_request_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRequestRate", []))

    @jsii.member(jsii_name="metricTps")
    def metric_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricRequestRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTps", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="fillTpsWithZeroes")
    def _fill_tps_with_zeroes(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "fillTpsWithZeroes"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AppSyncMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "api": "api",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class AppSyncMetricFactoryProps:
    def __init__(
        self,
        *,
        api: aws_cdk.aws_appsync_alpha.GraphqlApi,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param api: (experimental) the GraphQL API to monitor.
        :param fill_tps_with_zeroes: (experimental) whether the TPS should be filled with zeroes. Default: - true
        :param rate_computation_method: (experimental) method to compute TPS. Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMetricFactoryProps.__init__)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def api(self) -> aws_cdk.aws_appsync_alpha.GraphqlApi:
        '''(experimental) the GraphQL API to monitor.

        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_appsync_alpha.GraphqlApi, result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''(experimental) whether the TPS should be filled with zeroes.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''(experimental) method to compute TPS.

        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSyncMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApplicationLoadBalancerMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "application_load_balancer": "applicationLoadBalancer",
        "application_target_group": "applicationTargetGroup",
    },
)
class ApplicationLoadBalancerMetricFactoryProps:
    def __init__(
        self,
        *,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
    ) -> None:
        '''(experimental) Props to create ApplicationLoadBalancerMetricFactory.

        :param application_load_balancer: 
        :param application_target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApplicationLoadBalancerMetricFactoryProps.__init__)
            check_type(argname="argument application_load_balancer", value=application_load_balancer, expected_type=type_hints["application_load_balancer"])
            check_type(argname="argument application_target_group", value=application_target_group, expected_type=type_hints["application_target_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "application_load_balancer": application_load_balancer,
            "application_target_group": application_target_group,
        }

    @builtins.property
    def application_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_load_balancer")
        assert result is not None, "Required property 'application_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, result)

    @builtins.property
    def application_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_target_group")
        assert result is not None, "Required property 'application_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoScalingGroupMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AutoScalingGroupMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        auto_scaling_group: aws_cdk.aws_autoscaling.IAutoScalingGroup,
    ) -> None:
        '''
        :param metric_factory: -
        :param auto_scaling_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = AutoScalingGroupMetricFactoryProps(
            auto_scaling_group=auto_scaling_group
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricGroupDesiredCapacity")
    def metric_group_desired_capacity(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The number of instances that the Auto Scaling group attempts to maintain.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupDesiredCapacity", []))

    @jsii.member(jsii_name="metricGroupInServiceInstances")
    def metric_group_in_service_instances(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The number of instances that are running as part of the Auto Scaling group.

        This metric does not include instances that are pending or terminating.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupInServiceInstances", []))

    @jsii.member(jsii_name="metricGroupMaxSize")
    def metric_group_max_size(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The maximum size of the Auto Scaling group.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupMaxSize", []))

    @jsii.member(jsii_name="metricGroupMinSize")
    def metric_group_min_size(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The minimum size of the Auto Scaling group.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupMinSize", []))

    @jsii.member(jsii_name="metricGroupPendingInstances")
    def metric_group_pending_instances(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The number of instances that are pending.

        A pending instance is not yet in service.
        This metric does not include instances that are in service or terminating.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupPendingInstances", []))

    @jsii.member(jsii_name="metricGroupStandbyInstances")
    def metric_group_standby_instances(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The number of instances that are in a Standby state.

        Instances in this state are still running but are not actively in service.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupStandbyInstances", []))

    @jsii.member(jsii_name="metricGroupTerminatingInstances")
    def metric_group_terminating_instances(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The number of instances that are in the process of terminating.

        This metric does not include instances that are in service or pending.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupTerminatingInstances", []))

    @jsii.member(jsii_name="metricGroupTotalInstances")
    def metric_group_total_instances(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) The total number of instances in the Auto Scaling group.

        This metric identifies the number of instances that are in service, pending, and terminating.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGroupTotalInstances", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AutoScalingGroupMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"auto_scaling_group": "autoScalingGroup"},
)
class AutoScalingGroupMetricFactoryProps:
    def __init__(
        self,
        *,
        auto_scaling_group: aws_cdk.aws_autoscaling.IAutoScalingGroup,
    ) -> None:
        '''
        :param auto_scaling_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMetricFactoryProps.__init__)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "auto_scaling_group": auto_scaling_group,
        }

    @builtins.property
    def auto_scaling_group(self) -> aws_cdk.aws_autoscaling.IAutoScalingGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        assert result is not None, "Required property 'auto_scaling_group' is missing"
        return typing.cast(aws_cdk.aws_autoscaling.IAutoScalingGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AwsConsoleUrlFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AwsConsoleUrlFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        aws_account_id: builtins.str,
        aws_account_region: builtins.str,
    ) -> None:
        '''
        :param aws_account_id: 
        :param aws_account_region: 

        :stability: experimental
        '''
        props = AwsConsoleUrlFactoryProps(
            aws_account_id=aws_account_id, aws_account_region=aws_account_region
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="getApiGatewayUrl")
    def get_api_gateway_url(
        self,
        rest_api_id: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param rest_api_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_api_gateway_url)
            check_type(argname="argument rest_api_id", value=rest_api_id, expected_type=type_hints["rest_api_id"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getApiGatewayUrl", [rest_api_id]))

    @jsii.member(jsii_name="getAwsConsoleUrl")
    def get_aws_console_url(
        self,
        destination_url: typing.Optional[builtins.str] = None,
    ) -> typing.Optional[builtins.str]:
        '''
        :param destination_url: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_aws_console_url)
            check_type(argname="argument destination_url", value=destination_url, expected_type=type_hints["destination_url"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getAwsConsoleUrl", [destination_url]))

    @jsii.member(jsii_name="getCloudFrontDistributionUrl")
    def get_cloud_front_distribution_url(
        self,
        distribution_id: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param distribution_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_cloud_front_distribution_url)
            check_type(argname="argument distribution_id", value=distribution_id, expected_type=type_hints["distribution_id"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getCloudFrontDistributionUrl", [distribution_id]))

    @jsii.member(jsii_name="getCloudWatchLogGroupUrl")
    def get_cloud_watch_log_group_url(
        self,
        log_group_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param log_group_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_cloud_watch_log_group_url)
            check_type(argname="argument log_group_name", value=log_group_name, expected_type=type_hints["log_group_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getCloudWatchLogGroupUrl", [log_group_name]))

    @jsii.member(jsii_name="getCodeBuildProjectUrl")
    def get_code_build_project_url(
        self,
        project_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param project_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_code_build_project_url)
            check_type(argname="argument project_name", value=project_name, expected_type=type_hints["project_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getCodeBuildProjectUrl", [project_name]))

    @jsii.member(jsii_name="getDocumentDbClusterUrl")
    def get_document_db_cluster_url(
        self,
        cluster_id: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param cluster_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_document_db_cluster_url)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getDocumentDbClusterUrl", [cluster_id]))

    @jsii.member(jsii_name="getDynamoTableUrl")
    def get_dynamo_table_url(
        self,
        table_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param table_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_dynamo_table_url)
            check_type(argname="argument table_name", value=table_name, expected_type=type_hints["table_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getDynamoTableUrl", [table_name]))

    @jsii.member(jsii_name="getElastiCacheClusterUrl")
    def get_elasti_cache_cluster_url(
        self,
        cluster_id: builtins.str,
        cluster_type: "ElastiCacheClusterType",
    ) -> typing.Optional[builtins.str]:
        '''
        :param cluster_id: -
        :param cluster_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_elasti_cache_cluster_url)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument cluster_type", value=cluster_type, expected_type=type_hints["cluster_type"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getElastiCacheClusterUrl", [cluster_id, cluster_type]))

    @jsii.member(jsii_name="getKinesisAnalyticsUrl")
    def get_kinesis_analytics_url(
        self,
        application: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param application: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_kinesis_analytics_url)
            check_type(argname="argument application", value=application, expected_type=type_hints["application"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getKinesisAnalyticsUrl", [application]))

    @jsii.member(jsii_name="getKinesisDataStreamUrl")
    def get_kinesis_data_stream_url(
        self,
        stream_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param stream_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_kinesis_data_stream_url)
            check_type(argname="argument stream_name", value=stream_name, expected_type=type_hints["stream_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getKinesisDataStreamUrl", [stream_name]))

    @jsii.member(jsii_name="getKinesisFirehoseDeliveryStreamUrl")
    def get_kinesis_firehose_delivery_stream_url(
        self,
        stream_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param stream_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_kinesis_firehose_delivery_stream_url)
            check_type(argname="argument stream_name", value=stream_name, expected_type=type_hints["stream_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getKinesisFirehoseDeliveryStreamUrl", [stream_name]))

    @jsii.member(jsii_name="getLambdaFunctionUrl")
    def get_lambda_function_url(
        self,
        function_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param function_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_lambda_function_url)
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getLambdaFunctionUrl", [function_name]))

    @jsii.member(jsii_name="getOpenSearchClusterUrl")
    def get_open_search_cluster_url(
        self,
        domain_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param domain_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_open_search_cluster_url)
            check_type(argname="argument domain_name", value=domain_name, expected_type=type_hints["domain_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getOpenSearchClusterUrl", [domain_name]))

    @jsii.member(jsii_name="getRdsClusterUrl")
    def get_rds_cluster_url(
        self,
        cluster_id: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param cluster_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_rds_cluster_url)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getRdsClusterUrl", [cluster_id]))

    @jsii.member(jsii_name="getRedshiftClusterUrl")
    def get_redshift_cluster_url(
        self,
        cluster_id: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param cluster_id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_redshift_cluster_url)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getRedshiftClusterUrl", [cluster_id]))

    @jsii.member(jsii_name="getResolvedDestinationUrl")
    def _get_resolved_destination_url(
        self,
        context: aws_cdk.IResolveContext,
        destination_url: builtins.str,
    ) -> builtins.str:
        '''(experimental) Resolves a destination URL within a resolution context.

        :param context: The resolution context.
        :param destination_url: The destination URL to resolve since it may contain CDK tokens.

        :see: https://docs.aws.amazon.com/cdk/latest/guide/tokens.html
        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory._get_resolved_destination_url)
            check_type(argname="argument context", value=context, expected_type=type_hints["context"])
            check_type(argname="argument destination_url", value=destination_url, expected_type=type_hints["destination_url"])
        return typing.cast(builtins.str, jsii.invoke(self, "getResolvedDestinationUrl", [context, destination_url]))

    @jsii.member(jsii_name="getS3BucketUrl")
    def get_s3_bucket_url(
        self,
        bucket_name: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param bucket_name: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_s3_bucket_url)
            check_type(argname="argument bucket_name", value=bucket_name, expected_type=type_hints["bucket_name"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getS3BucketUrl", [bucket_name]))

    @jsii.member(jsii_name="getSnsTopicUrl")
    def get_sns_topic_url(
        self,
        topic_arn: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param topic_arn: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_sns_topic_url)
            check_type(argname="argument topic_arn", value=topic_arn, expected_type=type_hints["topic_arn"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getSnsTopicUrl", [topic_arn]))

    @jsii.member(jsii_name="getSqsQueueUrl")
    def get_sqs_queue_url(
        self,
        queue_url: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param queue_url: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_sqs_queue_url)
            check_type(argname="argument queue_url", value=queue_url, expected_type=type_hints["queue_url"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getSqsQueueUrl", [queue_url]))

    @jsii.member(jsii_name="getStateMachineUrl")
    def get_state_machine_url(
        self,
        state_machine_arn: builtins.str,
    ) -> typing.Optional[builtins.str]:
        '''
        :param state_machine_arn: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactory.get_state_machine_url)
            check_type(argname="argument state_machine_arn", value=state_machine_arn, expected_type=type_hints["state_machine_arn"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "getStateMachineUrl", [state_machine_arn]))

    @builtins.property
    @jsii.member(jsii_name="awsAccountId")
    def _aws_account_id(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "awsAccountId"))

    @builtins.property
    @jsii.member(jsii_name="awsAccountRegion")
    def _aws_account_region(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "awsAccountRegion"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AwsConsoleUrlFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "aws_account_id": "awsAccountId",
        "aws_account_region": "awsAccountRegion",
    },
)
class AwsConsoleUrlFactoryProps:
    def __init__(
        self,
        *,
        aws_account_id: builtins.str,
        aws_account_region: builtins.str,
    ) -> None:
        '''
        :param aws_account_id: 
        :param aws_account_region: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AwsConsoleUrlFactoryProps.__init__)
            check_type(argname="argument aws_account_id", value=aws_account_id, expected_type=type_hints["aws_account_id"])
            check_type(argname="argument aws_account_region", value=aws_account_region, expected_type=type_hints["aws_account_region"])
        self._values: typing.Dict[str, typing.Any] = {
            "aws_account_id": aws_account_id,
            "aws_account_region": aws_account_region,
        }

    @builtins.property
    def aws_account_id(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("aws_account_id")
        assert result is not None, "Required property 'aws_account_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def aws_account_region(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("aws_account_region")
        assert result is not None, "Required property 'aws_account_region' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AwsConsoleUrlFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.AxisPosition")
class AxisPosition(enum.Enum):
    '''
    :stability: experimental
    '''

    LEFT = "LEFT"
    '''
    :stability: experimental
    '''
    RIGHT = "RIGHT"
    '''
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseDlqAlarms",
    jsii_struct_bases=[],
    name_mapping={
        "add_dead_letter_queue_max_incoming_messages_alarm": "addDeadLetterQueueMaxIncomingMessagesAlarm",
        "add_dead_letter_queue_max_message_age_alarm": "addDeadLetterQueueMaxMessageAgeAlarm",
        "add_dead_letter_queue_max_size_alarm": "addDeadLetterQueueMaxSizeAlarm",
    },
)
class BaseDlqAlarms:
    def __init__(
        self,
        *,
        add_dead_letter_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxIncomingMessagesCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxMessageAgeThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxMessageCountThreshold", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param add_dead_letter_queue_max_incoming_messages_alarm: (experimental) Alarm on the number of messages added to a queue. Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ as a result of a failed processing attempt.
        :param add_dead_letter_queue_max_message_age_alarm: 
        :param add_dead_letter_queue_max_size_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseDlqAlarms.__init__)
            check_type(argname="argument add_dead_letter_queue_max_incoming_messages_alarm", value=add_dead_letter_queue_max_incoming_messages_alarm, expected_type=type_hints["add_dead_letter_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_dead_letter_queue_max_message_age_alarm", value=add_dead_letter_queue_max_message_age_alarm, expected_type=type_hints["add_dead_letter_queue_max_message_age_alarm"])
            check_type(argname="argument add_dead_letter_queue_max_size_alarm", value=add_dead_letter_queue_max_size_alarm, expected_type=type_hints["add_dead_letter_queue_max_size_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_dead_letter_queue_max_incoming_messages_alarm is not None:
            self._values["add_dead_letter_queue_max_incoming_messages_alarm"] = add_dead_letter_queue_max_incoming_messages_alarm
        if add_dead_letter_queue_max_message_age_alarm is not None:
            self._values["add_dead_letter_queue_max_message_age_alarm"] = add_dead_letter_queue_max_message_age_alarm
        if add_dead_letter_queue_max_size_alarm is not None:
            self._values["add_dead_letter_queue_max_size_alarm"] = add_dead_letter_queue_max_size_alarm

    @builtins.property
    def add_dead_letter_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxIncomingMessagesCountThreshold"]]:
        '''(experimental) Alarm on the number of messages added to a queue.

        Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ
        as a result of a failed processing attempt.

        :see: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html#sqs-dlq-number-of-messages
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxIncomingMessagesCountThreshold"]], result)

    @builtins.property
    def add_dead_letter_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxMessageAgeThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxMessageAgeThreshold"]], result)

    @builtins.property
    def add_dead_letter_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxMessageCountThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxMessageCountThreshold"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseDlqAlarms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseEc2ServiceAlarms",
    jsii_struct_bases=[],
    name_mapping={
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
    },
)
class BaseEc2ServiceAlarms:
    def __init__(
        self,
        *,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["RunningTaskCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseEc2ServiceAlarms.__init__)
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "RunningTaskCountThreshold"]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "RunningTaskCountThreshold"]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseEc2ServiceAlarms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseFargateServiceAlarms",
    jsii_struct_bases=[],
    name_mapping={
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
    },
)
class BaseFargateServiceAlarms:
    def __init__(
        self,
        *,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["RunningTaskCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseFargateServiceAlarms.__init__)
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "UsageThreshold"]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "RunningTaskCountThreshold"]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "RunningTaskCountThreshold"]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseFargateServiceAlarms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BaseServiceMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.BaseServiceMetricFactory",
):
    '''(experimental) Metric factory for a base service (parent class for e.g. Fargate and EC2 services).

    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        service: aws_cdk.aws_ecs.BaseService,
    ) -> None:
        '''
        :param metric_factory: -
        :param service: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseServiceMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = BaseServiceMetricFactoryProps(service=service)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricClusterCpuUtilisationInPercent")
    def metric_cluster_cpu_utilisation_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterCpuUtilisationInPercent", []))

    @jsii.member(jsii_name="metricClusterMemoryUtilisationInPercent")
    def metric_cluster_memory_utilisation_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterMemoryUtilisationInPercent", []))

    @jsii.member(jsii_name="metricRunningTaskCount")
    def metric_running_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRunningTaskCount", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="service")
    def _service(self) -> aws_cdk.aws_ecs.BaseService:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_ecs.BaseService, jsii.get(self, "service"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseServiceMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"service": "service"},
)
class BaseServiceMetricFactoryProps:
    def __init__(self, *, service: aws_cdk.aws_ecs.BaseService) -> None:
        '''(experimental) Props to create BaseServiceMetricFactory.

        :param service: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseServiceMetricFactoryProps.__init__)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        self._values: typing.Dict[str, typing.Any] = {
            "service": service,
        }

    @builtins.property
    def service(self) -> aws_cdk.aws_ecs.BaseService:
        '''
        :stability: experimental
        '''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(aws_cdk.aws_ecs.BaseService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseServiceMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseSqsQueueAlarms",
    jsii_struct_bases=[],
    name_mapping={
        "add_queue_max_incoming_messages_alarm": "addQueueMaxIncomingMessagesAlarm",
        "add_queue_max_message_age_alarm": "addQueueMaxMessageAgeAlarm",
        "add_queue_max_size_alarm": "addQueueMaxSizeAlarm",
        "add_queue_max_time_to_drain_messages_alarm": "addQueueMaxTimeToDrainMessagesAlarm",
        "add_queue_min_incoming_messages_alarm": "addQueueMinIncomingMessagesAlarm",
        "add_queue_min_size_alarm": "addQueueMinSizeAlarm",
    },
)
class BaseSqsQueueAlarms:
    def __init__(
        self,
        *,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxIncomingMessagesCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxMessageAgeThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxMessageCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MaxTimeToDrainThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MinIncomingMessagesCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["MinMessageCountThreshold", typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseSqsQueueAlarms.__init__)
            check_type(argname="argument add_queue_max_incoming_messages_alarm", value=add_queue_max_incoming_messages_alarm, expected_type=type_hints["add_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_queue_max_message_age_alarm", value=add_queue_max_message_age_alarm, expected_type=type_hints["add_queue_max_message_age_alarm"])
            check_type(argname="argument add_queue_max_size_alarm", value=add_queue_max_size_alarm, expected_type=type_hints["add_queue_max_size_alarm"])
            check_type(argname="argument add_queue_max_time_to_drain_messages_alarm", value=add_queue_max_time_to_drain_messages_alarm, expected_type=type_hints["add_queue_max_time_to_drain_messages_alarm"])
            check_type(argname="argument add_queue_min_incoming_messages_alarm", value=add_queue_min_incoming_messages_alarm, expected_type=type_hints["add_queue_min_incoming_messages_alarm"])
            check_type(argname="argument add_queue_min_size_alarm", value=add_queue_min_size_alarm, expected_type=type_hints["add_queue_min_size_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_queue_max_incoming_messages_alarm is not None:
            self._values["add_queue_max_incoming_messages_alarm"] = add_queue_max_incoming_messages_alarm
        if add_queue_max_message_age_alarm is not None:
            self._values["add_queue_max_message_age_alarm"] = add_queue_max_message_age_alarm
        if add_queue_max_size_alarm is not None:
            self._values["add_queue_max_size_alarm"] = add_queue_max_size_alarm
        if add_queue_max_time_to_drain_messages_alarm is not None:
            self._values["add_queue_max_time_to_drain_messages_alarm"] = add_queue_max_time_to_drain_messages_alarm
        if add_queue_min_incoming_messages_alarm is not None:
            self._values["add_queue_min_incoming_messages_alarm"] = add_queue_min_incoming_messages_alarm
        if add_queue_min_size_alarm is not None:
            self._values["add_queue_min_size_alarm"] = add_queue_min_size_alarm

    @builtins.property
    def add_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxIncomingMessagesCountThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxIncomingMessagesCountThreshold"]], result)

    @builtins.property
    def add_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxMessageAgeThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxMessageAgeThreshold"]], result)

    @builtins.property
    def add_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxMessageCountThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxMessageCountThreshold"]], result)

    @builtins.property
    def add_queue_max_time_to_drain_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MaxTimeToDrainThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_time_to_drain_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MaxTimeToDrainThreshold"]], result)

    @builtins.property
    def add_queue_min_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MinIncomingMessagesCountThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MinIncomingMessagesCountThreshold"]], result)

    @builtins.property
    def add_queue_min_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "MinMessageCountThreshold"]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "MinMessageCountThreshold"]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseSqsQueueAlarms(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BillingMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.BillingMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="metricSearchTopCostByServiceInUsd")
    def metric_search_top_cost_by_service_in_usd(
        self,
    ) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.invoke(self, "metricSearchTopCostByServiceInUsd", []))

    @jsii.member(jsii_name="metricTotalCostInUsd")
    def metric_total_cost_in_usd(self) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.invoke(self, "metricTotalCostInUsd", []))


class BitmapDashboard(
    aws_cdk.aws_cloudwatch.Dashboard,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.BitmapDashboard",
):
    '''(experimental) Specific subtype of dashboard that renders supported widgets as bitmaps, while preserving the overall layout.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        dashboard_name: typing.Optional[builtins.str] = None,
        end: typing.Optional[builtins.str] = None,
        period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        start: typing.Optional[builtins.str] = None,
        widgets: typing.Optional[typing.Sequence[typing.Sequence[aws_cdk.aws_cloudwatch.IWidget]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param dashboard_name: Name of the dashboard. If set, must only contain alphanumerics, dash (-) and underscore (_) Default: - automatically generated name
        :param end: The end of the time range to use for each widget on the dashboard when the dashboard loads. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.
        :param period_override: Use this field to specify the period for the graphs when the dashboard loads. Specifying ``Auto`` causes the period of all graphs on the dashboard to automatically adapt to the time range of the dashboard. Specifying ``Inherit`` ensures that the period set for each graph is always obeyed. Default: Auto
        :param start: The start of the time range to use for each widget on the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.
        :param widgets: Initial set of widgets on the dashboard. One array represents a row of widgets. Default: - No widgets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapDashboard.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = aws_cdk.aws_cloudwatch.DashboardProps(
            dashboard_name=dashboard_name,
            end=end,
            period_override=period_override,
            start=start,
            widgets=widgets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addWidgets")
    def add_widgets(self, *widgets: aws_cdk.aws_cloudwatch.IWidget) -> None:
        '''(experimental) Add a widget to the dashboard.

        Widgets given in multiple calls to add() will be laid out stacked on
        top of each other.

        Multiple widgets added in the same call to add() will be laid out next
        to each other.

        :param widgets: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapDashboard.add_widgets)
            check_type(argname="argument widgets", value=widgets, expected_type=typing.Tuple[type_hints["widgets"], ...]) # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(None, jsii.invoke(self, "addWidgets", [*widgets]))

    @jsii.member(jsii_name="asBitmap")
    def _as_bitmap(
        self,
        widget: aws_cdk.aws_cloudwatch.IWidget,
    ) -> aws_cdk.aws_cloudwatch.IWidget:
        '''
        :param widget: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapDashboard._as_bitmap)
            check_type(argname="argument widget", value=widget, expected_type=type_hints["widget"])
        return typing.cast(aws_cdk.aws_cloudwatch.IWidget, jsii.invoke(self, "asBitmap", [widget]))

    @jsii.member(jsii_name="asBitmaps")
    def _as_bitmaps(
        self,
        *widgets: aws_cdk.aws_cloudwatch.IWidget,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''
        :param widgets: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapDashboard._as_bitmaps)
            check_type(argname="argument widgets", value=widgets, expected_type=typing.Tuple[type_hints["widgets"], ...]) # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "asBitmaps", [*widgets]))

    @builtins.property
    @jsii.member(jsii_name="bitmapRenderingSupport")
    def _bitmap_rendering_support(self) -> "BitmapWidgetRenderingSupport":
        '''
        :stability: experimental
        '''
        return typing.cast("BitmapWidgetRenderingSupport", jsii.get(self, "bitmapRenderingSupport"))


class BitmapWidgetRenderingSupport(
    constructs.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.BitmapWidgetRenderingSupport",
):
    '''(experimental) Support for rendering bitmap widgets on the server side.

    It is a custom widget lambda with some additional roles and helper methods.

    :stability: experimental
    '''

    def __init__(self, scope: constructs.Construct, id: builtins.str) -> None:
        '''
        :param scope: -
        :param id: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapWidgetRenderingSupport.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [scope, id])

    @jsii.member(jsii_name="asBitmap")
    def as_bitmap(self, widget: aws_cdk.aws_cloudwatch.IWidget) -> "CustomWidget":
        '''
        :param widget: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapWidgetRenderingSupport.as_bitmap)
            check_type(argname="argument widget", value=widget, expected_type=type_hints["widget"])
        return typing.cast("CustomWidget", jsii.invoke(self, "asBitmap", [widget]))

    @jsii.member(jsii_name="getWidgetProperties")
    def _get_widget_properties(
        self,
        widget: aws_cdk.aws_cloudwatch.IWidget,
    ) -> typing.Any:
        '''
        :param widget: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BitmapWidgetRenderingSupport._get_widget_properties)
            check_type(argname="argument widget", value=widget, expected_type=type_hints["widget"])
        return typing.cast(typing.Any, jsii.invoke(self, "getWidgetProperties", [widget]))

    @builtins.property
    @jsii.member(jsii_name="handler")
    def handler(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_lambda.IFunction, jsii.get(self, "handler"))


@jsii.enum(jsii_type="cdk-monitoring-constructs.CapacityType")
class CapacityType(enum.Enum):
    '''
    :stability: experimental
    '''

    READ = "READ"
    '''
    :stability: experimental
    '''
    WRITE = "WRITE"
    '''
    :stability: experimental
    '''


class CertificateManagerMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CertificateManagerMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        certificate: aws_cdk.aws_certificatemanager.ICertificate,
    ) -> None:
        '''
        :param metric_factory: -
        :param certificate: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = CertificateManagerMetricFactoryProps(certificate=certificate)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricDaysToExpiry")
    def metric_days_to_expiry(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDaysToExpiry", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CertificateManagerMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"certificate": "certificate"},
)
class CertificateManagerMetricFactoryProps:
    def __init__(
        self,
        *,
        certificate: aws_cdk.aws_certificatemanager.ICertificate,
    ) -> None:
        '''
        :param certificate: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMetricFactoryProps.__init__)
            check_type(argname="argument certificate", value=certificate, expected_type=type_hints["certificate"])
        self._values: typing.Dict[str, typing.Any] = {
            "certificate": certificate,
        }

    @builtins.property
    def certificate(self) -> aws_cdk.aws_certificatemanager.ICertificate:
        '''
        :stability: experimental
        '''
        result = self._values.get("certificate")
        assert result is not None, "Required property 'certificate' is missing"
        return typing.cast(aws_cdk.aws_certificatemanager.ICertificate, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateManagerMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CloudFrontDistributionMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CloudFrontDistributionMetricFactory",
):
    '''(experimental) To get the CloudFront metrics from the CloudWatch API, you must use the US East (N.

    Virginia) Region (us-east-1).
    https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/programming-cloudwatch-metrics.html

    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        distribution: aws_cdk.aws_cloudfront.IDistribution,
        additional_metrics_enabled: typing.Optional[builtins.bool] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param distribution: 
        :param additional_metrics_enabled: (experimental) Generate dashboard charts for additional CloudFront distribution metrics. To enable additional metrics on your CloudFront distribution, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional Default: - true
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = CloudFrontDistributionMetricFactoryProps(
            distribution=distribution,
            additional_metrics_enabled=additional_metrics_enabled,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metric4xxErrorRateAverage")
    def metric4xx_error_rate_average(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4xxErrorRateAverage", []))

    @jsii.member(jsii_name="metric5xxErrorRateAverage")
    def metric5xx_error_rate_average(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5xxErrorRateAverage", []))

    @jsii.member(jsii_name="metricCacheHitRateAverageInPercent")
    def metric_cache_hit_rate_average_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Cache hit rate metric.

        This is an additional metric that needs to be explicitly enabled for an additional cost.

        :see: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCacheHitRateAverageInPercent", []))

    @jsii.member(jsii_name="metricRequestCount")
    def metric_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRequestCount", []))

    @jsii.member(jsii_name="metricRequestRate")
    def metric_request_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRequestRate", []))

    @jsii.member(jsii_name="metricRequestTps")
    def metric_request_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricRequestRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRequestTps", []))

    @jsii.member(jsii_name="metricTotalBytesDownloaded")
    def metric_total_bytes_downloaded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalBytesDownloaded", []))

    @jsii.member(jsii_name="metricTotalBytesUploaded")
    def metric_total_bytes_uploaded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalBytesUploaded", []))

    @jsii.member(jsii_name="metricTotalErrorRateAverage")
    def metric_total_error_rate_average(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalErrorRateAverage", []))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CloudFrontDistributionMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "distribution": "distribution",
        "additional_metrics_enabled": "additionalMetricsEnabled",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class CloudFrontDistributionMetricFactoryProps:
    def __init__(
        self,
        *,
        distribution: aws_cdk.aws_cloudfront.IDistribution,
        additional_metrics_enabled: typing.Optional[builtins.bool] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param distribution: 
        :param additional_metrics_enabled: (experimental) Generate dashboard charts for additional CloudFront distribution metrics. To enable additional metrics on your CloudFront distribution, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional Default: - true
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMetricFactoryProps.__init__)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument additional_metrics_enabled", value=additional_metrics_enabled, expected_type=type_hints["additional_metrics_enabled"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "distribution": distribution,
        }
        if additional_metrics_enabled is not None:
            self._values["additional_metrics_enabled"] = additional_metrics_enabled
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def distribution(self) -> aws_cdk.aws_cloudfront.IDistribution:
        '''
        :stability: experimental
        '''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(aws_cdk.aws_cloudfront.IDistribution, result)

    @builtins.property
    def additional_metrics_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Generate dashboard charts for additional CloudFront distribution metrics.

        To enable additional metrics on your CloudFront distribution, see
        https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("additional_metrics_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CodeBuildProjectMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CodeBuildProjectMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        project: aws_cdk.aws_codebuild.IProject,
    ) -> None:
        '''
        :param metric_factory: -
        :param project: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = CodeBuildProjectMetricFactoryProps(project=project)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricBuildCount")
    def metric_build_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricBuildCount", []))

    @jsii.member(jsii_name="metricDurationP50InSeconds")
    def metric_duration_p50_in_seconds(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDurationP50InSeconds", []))

    @jsii.member(jsii_name="metricDurationP90InSeconds")
    def metric_duration_p90_in_seconds(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDurationP90InSeconds", []))

    @jsii.member(jsii_name="metricDurationP99InSeconds")
    def metric_duration_p99_in_seconds(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDurationP99InSeconds", []))

    @jsii.member(jsii_name="metricFailedBuildCount")
    def metric_failed_build_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFailedBuildCount", []))

    @jsii.member(jsii_name="metricFailedBuildRate")
    def metric_failed_build_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFailedBuildRate", []))

    @jsii.member(jsii_name="metricSucceededBuildCount")
    def metric_succeeded_build_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSucceededBuildCount", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="project")
    def _project(self) -> aws_cdk.aws_codebuild.IProject:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_codebuild.IProject, jsii.get(self, "project"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CodeBuildProjectMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"project": "project"},
)
class CodeBuildProjectMetricFactoryProps:
    def __init__(self, *, project: aws_cdk.aws_codebuild.IProject) -> None:
        '''
        :param project: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMetricFactoryProps.__init__)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        self._values: typing.Dict[str, typing.Any] = {
            "project": project,
        }

    @builtins.property
    def project(self) -> aws_cdk.aws_codebuild.IProject:
        '''
        :stability: experimental
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(aws_cdk.aws_codebuild.IProject, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CodeBuildProjectMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.CompositeAlarmOperator")
class CompositeAlarmOperator(enum.Enum):
    '''
    :stability: experimental
    '''

    AND = "AND"
    '''(experimental) trigger only if all the alarms are triggered.

    :stability: experimental
    '''
    OR = "OR"
    '''(experimental) trigger if any of the alarms is triggered.

    :stability: experimental
    '''


class ConnectionAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ConnectionAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ConnectionAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxConnectionCountAlarm")
    def add_max_connection_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["HighConnectionCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ConnectionAlarmFactory.add_max_connection_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxConnectionCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinConnectionCountAlarm")
    def add_min_connection_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["LowConnectionCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ConnectionAlarmFactory.add_min_connection_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinConnectionCountAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class CustomAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CustomAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addCustomAlarm")
    def add_custom_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        alarm_name_suffix: builtins.str,
        disambiguator: builtins.str,
        *,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        threshold: jsii.Number,
        additional_description: typing.Optional[builtins.str] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param alarm_name_suffix: -
        :param disambiguator: -
        :param comparison_operator: 
        :param threshold: 
        :param additional_description: 
        :param dedupe_string: 
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomAlarmFactory.add_custom_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument alarm_name_suffix", value=alarm_name_suffix, expected_type=type_hints["alarm_name_suffix"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        props = CustomThreshold(
            comparison_operator=comparison_operator,
            threshold=threshold,
            additional_description=additional_description,
            dedupe_string=dedupe_string,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            comparison_operator_override=comparison_operator_override,
            custom_params=custom_params,
            custom_tags=custom_tags,
            datapoints_to_alarm=datapoints_to_alarm,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            evaluate_low_sample_count_percentile=evaluate_low_sample_count_percentile,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            period=period,
            runbook_link=runbook_link,
            treat_missing_data_override=treat_missing_data_override,
        )

        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addCustomAlarm", [metric, alarm_name_suffix, disambiguator, props]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomAlarmThreshold",
    jsii_struct_bases=[],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
    },
)
class CustomAlarmThreshold:
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
    ) -> None:
        '''(experimental) Common customization that can be attached to each alarm.

        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomAlarmThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
        self._values: typing.Dict[str, typing.Any] = {}
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomAlarmThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMetricGroup",
    jsii_struct_bases=[],
    name_mapping={
        "metrics": "metrics",
        "title": "title",
        "graph_widget_axis": "graphWidgetAxis",
        "graph_widget_legend": "graphWidgetLegend",
        "graph_widget_right_axis": "graphWidgetRightAxis",
        "graph_widget_type": "graphWidgetType",
        "horizontal_annotations": "horizontalAnnotations",
        "horizontal_right_annotations": "horizontalRightAnnotations",
        "important": "important",
    },
)
class CustomMetricGroup:
    def __init__(
        self,
        *,
        metrics: typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression, typing.Union["CustomMetricWithAlarm", typing.Dict[str, typing.Any]], typing.Union["CustomMetricWithAnomalyDetection", typing.Dict[str, typing.Any]], typing.Union["CustomMetricSearch", typing.Dict[str, typing.Any]]]],
        title: builtins.str,
        graph_widget_axis: typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]]] = None,
        graph_widget_legend: typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition] = None,
        graph_widget_right_axis: typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]]] = None,
        graph_widget_type: typing.Optional["GraphWidgetType"] = None,
        horizontal_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        horizontal_right_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        important: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''(experimental) Custom metric group represents a single widget.

        :param metrics: (experimental) list of metrics in the group (can be defined in different ways, see the type documentation).
        :param title: (experimental) title of the whole group.
        :param graph_widget_axis: (experimental) optional axis. Default: undefined
        :param graph_widget_legend: (experimental) graph widget legend. Default: BOTTOM
        :param graph_widget_right_axis: (experimental) optional right axis. Default: undefined
        :param graph_widget_type: (experimental) type of the widget. Default: line
        :param horizontal_annotations: (experimental) optional custom horizontal annotations which will be displayed over the metrics on the left axis (if there are any alarms, any existing annotations will be merged together).
        :param horizontal_right_annotations: (experimental) optional custom horizontal annotations which will be displayed over the metrics on the right axis (if there are any alarms, any existing annotations will be merged together).
        :param important: (experimental) Flag indicating, whether this is an important metric group that should be included in the summary as well. Default: false

        :stability: experimental
        '''
        if isinstance(graph_widget_axis, dict):
            graph_widget_axis = aws_cdk.aws_cloudwatch.YAxisProps(**graph_widget_axis)
        if isinstance(graph_widget_right_axis, dict):
            graph_widget_right_axis = aws_cdk.aws_cloudwatch.YAxisProps(**graph_widget_right_axis)
        if __debug__:
            type_hints = typing.get_type_hints(CustomMetricGroup.__init__)
            check_type(argname="argument metrics", value=metrics, expected_type=type_hints["metrics"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
            check_type(argname="argument graph_widget_axis", value=graph_widget_axis, expected_type=type_hints["graph_widget_axis"])
            check_type(argname="argument graph_widget_legend", value=graph_widget_legend, expected_type=type_hints["graph_widget_legend"])
            check_type(argname="argument graph_widget_right_axis", value=graph_widget_right_axis, expected_type=type_hints["graph_widget_right_axis"])
            check_type(argname="argument graph_widget_type", value=graph_widget_type, expected_type=type_hints["graph_widget_type"])
            check_type(argname="argument horizontal_annotations", value=horizontal_annotations, expected_type=type_hints["horizontal_annotations"])
            check_type(argname="argument horizontal_right_annotations", value=horizontal_right_annotations, expected_type=type_hints["horizontal_right_annotations"])
            check_type(argname="argument important", value=important, expected_type=type_hints["important"])
        self._values: typing.Dict[str, typing.Any] = {
            "metrics": metrics,
            "title": title,
        }
        if graph_widget_axis is not None:
            self._values["graph_widget_axis"] = graph_widget_axis
        if graph_widget_legend is not None:
            self._values["graph_widget_legend"] = graph_widget_legend
        if graph_widget_right_axis is not None:
            self._values["graph_widget_right_axis"] = graph_widget_right_axis
        if graph_widget_type is not None:
            self._values["graph_widget_type"] = graph_widget_type
        if horizontal_annotations is not None:
            self._values["horizontal_annotations"] = horizontal_annotations
        if horizontal_right_annotations is not None:
            self._values["horizontal_right_annotations"] = horizontal_right_annotations
        if important is not None:
            self._values["important"] = important

    @builtins.property
    def metrics(
        self,
    ) -> typing.List[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression, "CustomMetricWithAlarm", "CustomMetricWithAnomalyDetection", "CustomMetricSearch"]]:
        '''(experimental) list of metrics in the group (can be defined in different ways, see the type documentation).

        :stability: experimental
        '''
        result = self._values.get("metrics")
        assert result is not None, "Required property 'metrics' is missing"
        return typing.cast(typing.List[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression, "CustomMetricWithAlarm", "CustomMetricWithAnomalyDetection", "CustomMetricSearch"]], result)

    @builtins.property
    def title(self) -> builtins.str:
        '''(experimental) title of the whole group.

        :stability: experimental
        '''
        result = self._values.get("title")
        assert result is not None, "Required property 'title' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def graph_widget_axis(self) -> typing.Optional[aws_cdk.aws_cloudwatch.YAxisProps]:
        '''(experimental) optional axis.

        :default: undefined

        :stability: experimental
        '''
        result = self._values.get("graph_widget_axis")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.YAxisProps], result)

    @builtins.property
    def graph_widget_legend(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition]:
        '''(experimental) graph widget legend.

        :default: BOTTOM

        :stability: experimental
        '''
        result = self._values.get("graph_widget_legend")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.LegendPosition], result)

    @builtins.property
    def graph_widget_right_axis(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.YAxisProps]:
        '''(experimental) optional right axis.

        :default: undefined

        :stability: experimental
        '''
        result = self._values.get("graph_widget_right_axis")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.YAxisProps], result)

    @builtins.property
    def graph_widget_type(self) -> typing.Optional["GraphWidgetType"]:
        '''(experimental) type of the widget.

        :default: line

        :stability: experimental
        '''
        result = self._values.get("graph_widget_type")
        return typing.cast(typing.Optional["GraphWidgetType"], result)

    @builtins.property
    def horizontal_annotations(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]]:
        '''(experimental) optional custom horizontal annotations which will be displayed over the metrics on the left axis (if there are any alarms, any existing annotations will be merged together).

        :stability: experimental
        '''
        result = self._values.get("horizontal_annotations")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]], result)

    @builtins.property
    def horizontal_right_annotations(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]]:
        '''(experimental) optional custom horizontal annotations which will be displayed over the metrics on the right axis (if there are any alarms, any existing annotations will be merged together).

        :stability: experimental
        '''
        result = self._values.get("horizontal_right_annotations")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]], result)

    @builtins.property
    def important(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating, whether this is an important metric group that should be included in the summary as well.

        :default: false

        :stability: experimental
        '''
        result = self._values.get("important")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMetricGroup(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMetricGroupWithAnnotations",
    jsii_struct_bases=[],
    name_mapping={
        "annotations": "annotations",
        "metric_group": "metricGroup",
        "right_annotations": "rightAnnotations",
        "title_addons": "titleAddons",
    },
)
class CustomMetricGroupWithAnnotations:
    def __init__(
        self,
        *,
        annotations: typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]],
        metric_group: typing.Union[CustomMetricGroup, typing.Dict[str, typing.Any]],
        right_annotations: typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]],
        title_addons: typing.Sequence[builtins.str],
    ) -> None:
        '''
        :param annotations: 
        :param metric_group: 
        :param right_annotations: 
        :param title_addons: 

        :stability: experimental
        '''
        if isinstance(metric_group, dict):
            metric_group = CustomMetricGroup(**metric_group)
        if __debug__:
            type_hints = typing.get_type_hints(CustomMetricGroupWithAnnotations.__init__)
            check_type(argname="argument annotations", value=annotations, expected_type=type_hints["annotations"])
            check_type(argname="argument metric_group", value=metric_group, expected_type=type_hints["metric_group"])
            check_type(argname="argument right_annotations", value=right_annotations, expected_type=type_hints["right_annotations"])
            check_type(argname="argument title_addons", value=title_addons, expected_type=type_hints["title_addons"])
        self._values: typing.Dict[str, typing.Any] = {
            "annotations": annotations,
            "metric_group": metric_group,
            "right_annotations": right_annotations,
            "title_addons": title_addons,
        }

    @builtins.property
    def annotations(self) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        result = self._values.get("annotations")
        assert result is not None, "Required property 'annotations' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], result)

    @builtins.property
    def metric_group(self) -> CustomMetricGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("metric_group")
        assert result is not None, "Required property 'metric_group' is missing"
        return typing.cast(CustomMetricGroup, result)

    @builtins.property
    def right_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        result = self._values.get("right_annotations")
        assert result is not None, "Required property 'right_annotations' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], result)

    @builtins.property
    def title_addons(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("title_addons")
        assert result is not None, "Required property 'title_addons' is missing"
        return typing.cast(typing.List[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMetricGroupWithAnnotations(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMetricSearch",
    jsii_struct_bases=[],
    name_mapping={
        "dimensions_map": "dimensionsMap",
        "search_query": "searchQuery",
        "statistic": "statistic",
        "label": "label",
        "namespace": "namespace",
        "period": "period",
        "position": "position",
    },
)
class CustomMetricSearch:
    def __init__(
        self,
        *,
        dimensions_map: typing.Mapping[builtins.str, builtins.str],
        search_query: builtins.str,
        statistic: "MetricStatistic",
        label: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        position: typing.Optional[AxisPosition] = None,
    ) -> None:
        '''(experimental) Custom metric search.

        :param dimensions_map: (experimental) search dimensions (can be empty).
        :param search_query: (experimental) search query (can be empty).
        :param statistic: (experimental) metric statistic.
        :param label: (experimental) custom label for the metrics. Default: - " "
        :param namespace: (experimental) metric namespace. Default: - none
        :param period: (experimental) metric period. Default: - global default
        :param position: (experimental) axis (right or left) on which to graph metric default: AxisPosition.LEFT.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomMetricSearch.__init__)
            check_type(argname="argument dimensions_map", value=dimensions_map, expected_type=type_hints["dimensions_map"])
            check_type(argname="argument search_query", value=search_query, expected_type=type_hints["search_query"])
            check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument position", value=position, expected_type=type_hints["position"])
        self._values: typing.Dict[str, typing.Any] = {
            "dimensions_map": dimensions_map,
            "search_query": search_query,
            "statistic": statistic,
        }
        if label is not None:
            self._values["label"] = label
        if namespace is not None:
            self._values["namespace"] = namespace
        if period is not None:
            self._values["period"] = period
        if position is not None:
            self._values["position"] = position

    @builtins.property
    def dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''(experimental) search dimensions (can be empty).

        :stability: experimental
        '''
        result = self._values.get("dimensions_map")
        assert result is not None, "Required property 'dimensions_map' is missing"
        return typing.cast(typing.Mapping[builtins.str, builtins.str], result)

    @builtins.property
    def search_query(self) -> builtins.str:
        '''(experimental) search query (can be empty).

        :stability: experimental
        '''
        result = self._values.get("search_query")
        assert result is not None, "Required property 'search_query' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def statistic(self) -> "MetricStatistic":
        '''(experimental) metric statistic.

        :stability: experimental
        '''
        result = self._values.get("statistic")
        assert result is not None, "Required property 'statistic' is missing"
        return typing.cast("MetricStatistic", result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''(experimental) custom label for the metrics.

        :default: - " "

        :stability: experimental
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''(experimental) metric namespace.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) metric period.

        :default: - global default

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def position(self) -> typing.Optional[AxisPosition]:
        '''(experimental) axis (right or left) on which to graph metric default: AxisPosition.LEFT.

        :stability: experimental
        '''
        result = self._values.get("position")
        return typing.cast(typing.Optional[AxisPosition], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMetricSearch(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMetricWithAlarm",
    jsii_struct_bases=[],
    name_mapping={
        "add_alarm": "addAlarm",
        "alarm_friendly_name": "alarmFriendlyName",
        "metric": "metric",
        "position": "position",
    },
)
class CustomMetricWithAlarm:
    def __init__(
        self,
        *,
        add_alarm: typing.Mapping[builtins.str, typing.Union["CustomThreshold", typing.Dict[str, typing.Any]]],
        alarm_friendly_name: builtins.str,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        position: typing.Optional[AxisPosition] = None,
    ) -> None:
        '''(experimental) Custom metric with an alarm defined.

        :param add_alarm: (experimental) alarm definitions.
        :param alarm_friendly_name: (experimental) alarm friendly name.
        :param metric: (experimental) metric to alarm on.
        :param position: (experimental) axis (right or left) on which to graph metric default: AxisPosition.LEFT.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomMetricWithAlarm.__init__)
            check_type(argname="argument add_alarm", value=add_alarm, expected_type=type_hints["add_alarm"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument position", value=position, expected_type=type_hints["position"])
        self._values: typing.Dict[str, typing.Any] = {
            "add_alarm": add_alarm,
            "alarm_friendly_name": alarm_friendly_name,
            "metric": metric,
        }
        if position is not None:
            self._values["position"] = position

    @builtins.property
    def add_alarm(self) -> typing.Mapping[builtins.str, "CustomThreshold"]:
        '''(experimental) alarm definitions.

        :stability: experimental
        '''
        result = self._values.get("add_alarm")
        assert result is not None, "Required property 'add_alarm' is missing"
        return typing.cast(typing.Mapping[builtins.str, "CustomThreshold"], result)

    @builtins.property
    def alarm_friendly_name(self) -> builtins.str:
        '''(experimental) alarm friendly name.

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        assert result is not None, "Required property 'alarm_friendly_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) metric to alarm on.

        :stability: experimental
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], result)

    @builtins.property
    def position(self) -> typing.Optional[AxisPosition]:
        '''(experimental) axis (right or left) on which to graph metric default: AxisPosition.LEFT.

        :stability: experimental
        '''
        result = self._values.get("position")
        return typing.cast(typing.Optional[AxisPosition], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMetricWithAlarm(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMetricWithAnomalyDetection",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "anomaly_detection_standard_deviation_to_render": "anomalyDetectionStandardDeviationToRender",
        "metric": "metric",
        "add_alarm_on_anomaly": "addAlarmOnAnomaly",
        "period": "period",
    },
)
class CustomMetricWithAnomalyDetection:
    def __init__(
        self,
        *,
        alarm_friendly_name: builtins.str,
        anomaly_detection_standard_deviation_to_render: jsii.Number,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        add_alarm_on_anomaly: typing.Optional[typing.Mapping[builtins.str, typing.Union["AnomalyDetectionThreshold", typing.Dict[str, typing.Any]]]] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> None:
        '''(experimental) Custom metric with anomaly detection.

        :param alarm_friendly_name: (experimental) alarm friendly name.
        :param anomaly_detection_standard_deviation_to_render: (experimental) standard deviation for the anomaly detection to be rendered on the graph widget.
        :param metric: (experimental) metric to alarm on.
        :param add_alarm_on_anomaly: (experimental) adds alarm on a detected anomaly.
        :param period: (experimental) anomaly detection period. Default: - metric period (if defined) or global default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomMetricWithAnomalyDetection.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument anomaly_detection_standard_deviation_to_render", value=anomaly_detection_standard_deviation_to_render, expected_type=type_hints["anomaly_detection_standard_deviation_to_render"])
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument add_alarm_on_anomaly", value=add_alarm_on_anomaly, expected_type=type_hints["add_alarm_on_anomaly"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarm_friendly_name": alarm_friendly_name,
            "anomaly_detection_standard_deviation_to_render": anomaly_detection_standard_deviation_to_render,
            "metric": metric,
        }
        if add_alarm_on_anomaly is not None:
            self._values["add_alarm_on_anomaly"] = add_alarm_on_anomaly
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_friendly_name(self) -> builtins.str:
        '''(experimental) alarm friendly name.

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        assert result is not None, "Required property 'alarm_friendly_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def anomaly_detection_standard_deviation_to_render(self) -> jsii.Number:
        '''(experimental) standard deviation for the anomaly detection to be rendered on the graph widget.

        :stability: experimental
        '''
        result = self._values.get("anomaly_detection_standard_deviation_to_render")
        assert result is not None, "Required property 'anomaly_detection_standard_deviation_to_render' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) metric to alarm on.

        :stability: experimental
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], result)

    @builtins.property
    def add_alarm_on_anomaly(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, "AnomalyDetectionThreshold"]]:
        '''(experimental) adds alarm on a detected anomaly.

        :stability: experimental
        '''
        result = self._values.get("add_alarm_on_anomaly")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, "AnomalyDetectionThreshold"]], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) anomaly detection period.

        :default: - metric period (if defined) or global default

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMetricWithAnomalyDetection(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "comparison_operator": "comparisonOperator",
        "threshold": "threshold",
        "additional_description": "additionalDescription",
        "dedupe_string": "dedupeString",
    },
)
class CustomThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        threshold: jsii.Number,
        additional_description: typing.Optional[builtins.str] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param comparison_operator: 
        :param threshold: 
        :param additional_description: 
        :param dedupe_string: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument additional_description", value=additional_description, expected_type=type_hints["additional_description"])
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
        self._values: typing.Dict[str, typing.Any] = {
            "comparison_operator": comparison_operator,
            "threshold": threshold,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override
        if additional_description is not None:
            self._values["additional_description"] = additional_description
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def comparison_operator(self) -> aws_cdk.aws_cloudwatch.ComparisonOperator:
        '''
        :stability: experimental
        '''
        result = self._values.get("comparison_operator")
        assert result is not None, "Required property 'comparison_operator' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.ComparisonOperator, result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def additional_description(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("additional_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CustomWidget(
    aws_cdk.aws_cloudwatch.ConcreteWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CustomWidget",
):
    '''(experimental) A dashboard widget that can be customized using a Lambda.

    :stability: experimental
    '''

    def __init__(
        self,
        *,
        handler: aws_cdk.aws_lambda.IFunction,
        handler_params: typing.Any = None,
        height: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
        update_on_refresh: typing.Optional[builtins.bool] = None,
        update_on_resize: typing.Optional[builtins.bool] = None,
        update_on_time_range_change: typing.Optional[builtins.bool] = None,
        width: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param handler: (experimental) Lambda providing the widget contents. The Lambda function should return HTML with widget code. The simplest Lambda example:: exports.handler = function (event, context, callback) { return callback(null, "<h1>Hello! This is a custom widget.</h1><pre>" + JSON.stringify(event, null, 2) + "</pre>"); };
        :param handler_params: (experimental) Arguments to pass to the Lambda. These arguments will be available in the Lambda context.
        :param height: (experimental) Height of the widget. Default: - 6
        :param title: (experimental) Title for the graph.
        :param update_on_refresh: (experimental) Whether the widget should be updated (by calling the Lambda again) on refresh. Default: - true
        :param update_on_resize: (experimental) Whether the widget should be updated (by calling the Lambda again) on resize. Default: - true
        :param update_on_time_range_change: (experimental) Whether the widget should be updated (by calling the Lambda again) on time range change. Default: - true
        :param width: (experimental) Width of the widget, in a grid of 24 units wide. Default: - 6

        :stability: experimental
        '''
        props = CustomWidgetProps(
            handler=handler,
            handler_params=handler_params,
            height=height,
            title=title,
            update_on_refresh=update_on_refresh,
            update_on_resize=update_on_resize,
            update_on_time_range_change=update_on_time_range_change,
            width=width,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="toJson")
    def to_json(self) -> typing.List[typing.Any]:
        '''(experimental) Return the widget JSON for use in the dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[typing.Any], jsii.invoke(self, "toJson", []))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomWidgetProps",
    jsii_struct_bases=[],
    name_mapping={
        "handler": "handler",
        "handler_params": "handlerParams",
        "height": "height",
        "title": "title",
        "update_on_refresh": "updateOnRefresh",
        "update_on_resize": "updateOnResize",
        "update_on_time_range_change": "updateOnTimeRangeChange",
        "width": "width",
    },
)
class CustomWidgetProps:
    def __init__(
        self,
        *,
        handler: aws_cdk.aws_lambda.IFunction,
        handler_params: typing.Any = None,
        height: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
        update_on_refresh: typing.Optional[builtins.bool] = None,
        update_on_resize: typing.Optional[builtins.bool] = None,
        update_on_time_range_change: typing.Optional[builtins.bool] = None,
        width: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''(experimental) Properties of a custom widget.

        :param handler: (experimental) Lambda providing the widget contents. The Lambda function should return HTML with widget code. The simplest Lambda example:: exports.handler = function (event, context, callback) { return callback(null, "<h1>Hello! This is a custom widget.</h1><pre>" + JSON.stringify(event, null, 2) + "</pre>"); };
        :param handler_params: (experimental) Arguments to pass to the Lambda. These arguments will be available in the Lambda context.
        :param height: (experimental) Height of the widget. Default: - 6
        :param title: (experimental) Title for the graph.
        :param update_on_refresh: (experimental) Whether the widget should be updated (by calling the Lambda again) on refresh. Default: - true
        :param update_on_resize: (experimental) Whether the widget should be updated (by calling the Lambda again) on resize. Default: - true
        :param update_on_time_range_change: (experimental) Whether the widget should be updated (by calling the Lambda again) on time range change. Default: - true
        :param width: (experimental) Width of the widget, in a grid of 24 units wide. Default: - 6

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomWidgetProps.__init__)
            check_type(argname="argument handler", value=handler, expected_type=type_hints["handler"])
            check_type(argname="argument handler_params", value=handler_params, expected_type=type_hints["handler_params"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
            check_type(argname="argument update_on_refresh", value=update_on_refresh, expected_type=type_hints["update_on_refresh"])
            check_type(argname="argument update_on_resize", value=update_on_resize, expected_type=type_hints["update_on_resize"])
            check_type(argname="argument update_on_time_range_change", value=update_on_time_range_change, expected_type=type_hints["update_on_time_range_change"])
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
        self._values: typing.Dict[str, typing.Any] = {
            "handler": handler,
        }
        if handler_params is not None:
            self._values["handler_params"] = handler_params
        if height is not None:
            self._values["height"] = height
        if title is not None:
            self._values["title"] = title
        if update_on_refresh is not None:
            self._values["update_on_refresh"] = update_on_refresh
        if update_on_resize is not None:
            self._values["update_on_resize"] = update_on_resize
        if update_on_time_range_change is not None:
            self._values["update_on_time_range_change"] = update_on_time_range_change
        if width is not None:
            self._values["width"] = width

    @builtins.property
    def handler(self) -> aws_cdk.aws_lambda.IFunction:
        '''(experimental) Lambda providing the widget contents.

        The Lambda function should return HTML with widget code.
        The simplest Lambda example::

           exports.handler = function (event, context, callback) {
              return callback(null, "<h1>Hello! This is a custom widget.</h1><pre>" + JSON.stringify(event, null, 2) + "</pre>");
           };

        :stability: experimental
        '''
        result = self._values.get("handler")
        assert result is not None, "Required property 'handler' is missing"
        return typing.cast(aws_cdk.aws_lambda.IFunction, result)

    @builtins.property
    def handler_params(self) -> typing.Any:
        '''(experimental) Arguments to pass to the Lambda.

        These arguments will be available in the Lambda context.

        :stability: experimental
        '''
        result = self._values.get("handler_params")
        return typing.cast(typing.Any, result)

    @builtins.property
    def height(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Height of the widget.

        :default: - 6

        :stability: experimental
        '''
        result = self._values.get("height")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''(experimental) Title for the graph.

        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def update_on_refresh(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the widget should be updated (by calling the Lambda again) on refresh.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("update_on_refresh")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def update_on_resize(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the widget should be updated (by calling the Lambda again) on resize.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("update_on_resize")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def update_on_time_range_change(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Whether the widget should be updated (by calling the Lambda again) on time range change.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("update_on_time_range_change")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def width(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Width of the widget, in a grid of 24 units wide.

        :default: - 6

        :stability: experimental
        '''
        result = self._values.get("width")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.DashboardRenderingPreference")
class DashboardRenderingPreference(enum.Enum):
    '''(experimental) Preferred way of rendering the widgets.

    :stability: experimental
    '''

    INTERACTIVE_ONLY = "INTERACTIVE_ONLY"
    '''(experimental) create standard set of dashboards with interactive widgets only.

    :stability: experimental
    '''
    BITMAP_ONLY = "BITMAP_ONLY"
    '''(experimental) create standard set of dashboards with bitmap widgets only.

    :stability: experimental
    '''
    INTERACTIVE_AND_BITMAP = "INTERACTIVE_AND_BITMAP"
    '''(experimental) create a two sets of dashboards: standard set (interactive) and a copy (bitmap).

    :stability: experimental
    '''


class DashboardWithBitmapCopy(
    aws_cdk.aws_cloudwatch.Dashboard,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DashboardWithBitmapCopy",
):
    '''(experimental) Composite dashboard which keeps a normal dashboard with its bitmap copy.

    The bitmap copy name will be derived from the primary dashboard name, if specified.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        dashboard_name: typing.Optional[builtins.str] = None,
        end: typing.Optional[builtins.str] = None,
        period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        start: typing.Optional[builtins.str] = None,
        widgets: typing.Optional[typing.Sequence[typing.Sequence[aws_cdk.aws_cloudwatch.IWidget]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param dashboard_name: Name of the dashboard. If set, must only contain alphanumerics, dash (-) and underscore (_) Default: - automatically generated name
        :param end: The end of the time range to use for each widget on the dashboard when the dashboard loads. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.
        :param period_override: Use this field to specify the period for the graphs when the dashboard loads. Specifying ``Auto`` causes the period of all graphs on the dashboard to automatically adapt to the time range of the dashboard. Specifying ``Inherit`` ensures that the period set for each graph is always obeyed. Default: Auto
        :param start: The start of the time range to use for each widget on the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.
        :param widgets: Initial set of widgets on the dashboard. One array represents a row of widgets. Default: - No widgets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DashboardWithBitmapCopy.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = aws_cdk.aws_cloudwatch.DashboardProps(
            dashboard_name=dashboard_name,
            end=end,
            period_override=period_override,
            start=start,
            widgets=widgets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addWidgets")
    def add_widgets(self, *widgets: aws_cdk.aws_cloudwatch.IWidget) -> None:
        '''(experimental) Add a widget to the dashboard.

        Widgets given in multiple calls to add() will be laid out stacked on
        top of each other.

        Multiple widgets added in the same call to add() will be laid out next
        to each other.

        :param widgets: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DashboardWithBitmapCopy.add_widgets)
            check_type(argname="argument widgets", value=widgets, expected_type=typing.Tuple[type_hints["widgets"], ...]) # pyright: ignore [reportGeneralTypeIssues]
        return typing.cast(None, jsii.invoke(self, "addWidgets", [*widgets]))

    @builtins.property
    @jsii.member(jsii_name="bitmapCopy")
    def _bitmap_copy(self) -> BitmapDashboard:
        '''
        :stability: experimental
        '''
        return typing.cast(BitmapDashboard, jsii.get(self, "bitmapCopy"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DaysSinceUpdateThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_days_since_update": "maxDaysSinceUpdate",
    },
)
class DaysSinceUpdateThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_days_since_update: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_days_since_update: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DaysSinceUpdateThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_days_since_update", value=max_days_since_update, expected_type=type_hints["max_days_since_update"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_days_since_update": max_days_since_update,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_days_since_update(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_days_since_update")
        assert result is not None, "Required property 'max_days_since_update' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaysSinceUpdateThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DaysToExpiryThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_days_to_expiry": "minDaysToExpiry",
    },
)
class DaysToExpiryThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_days_to_expiry: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_days_to_expiry: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DaysToExpiryThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_days_to_expiry", value=min_days_to_expiry, expected_type=type_hints["min_days_to_expiry"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_days_to_expiry": min_days_to_expiry,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_days_to_expiry(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_days_to_expiry")
        assert result is not None, "Required property 'min_days_to_expiry' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DaysToExpiryThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DocumentDbMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DocumentDbMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        cluster: aws_cdk.aws_docdb.IDatabaseCluster,
    ) -> None:
        '''
        :param metric_factory: -
        :param cluster: (experimental) database cluster.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = DocumentDbMetricFactoryProps(cluster=cluster)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageCpuUsageInPercent")
    def metric_average_cpu_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageCpuUsageInPercent", []))

    @jsii.member(jsii_name="metricMaxConnectionCount")
    def metric_max_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxConnectionCount", []))

    @jsii.member(jsii_name="metricMaxCursorCount")
    def metric_max_cursor_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxCursorCount", []))

    @jsii.member(jsii_name="metricMaxTransactionOpenCount")
    def metric_max_transaction_open_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxTransactionOpenCount", []))

    @jsii.member(jsii_name="metricOperationsThrottledDueLowMemoryCount")
    def metric_operations_throttled_due_low_memory_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricOperationsThrottledDueLowMemoryCount", []))

    @jsii.member(jsii_name="metricReadLatencyInMillis")
    def metric_read_latency_in_millis(
        self,
        latency_type: "LatencyType",
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param latency_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMetricFactory.metric_read_latency_in_millis)
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricReadLatencyInMillis", [latency_type]))

    @jsii.member(jsii_name="metricWriteLatencyInMillis")
    def metric_write_latency_in_millis(
        self,
        latency_type: "LatencyType",
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param latency_type: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMetricFactory.metric_write_latency_in_millis)
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricWriteLatencyInMillis", [latency_type]))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DocumentDbMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"cluster": "cluster"},
)
class DocumentDbMetricFactoryProps:
    def __init__(self, *, cluster: aws_cdk.aws_docdb.IDatabaseCluster) -> None:
        '''
        :param cluster: (experimental) database cluster.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMetricFactoryProps.__init__)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }

    @builtins.property
    def cluster(self) -> aws_cdk.aws_docdb.IDatabaseCluster:
        '''(experimental) database cluster.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_docdb.IDatabaseCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentDbMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DoubleAxisGraphWidget(
    aws_cdk.aws_cloudwatch.GraphWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DoubleAxisGraphWidget",
):
    '''(experimental) Line graph widget with both left and right axes.

    The purpose of this custom class is to make the properties more strict.
    It will avoid graphs with undefined axes and dimensions.

    :stability: experimental
    '''

    def __init__(
        self,
        *,
        height: jsii.Number,
        left_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        left_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        right_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        right_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        width: jsii.Number,
        left_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        right_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param height: 
        :param left_axis: 
        :param left_metrics: 
        :param right_axis: 
        :param right_metrics: 
        :param width: 
        :param left_annotations: 
        :param right_annotations: 
        :param title: 

        :stability: experimental
        '''
        props = DoubleAxisGraphWidgetProps(
            height=height,
            left_axis=left_axis,
            left_metrics=left_metrics,
            right_axis=right_axis,
            right_metrics=right_metrics,
            width=width,
            left_annotations=left_annotations,
            right_annotations=right_annotations,
            title=title,
        )

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DoubleAxisGraphWidgetProps",
    jsii_struct_bases=[],
    name_mapping={
        "height": "height",
        "left_axis": "leftAxis",
        "left_metrics": "leftMetrics",
        "right_axis": "rightAxis",
        "right_metrics": "rightMetrics",
        "width": "width",
        "left_annotations": "leftAnnotations",
        "right_annotations": "rightAnnotations",
        "title": "title",
    },
)
class DoubleAxisGraphWidgetProps:
    def __init__(
        self,
        *,
        height: jsii.Number,
        left_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        left_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        right_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        right_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        width: jsii.Number,
        left_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        right_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param height: 
        :param left_axis: 
        :param left_metrics: 
        :param right_axis: 
        :param right_metrics: 
        :param width: 
        :param left_annotations: 
        :param right_annotations: 
        :param title: 

        :stability: experimental
        '''
        if isinstance(left_axis, dict):
            left_axis = aws_cdk.aws_cloudwatch.YAxisProps(**left_axis)
        if isinstance(right_axis, dict):
            right_axis = aws_cdk.aws_cloudwatch.YAxisProps(**right_axis)
        if __debug__:
            type_hints = typing.get_type_hints(DoubleAxisGraphWidgetProps.__init__)
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
            check_type(argname="argument left_axis", value=left_axis, expected_type=type_hints["left_axis"])
            check_type(argname="argument left_metrics", value=left_metrics, expected_type=type_hints["left_metrics"])
            check_type(argname="argument right_axis", value=right_axis, expected_type=type_hints["right_axis"])
            check_type(argname="argument right_metrics", value=right_metrics, expected_type=type_hints["right_metrics"])
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument left_annotations", value=left_annotations, expected_type=type_hints["left_annotations"])
            check_type(argname="argument right_annotations", value=right_annotations, expected_type=type_hints["right_annotations"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        self._values: typing.Dict[str, typing.Any] = {
            "height": height,
            "left_axis": left_axis,
            "left_metrics": left_metrics,
            "right_axis": right_axis,
            "right_metrics": right_metrics,
            "width": width,
        }
        if left_annotations is not None:
            self._values["left_annotations"] = left_annotations
        if right_annotations is not None:
            self._values["right_annotations"] = right_annotations
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def height(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("height")
        assert result is not None, "Required property 'height' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def left_axis(self) -> aws_cdk.aws_cloudwatch.YAxisProps:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_axis")
        assert result is not None, "Required property 'left_axis' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.YAxisProps, result)

    @builtins.property
    def left_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_metrics")
        assert result is not None, "Required property 'left_metrics' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], result)

    @builtins.property
    def right_axis(self) -> aws_cdk.aws_cloudwatch.YAxisProps:
        '''
        :stability: experimental
        '''
        result = self._values.get("right_axis")
        assert result is not None, "Required property 'right_axis' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.YAxisProps, result)

    @builtins.property
    def right_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        result = self._values.get("right_metrics")
        assert result is not None, "Required property 'right_metrics' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], result)

    @builtins.property
    def width(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("width")
        assert result is not None, "Required property 'width' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def left_annotations(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_annotations")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]], result)

    @builtins.property
    def right_annotations(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("right_annotations")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DoubleAxisGraphWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DurationThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_duration": "maxDuration",
    },
)
class DurationThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_duration: aws_cdk.Duration,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_duration: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DurationThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_duration", value=max_duration, expected_type=type_hints["max_duration"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_duration": max_duration,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_duration(self) -> aws_cdk.Duration:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_duration")
        assert result is not None, "Required property 'max_duration' is missing"
        return typing.cast(aws_cdk.Duration, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DurationThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DynamoAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addConsumedCapacityAlarm")
    def add_consumed_capacity_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        capacity_type: CapacityType,
        props: typing.Union["ConsumedCapacityThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param capacity_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoAlarmFactory.add_consumed_capacity_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument capacity_type", value=capacity_type, expected_type=type_hints["capacity_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addConsumedCapacityAlarm", [metric, capacity_type, props, disambiguator]))

    @jsii.member(jsii_name="addThrottledEventsAlarm")
    def add_throttled_events_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        capacity_type: CapacityType,
        props: typing.Union["ThrottledEventsThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param capacity_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoAlarmFactory.add_throttled_events_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument capacity_type", value=capacity_type, expected_type=type_hints["capacity_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addThrottledEventsAlarm", [metric, capacity_type, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class DynamoTableGlobalSecondaryIndexMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DynamoTableGlobalSecondaryIndexMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        global_secondary_index_name: builtins.str,
        table: aws_cdk.aws_dynamodb.ITable,
    ) -> None:
        '''
        :param metric_factory: -
        :param global_secondary_index_name: 
        :param table: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = DynamoTableGlobalSecondaryIndexMetricFactoryProps(
            global_secondary_index_name=global_secondary_index_name, table=table
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricConsumedReadCapacityUnits")
    def metric_consumed_read_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConsumedReadCapacityUnits", []))

    @jsii.member(jsii_name="metricConsumedWriteCapacityUnits")
    def metric_consumed_write_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConsumedWriteCapacityUnits", []))

    @jsii.member(jsii_name="metricIndexConsumedWriteUnitsMetric")
    def metric_index_consumed_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIndexConsumedWriteUnitsMetric", []))

    @jsii.member(jsii_name="metricProvisionedReadCapacityUnits")
    def metric_provisioned_read_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedReadCapacityUnits", []))

    @jsii.member(jsii_name="metricProvisionedWriteCapacityUnits")
    def metric_provisioned_write_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedWriteCapacityUnits", []))

    @jsii.member(jsii_name="metricThrottledIndexRequestCount")
    def metric_throttled_index_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledIndexRequestCount", []))

    @jsii.member(jsii_name="metricThrottledReadRequestCount")
    def metric_throttled_read_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledReadRequestCount", []))

    @jsii.member(jsii_name="metricThrottledWriteRequestCount")
    def metric_throttled_write_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledWriteRequestCount", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DynamoTableGlobalSecondaryIndexMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "global_secondary_index_name": "globalSecondaryIndexName",
        "table": "table",
    },
)
class DynamoTableGlobalSecondaryIndexMetricFactoryProps:
    def __init__(
        self,
        *,
        global_secondary_index_name: builtins.str,
        table: aws_cdk.aws_dynamodb.ITable,
    ) -> None:
        '''
        :param global_secondary_index_name: 
        :param table: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMetricFactoryProps.__init__)
            check_type(argname="argument global_secondary_index_name", value=global_secondary_index_name, expected_type=type_hints["global_secondary_index_name"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
        self._values: typing.Dict[str, typing.Any] = {
            "global_secondary_index_name": global_secondary_index_name,
            "table": table,
        }

    @builtins.property
    def global_secondary_index_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("global_secondary_index_name")
        assert result is not None, "Required property 'global_secondary_index_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def table(self) -> aws_cdk.aws_dynamodb.ITable:
        '''
        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(aws_cdk.aws_dynamodb.ITable, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoTableGlobalSecondaryIndexMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoTableMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DynamoTableMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        table: aws_cdk.aws_dynamodb.ITable,
        billing_mode: typing.Optional[aws_cdk.aws_dynamodb.BillingMode] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param table: (experimental) table to monitor.
        :param billing_mode: (experimental) table billing mode. Default: - best effort auto-detection or PROVISIONED as a fallback

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = DynamoTableMetricFactoryProps(table=table, billing_mode=billing_mode)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageSuccessfulRequestLatencyInMillis")
    def metric_average_successful_request_latency_in_millis(
        self,
        operation: aws_cdk.aws_dynamodb.Operation,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :param operation: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMetricFactory.metric_average_successful_request_latency_in_millis)
            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageSuccessfulRequestLatencyInMillis", [operation]))

    @jsii.member(jsii_name="metricConsumedReadCapacityUnits")
    def metric_consumed_read_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConsumedReadCapacityUnits", []))

    @jsii.member(jsii_name="metricConsumedWriteCapacityUnits")
    def metric_consumed_write_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConsumedWriteCapacityUnits", []))

    @jsii.member(jsii_name="metricProvisionedReadCapacityUnits")
    def metric_provisioned_read_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedReadCapacityUnits", []))

    @jsii.member(jsii_name="metricProvisionedWriteCapacityUnits")
    def metric_provisioned_write_capacity_units(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedWriteCapacityUnits", []))

    @jsii.member(jsii_name="metricReadCapacityUtilizationPercentage")
    def metric_read_capacity_utilization_percentage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricReadCapacityUtilizationPercentage", []))

    @jsii.member(jsii_name="metricSearchAverageSuccessfulRequestLatencyInMillis")
    def metric_search_average_successful_request_latency_in_millis(
        self,
    ) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.invoke(self, "metricSearchAverageSuccessfulRequestLatencyInMillis", []))

    @jsii.member(jsii_name="metricSystemErrorsCount")
    def metric_system_errors_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) This represents the number of requests that resulted in a 500 (server error) error code.

        It summarizes across the basic CRUD operations:
        GetItem, BatchGetItem, Scan, Query, GetRecords, PutItem, DeleteItem, UpdateItem, BatchWriteItem

        It’s usually equal to zero.

        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSystemErrorsCount", []))

    @jsii.member(jsii_name="metricThrottledReadRequestCount")
    def metric_throttled_read_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledReadRequestCount", []))

    @jsii.member(jsii_name="metricThrottledWriteRequestCount")
    def metric_throttled_write_request_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledWriteRequestCount", []))

    @jsii.member(jsii_name="metricWriteCapacityUtilizationPercentage")
    def metric_write_capacity_utilization_percentage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricWriteCapacityUtilizationPercentage", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="table")
    def _table(self) -> aws_cdk.aws_dynamodb.ITable:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_dynamodb.ITable, jsii.get(self, "table"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DynamoTableMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"table": "table", "billing_mode": "billingMode"},
)
class DynamoTableMetricFactoryProps:
    def __init__(
        self,
        *,
        table: aws_cdk.aws_dynamodb.ITable,
        billing_mode: typing.Optional[aws_cdk.aws_dynamodb.BillingMode] = None,
    ) -> None:
        '''
        :param table: (experimental) table to monitor.
        :param billing_mode: (experimental) table billing mode. Default: - best effort auto-detection or PROVISIONED as a fallback

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMetricFactoryProps.__init__)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument billing_mode", value=billing_mode, expected_type=type_hints["billing_mode"])
        self._values: typing.Dict[str, typing.Any] = {
            "table": table,
        }
        if billing_mode is not None:
            self._values["billing_mode"] = billing_mode

    @builtins.property
    def table(self) -> aws_cdk.aws_dynamodb.ITable:
        '''(experimental) table to monitor.

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(aws_cdk.aws_dynamodb.ITable, result)

    @builtins.property
    def billing_mode(self) -> typing.Optional[aws_cdk.aws_dynamodb.BillingMode]:
        '''(experimental) table billing mode.

        :default: - best effort auto-detection or PROVISIONED as a fallback

        :stability: experimental
        '''
        result = self._values.get("billing_mode")
        return typing.cast(typing.Optional[aws_cdk.aws_dynamodb.BillingMode], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoTableMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EC2MetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.EC2MetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2MetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = EC2MetricFactoryProps(
            auto_scaling_group=auto_scaling_group, instance_ids=instance_ids
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageCpuUtilisationPercent")
    def metric_average_cpu_utilisation_percent(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) The percentage of allocated EC2 compute units that are currently in use on the instance.

        This metric identifies the processing power required to run an application on a selected instance.
        Depending on the instance type, tools in your operating system can show a lower percentage than
        CloudWatch when the instance is not allocated a full processor core.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageCpuUtilisationPercent", []))

    @jsii.member(jsii_name="metricAverageDiskReadBytes")
    def metric_average_disk_read_bytes(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) Bytes read from all instance store volumes available to the instance.

        This metric is used to determine the volume of the data the application reads from the hard disk of the instance.
        This can be used to determine the speed of the application.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageDiskReadBytes", []))

    @jsii.member(jsii_name="metricAverageDiskReadOps")
    def metric_average_disk_read_ops(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) Completed read operations from all instance store volumes available to the instance in a specified period of time.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageDiskReadOps", []))

    @jsii.member(jsii_name="metricAverageDiskWriteBytes")
    def metric_average_disk_write_bytes(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) Bytes written to all instance store volumes available to the instance.

        This metric is used to determine the volume of the data the application writes onto the hard disk of the instance.
        This can be used to determine the speed of the application.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageDiskWriteBytes", []))

    @jsii.member(jsii_name="metricAverageDiskWriteOps")
    def metric_average_disk_write_ops(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) Completed write operations to all instance store volumes available to the instance in a specified period of time.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageDiskWriteOps", []))

    @jsii.member(jsii_name="metricAverageNetworkInRateBytes")
    def metric_average_network_in_rate_bytes(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) The number of bytes received on all network interfaces by the instance.

        This metric identifies the volume of incoming network traffic to a single instance.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageNetworkInRateBytes", []))

    @jsii.member(jsii_name="metricAverageNetworkOutRateBytes")
    def metric_average_network_out_rate_bytes(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''(experimental) The number of bytes sent out on all network interfaces by the instance.

        This metric identifies the volume of outgoing network traffic from a single instance.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "metricAverageNetworkOutRateBytes", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="strategy")
    def _strategy(self) -> "IEC2MetricFactoryStrategy":
        '''
        :stability: experimental
        '''
        return typing.cast("IEC2MetricFactoryStrategy", jsii.get(self, "strategy"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.EC2MetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "auto_scaling_group": "autoScalingGroup",
        "instance_ids": "instanceIds",
    },
)
class EC2MetricFactoryProps:
    def __init__(
        self,
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2MetricFactoryProps.__init__)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auto_scaling_group is not None:
            self._values["auto_scaling_group"] = auto_scaling_group
        if instance_ids is not None:
            self._values["instance_ids"] = instance_ids

    @builtins.property
    def auto_scaling_group(
        self,
    ) -> typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup]:
        '''(experimental) Auto-Scaling Group to monitor.

        :default: - no Auto-Scaling Group filter

        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        return typing.cast(typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup], result)

    @builtins.property
    def instance_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Selected IDs of EC2 instances to monitor.

        :default: - no instance filter

        :stability: experimental
        '''
        result = self._values.get("instance_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EC2MetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ElastiCacheAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxEvictedItemsCountAlarm")
    def add_max_evicted_items_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxItemsCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheAlarmFactory.add_max_evicted_items_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxEvictedItemsCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxItemsCountAlarm")
    def add_max_items_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxItemsCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheAlarmFactory.add_max_items_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxItemsCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxUsedSwapMemoryAlarm")
    def add_max_used_swap_memory_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxUsedSwapMemoryThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheAlarmFactory.add_max_used_swap_memory_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxUsedSwapMemoryAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinFreeableMemoryAlarm")
    def add_min_freeable_memory_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MinFreeableMemoryThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheAlarmFactory.add_min_freeable_memory_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinFreeableMemoryAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class ElastiCacheClusterMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ElastiCacheClusterMetricFactory",
):
    '''
    :see: https://docs.aws.amazon.com/AmazonElastiCache/latest/mem-ug/CacheMetrics.html
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        cluster_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param cluster_id: (experimental) Cluster to monitor. Default: - monitor all clusters

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = ElastiCacheClusterMetricFactoryProps(cluster_id=cluster_id)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageCachedItemsSizeInBytes")
    def metric_average_cached_items_size_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageCachedItemsSizeInBytes", []))

    @jsii.member(jsii_name="metricAverageConnections")
    def metric_average_connections(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageConnections", []))

    @jsii.member(jsii_name="metricAverageFreeableMemoryInBytes")
    def metric_average_freeable_memory_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageFreeableMemoryInBytes", []))

    @jsii.member(jsii_name="metricAverageSwapUsageInBytes")
    def metric_average_swap_usage_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageSwapUsageInBytes", []))

    @jsii.member(jsii_name="metricAverageUnusedMemoryInBytes")
    def metric_average_unused_memory_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageUnusedMemoryInBytes", []))

    @jsii.member(jsii_name="metricEvictions")
    def metric_evictions(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricEvictions", []))

    @jsii.member(jsii_name="metricMaxCpuUtilizationInPercent")
    def metric_max_cpu_utilization_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxCpuUtilizationInPercent", []))

    @jsii.member(jsii_name="metricMaxItemCount")
    def metric_max_item_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxItemCount", []))

    @jsii.member(jsii_name="metricNetworkBytesIn")
    def metric_network_bytes_in(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNetworkBytesIn", []))

    @jsii.member(jsii_name="metricNetworkBytesOut")
    def metric_network_bytes_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNetworkBytesOut", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ElastiCacheClusterMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"cluster_id": "clusterId"},
)
class ElastiCacheClusterMetricFactoryProps:
    def __init__(self, *, cluster_id: typing.Optional[builtins.str] = None) -> None:
        '''
        :param cluster_id: (experimental) Cluster to monitor. Default: - monitor all clusters

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMetricFactoryProps.__init__)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cluster_id is not None:
            self._values["cluster_id"] = cluster_id

    @builtins.property
    def cluster_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) Cluster to monitor.

        :default: - monitor all clusters

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.ElastiCacheClusterType")
class ElastiCacheClusterType(enum.Enum):
    '''
    :stability: experimental
    '''

    MEMCACHED = "MEMCACHED"
    '''
    :stability: experimental
    '''
    REDIS = "REDIS"
    '''
    :stability: experimental
    '''


@jsii.enum(jsii_type="cdk-monitoring-constructs.ElasticsearchClusterStatus")
class ElasticsearchClusterStatus(enum.Enum):
    '''
    :stability: experimental
    '''

    RED = "RED"
    '''
    :stability: experimental
    '''
    YELLOW = "YELLOW"
    '''
    :stability: experimental
    '''


class ErrorAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ErrorAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ErrorAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addErrorCountAlarm")
    def add_error_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        error_type: "ErrorType",
        props: typing.Union["ErrorCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param error_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ErrorAlarmFactory.add_error_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument error_type", value=error_type, expected_type=type_hints["error_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addErrorCountAlarm", [metric, error_type, props, disambiguator]))

    @jsii.member(jsii_name="addErrorRateAlarm")
    def add_error_rate_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        error_type: "ErrorType",
        props: typing.Union["ErrorRateThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param error_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ErrorAlarmFactory.add_error_rate_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument error_type", value=error_type, expected_type=type_hints["error_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addErrorRateAlarm", [metric, error_type, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ErrorCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_error_count": "maxErrorCount",
    },
)
class ErrorCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_error_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_error_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ErrorCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_error_count", value=max_error_count, expected_type=type_hints["max_error_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_error_count": max_error_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_error_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_error_count")
        assert result is not None, "Required property 'max_error_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ErrorCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ErrorRateThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_error_rate": "maxErrorRate",
    },
)
class ErrorRateThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_error_rate: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_error_rate: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ErrorRateThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_error_rate", value=max_error_rate, expected_type=type_hints["max_error_rate"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_error_rate": max_error_rate,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_error_rate(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_error_rate")
        assert result is not None, "Required property 'max_error_rate' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ErrorRateThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.ErrorType")
class ErrorType(enum.Enum):
    '''
    :stability: experimental
    '''

    FAULT = "FAULT"
    '''
    :stability: experimental
    '''
    ERROR = "ERROR"
    '''
    :stability: experimental
    '''
    SYSTEM_ERROR = "SYSTEM_ERROR"
    '''
    :stability: experimental
    '''
    USER_ERROR = "USER_ERROR"
    '''
    :stability: experimental
    '''
    FAILURE = "FAILURE"
    '''
    :stability: experimental
    '''
    ABORTED = "ABORTED"
    '''
    :stability: experimental
    '''
    THROTTLED = "THROTTLED"
    '''
    :stability: experimental
    '''
    TIMED_OUT = "TIMED_OUT"
    '''
    :stability: experimental
    '''
    READ_ERROR = "READ_ERROR"
    '''
    :stability: experimental
    '''
    WRITE_ERROR = "WRITE_ERROR"
    '''
    :stability: experimental
    '''
    EXPIRED = "EXPIRED"
    '''
    :stability: experimental
    '''
    KILLED = "KILLED"
    '''
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.FullRestartCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_full_restart_count": "maxFullRestartCount",
    },
)
class FullRestartCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_full_restart_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_full_restart_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FullRestartCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_full_restart_count", value=max_full_restart_count, expected_type=type_hints["max_full_restart_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_full_restart_count": max_full_restart_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_full_restart_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_full_restart_count")
        assert result is not None, "Required property 'max_full_restart_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FullRestartCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class GlueJobMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.GlueJobMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        job_name: builtins.str,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param job_name: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = GlueJobMetricFactoryProps(
            job_name=job_name, rate_computation_method=rate_computation_method
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricActiveExecutorsAverage")
    def metric_active_executors_average(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActiveExecutorsAverage", []))

    @jsii.member(jsii_name="metricAverageExecutorCpuUsagePercentage")
    def metric_average_executor_cpu_usage_percentage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageExecutorCpuUsagePercentage", []))

    @jsii.member(jsii_name="metricAverageExecutorMemoryUsagePercentage")
    def metric_average_executor_memory_usage_percentage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageExecutorMemoryUsagePercentage", []))

    @jsii.member(jsii_name="metricCompletedStagesSum")
    def metric_completed_stages_sum(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCompletedStagesSum", []))

    @jsii.member(jsii_name="metricCompletedTasksSum")
    def metric_completed_tasks_sum(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCompletedTasksSum", []))

    @jsii.member(jsii_name="metricFailedTasksRate")
    def metric_failed_tasks_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFailedTasksRate", []))

    @jsii.member(jsii_name="metricFailedTasksSum")
    def metric_failed_tasks_sum(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFailedTasksSum", []))

    @jsii.member(jsii_name="metricKilledTasksRate")
    def metric_killed_tasks_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricKilledTasksRate", []))

    @jsii.member(jsii_name="metricKilledTasksSum")
    def metric_killed_tasks_sum(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricKilledTasksSum", []))

    @jsii.member(jsii_name="metricMaximumNeededExecutors")
    def metric_maximum_needed_executors(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaximumNeededExecutors", []))

    @jsii.member(jsii_name="metricTotalReadBytesFromS3")
    def metric_total_read_bytes_from_s3(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalReadBytesFromS3", []))

    @jsii.member(jsii_name="metricTotalWrittenBytesToS3")
    def metric_total_written_bytes_to_s3(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalWrittenBytesToS3", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))

    @builtins.property
    @jsii.member(jsii_name="typeCountDimensionsMap")
    def _type_count_dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "typeCountDimensionsMap"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.GlueJobMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "job_name": "jobName",
        "rate_computation_method": "rateComputationMethod",
    },
)
class GlueJobMetricFactoryProps:
    def __init__(
        self,
        *,
        job_name: builtins.str,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param job_name: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMetricFactoryProps.__init__)
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "job_name": job_name,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def job_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("job_name")
        assert result is not None, "Required property 'job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GlueJobMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.GraphWidgetType")
class GraphWidgetType(enum.Enum):
    '''
    :stability: experimental
    '''

    LINE = "LINE"
    '''
    :stability: experimental
    '''
    STACKED_AREA = "STACKED_AREA"
    '''
    :stability: experimental
    '''
    PIE = "PIE"
    '''
    :stability: experimental
    '''
    BAR = "BAR"
    '''
    :stability: experimental
    '''
    SINGLE_VALUE = "SINGLE_VALUE"
    '''
    :stability: experimental
    '''


@jsii.enum(jsii_type="cdk-monitoring-constructs.HeaderLevel")
class HeaderLevel(enum.Enum):
    '''
    :stability: experimental
    '''

    LARGE = "LARGE"
    '''
    :stability: experimental
    '''
    MEDIUM = "MEDIUM"
    '''
    :stability: experimental
    '''
    SMALL = "SMALL"
    '''
    :stability: experimental
    '''


class HeaderWidget(
    aws_cdk.aws_cloudwatch.TextWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.HeaderWidget",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        text: builtins.str,
        level: typing.Optional[HeaderLevel] = None,
    ) -> None:
        '''
        :param text: -
        :param level: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HeaderWidget.__init__)
            check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            check_type(argname="argument level", value=level, expected_type=type_hints["level"])
        jsii.create(self.__class__, self, [text, level])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.HealthyTaskCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_healthy_tasks": "minHealthyTasks",
    },
)
class HealthyTaskCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_healthy_tasks: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_healthy_tasks: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HealthyTaskCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_healthy_tasks", value=min_healthy_tasks, expected_type=type_hints["min_healthy_tasks"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_healthy_tasks": min_healthy_tasks,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_healthy_tasks(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_healthy_tasks")
        assert result is not None, "Required property 'min_healthy_tasks' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HealthyTaskCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.HealthyTaskPercentThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_healthy_task_percent": "minHealthyTaskPercent",
    },
)
class HealthyTaskPercentThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_healthy_task_percent: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_healthy_task_percent: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HealthyTaskPercentThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_healthy_task_percent", value=min_healthy_task_percent, expected_type=type_hints["min_healthy_task_percent"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_healthy_task_percent": min_healthy_task_percent,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_healthy_task_percent(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_healthy_task_percent")
        assert result is not None, "Required property 'min_healthy_task_percent' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HealthyTaskPercentThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.HighConnectionCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_connection_count": "maxConnectionCount",
    },
)
class HighConnectionCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_connection_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_connection_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HighConnectionCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_connection_count", value=max_connection_count, expected_type=type_hints["max_connection_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_connection_count": max_connection_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_connection_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_connection_count")
        assert result is not None, "Required property 'max_connection_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HighConnectionCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.HighMessagesPublishedThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_messages_published_count": "maxMessagesPublishedCount",
    },
)
class HighMessagesPublishedThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_messages_published_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_messages_published_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HighMessagesPublishedThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_messages_published_count", value=max_messages_published_count, expected_type=type_hints["max_messages_published_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_messages_published_count": max_messages_published_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_messages_published_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_messages_published_count")
        assert result is not None, "Required property 'max_messages_published_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HighMessagesPublishedThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.HighTpsThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_tps": "maxTps",
    },
)
class HighTpsThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional["IAlarmActionStrategy"] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_tps: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_tps: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(HighTpsThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_tps", value=max_tps, expected_type=type_hints["max_tps"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_tps": max_tps,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional["IAlarmActionStrategy"]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional["IAlarmActionStrategy"], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_tps(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_tps")
        assert result is not None, "Required property 'max_tps' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "HighTpsThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.interface(jsii_type="cdk-monitoring-constructs.IAlarmActionStrategy")
class IAlarmActionStrategy(typing_extensions.Protocol):
    '''(experimental) An object that appends actions to alarms.

    :stability: experimental
    '''

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: "IAlarmActionStrategy",
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        ...


class _IAlarmActionStrategyProxy:
    '''(experimental) An object that appends actions to alarms.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IAlarmActionStrategy"

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmActionStrategyProps(
            alarm=alarm,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarmActions", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlarmActionStrategy).__jsii_proxy_class__ = lambda : _IAlarmActionStrategyProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IAlarmAnnotationStrategy")
class IAlarmAnnotationStrategy(typing_extensions.Protocol):
    '''(experimental) Helper class for creating annotations for alarms.

    :stability: experimental
    '''

    @jsii.member(jsii_name="createAnnotation")
    def create_annotation(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''(experimental) Creates annotation based on the metric and alarm properties.

        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        ...


class _IAlarmAnnotationStrategyProxy:
    '''(experimental) Helper class for creating annotations for alarms.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IAlarmAnnotationStrategy"

    @jsii.member(jsii_name="createAnnotation")
    def create_annotation(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''(experimental) Creates annotation based on the metric and alarm properties.

        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, jsii.invoke(self, "createAnnotation", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlarmAnnotationStrategy).__jsii_proxy_class__ = lambda : _IAlarmAnnotationStrategyProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IAlarmConsumer")
class IAlarmConsumer(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="consume")
    def consume(
        self,
        alarms: typing.Sequence[typing.Union[AlarmWithAnnotation, typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param alarms: -

        :stability: experimental
        '''
        ...


class _IAlarmConsumerProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IAlarmConsumer"

    @jsii.member(jsii_name="consume")
    def consume(
        self,
        alarms: typing.Sequence[typing.Union[AlarmWithAnnotation, typing.Dict[str, typing.Any]]],
    ) -> None:
        '''
        :param alarms: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IAlarmConsumer.consume)
            check_type(argname="argument alarms", value=alarms, expected_type=type_hints["alarms"])
        return typing.cast(None, jsii.invoke(self, "consume", [alarms]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlarmConsumer).__jsii_proxy_class__ = lambda : _IAlarmConsumerProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IAlarmDedupeStringProcessor")
class IAlarmDedupeStringProcessor(typing_extensions.Protocol):
    '''(experimental) Strategy used to finalize dedupe string.

    :stability: experimental
    '''

    @jsii.member(jsii_name="processDedupeString")
    def process_dedupe_string(self, dedupe_string: builtins.str) -> builtins.str:
        '''(experimental) Process the dedupe string which was auto-generated.

        :param dedupe_string: -

        :return: final dedupe string

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="processDedupeStringOverride")
    def process_dedupe_string_override(
        self,
        dedupe_string: builtins.str,
    ) -> builtins.str:
        '''(experimental) Process the dedupe string which was specified by the user as an override.

        :param dedupe_string: -

        :return: final dedupe string

        :stability: experimental
        '''
        ...


class _IAlarmDedupeStringProcessorProxy:
    '''(experimental) Strategy used to finalize dedupe string.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IAlarmDedupeStringProcessor"

    @jsii.member(jsii_name="processDedupeString")
    def process_dedupe_string(self, dedupe_string: builtins.str) -> builtins.str:
        '''(experimental) Process the dedupe string which was auto-generated.

        :param dedupe_string: -

        :return: final dedupe string

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IAlarmDedupeStringProcessor.process_dedupe_string)
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
        return typing.cast(builtins.str, jsii.invoke(self, "processDedupeString", [dedupe_string]))

    @jsii.member(jsii_name="processDedupeStringOverride")
    def process_dedupe_string_override(
        self,
        dedupe_string: builtins.str,
    ) -> builtins.str:
        '''(experimental) Process the dedupe string which was specified by the user as an override.

        :param dedupe_string: -

        :return: final dedupe string

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IAlarmDedupeStringProcessor.process_dedupe_string_override)
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
        return typing.cast(builtins.str, jsii.invoke(self, "processDedupeStringOverride", [dedupe_string]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IAlarmDedupeStringProcessor).__jsii_proxy_class__ = lambda : _IAlarmDedupeStringProcessorProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IDashboardFactory")
class IDashboardFactory(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="addSegment")
    def add_segment(self, props: "IDashboardFactoryProps") -> None:
        '''
        :param props: -

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createdAlarmDashboard")
    def created_alarm_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createdDashboard")
    def created_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createdSummaryDashboard")
    def created_summary_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        ...


class _IDashboardFactoryProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IDashboardFactory"

    @jsii.member(jsii_name="addSegment")
    def add_segment(self, props: "IDashboardFactoryProps") -> None:
        '''
        :param props: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IDashboardFactory.add_segment)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(None, jsii.invoke(self, "addSegment", [props]))

    @jsii.member(jsii_name="createdAlarmDashboard")
    def created_alarm_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdAlarmDashboard", []))

    @jsii.member(jsii_name="createdDashboard")
    def created_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdDashboard", []))

    @jsii.member(jsii_name="createdSummaryDashboard")
    def created_summary_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdSummaryDashboard", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDashboardFactory).__jsii_proxy_class__ = lambda : _IDashboardFactoryProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IDashboardFactoryProps")
class IDashboardFactoryProps(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @builtins.property
    @jsii.member(jsii_name="segment")
    def segment(self) -> "IDashboardSegment":
        '''(experimental) Segment to be placed on the dashboard.

        :stability: experimental
        '''
        ...

    @segment.setter
    def segment(self, value: "IDashboardSegment") -> None:
        ...

    @builtins.property
    @jsii.member(jsii_name="overrideProps")
    def override_props(self) -> typing.Optional["MonitoringDashboardsOverrideProps"]:
        '''(experimental) Dashboard placement override props.

        :default: - all default

        :stability: experimental
        '''
        ...

    @override_props.setter
    def override_props(
        self,
        value: typing.Optional["MonitoringDashboardsOverrideProps"],
    ) -> None:
        ...


class _IDashboardFactoryPropsProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IDashboardFactoryProps"

    @builtins.property
    @jsii.member(jsii_name="segment")
    def segment(self) -> "IDashboardSegment":
        '''(experimental) Segment to be placed on the dashboard.

        :stability: experimental
        '''
        return typing.cast("IDashboardSegment", jsii.get(self, "segment"))

    @segment.setter
    def segment(self, value: "IDashboardSegment") -> None:
        if __debug__:
            type_hints = typing.get_type_hints(getattr(IDashboardFactoryProps, "segment").fset)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "segment", value)

    @builtins.property
    @jsii.member(jsii_name="overrideProps")
    def override_props(self) -> typing.Optional["MonitoringDashboardsOverrideProps"]:
        '''(experimental) Dashboard placement override props.

        :default: - all default

        :stability: experimental
        '''
        return typing.cast(typing.Optional["MonitoringDashboardsOverrideProps"], jsii.get(self, "overrideProps"))

    @override_props.setter
    def override_props(
        self,
        value: typing.Optional["MonitoringDashboardsOverrideProps"],
    ) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(getattr(IDashboardFactoryProps, "override_props").fset)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "overrideProps", value)

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDashboardFactoryProps).__jsii_proxy_class__ = lambda : _IDashboardFactoryPropsProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IDashboardSegment")
class IDashboardSegment(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="alarmWidgets")
    def alarm_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for all alarms.

        These should go to the runbook or service dashboard.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for the summary.

        These should go to the team OPS dashboard.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns all widgets.

        These should go to the detailed service dashboard.

        :stability: experimental
        '''
        ...


class _IDashboardSegmentProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IDashboardSegment"

    @jsii.member(jsii_name="alarmWidgets")
    def alarm_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for all alarms.

        These should go to the runbook or service dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "alarmWidgets", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for the summary.

        These should go to the team OPS dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns all widgets.

        These should go to the detailed service dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IDashboardSegment).__jsii_proxy_class__ = lambda : _IDashboardSegmentProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IEC2MetricFactoryStrategy")
class IEC2MetricFactoryStrategy(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="createMetrics")
    def create_metrics(
        self,
        metric_factory: "MetricFactory",
        metric_name: builtins.str,
        statistic: "MetricStatistic",
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :param metric_factory: -
        :param metric_name: -
        :param statistic: -

        :stability: experimental
        '''
        ...


class _IEC2MetricFactoryStrategyProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IEC2MetricFactoryStrategy"

    @jsii.member(jsii_name="createMetrics")
    def create_metrics(
        self,
        metric_factory: "MetricFactory",
        metric_name: builtins.str,
        statistic: "MetricStatistic",
    ) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :param metric_factory: -
        :param metric_name: -
        :param statistic: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IEC2MetricFactoryStrategy.create_metrics)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.invoke(self, "createMetrics", [metric_factory, metric_name, statistic]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IEC2MetricFactoryStrategy).__jsii_proxy_class__ = lambda : _IEC2MetricFactoryStrategyProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.ILoadBalancerMetricFactory")
class ILoadBalancerMetricFactory(typing_extensions.Protocol):
    '''(experimental) Common interface for load-balancer based service metric factories.

    :stability: experimental
    '''

    @jsii.member(jsii_name="metricActiveConnectionCount")
    def metric_active_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricHealthyTaskCount")
    def metric_healthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricHealthyTaskInPercent")
    def metric_healthy_task_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricNewConnectionCount")
    def metric_new_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricProcessedBytesMin")
    def metric_processed_bytes_min(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="metricUnhealthyTaskCount")
    def metric_unhealthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        ...


class _ILoadBalancerMetricFactoryProxy:
    '''(experimental) Common interface for load-balancer based service metric factories.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.ILoadBalancerMetricFactory"

    @jsii.member(jsii_name="metricActiveConnectionCount")
    def metric_active_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActiveConnectionCount", []))

    @jsii.member(jsii_name="metricHealthyTaskCount")
    def metric_healthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskCount", []))

    @jsii.member(jsii_name="metricHealthyTaskInPercent")
    def metric_healthy_task_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskInPercent", []))

    @jsii.member(jsii_name="metricNewConnectionCount")
    def metric_new_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNewConnectionCount", []))

    @jsii.member(jsii_name="metricProcessedBytesMin")
    def metric_processed_bytes_min(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProcessedBytesMin", []))

    @jsii.member(jsii_name="metricUnhealthyTaskCount")
    def metric_unhealthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUnhealthyTaskCount", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, ILoadBalancerMetricFactory).__jsii_proxy_class__ = lambda : _ILoadBalancerMetricFactoryProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IPublisherConsumer")
class IPublisherConsumer(typing_extensions.Protocol):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="consume")
    def consume(self, lambda_function: aws_cdk.aws_lambda.IFunction) -> None:
        '''
        :param lambda_function: -

        :stability: experimental
        '''
        ...


class _IPublisherConsumerProxy:
    '''
    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IPublisherConsumer"

    @jsii.member(jsii_name="consume")
    def consume(self, lambda_function: aws_cdk.aws_lambda.IFunction) -> None:
        '''
        :param lambda_function: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(IPublisherConsumer.consume)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        return typing.cast(None, jsii.invoke(self, "consume", [lambda_function]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IPublisherConsumer).__jsii_proxy_class__ = lambda : _IPublisherConsumerProxy


@jsii.interface(jsii_type="cdk-monitoring-constructs.IWidgetFactory")
class IWidgetFactory(typing_extensions.Protocol):
    '''(experimental) Strategy for creating widgets.

    :stability: experimental
    '''

    @jsii.member(jsii_name="createAlarmDetailWidget")
    def create_alarm_detail_widget(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        alarm_description: builtins.str,
        alarm_label: builtins.str,
        alarm_name: builtins.str,
        alarm_name_suffix: builtins.str,
        alarm_rule_when_alarming: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_insufficient_data: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_ok: aws_cdk.aws_cloudwatch.IAlarmRule,
        annotation: typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]],
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.IWidget:
        '''(experimental) Create widget representing an alarm detail.

        :param alarm: 
        :param alarm_description: 
        :param alarm_label: 
        :param alarm_name: 
        :param alarm_name_suffix: 
        :param alarm_rule_when_alarming: 
        :param alarm_rule_when_insufficient_data: 
        :param alarm_rule_when_ok: 
        :param annotation: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        ...


class _IWidgetFactoryProxy:
    '''(experimental) Strategy for creating widgets.

    :stability: experimental
    '''

    __jsii_type__: typing.ClassVar[str] = "cdk-monitoring-constructs.IWidgetFactory"

    @jsii.member(jsii_name="createAlarmDetailWidget")
    def create_alarm_detail_widget(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        alarm_description: builtins.str,
        alarm_label: builtins.str,
        alarm_name: builtins.str,
        alarm_name_suffix: builtins.str,
        alarm_rule_when_alarming: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_insufficient_data: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_ok: aws_cdk.aws_cloudwatch.IAlarmRule,
        annotation: typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]],
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.IWidget:
        '''(experimental) Create widget representing an alarm detail.

        :param alarm: 
        :param alarm_description: 
        :param alarm_label: 
        :param alarm_name: 
        :param alarm_name_suffix: 
        :param alarm_rule_when_alarming: 
        :param alarm_rule_when_insufficient_data: 
        :param alarm_rule_when_ok: 
        :param annotation: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        alarm_ = AlarmWithAnnotation(
            alarm=alarm,
            alarm_description=alarm_description,
            alarm_label=alarm_label,
            alarm_name=alarm_name,
            alarm_name_suffix=alarm_name_suffix,
            alarm_rule_when_alarming=alarm_rule_when_alarming,
            alarm_rule_when_insufficient_data=alarm_rule_when_insufficient_data,
            alarm_rule_when_ok=alarm_rule_when_ok,
            annotation=annotation,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.IWidget, jsii.invoke(self, "createAlarmDetailWidget", [alarm_]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the interface
typing.cast(typing.Any, IWidgetFactory).__jsii_proxy_class__ = lambda : _IWidgetFactoryProxy


class KeyValueTableWidget(
    aws_cdk.aws_cloudwatch.TextWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KeyValueTableWidget",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        data: typing.Sequence[typing.Mapping[typing.Any, typing.Any]],
    ) -> None:
        '''
        :param data: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KeyValueTableWidget.__init__)
            check_type(argname="argument data", value=data, expected_type=type_hints["data"])
        jsii.create(self.__class__, self, [data])


class KinesisAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addIteratorMaxAgeAlarm")
    def add_iterator_max_age_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxIteratorAgeThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.add_iterator_max_age_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addIteratorMaxAgeAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addProvisionedReadThroughputExceededAlarm")
    def add_provisioned_read_throughput_exceeded_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["RecordsThrottledThreshold", typing.Dict[str, typing.Any]],
        disambiguator: builtins.str,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.add_provisioned_read_throughput_exceeded_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addProvisionedReadThroughputExceededAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addProvisionedWriteThroughputExceededAlarm")
    def add_provisioned_write_throughput_exceeded_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["RecordsThrottledThreshold", typing.Dict[str, typing.Any]],
        disambiguator: builtins.str,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.add_provisioned_write_throughput_exceeded_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addProvisionedWriteThroughputExceededAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addPutRecordsFailedAlarm")
    def add_put_records_failed_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["RecordsFailedThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.add_put_records_failed_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addPutRecordsFailedAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addPutRecordsThrottledAlarm")
    def add_put_records_throttled_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["RecordsThrottledThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisAlarmFactory.add_put_records_throttled_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addPutRecordsThrottledAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class KinesisDataAnalyticsAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addDowntimeAlarm")
    def add_downtime_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["MaxDowntimeThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsAlarmFactory.add_downtime_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addDowntimeAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addFullRestartAlarm")
    def add_full_restart_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[FullRestartCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsAlarmFactory.add_full_restart_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addFullRestartAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class KinesisDataAnalyticsMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsMetricFactory",
):
    '''
    :see: https://docs.aws.amazon.com/kinesisanalytics/latest/java/metrics-dimensions.html
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        application: builtins.str,
    ) -> None:
        '''
        :param metric_factory: -
        :param application: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = KinesisDataAnalyticsMetricFactoryProps(application=application)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricCpuUtilizationPercent")
    def metric_cpu_utilization_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCpuUtilizationPercent", []))

    @jsii.member(jsii_name="metricDowntimeMs")
    def metric_downtime_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDowntimeMs", []))

    @jsii.member(jsii_name="metricFullRestartsCount")
    def metric_full_restarts_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFullRestartsCount", []))

    @jsii.member(jsii_name="metricHeapMemoryUtilizationPercent")
    def metric_heap_memory_utilization_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHeapMemoryUtilizationPercent", []))

    @jsii.member(jsii_name="metricKPUsCount")
    def metric_kp_us_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricKPUsCount", []))

    @jsii.member(jsii_name="metricLastCheckpointDurationMs")
    def metric_last_checkpoint_duration_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLastCheckpointDurationMs", []))

    @jsii.member(jsii_name="metricLastCheckpointSizeBytes")
    def metric_last_checkpoint_size_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLastCheckpointSizeBytes", []))

    @jsii.member(jsii_name="metricNumberOfFailedCheckpointsCount")
    def metric_number_of_failed_checkpoints_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNumberOfFailedCheckpointsCount", []))

    @jsii.member(jsii_name="metricOldGenerationGCCount")
    def metric_old_generation_gc_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricOldGenerationGCCount", []))

    @jsii.member(jsii_name="metricOldGenerationGCTimeMs")
    def metric_old_generation_gc_time_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricOldGenerationGCTimeMs", []))

    @jsii.member(jsii_name="metricUptimeMs")
    def metric_uptime_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUptimeMs", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"application": "application"},
)
class KinesisDataAnalyticsMetricFactoryProps:
    def __init__(self, *, application: builtins.str) -> None:
        '''
        :param application: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMetricFactoryProps.__init__)
            check_type(argname="argument application", value=application, expected_type=type_hints["application"])
        self._values: typing.Dict[str, typing.Any] = {
            "application": application,
        }

    @builtins.property
    def application(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("application")
        assert result is not None, "Required property 'application' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataAnalyticsMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class KinesisDataStreamMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisDataStreamMetricFactory",
):
    '''
    :see: https://docs.aws.amazon.com/streams/latest/dev/monitoring-with-cloudwatch.html
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        stream_name: builtins.str,
    ) -> None:
        '''
        :param metric_factory: -
        :param stream_name: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = KinesisDataStreamMetricFactoryProps(stream_name=stream_name)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricGetRecordsIteratorAgeMaxMs")
    def metric_get_records_iterator_age_max_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGetRecordsIteratorAgeMaxMs", []))

    @jsii.member(jsii_name="metricGetRecordsLatencyAverageMs")
    def metric_get_records_latency_average_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGetRecordsLatencyAverageMs", []))

    @jsii.member(jsii_name="metricGetRecordsSuccessCount")
    def metric_get_records_success_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGetRecordsSuccessCount", []))

    @jsii.member(jsii_name="metricGetRecordsSumBytes")
    def metric_get_records_sum_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGetRecordsSumBytes", []))

    @jsii.member(jsii_name="metricGetRecordsSumCount")
    def metric_get_records_sum_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricGetRecordsSumCount", []))

    @jsii.member(jsii_name="metricIncomingDataSumBytes")
    def metric_incoming_data_sum_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingDataSumBytes", []))

    @jsii.member(jsii_name="metricIncomingDataSumCount")
    def metric_incoming_data_sum_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingDataSumCount", []))

    @jsii.member(jsii_name="metricPutRecordLatencyAverageMs")
    def metric_put_record_latency_average_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordLatencyAverageMs", []))

    @jsii.member(jsii_name="metricPutRecordsFailedRecordsCount")
    def metric_put_records_failed_records_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsFailedRecordsCount", []))

    @jsii.member(jsii_name="metricPutRecordsLatencyAverageMs")
    def metric_put_records_latency_average_ms(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsLatencyAverageMs", []))

    @jsii.member(jsii_name="metricPutRecordsSuccessCount")
    def metric_put_records_success_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsSuccessCount", []))

    @jsii.member(jsii_name="metricPutRecordsSuccessfulRecordsCount")
    def metric_put_records_successful_records_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsSuccessfulRecordsCount", []))

    @jsii.member(jsii_name="metricPutRecordsSumBytes")
    def metric_put_records_sum_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsSumBytes", []))

    @jsii.member(jsii_name="metricPutRecordsThrottledRecordsCount")
    def metric_put_records_throttled_records_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsThrottledRecordsCount", []))

    @jsii.member(jsii_name="metricPutRecordsTotalRecordsCount")
    def metric_put_records_total_records_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordsTotalRecordsCount", []))

    @jsii.member(jsii_name="metricPutRecordSuccessCount")
    def metric_put_record_success_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordSuccessCount", []))

    @jsii.member(jsii_name="metricPutRecordSumBytes")
    def metric_put_record_sum_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordSumBytes", []))

    @jsii.member(jsii_name="metricReadProvisionedThroughputExceededPercent")
    def metric_read_provisioned_throughput_exceeded_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricReadProvisionedThroughputExceededPercent", []))

    @jsii.member(jsii_name="metricWriteProvisionedThroughputExceededPercent")
    def metric_write_provisioned_throughput_exceeded_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricWriteProvisionedThroughputExceededPercent", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataStreamMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"stream_name": "streamName"},
)
class KinesisDataStreamMetricFactoryProps:
    def __init__(self, *, stream_name: builtins.str) -> None:
        '''
        :param stream_name: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMetricFactoryProps.__init__)
            check_type(argname="argument stream_name", value=stream_name, expected_type=type_hints["stream_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "stream_name": stream_name,
        }

    @builtins.property
    def stream_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("stream_name")
        assert result is not None, "Required property 'stream_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataStreamMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class KinesisFirehoseMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisFirehoseMetricFactory",
):
    '''
    :see: https://docs.aws.amazon.com/firehose/latest/dev/monitoring-with-cloudwatch-metrics.html
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        delivery_stream_name: builtins.str,
    ) -> None:
        '''
        :param metric_factory: -
        :param delivery_stream_name: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = KinesisFirehoseMetricFactoryProps(
            delivery_stream_name=delivery_stream_name
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricBytesPerSecondLimit")
    def metric_bytes_per_second_limit(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricBytesPerSecondLimit", []))

    @jsii.member(jsii_name="metricFailedConversionCount")
    def metric_failed_conversion_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFailedConversionCount", []))

    @jsii.member(jsii_name="metricIncomingBytes")
    def metric_incoming_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingBytes", []))

    @jsii.member(jsii_name="metricIncomingBytesToLimitRate")
    def metric_incoming_bytes_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingBytesToLimitRate", []))

    @jsii.member(jsii_name="metricIncomingPutRequests")
    def metric_incoming_put_requests(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingPutRequests", []))

    @jsii.member(jsii_name="metricIncomingPutRequestsToLimitRate")
    def metric_incoming_put_requests_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingPutRequestsToLimitRate", []))

    @jsii.member(jsii_name="metricIncomingRecordCount")
    def metric_incoming_record_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingRecordCount", []))

    @jsii.member(jsii_name="metricIncomingRecordsToLimitRate")
    def metric_incoming_records_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingRecordsToLimitRate", []))

    @jsii.member(jsii_name="metricPutRecordBatchLatencyP90InMillis")
    def metric_put_record_batch_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordBatchLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricPutRecordLatencyP90InMillis")
    def metric_put_record_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRecordLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricPutRequestsPerSecondLimit")
    def metric_put_requests_per_second_limit(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricPutRequestsPerSecondLimit", []))

    @jsii.member(jsii_name="metricRecordsPerSecondLimit")
    def metric_records_per_second_limit(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricRecordsPerSecondLimit", []))

    @jsii.member(jsii_name="metricSuccessfulConversionCount")
    def metric_successful_conversion_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSuccessfulConversionCount", []))

    @jsii.member(jsii_name="metricThrottledRecordCount")
    def metric_throttled_record_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottledRecordCount", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisFirehoseMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"delivery_stream_name": "deliveryStreamName"},
)
class KinesisFirehoseMetricFactoryProps:
    def __init__(self, *, delivery_stream_name: builtins.str) -> None:
        '''
        :param delivery_stream_name: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMetricFactoryProps.__init__)
            check_type(argname="argument delivery_stream_name", value=delivery_stream_name, expected_type=type_hints["delivery_stream_name"])
        self._values: typing.Dict[str, typing.Any] = {
            "delivery_stream_name": delivery_stream_name,
        }

    @builtins.property
    def delivery_stream_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("delivery_stream_name")
        assert result is not None, "Required property 'delivery_stream_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisFirehoseMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaFunctionEnhancedMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LambdaFunctionEnhancedMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        lambda_function: aws_cdk.aws_lambda.IFunction,
    ) -> None:
        '''
        :param metric_factory: -
        :param lambda_function: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionEnhancedMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        jsii.create(self.__class__, self, [metric_factory, lambda_function])

    @jsii.member(jsii_name="enhancedMetricAvgCpuTotalTime")
    def enhanced_metric_avg_cpu_total_time(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricAvgCpuTotalTime", []))

    @jsii.member(jsii_name="enhancedMetricAvgMemoryUtilization")
    def enhanced_metric_avg_memory_utilization(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricAvgMemoryUtilization", []))

    @jsii.member(jsii_name="enhancedMetricFunctionCost")
    def enhanced_metric_function_cost(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricFunctionCost", []))

    @jsii.member(jsii_name="enhancedMetricMaxCpuTotalTime")
    def enhanced_metric_max_cpu_total_time(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricMaxCpuTotalTime", []))

    @jsii.member(jsii_name="enhancedMetricMaxMemoryUtilization")
    def enhanced_metric_max_memory_utilization(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricMaxMemoryUtilization", []))

    @jsii.member(jsii_name="enhancedMetricP90CpuTotalTime")
    def enhanced_metric_p90_cpu_total_time(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricP90CpuTotalTime", []))

    @jsii.member(jsii_name="enhancedMetricP90MemoryUtilization")
    def enhanced_metric_p90_memory_utilization(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "enhancedMetricP90MemoryUtilization", []))

    @builtins.property
    @jsii.member(jsii_name="lambdaFunction")
    def _lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_lambda.IFunction, jsii.get(self, "lambdaFunction"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))


class LambdaFunctionMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LambdaFunctionMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: "MetricFactory",
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        lambda_insights_enabled: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param lambda_function: 
        :param fill_tps_with_zeroes: Default: - true
        :param lambda_insights_enabled: (experimental) Generate dashboard charts for Lambda Insights metrics. To enable Lambda Insights on your Lambda function, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html Default: - false
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = LambdaFunctionMetricFactoryProps(
            lambda_function=lambda_function,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            lambda_insights_enabled=lambda_insights_enabled,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricConcurrentExecutions")
    def metric_concurrent_executions(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConcurrentExecutions", []))

    @jsii.member(jsii_name="metricFaultCount")
    def metric_fault_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFaultCount", []))

    @jsii.member(jsii_name="metricFaultRate")
    def metric_fault_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFaultRate", []))

    @jsii.member(jsii_name="metricInvocationCount")
    def metric_invocation_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationCount", []))

    @jsii.member(jsii_name="metricInvocationRate")
    def metric_invocation_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInvocationRate", []))

    @jsii.member(jsii_name="metricLatencyP50InMillis")
    def metric_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricLatencyP90InMillis")
    def metric_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricLatencyP99InMillis")
    def metric_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricMaxIteratorAgeInMillis")
    def metric_max_iterator_age_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaxIteratorAgeInMillis", []))

    @jsii.member(jsii_name="metricProvisionedConcurrencySpilloverInvocations")
    def metric_provisioned_concurrency_spillover_invocations(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedConcurrencySpilloverInvocations", []))

    @jsii.member(jsii_name="metricProvisionedConcurrencySpilloverRate")
    def metric_provisioned_concurrency_spillover_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProvisionedConcurrencySpilloverRate", []))

    @jsii.member(jsii_name="metricThrottlesCount")
    def metric_throttles_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottlesCount", []))

    @jsii.member(jsii_name="metricThrottlesRate")
    def metric_throttles_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricThrottlesRate", []))

    @jsii.member(jsii_name="metricTps")
    def metric_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricInvocationRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTps", []))

    @builtins.property
    @jsii.member(jsii_name="fillTpsWithZeroes")
    def _fill_tps_with_zeroes(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "fillTpsWithZeroes"))

    @builtins.property
    @jsii.member(jsii_name="lambdaFunction")
    def _lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_lambda.IFunction, jsii.get(self, "lambdaFunction"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> "MetricFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactory", jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LambdaFunctionMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "lambda_function": "lambdaFunction",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "lambda_insights_enabled": "lambdaInsightsEnabled",
        "rate_computation_method": "rateComputationMethod",
    },
)
class LambdaFunctionMetricFactoryProps:
    def __init__(
        self,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        lambda_insights_enabled: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param lambda_function: 
        :param fill_tps_with_zeroes: Default: - true
        :param lambda_insights_enabled: (experimental) Generate dashboard charts for Lambda Insights metrics. To enable Lambda Insights on your Lambda function, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html Default: - false
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMetricFactoryProps.__init__)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument lambda_insights_enabled", value=lambda_insights_enabled, expected_type=type_hints["lambda_insights_enabled"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if lambda_insights_enabled is not None:
            self._values["lambda_insights_enabled"] = lambda_insights_enabled
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(aws_cdk.aws_lambda.IFunction, result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def lambda_insights_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Generate dashboard charts for Lambda Insights metrics.

        To enable Lambda Insights on your Lambda function, see
        https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("lambda_insights_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaFunctionMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LatencyAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LatencyAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addDurationAlarm")
    def add_duration_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        latency_type: "LatencyType",
        props: typing.Union[DurationThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param latency_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyAlarmFactory.add_duration_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addDurationAlarm", [metric, latency_type, props, disambiguator]))

    @jsii.member(jsii_name="addIntegrationLatencyAlarm")
    def add_integration_latency_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        latency_type: "LatencyType",
        props: typing.Union["LatencyThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param latency_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyAlarmFactory.add_integration_latency_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addIntegrationLatencyAlarm", [metric, latency_type, props, disambiguator]))

    @jsii.member(jsii_name="addJvmGarbageCollectionDurationAlarm")
    def add_jvm_garbage_collection_duration_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        latency_type: "LatencyType",
        props: typing.Union[DurationThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param latency_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyAlarmFactory.add_jvm_garbage_collection_duration_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addJvmGarbageCollectionDurationAlarm", [metric, latency_type, props, disambiguator]))

    @jsii.member(jsii_name="addLatencyAlarm")
    def add_latency_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        latency_type: "LatencyType",
        props: typing.Union["LatencyThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param latency_type: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyAlarmFactory.add_latency_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument latency_type", value=latency_type, expected_type=type_hints["latency_type"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addLatencyAlarm", [metric, latency_type, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LatencyThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_latency": "maxLatency",
    },
)
class LatencyThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_latency: aws_cdk.Duration,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_latency: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LatencyThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_latency", value=max_latency, expected_type=type_hints["max_latency"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_latency": max_latency,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_latency(self) -> aws_cdk.Duration:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_latency")
        assert result is not None, "Required property 'max_latency' is missing"
        return typing.cast(aws_cdk.Duration, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LatencyThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.LatencyType")
class LatencyType(enum.Enum):
    '''
    :stability: experimental
    '''

    P50 = "P50"
    '''
    :stability: experimental
    '''
    P70 = "P70"
    '''
    :stability: experimental
    '''
    P90 = "P90"
    '''
    :stability: experimental
    '''
    P95 = "P95"
    '''
    :stability: experimental
    '''
    P99 = "P99"
    '''
    :stability: experimental
    '''
    P999 = "P999"
    '''
    :stability: experimental
    '''
    P9999 = "P9999"
    '''
    :stability: experimental
    '''
    P100 = "P100"
    '''
    :stability: experimental
    '''
    TM50 = "TM50"
    '''
    :stability: experimental
    '''
    TM70 = "TM70"
    '''
    :stability: experimental
    '''
    TM90 = "TM90"
    '''
    :stability: experimental
    '''
    TM95 = "TM95"
    '''
    :stability: experimental
    '''
    TM99 = "TM99"
    '''
    :stability: experimental
    '''
    TM999 = "TM999"
    '''
    :stability: experimental
    '''
    TM9999 = "TM9999"
    '''
    :stability: experimental
    '''
    AVERAGE = "AVERAGE"
    '''
    :stability: experimental
    '''


@jsii.enum(jsii_type="cdk-monitoring-constructs.LogLevel")
class LogLevel(enum.Enum):
    '''(experimental) Level of a given log.

    :stability: experimental
    '''

    ERROR = "ERROR"
    '''
    :stability: experimental
    '''
    CRITICAL = "CRITICAL"
    '''
    :stability: experimental
    '''
    FATAL = "FATAL"
    '''
    :stability: experimental
    '''


class LogLevelAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LogLevelAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogLevelAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addLogCountAlarm")
    def add_log_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        log_level: LogLevel,
        props: typing.Union["LogLevelCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param log_level: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogLevelAlarmFactory.add_log_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument log_level", value=log_level, expected_type=type_hints["log_level"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addLogCountAlarm", [metric, log_level, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LogLevelCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_log_count": "maxLogCount",
    },
)
class LogLevelCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_log_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_log_count: (experimental) Threshold for the number of logs to alarm on.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogLevelCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_log_count", value=max_log_count, expected_type=type_hints["max_log_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_log_count": max_log_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_log_count(self) -> jsii.Number:
        '''(experimental) Threshold for the number of logs to alarm on.

        :stability: experimental
        '''
        result = self._values.get("max_log_count")
        assert result is not None, "Required property 'max_log_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogLevelCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LowConnectionCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_connection_count": "minConnectionCount",
    },
)
class LowConnectionCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_connection_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_connection_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LowConnectionCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_connection_count", value=min_connection_count, expected_type=type_hints["min_connection_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_connection_count": min_connection_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_connection_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_connection_count")
        assert result is not None, "Required property 'min_connection_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LowConnectionCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LowMessagesPublishedThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_messages_published_count": "minMessagesPublishedCount",
    },
)
class LowMessagesPublishedThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_messages_published_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_messages_published_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LowMessagesPublishedThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_messages_published_count", value=min_messages_published_count, expected_type=type_hints["min_messages_published_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_messages_published_count": min_messages_published_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_messages_published_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_messages_published_count")
        assert result is not None, "Required property 'min_messages_published_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LowMessagesPublishedThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LowTpsThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_tps": "minTps",
    },
)
class LowTpsThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_tps: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_tps: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LowTpsThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_tps", value=min_tps, expected_type=type_hints["min_tps"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_tps": min_tps,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_tps(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_tps")
        assert result is not None, "Required property 'min_tps' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LowTpsThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxAgeThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_age_in_millis": "maxAgeInMillis",
    },
)
class MaxAgeThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_age_in_millis: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_age_in_millis: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxAgeThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_age_in_millis", value=max_age_in_millis, expected_type=type_hints["max_age_in_millis"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_age_in_millis": max_age_in_millis,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_age_in_millis(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_age_in_millis")
        assert result is not None, "Required property 'max_age_in_millis' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxAgeThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxDowntimeThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_downtime_in_millis": "maxDowntimeInMillis",
    },
)
class MaxDowntimeThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_downtime_in_millis: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_downtime_in_millis: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxDowntimeThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_downtime_in_millis", value=max_downtime_in_millis, expected_type=type_hints["max_downtime_in_millis"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_downtime_in_millis": max_downtime_in_millis,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_downtime_in_millis(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_downtime_in_millis")
        assert result is not None, "Required property 'max_downtime_in_millis' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxDowntimeThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxIncomingMessagesCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_incoming_messages_count": "maxIncomingMessagesCount",
    },
)
class MaxIncomingMessagesCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_incoming_messages_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_incoming_messages_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxIncomingMessagesCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_incoming_messages_count", value=max_incoming_messages_count, expected_type=type_hints["max_incoming_messages_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_incoming_messages_count": max_incoming_messages_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_incoming_messages_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_incoming_messages_count")
        assert result is not None, "Required property 'max_incoming_messages_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxIncomingMessagesCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxItemsCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_items_count": "maxItemsCount",
    },
)
class MaxItemsCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_items_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_items_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxItemsCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_items_count", value=max_items_count, expected_type=type_hints["max_items_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_items_count": max_items_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_items_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_items_count")
        assert result is not None, "Required property 'max_items_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxItemsCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxIteratorAgeThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_age_in_millis": "maxAgeInMillis",
    },
)
class MaxIteratorAgeThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_age_in_millis: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_age_in_millis: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxIteratorAgeThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_age_in_millis", value=max_age_in_millis, expected_type=type_hints["max_age_in_millis"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_age_in_millis": max_age_in_millis,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_age_in_millis(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_age_in_millis")
        assert result is not None, "Required property 'max_age_in_millis' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxIteratorAgeThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxMessageAgeThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_age_in_seconds": "maxAgeInSeconds",
    },
)
class MaxMessageAgeThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_age_in_seconds: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_age_in_seconds: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxMessageAgeThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_age_in_seconds", value=max_age_in_seconds, expected_type=type_hints["max_age_in_seconds"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_age_in_seconds": max_age_in_seconds,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_age_in_seconds(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_age_in_seconds")
        assert result is not None, "Required property 'max_age_in_seconds' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxMessageAgeThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxMessageCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_message_count": "maxMessageCount",
    },
)
class MaxMessageCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_message_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_message_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxMessageCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_message_count", value=max_message_count, expected_type=type_hints["max_message_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_message_count": max_message_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_message_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_message_count")
        assert result is not None, "Required property 'max_message_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxMessageCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxTimeToDrainThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_time_to_drain": "maxTimeToDrain",
    },
)
class MaxTimeToDrainThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_time_to_drain: aws_cdk.Duration,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_time_to_drain: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxTimeToDrainThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_time_to_drain", value=max_time_to_drain, expected_type=type_hints["max_time_to_drain"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_time_to_drain": max_time_to_drain,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_time_to_drain(self) -> aws_cdk.Duration:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_time_to_drain")
        assert result is not None, "Required property 'max_time_to_drain' is missing"
        return typing.cast(aws_cdk.Duration, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxTimeToDrainThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MaxUsedSwapMemoryThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_used_swap_memory_in_bytes": "maxUsedSwapMemoryInBytes",
    },
)
class MaxUsedSwapMemoryThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_used_swap_memory_in_bytes: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_used_swap_memory_in_bytes: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MaxUsedSwapMemoryThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_used_swap_memory_in_bytes", value=max_used_swap_memory_in_bytes, expected_type=type_hints["max_used_swap_memory_in_bytes"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_used_swap_memory_in_bytes": max_used_swap_memory_in_bytes,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_used_swap_memory_in_bytes(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_used_swap_memory_in_bytes")
        assert result is not None, "Required property 'max_used_swap_memory_in_bytes' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MaxUsedSwapMemoryThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        global_defaults: typing.Optional[typing.Union["MetricFactoryDefaults", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param global_defaults: (experimental) Allows you to specify the global defaults, which can be overridden in the individual metrics or alarms.

        :stability: experimental
        '''
        props = MetricFactoryProps(global_defaults=global_defaults)

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="adaptMetric")
    def adapt_metric(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Adapts properties of a foreign metric (metric created outside of this metric factory) to comply with the global defaults.

        Might modify namespace and metric period.

        :param metric: metric to be adapted.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.adapt_metric)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "adaptMetric", [metric]))

    @jsii.member(jsii_name="adaptMetricPreservingPeriod")
    def adapt_metric_preserving_period(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Adapts properties of a foreign metric (metric created outside of this metric factory) to comply with the global defaults.

        Might modify namespace. Preserves metric period.

        :param metric: metric to be adapted.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.adapt_metric_preserving_period)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "adaptMetricPreservingPeriod", [metric]))

    @jsii.member(jsii_name="addAdditionalDimensions")
    def add_additional_dimensions(
        self,
        target: typing.Mapping[builtins.str, builtins.str],
        additional_dimensions: typing.Mapping[builtins.str, builtins.str],
    ) -> None:
        '''(experimental) Merges the given additional dimensions to the given target dimension hash.

        All existing dimensions with the same key are replaced.

        :param target: target dimension hash to update.
        :param additional_dimensions: additional dimensions.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.add_additional_dimensions)
            check_type(argname="argument target", value=target, expected_type=type_hints["target"])
            check_type(argname="argument additional_dimensions", value=additional_dimensions, expected_type=type_hints["additional_dimensions"])
        return typing.cast(None, jsii.invoke(self, "addAdditionalDimensions", [target, additional_dimensions]))

    @jsii.member(jsii_name="createMetric")
    def create_metric(
        self,
        metric_name: builtins.str,
        statistic: "MetricStatistic",
        label: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        color: typing.Optional[builtins.str] = None,
        namespace: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Factory method that creates a metric.

        The metric properties will already be updated to comply with the global defaults.

        :param metric_name: metric name.
        :param statistic: aggregation statistic to use.
        :param label: metric label; if undefined, metric name is used by CloudWatch
        :param dimensions_map: additional dimensions to be added.
        :param color: metric color; if undefined, uses a CloudWatch provided color (preferred)
        :param namespace: specify a custom namespace; if undefined, uses the global default
        :param period: specify a custom period; if undefined, uses the global default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.create_metric)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
            check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument dimensions_map", value=dimensions_map, expected_type=type_hints["dimensions_map"])
            check_type(argname="argument color", value=color, expected_type=type_hints["color"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "createMetric", [metric_name, statistic, label, dimensions_map, color, namespace, period]))

    @jsii.member(jsii_name="createMetricAnomalyDetection")
    def create_metric_anomaly_detection(
        self,
        metric: aws_cdk.aws_cloudwatch.IMetric,
        stdev: jsii.Number,
        label: builtins.str,
        color: typing.Optional[builtins.str] = None,
        expression_id: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Factory method that creates anomaly detection on a metric.

        Anomaly occurs whenever a metric value falls outside of a precomputed range of predicted values.
        The detection does not need any setup. The model will start learning automatically and should be ready in a few minutes.
        Usually, the anomaly detection is paired with an alarm.

        :param metric: metric to detect anomaly detection of.
        :param stdev: standard deviation, basically the tolerance / band thickness.
        :param label: metric label (required, as there is no reasonable default).
        :param color: metric color; if undefined, uses a CloudWatch provided color (preferred)
        :param expression_id: expression ID of the metric; uses ``m1`` if undefined
        :param period: specify a custom period; if undefined, uses the global default

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Anomaly_Detection.html
        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.create_metric_anomaly_detection)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument stdev", value=stdev, expected_type=type_hints["stdev"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument color", value=color, expected_type=type_hints["color"])
            check_type(argname="argument expression_id", value=expression_id, expected_type=type_hints["expression_id"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "createMetricAnomalyDetection", [metric, stdev, label, color, expression_id, period]))

    @jsii.member(jsii_name="createMetricMath")
    def create_metric_math(
        self,
        expression: builtins.str,
        using_metrics: typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric],
        label: builtins.str,
        color: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Factory method that creates a metric math expression.

        The metric properties will already be updated to comply with the global defaults.

        :param expression: CloudWatch metric math expression (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html).
        :param using_metrics: map of metrics, where keys are expression IDs (used in the expression) and values are metrics.
        :param label: metric label (required, as there is no reasonable default).
        :param color: metric color; if undefined, uses a CloudWatch provided color (preferred)
        :param period: specify a custom period; if undefined, uses the global default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.create_metric_math)
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument using_metrics", value=using_metrics, expected_type=type_hints["using_metrics"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument color", value=color, expected_type=type_hints["color"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "createMetricMath", [expression, using_metrics, label, color, period]))

    @jsii.member(jsii_name="createMetricSearch")
    def create_metric_search(
        self,
        query: builtins.str,
        dimensions_map: typing.Mapping[builtins.str, builtins.str],
        statistic: "MetricStatistic",
        namespace: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> aws_cdk.aws_cloudwatch.IMetric:
        '''(experimental) Factory method that creates a metric search query.

        The metric properties will already be updated to comply with the global defaults.
        If you want to match "any value" of a specific dimension, please use ``undefined`` value representation in your consumer language.
        (For example, ``undefined as any as string`` in TypeScript, due to JSII typing quirks.)

        :param query: metric search query (the same as the search query prompt in CloudWatch AWS Console), it might also be empty.
        :param dimensions_map: dimensions, further narrowing the search results; use ``undefined`` if you want to represent "any value" (in TS: ``undefined as any as string``)
        :param statistic: aggregation statistic to use.
        :param namespace: specify a custom namespace; if undefined, uses the global default
        :param label: specify custom label for search metrics; default is " " as it cannot be empty string
        :param period: specify a custom period; if undefined, uses the global default

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.create_metric_search)
            check_type(argname="argument query", value=query, expected_type=type_hints["query"])
            check_type(argname="argument dimensions_map", value=dimensions_map, expected_type=type_hints["dimensions_map"])
            check_type(argname="argument statistic", value=statistic, expected_type=type_hints["statistic"])
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.invoke(self, "createMetricSearch", [query, dimensions_map, statistic, namespace, label, period]))

    @jsii.member(jsii_name="divideMetric")
    def divide_metric(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        divisor: jsii.Number,
        label: builtins.str,
        expression_id: typing.Optional[builtins.str] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Creates a metric math expression that divides the given metric by given coefficient.

        Does nothing if the divisor is one. Preserves the metric period.

        :param metric: metric to multiply.
        :param divisor: divisor (must be > 1).
        :param label: expression label.
        :param expression_id: expression ID of the metric; uses ``m1`` if undefined

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.divide_metric)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument divisor", value=divisor, expected_type=type_hints["divisor"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument expression_id", value=expression_id, expected_type=type_hints["expression_id"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "divideMetric", [metric, divisor, label, expression_id]))

    @jsii.member(jsii_name="getNamespaceWithFallback")
    def get_namespace_with_fallback(
        self,
        value: typing.Optional[builtins.str] = None,
    ) -> builtins.str:
        '''(experimental) Returns the given namespace (if defined) or the global namespace as a fallback.

        If there is no namespace to fallback to (neither the custom or the default one), it will fail.

        :param value: custom namespace.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.get_namespace_with_fallback)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        return typing.cast(builtins.str, jsii.invoke(self, "getNamespaceWithFallback", [value]))

    @jsii.member(jsii_name="multiplyMetric")
    def multiply_metric(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        multiplier: jsii.Number,
        label: builtins.str,
        expression_id: typing.Optional[builtins.str] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Creates a metric math expression that multiplies the given metric by given coefficient.

        Does nothing if the multiplier is one. Preserves the metric period.

        :param metric: metric to multiply.
        :param multiplier: multiplier (must be > 1).
        :param label: expression label.
        :param expression_id: expression ID of the metric; uses ``m1`` if undefined

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.multiply_metric)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument multiplier", value=multiplier, expected_type=type_hints["multiplier"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument expression_id", value=expression_id, expected_type=type_hints["expression_id"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "multiplyMetric", [metric, multiplier, label, expression_id]))

    @jsii.member(jsii_name="sanitizeMetricExpressionIdSuffix")
    def sanitize_metric_expression_id_suffix(
        self,
        expression_id: builtins.str,
    ) -> builtins.str:
        '''(experimental) Helper method that helps to sanitize the given expression ID and removes all invalid characters.

        Valid expression ID regexp is the following: ^[a-z][a-zA-Z0-9_]*$
        As this is just to validate a suffix and not the whole ID, we do not have to verify the first lower case letter.

        :param expression_id: expression ID to sanitize.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.sanitize_metric_expression_id_suffix)
            check_type(argname="argument expression_id", value=expression_id, expected_type=type_hints["expression_id"])
        return typing.cast(builtins.str, jsii.invoke(self, "sanitizeMetricExpressionIdSuffix", [expression_id]))

    @jsii.member(jsii_name="toRate")
    def to_rate(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        method: "RateComputationMethod",
        add_stats_to_label: typing.Optional[builtins.bool] = None,
        expression_id: typing.Optional[builtins.str] = None,
        fill_with_zeroes: typing.Optional[builtins.bool] = None,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''(experimental) Creates a metric math expression that computes a rate from a regular metric.

        For example, it allows you to compute rate per second (TPS), per minute, or just an average of your transactions.

        :param metric: metric to calculate the rate from.
        :param method: rate computation method.
        :param add_stats_to_label: add detailed statistics (min, max, average) to the label.
        :param expression_id: expression ID of the metric; uses ``m1`` if undefined
        :param fill_with_zeroes: if TRUE, the final metric will be zero-filled (0 on no data); false if undefined

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactory.to_rate)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument add_stats_to_label", value=add_stats_to_label, expected_type=type_hints["add_stats_to_label"])
            check_type(argname="argument expression_id", value=expression_id, expected_type=type_hints["expression_id"])
            check_type(argname="argument fill_with_zeroes", value=fill_with_zeroes, expected_type=type_hints["fill_with_zeroes"])
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "toRate", [metric, method, add_stats_to_label, expression_id, fill_with_zeroes]))

    @builtins.property
    @jsii.member(jsii_name="globalDefaults")
    def _global_defaults(self) -> "MetricFactoryDefaults":
        '''
        :stability: experimental
        '''
        return typing.cast("MetricFactoryDefaults", jsii.get(self, "globalDefaults"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MetricFactoryDefaults",
    jsii_struct_bases=[],
    name_mapping={"namespace": "namespace", "period": "period"},
)
class MetricFactoryDefaults:
    def __init__(
        self,
        *,
        namespace: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
    ) -> None:
        '''(experimental) These are the globals used for each metric, unless there is some kind of override.

        :param namespace: (experimental) Each metric exists in a namespace. AWS Services have their own namespace, but here you can specify your custom one.
        :param period: (experimental) Metric period. Default value is used if not defined. Default: - DefaultMetricPeriod

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactoryDefaults.__init__)
            check_type(argname="argument namespace", value=namespace, expected_type=type_hints["namespace"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[str, typing.Any] = {}
        if namespace is not None:
            self._values["namespace"] = namespace
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def namespace(self) -> typing.Optional[builtins.str]:
        '''(experimental) Each metric exists in a namespace.

        AWS Services have their own namespace, but here you can specify your custom one.

        :stability: experimental
        '''
        result = self._values.get("namespace")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Metric period.

        Default value is used if not defined.

        :default: - DefaultMetricPeriod

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricFactoryDefaults(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"global_defaults": "globalDefaults"},
)
class MetricFactoryProps:
    def __init__(
        self,
        *,
        global_defaults: typing.Optional[typing.Union[MetricFactoryDefaults, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param global_defaults: (experimental) Allows you to specify the global defaults, which can be overridden in the individual metrics or alarms.

        :stability: experimental
        '''
        if isinstance(global_defaults, dict):
            global_defaults = MetricFactoryDefaults(**global_defaults)
        if __debug__:
            type_hints = typing.get_type_hints(MetricFactoryProps.__init__)
            check_type(argname="argument global_defaults", value=global_defaults, expected_type=type_hints["global_defaults"])
        self._values: typing.Dict[str, typing.Any] = {}
        if global_defaults is not None:
            self._values["global_defaults"] = global_defaults

    @builtins.property
    def global_defaults(self) -> typing.Optional[MetricFactoryDefaults]:
        '''(experimental) Allows you to specify the global defaults, which can be overridden in the individual metrics or alarms.

        :stability: experimental
        '''
        result = self._values.get("global_defaults")
        return typing.cast(typing.Optional[MetricFactoryDefaults], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.MetricStatistic")
class MetricStatistic(enum.Enum):
    '''(experimental) Metric aggregation statistic to be used with the IMetric objects.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html
    :stability: experimental
    '''

    P50 = "P50"
    '''(experimental) 50th percentile of all datapoints.

    :stability: experimental
    '''
    P70 = "P70"
    '''(experimental) 70th percentile of all datapoints.

    :stability: experimental
    '''
    P90 = "P90"
    '''(experimental) 90th percentile of all datapoints.

    :stability: experimental
    '''
    P95 = "P95"
    '''(experimental) 95th percentile of all datapoints.

    :stability: experimental
    '''
    P99 = "P99"
    '''(experimental) 99th percentile of all datapoints.

    :stability: experimental
    '''
    P999 = "P999"
    '''(experimental) 99.9th percentile of all datapoints.

    :stability: experimental
    '''
    P9999 = "P9999"
    '''(experimental) 99.99th percentile of all datapoints.

    :stability: experimental
    '''
    P100 = "P100"
    '''(experimental) 100th percentile of all datapoints.

    :stability: experimental
    '''
    TM50 = "TM50"
    '''(experimental) trimmed mean;

    calculates the average after removing the 50% of data points with the highest values

    :stability: experimental
    '''
    TM70 = "TM70"
    '''(experimental) trimmed mean;

    calculates the average after removing the 30% of data points with the highest values

    :stability: experimental
    '''
    TM90 = "TM90"
    '''(experimental) trimmed mean;

    calculates the average after removing the 10% of data points with the highest values

    :stability: experimental
    '''
    TM95 = "TM95"
    '''(experimental) trimmed mean;

    calculates the average after removing the 5% of data points with the highest values

    :stability: experimental
    '''
    TM99 = "TM99"
    '''(experimental) trimmed mean;

    calculates the average after removing the 1% of data points with the highest values

    :stability: experimental
    '''
    TM999 = "TM999"
    '''(experimental) trimmed mean;

    calculates the average after removing the 0.1% of data points with the highest values

    :stability: experimental
    '''
    TM9999 = "TM9999"
    '''(experimental) trimmed mean;

    calculates the average after removing the 0.01% of data points with the highest values

    :stability: experimental
    '''
    TM99_BOTH = "TM99_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 1% lowest data points and the 1% highest data points

    :stability: experimental
    '''
    TM95_BOTH = "TM95_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 5% lowest data points and the 5% highest data points

    :stability: experimental
    '''
    TM90_BOTH = "TM90_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 10% lowest data points and the 10% highest data points

    :stability: experimental
    '''
    TM85_BOTH = "TM85_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 15% lowest data points and the 15% highest data points

    :stability: experimental
    '''
    TM80_BOTH = "TM80_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 20% lowest data points and the 20% highest data points

    :stability: experimental
    '''
    TM75_BOTH = "TM75_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 25% lowest data points and the 25% highest data points

    :stability: experimental
    '''
    TM70_BOTH = "TM70_BOTH"
    '''(experimental) trimmed mean;

    calculates the average after removing the 30% lowest data points and the 30% highest data points

    :stability: experimental
    '''
    WM50 = "WM50"
    '''(experimental) winsorized mean;

    calculates the average while treating the 50% of the highest values to be equal to the value at the 50th percentile

    :stability: experimental
    '''
    WM70 = "WM70"
    '''(experimental) winsorized mean;

    calculates the average while treating the 30% of the highest values to be equal to the value at the 70th percentile

    :stability: experimental
    '''
    WM90 = "WM90"
    '''(experimental) winsorized mean;

    calculates the average while treating the 10% of the highest values to be equal to the value at the 90th percentile

    :stability: experimental
    '''
    WM95 = "WM95"
    '''(experimental) winsorized mean;

    calculates the average while treating the 5% of the highest values to be equal to the value at the 95th percentile

    :stability: experimental
    '''
    WM99 = "WM99"
    '''(experimental) winsorized mean;

    calculates the average while treating the 1% of the highest values to be equal to the value at the 99th percentile

    :stability: experimental
    '''
    WM999 = "WM999"
    '''(experimental) winsorized mean;

    calculates the average while treating the 0.1% of the highest values to be equal to the value at the 99.9th percentile

    :stability: experimental
    '''
    WM9999 = "WM9999"
    '''(experimental) winsorized mean;

    calculates the average while treating the 0.01% of the highest values to be equal to the value at the 99.99th percentile

    :stability: experimental
    '''
    WM99_BOTH = "WM99_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 1% of data points to be the value of the 99% boundary, and treating the lowest 1% of data points to be the value of the 1% boundary

    :stability: experimental
    '''
    WM95_BOTH = "WM95_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 5% of data points to be the value of the 95% boundary, and treating the lowest 5% of data points to be the value of the 5% boundary

    :stability: experimental
    '''
    WM90_BOTH = "WM90_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 10% of data points to be the value of the 90% boundary, and treating the lowest 10% of data points to be the value of the 10% boundary

    :stability: experimental
    '''
    WM85_BOTH = "WM85_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 15% of data points to be the value of the 85% boundary, and treating the lowest 15% of data points to be the value of the 15% boundary

    :stability: experimental
    '''
    WM80_BOTH = "WM80_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 20% of data points to be the value of the 80% boundary, and treating the lowest 20% of data points to be the value of the 20% boundary

    :stability: experimental
    '''
    WM75_BOTH = "WM75_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 25% of data points to be the value of the 75% boundary, and treating the lowest 25% of data points to be the value of the 25% boundary

    :stability: experimental
    '''
    WM70_BOTH = "WM70_BOTH"
    '''(experimental) winsorized mean;

    calculates the average while treating the highest 30% of data points to be the value of the 70% boundary, and treating the lowest 30% of data points to be the value of the 30% boundary

    :stability: experimental
    '''
    MIN = "MIN"
    '''(experimental) minimum of all datapoints.

    :stability: experimental
    '''
    MAX = "MAX"
    '''(experimental) maximum of all datapoints.

    :stability: experimental
    '''
    SUM = "SUM"
    '''(experimental) sum of all datapoints.

    :stability: experimental
    '''
    AVERAGE = "AVERAGE"
    '''(experimental) average of all datapoints.

    :stability: experimental
    '''
    N = "N"
    '''(experimental) number of datapoints.

    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinFreeableMemoryThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_freeable_memory_in_bytes": "minFreeableMemoryInBytes",
    },
)
class MinFreeableMemoryThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_freeable_memory_in_bytes: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_freeable_memory_in_bytes: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinFreeableMemoryThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_freeable_memory_in_bytes", value=min_freeable_memory_in_bytes, expected_type=type_hints["min_freeable_memory_in_bytes"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_freeable_memory_in_bytes": min_freeable_memory_in_bytes,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_freeable_memory_in_bytes(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_freeable_memory_in_bytes")
        assert result is not None, "Required property 'min_freeable_memory_in_bytes' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinFreeableMemoryThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinIncomingMessagesCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_incoming_messages_count": "minIncomingMessagesCount",
    },
)
class MinIncomingMessagesCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_incoming_messages_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_incoming_messages_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinIncomingMessagesCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_incoming_messages_count", value=min_incoming_messages_count, expected_type=type_hints["min_incoming_messages_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_incoming_messages_count": min_incoming_messages_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_incoming_messages_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_incoming_messages_count")
        assert result is not None, "Required property 'min_incoming_messages_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinIncomingMessagesCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinMessageCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_message_count": "minMessageCount",
    },
)
class MinMessageCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_message_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_message_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinMessageCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_message_count", value=min_message_count, expected_type=type_hints["min_message_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_message_count": min_message_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_message_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_message_count")
        assert result is not None, "Required property 'min_message_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinMessageCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinProcessedBytesThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_processed_bytes": "minProcessedBytes",
    },
)
class MinProcessedBytesThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_processed_bytes: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_processed_bytes: (experimental) Threshold for the least number of bytes processed.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinProcessedBytesThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_processed_bytes", value=min_processed_bytes, expected_type=type_hints["min_processed_bytes"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_processed_bytes": min_processed_bytes,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_processed_bytes(self) -> jsii.Number:
        '''(experimental) Threshold for the least number of bytes processed.

        :stability: experimental
        '''
        result = self._values.get("min_processed_bytes")
        assert result is not None, "Required property 'min_processed_bytes' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinProcessedBytesThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinRunningTaskCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_running_tasks": "minRunningTasks",
    },
)
class MinRunningTaskCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_running_tasks: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_running_tasks: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinRunningTaskCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_running_tasks", value=min_running_tasks, expected_type=type_hints["min_running_tasks"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_running_tasks": min_running_tasks,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_running_tasks(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_running_tasks")
        assert result is not None, "Required property 'min_running_tasks' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinRunningTaskCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MinUsageCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_count": "minCount",
    },
)
class MinUsageCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MinUsageCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_count", value=min_count, expected_type=type_hints["min_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_count": min_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_count")
        assert result is not None, "Required property 'min_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MinUsageCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDashboardSegment)
class Monitoring(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="cdk-monitoring-constructs.Monitoring",
):
    '''(experimental) An independent unit of monitoring.

    This is the base for all monitoring classes with alarm support.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: "MonitoringScope",
        *,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Monitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = BaseMonitoringProps(
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="addAlarm")
    def add_alarm(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        alarm_description: builtins.str,
        alarm_label: builtins.str,
        alarm_name: builtins.str,
        alarm_name_suffix: builtins.str,
        alarm_rule_when_alarming: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_insufficient_data: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_ok: aws_cdk.aws_cloudwatch.IAlarmRule,
        annotation: typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]],
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Adds an alarm.

        :param alarm: 
        :param alarm_description: 
        :param alarm_label: 
        :param alarm_name: 
        :param alarm_name_suffix: 
        :param alarm_rule_when_alarming: 
        :param alarm_rule_when_insufficient_data: 
        :param alarm_rule_when_ok: 
        :param annotation: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        alarm_ = AlarmWithAnnotation(
            alarm=alarm,
            alarm_description=alarm_description,
            alarm_label=alarm_label,
            alarm_name=alarm_name,
            alarm_name_suffix=alarm_name_suffix,
            alarm_rule_when_alarming=alarm_rule_when_alarming,
            alarm_rule_when_insufficient_data=alarm_rule_when_insufficient_data,
            alarm_rule_when_ok=alarm_rule_when_ok,
            annotation=annotation,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarm", [alarm_]))

    @jsii.member(jsii_name="alarmWidgets")
    def alarm_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for all alarms.

        These can go to runbook or to service dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "alarmWidgets", []))

    @jsii.member(jsii_name="createAlarmFactory")
    def create_alarm_factory(self, alarm_name_prefix: builtins.str) -> AlarmFactory:
        '''(experimental) Creates a new alarm factory.

        Alarms created will be named with the given prefix, unless a local name override is present.

        :param alarm_name_prefix: alarm name prefix.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Monitoring.create_alarm_factory)
            check_type(argname="argument alarm_name_prefix", value=alarm_name_prefix, expected_type=type_hints["alarm_name_prefix"])
        return typing.cast(AlarmFactory, jsii.invoke(self, "createAlarmFactory", [alarm_name_prefix]))

    @jsii.member(jsii_name="createdAlarms")
    def created_alarms(self) -> typing.List[AlarmWithAnnotation]:
        '''(experimental) Returns all the alarms created.

        :stability: experimental
        '''
        return typing.cast(typing.List[AlarmWithAnnotation], jsii.invoke(self, "createdAlarms", []))

    @jsii.member(jsii_name="createMetricFactory")
    def create_metric_factory(self) -> MetricFactory:
        '''(experimental) Creates a new metric factory.

        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.invoke(self, "createMetricFactory", []))

    @jsii.member(jsii_name="createWidgetFactory")
    def create_widget_factory(self) -> IWidgetFactory:
        '''(experimental) Creates a new widget factory.

        :stability: experimental
        '''
        return typing.cast(IWidgetFactory, jsii.invoke(self, "createWidgetFactory", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :default: - no widgets.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    @abc.abstractmethod
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        ...

    @builtins.property
    @jsii.member(jsii_name="alarms")
    def _alarms(self) -> typing.List[AlarmWithAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[AlarmWithAnnotation], jsii.get(self, "alarms"))

    @builtins.property
    @jsii.member(jsii_name="scope")
    def _scope(self) -> "MonitoringScope":
        '''
        :stability: experimental
        '''
        return typing.cast("MonitoringScope", jsii.get(self, "scope"))

    @builtins.property
    @jsii.member(jsii_name="localAlarmNamePrefixOverride")
    def _local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "localAlarmNamePrefixOverride"))


class _MonitoringProxy(Monitoring):
    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, Monitoring).__jsii_proxy_class__ = lambda : _MonitoringProxy


@jsii.implements(aws_cdk.IAspect)
class MonitoringAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MonitoringAspect",
):
    '''(experimental) A CDK aspect that adds support for monitoring all resources within scope.

    :stability: experimental
    '''

    def __init__(
        self,
        monitoring_facade: "MonitoringFacade",
        *,
        acm: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        api_gateway: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        api_gateway_v2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        app_sync: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        auto_scaling_group: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        billing: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        cloud_front: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        code_build: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        document_db: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        dynamo_db: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        ec2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        elastic_cache: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        glue: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_data_analytics: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_data_stream: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_firehose: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        lambda_: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        rds: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        redshift: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        s3: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        secrets_manager: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        sns: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        sqs: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        step_functions: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        synthetics_canaries: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        web_application_firewall_acl_v2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param monitoring_facade: -
        :param acm: 
        :param api_gateway: 
        :param api_gateway_v2: 
        :param app_sync: 
        :param auto_scaling_group: 
        :param billing: 
        :param cloud_front: 
        :param code_build: 
        :param document_db: 
        :param dynamo_db: 
        :param ec2: 
        :param elastic_cache: 
        :param glue: 
        :param kinesis_data_analytics: 
        :param kinesis_data_stream: 
        :param kinesis_firehose: 
        :param lambda_: 
        :param open_search: 
        :param rds: 
        :param redshift: 
        :param s3: 
        :param secrets_manager: 
        :param sns: 
        :param sqs: 
        :param step_functions: 
        :param synthetics_canaries: 
        :param web_application_firewall_acl_v2: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringAspect.__init__)
            check_type(argname="argument monitoring_facade", value=monitoring_facade, expected_type=type_hints["monitoring_facade"])
        props = MonitoringAspectProps(
            acm=acm,
            api_gateway=api_gateway,
            api_gateway_v2=api_gateway_v2,
            app_sync=app_sync,
            auto_scaling_group=auto_scaling_group,
            billing=billing,
            cloud_front=cloud_front,
            code_build=code_build,
            document_db=document_db,
            dynamo_db=dynamo_db,
            ec2=ec2,
            elastic_cache=elastic_cache,
            glue=glue,
            kinesis_data_analytics=kinesis_data_analytics,
            kinesis_data_stream=kinesis_data_stream,
            kinesis_firehose=kinesis_firehose,
            lambda_=lambda_,
            open_search=open_search,
            rds=rds,
            redshift=redshift,
            s3=s3,
            secrets_manager=secrets_manager,
            sns=sns,
            sqs=sqs,
            step_functions=step_functions,
            synthetics_canaries=synthetics_canaries,
            web_application_firewall_acl_v2=web_application_firewall_acl_v2,
        )

        jsii.create(self.__class__, self, [monitoring_facade, props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: constructs.IConstruct) -> None:
        '''(experimental) All aspects can visit an IConstruct.

        :param node: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringAspect.visit)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringAspectProps",
    jsii_struct_bases=[],
    name_mapping={
        "acm": "acm",
        "api_gateway": "apiGateway",
        "api_gateway_v2": "apiGatewayV2",
        "app_sync": "appSync",
        "auto_scaling_group": "autoScalingGroup",
        "billing": "billing",
        "cloud_front": "cloudFront",
        "code_build": "codeBuild",
        "document_db": "documentDb",
        "dynamo_db": "dynamoDB",
        "ec2": "ec2",
        "elastic_cache": "elasticCache",
        "glue": "glue",
        "kinesis_data_analytics": "kinesisDataAnalytics",
        "kinesis_data_stream": "kinesisDataStream",
        "kinesis_firehose": "kinesisFirehose",
        "lambda_": "lambda",
        "open_search": "openSearch",
        "rds": "rds",
        "redshift": "redshift",
        "s3": "s3",
        "secrets_manager": "secretsManager",
        "sns": "sns",
        "sqs": "sqs",
        "step_functions": "stepFunctions",
        "synthetics_canaries": "syntheticsCanaries",
        "web_application_firewall_acl_v2": "webApplicationFirewallAclV2",
    },
)
class MonitoringAspectProps:
    def __init__(
        self,
        *,
        acm: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        api_gateway: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        api_gateway_v2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        app_sync: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        auto_scaling_group: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        billing: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        cloud_front: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        code_build: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        document_db: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        dynamo_db: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        ec2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        elastic_cache: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        glue: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_data_analytics: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_data_stream: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        kinesis_firehose: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        lambda_: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        rds: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        redshift: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        s3: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        secrets_manager: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        sns: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        sqs: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        step_functions: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        synthetics_canaries: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
        web_application_firewall_acl_v2: typing.Optional[typing.Union["MonitoringAspectType", typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param acm: 
        :param api_gateway: 
        :param api_gateway_v2: 
        :param app_sync: 
        :param auto_scaling_group: 
        :param billing: 
        :param cloud_front: 
        :param code_build: 
        :param document_db: 
        :param dynamo_db: 
        :param ec2: 
        :param elastic_cache: 
        :param glue: 
        :param kinesis_data_analytics: 
        :param kinesis_data_stream: 
        :param kinesis_firehose: 
        :param lambda_: 
        :param open_search: 
        :param rds: 
        :param redshift: 
        :param s3: 
        :param secrets_manager: 
        :param sns: 
        :param sqs: 
        :param step_functions: 
        :param synthetics_canaries: 
        :param web_application_firewall_acl_v2: 

        :stability: experimental
        '''
        if isinstance(acm, dict):
            acm = MonitoringAspectType(**acm)
        if isinstance(api_gateway, dict):
            api_gateway = MonitoringAspectType(**api_gateway)
        if isinstance(api_gateway_v2, dict):
            api_gateway_v2 = MonitoringAspectType(**api_gateway_v2)
        if isinstance(app_sync, dict):
            app_sync = MonitoringAspectType(**app_sync)
        if isinstance(auto_scaling_group, dict):
            auto_scaling_group = MonitoringAspectType(**auto_scaling_group)
        if isinstance(billing, dict):
            billing = MonitoringAspectType(**billing)
        if isinstance(cloud_front, dict):
            cloud_front = MonitoringAspectType(**cloud_front)
        if isinstance(code_build, dict):
            code_build = MonitoringAspectType(**code_build)
        if isinstance(document_db, dict):
            document_db = MonitoringAspectType(**document_db)
        if isinstance(dynamo_db, dict):
            dynamo_db = MonitoringAspectType(**dynamo_db)
        if isinstance(ec2, dict):
            ec2 = MonitoringAspectType(**ec2)
        if isinstance(elastic_cache, dict):
            elastic_cache = MonitoringAspectType(**elastic_cache)
        if isinstance(glue, dict):
            glue = MonitoringAspectType(**glue)
        if isinstance(kinesis_data_analytics, dict):
            kinesis_data_analytics = MonitoringAspectType(**kinesis_data_analytics)
        if isinstance(kinesis_data_stream, dict):
            kinesis_data_stream = MonitoringAspectType(**kinesis_data_stream)
        if isinstance(kinesis_firehose, dict):
            kinesis_firehose = MonitoringAspectType(**kinesis_firehose)
        if isinstance(lambda_, dict):
            lambda_ = MonitoringAspectType(**lambda_)
        if isinstance(open_search, dict):
            open_search = MonitoringAspectType(**open_search)
        if isinstance(rds, dict):
            rds = MonitoringAspectType(**rds)
        if isinstance(redshift, dict):
            redshift = MonitoringAspectType(**redshift)
        if isinstance(s3, dict):
            s3 = MonitoringAspectType(**s3)
        if isinstance(secrets_manager, dict):
            secrets_manager = MonitoringAspectType(**secrets_manager)
        if isinstance(sns, dict):
            sns = MonitoringAspectType(**sns)
        if isinstance(sqs, dict):
            sqs = MonitoringAspectType(**sqs)
        if isinstance(step_functions, dict):
            step_functions = MonitoringAspectType(**step_functions)
        if isinstance(synthetics_canaries, dict):
            synthetics_canaries = MonitoringAspectType(**synthetics_canaries)
        if isinstance(web_application_firewall_acl_v2, dict):
            web_application_firewall_acl_v2 = MonitoringAspectType(**web_application_firewall_acl_v2)
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringAspectProps.__init__)
            check_type(argname="argument acm", value=acm, expected_type=type_hints["acm"])
            check_type(argname="argument api_gateway", value=api_gateway, expected_type=type_hints["api_gateway"])
            check_type(argname="argument api_gateway_v2", value=api_gateway_v2, expected_type=type_hints["api_gateway_v2"])
            check_type(argname="argument app_sync", value=app_sync, expected_type=type_hints["app_sync"])
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument billing", value=billing, expected_type=type_hints["billing"])
            check_type(argname="argument cloud_front", value=cloud_front, expected_type=type_hints["cloud_front"])
            check_type(argname="argument code_build", value=code_build, expected_type=type_hints["code_build"])
            check_type(argname="argument document_db", value=document_db, expected_type=type_hints["document_db"])
            check_type(argname="argument dynamo_db", value=dynamo_db, expected_type=type_hints["dynamo_db"])
            check_type(argname="argument ec2", value=ec2, expected_type=type_hints["ec2"])
            check_type(argname="argument elastic_cache", value=elastic_cache, expected_type=type_hints["elastic_cache"])
            check_type(argname="argument glue", value=glue, expected_type=type_hints["glue"])
            check_type(argname="argument kinesis_data_analytics", value=kinesis_data_analytics, expected_type=type_hints["kinesis_data_analytics"])
            check_type(argname="argument kinesis_data_stream", value=kinesis_data_stream, expected_type=type_hints["kinesis_data_stream"])
            check_type(argname="argument kinesis_firehose", value=kinesis_firehose, expected_type=type_hints["kinesis_firehose"])
            check_type(argname="argument lambda_", value=lambda_, expected_type=type_hints["lambda_"])
            check_type(argname="argument open_search", value=open_search, expected_type=type_hints["open_search"])
            check_type(argname="argument rds", value=rds, expected_type=type_hints["rds"])
            check_type(argname="argument redshift", value=redshift, expected_type=type_hints["redshift"])
            check_type(argname="argument s3", value=s3, expected_type=type_hints["s3"])
            check_type(argname="argument secrets_manager", value=secrets_manager, expected_type=type_hints["secrets_manager"])
            check_type(argname="argument sns", value=sns, expected_type=type_hints["sns"])
            check_type(argname="argument sqs", value=sqs, expected_type=type_hints["sqs"])
            check_type(argname="argument step_functions", value=step_functions, expected_type=type_hints["step_functions"])
            check_type(argname="argument synthetics_canaries", value=synthetics_canaries, expected_type=type_hints["synthetics_canaries"])
            check_type(argname="argument web_application_firewall_acl_v2", value=web_application_firewall_acl_v2, expected_type=type_hints["web_application_firewall_acl_v2"])
        self._values: typing.Dict[str, typing.Any] = {}
        if acm is not None:
            self._values["acm"] = acm
        if api_gateway is not None:
            self._values["api_gateway"] = api_gateway
        if api_gateway_v2 is not None:
            self._values["api_gateway_v2"] = api_gateway_v2
        if app_sync is not None:
            self._values["app_sync"] = app_sync
        if auto_scaling_group is not None:
            self._values["auto_scaling_group"] = auto_scaling_group
        if billing is not None:
            self._values["billing"] = billing
        if cloud_front is not None:
            self._values["cloud_front"] = cloud_front
        if code_build is not None:
            self._values["code_build"] = code_build
        if document_db is not None:
            self._values["document_db"] = document_db
        if dynamo_db is not None:
            self._values["dynamo_db"] = dynamo_db
        if ec2 is not None:
            self._values["ec2"] = ec2
        if elastic_cache is not None:
            self._values["elastic_cache"] = elastic_cache
        if glue is not None:
            self._values["glue"] = glue
        if kinesis_data_analytics is not None:
            self._values["kinesis_data_analytics"] = kinesis_data_analytics
        if kinesis_data_stream is not None:
            self._values["kinesis_data_stream"] = kinesis_data_stream
        if kinesis_firehose is not None:
            self._values["kinesis_firehose"] = kinesis_firehose
        if lambda_ is not None:
            self._values["lambda_"] = lambda_
        if open_search is not None:
            self._values["open_search"] = open_search
        if rds is not None:
            self._values["rds"] = rds
        if redshift is not None:
            self._values["redshift"] = redshift
        if s3 is not None:
            self._values["s3"] = s3
        if secrets_manager is not None:
            self._values["secrets_manager"] = secrets_manager
        if sns is not None:
            self._values["sns"] = sns
        if sqs is not None:
            self._values["sqs"] = sqs
        if step_functions is not None:
            self._values["step_functions"] = step_functions
        if synthetics_canaries is not None:
            self._values["synthetics_canaries"] = synthetics_canaries
        if web_application_firewall_acl_v2 is not None:
            self._values["web_application_firewall_acl_v2"] = web_application_firewall_acl_v2

    @builtins.property
    def acm(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("acm")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def api_gateway(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("api_gateway")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def api_gateway_v2(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("api_gateway_v2")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def app_sync(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("app_sync")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def auto_scaling_group(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def billing(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("billing")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def cloud_front(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("cloud_front")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def code_build(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("code_build")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def document_db(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("document_db")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def dynamo_db(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dynamo_db")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def ec2(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def elastic_cache(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("elastic_cache")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def glue(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("glue")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def kinesis_data_analytics(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("kinesis_data_analytics")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def kinesis_data_stream(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("kinesis_data_stream")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def kinesis_firehose(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("kinesis_firehose")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def lambda_(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("lambda_")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def open_search(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("open_search")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def rds(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("rds")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def redshift(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("redshift")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def s3(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("s3")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def secrets_manager(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("secrets_manager")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def sns(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("sns")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def sqs(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("sqs")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def step_functions(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("step_functions")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def synthetics_canaries(self) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("synthetics_canaries")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    @builtins.property
    def web_application_firewall_acl_v2(
        self,
    ) -> typing.Optional["MonitoringAspectType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("web_application_firewall_acl_v2")
        return typing.cast(typing.Optional["MonitoringAspectType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringAspectProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringAspectType",
    jsii_struct_bases=[],
    name_mapping={"enabled": "enabled", "props": "props"},
)
class MonitoringAspectType:
    def __init__(
        self,
        *,
        enabled: typing.Optional[builtins.bool] = None,
        props: typing.Any = None,
    ) -> None:
        '''
        :param enabled: (experimental) If the monitoring aspect is enabled for this resource. Default: - true
        :param props: (experimental) The monitoring props for this resource. Default: - none

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringAspectType.__init__)
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        self._values: typing.Dict[str, typing.Any] = {}
        if enabled is not None:
            self._values["enabled"] = enabled
        if props is not None:
            self._values["props"] = props

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) If the monitoring aspect is enabled for this resource.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def props(self) -> typing.Any:
        '''(experimental) The monitoring props for this resource.

        :default: - none

        :stability: experimental
        '''
        result = self._values.get("props")
        return typing.cast(typing.Any, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringAspectType(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringDashboardsOverrideProps",
    jsii_struct_bases=[],
    name_mapping={
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
    },
)
class MonitoringDashboardsOverrideProps:
    def __init__(
        self,
        *,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringDashboardsOverrideProps.__init__)
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringDashboardsOverrideProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringDashboardsProps",
    jsii_struct_bases=[],
    name_mapping={
        "dashboard_name_prefix": "dashboardNamePrefix",
        "create_alarm_dashboard": "createAlarmDashboard",
        "create_dashboard": "createDashboard",
        "create_summary_dashboard": "createSummaryDashboard",
        "detail_dashboard_period_override": "detailDashboardPeriodOverride",
        "detail_dashboard_range": "detailDashboardRange",
        "rendering_preference": "renderingPreference",
        "summary_dashboard_period_override": "summaryDashboardPeriodOverride",
        "summary_dashboard_range": "summaryDashboardRange",
    },
)
class MonitoringDashboardsProps:
    def __init__(
        self,
        *,
        dashboard_name_prefix: builtins.str,
        create_alarm_dashboard: typing.Optional[builtins.bool] = None,
        create_dashboard: typing.Optional[builtins.bool] = None,
        create_summary_dashboard: typing.Optional[builtins.bool] = None,
        detail_dashboard_period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        detail_dashboard_range: typing.Optional[aws_cdk.Duration] = None,
        rendering_preference: typing.Optional[DashboardRenderingPreference] = None,
        summary_dashboard_period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        summary_dashboard_range: typing.Optional[aws_cdk.Duration] = None,
    ) -> None:
        '''
        :param dashboard_name_prefix: (experimental) Prefix added to each dashboard name. This allows to have all dashboards sorted close to each other and also separate multiple monitoring facades.
        :param create_alarm_dashboard: (experimental) Flag indicating whether the alarm dashboard should be created. This is independent on other create dashboard flags. Default: - false
        :param create_dashboard: (experimental) Flag indicating whether the default dashboard should be created. This is independent on other create dashboard flags. Default: - true
        :param create_summary_dashboard: (experimental) Flag indicating whether the summary dashboard should be created. This is independent on other create dashboard flags. Default: - false
        :param detail_dashboard_period_override: (experimental) Period override for the detail dashboard (and other auxiliary dashboards). Default: - respect individual graphs (PeriodOverride.INHERIT)
        :param detail_dashboard_range: (experimental) Range of the detail dashboard (and other auxiliary dashboards). Default: - 8 hours
        :param rendering_preference: (experimental) Dashboard rendering preference. Default: - DashboardRenderingPreference.INTERACTIVE_ONLY
        :param summary_dashboard_period_override: (experimental) Period override for the summary dashboard. Default: - respect individual graphs (PeriodOverride.INHERIT)
        :param summary_dashboard_range: (experimental) Range of the summary dashboard. Default: - 14 days

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringDashboardsProps.__init__)
            check_type(argname="argument dashboard_name_prefix", value=dashboard_name_prefix, expected_type=type_hints["dashboard_name_prefix"])
            check_type(argname="argument create_alarm_dashboard", value=create_alarm_dashboard, expected_type=type_hints["create_alarm_dashboard"])
            check_type(argname="argument create_dashboard", value=create_dashboard, expected_type=type_hints["create_dashboard"])
            check_type(argname="argument create_summary_dashboard", value=create_summary_dashboard, expected_type=type_hints["create_summary_dashboard"])
            check_type(argname="argument detail_dashboard_period_override", value=detail_dashboard_period_override, expected_type=type_hints["detail_dashboard_period_override"])
            check_type(argname="argument detail_dashboard_range", value=detail_dashboard_range, expected_type=type_hints["detail_dashboard_range"])
            check_type(argname="argument rendering_preference", value=rendering_preference, expected_type=type_hints["rendering_preference"])
            check_type(argname="argument summary_dashboard_period_override", value=summary_dashboard_period_override, expected_type=type_hints["summary_dashboard_period_override"])
            check_type(argname="argument summary_dashboard_range", value=summary_dashboard_range, expected_type=type_hints["summary_dashboard_range"])
        self._values: typing.Dict[str, typing.Any] = {
            "dashboard_name_prefix": dashboard_name_prefix,
        }
        if create_alarm_dashboard is not None:
            self._values["create_alarm_dashboard"] = create_alarm_dashboard
        if create_dashboard is not None:
            self._values["create_dashboard"] = create_dashboard
        if create_summary_dashboard is not None:
            self._values["create_summary_dashboard"] = create_summary_dashboard
        if detail_dashboard_period_override is not None:
            self._values["detail_dashboard_period_override"] = detail_dashboard_period_override
        if detail_dashboard_range is not None:
            self._values["detail_dashboard_range"] = detail_dashboard_range
        if rendering_preference is not None:
            self._values["rendering_preference"] = rendering_preference
        if summary_dashboard_period_override is not None:
            self._values["summary_dashboard_period_override"] = summary_dashboard_period_override
        if summary_dashboard_range is not None:
            self._values["summary_dashboard_range"] = summary_dashboard_range

    @builtins.property
    def dashboard_name_prefix(self) -> builtins.str:
        '''(experimental) Prefix added to each dashboard name.

        This allows to have all dashboards sorted close to each other and also separate multiple monitoring facades.

        :stability: experimental
        '''
        result = self._values.get("dashboard_name_prefix")
        assert result is not None, "Required property 'dashboard_name_prefix' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def create_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating whether the alarm dashboard should be created.

        This is independent on other create dashboard flags.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("create_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def create_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating whether the default dashboard should be created.

        This is independent on other create dashboard flags.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("create_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def create_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating whether the summary dashboard should be created.

        This is independent on other create dashboard flags.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("create_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def detail_dashboard_period_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride]:
        '''(experimental) Period override for the detail dashboard (and other auxiliary dashboards).

        :default: - respect individual graphs (PeriodOverride.INHERIT)

        :stability: experimental
        '''
        result = self._values.get("detail_dashboard_period_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride], result)

    @builtins.property
    def detail_dashboard_range(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Range of the detail dashboard (and other auxiliary dashboards).

        :default: - 8 hours

        :see: DefaultDetailDashboardRange
        :stability: experimental
        '''
        result = self._values.get("detail_dashboard_range")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def rendering_preference(self) -> typing.Optional[DashboardRenderingPreference]:
        '''(experimental) Dashboard rendering preference.

        :default: - DashboardRenderingPreference.INTERACTIVE_ONLY

        :stability: experimental
        '''
        result = self._values.get("rendering_preference")
        return typing.cast(typing.Optional[DashboardRenderingPreference], result)

    @builtins.property
    def summary_dashboard_period_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride]:
        '''(experimental) Period override for the summary dashboard.

        :default: - respect individual graphs (PeriodOverride.INHERIT)

        :stability: experimental
        '''
        result = self._values.get("summary_dashboard_period_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride], result)

    @builtins.property
    def summary_dashboard_range(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Range of the summary dashboard.

        :default: - 14 days

        :stability: experimental
        '''
        result = self._values.get("summary_dashboard_range")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringDashboardsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringFacadeProps",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_factory_defaults": "alarmFactoryDefaults",
        "dashboard_factory": "dashboardFactory",
        "metric_factory_defaults": "metricFactoryDefaults",
    },
)
class MonitoringFacadeProps:
    def __init__(
        self,
        *,
        alarm_factory_defaults: typing.Optional[typing.Union[AlarmFactoryDefaults, typing.Dict[str, typing.Any]]] = None,
        dashboard_factory: typing.Optional[IDashboardFactory] = None,
        metric_factory_defaults: typing.Optional[typing.Union[MetricFactoryDefaults, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param alarm_factory_defaults: (experimental) Defaults for alarm factory. Default: - actions enabled, facade logical ID used as default alarm name prefix
        :param dashboard_factory: (experimental) Defaults for dashboard factory. Default: - ``DefaultDashboardFactory``; facade logical ID used as default name
        :param metric_factory_defaults: (experimental) Defaults for metric factory. Default: - empty (no preferences)

        :stability: experimental
        '''
        if isinstance(alarm_factory_defaults, dict):
            alarm_factory_defaults = AlarmFactoryDefaults(**alarm_factory_defaults)
        if isinstance(metric_factory_defaults, dict):
            metric_factory_defaults = MetricFactoryDefaults(**metric_factory_defaults)
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacadeProps.__init__)
            check_type(argname="argument alarm_factory_defaults", value=alarm_factory_defaults, expected_type=type_hints["alarm_factory_defaults"])
            check_type(argname="argument dashboard_factory", value=dashboard_factory, expected_type=type_hints["dashboard_factory"])
            check_type(argname="argument metric_factory_defaults", value=metric_factory_defaults, expected_type=type_hints["metric_factory_defaults"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_factory_defaults is not None:
            self._values["alarm_factory_defaults"] = alarm_factory_defaults
        if dashboard_factory is not None:
            self._values["dashboard_factory"] = dashboard_factory
        if metric_factory_defaults is not None:
            self._values["metric_factory_defaults"] = metric_factory_defaults

    @builtins.property
    def alarm_factory_defaults(self) -> typing.Optional[AlarmFactoryDefaults]:
        '''(experimental) Defaults for alarm factory.

        :default: - actions enabled, facade logical ID used as default alarm name prefix

        :stability: experimental
        '''
        result = self._values.get("alarm_factory_defaults")
        return typing.cast(typing.Optional[AlarmFactoryDefaults], result)

    @builtins.property
    def dashboard_factory(self) -> typing.Optional[IDashboardFactory]:
        '''(experimental) Defaults for dashboard factory.

        :default: - ``DefaultDashboardFactory``; facade logical ID used as default name

        :stability: experimental
        '''
        result = self._values.get("dashboard_factory")
        return typing.cast(typing.Optional[IDashboardFactory], result)

    @builtins.property
    def metric_factory_defaults(self) -> typing.Optional[MetricFactoryDefaults]:
        '''(experimental) Defaults for metric factory.

        :default: - empty (no preferences)

        :stability: experimental
        '''
        result = self._values.get("metric_factory_defaults")
        return typing.cast(typing.Optional[MetricFactoryDefaults], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringFacadeProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MonitoringHeaderWidget(
    HeaderWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MonitoringHeaderWidget",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        title: builtins.str,
        family: typing.Optional[builtins.str] = None,
        go_to_link_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param title: 
        :param family: 
        :param go_to_link_url: 

        :stability: experimental
        '''
        props = MonitoringHeaderWidgetProps(
            title=title, family=family, go_to_link_url=go_to_link_url
        )

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.MonitoringHeaderWidgetProps",
    jsii_struct_bases=[],
    name_mapping={
        "title": "title",
        "family": "family",
        "go_to_link_url": "goToLinkUrl",
    },
)
class MonitoringHeaderWidgetProps:
    def __init__(
        self,
        *,
        title: builtins.str,
        family: typing.Optional[builtins.str] = None,
        go_to_link_url: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param title: 
        :param family: 
        :param go_to_link_url: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringHeaderWidgetProps.__init__)
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
            check_type(argname="argument family", value=family, expected_type=type_hints["family"])
            check_type(argname="argument go_to_link_url", value=go_to_link_url, expected_type=type_hints["go_to_link_url"])
        self._values: typing.Dict[str, typing.Any] = {
            "title": title,
        }
        if family is not None:
            self._values["family"] = family
        if go_to_link_url is not None:
            self._values["go_to_link_url"] = go_to_link_url

    @builtins.property
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("title")
        assert result is not None, "Required property 'title' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def family(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("family")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def go_to_link_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("go_to_link_url")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "MonitoringHeaderWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MonitoringNamingStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MonitoringNamingStrategy",
):
    '''(experimental) Utility class to unify approach to naming monitoring sections.

    :see: https://docs.aws.amazon.com/cdk/latest/guide/tokens.html#tokens_lazy
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        fallback_construct_name: typing.Optional[builtins.str] = None,
        named_construct: typing.Optional[constructs.IConstruct] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param fallback_construct_name: (experimental) Fallback name before we fallback to extracting name from the construct itself. This might be some construct reference, such is cluster ID, stream name, and so on. Default: - use namedConstruct to extract the name
        :param named_construct: (experimental) Construct that this naming strategy is naming. It is used as a last resort for naming.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :stability: experimental
        '''
        input = NameResolutionInput(
            fallback_construct_name=fallback_construct_name,
            named_construct=named_construct,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
        )

        jsii.create(self.__class__, self, [input])

    @jsii.member(jsii_name="isAlarmFriendly")
    @builtins.classmethod
    def is_alarm_friendly(
        cls,
        str: builtins.str,
    ) -> typing.Union[builtins.bool, builtins.str]:
        '''
        :param str: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringNamingStrategy.is_alarm_friendly)
            check_type(argname="argument str", value=str, expected_type=type_hints["str"])
        return typing.cast(typing.Union[builtins.bool, builtins.str], jsii.sinvoke(cls, "isAlarmFriendly", [str]))

    @jsii.member(jsii_name="resolveAlarmFriendlyName")
    def resolve_alarm_friendly_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "resolveAlarmFriendlyName", []))

    @jsii.member(jsii_name="resolveHumanReadableName")
    def resolve_human_readable_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.invoke(self, "resolveHumanReadableName", []))

    @builtins.property
    @jsii.member(jsii_name="input")
    def _input(self) -> "NameResolutionInput":
        '''
        :stability: experimental
        '''
        return typing.cast("NameResolutionInput", jsii.get(self, "input"))


class MonitoringScope(
    constructs.Construct,
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="cdk-monitoring-constructs.MonitoringScope",
):
    '''(experimental) A scope (construct) where all monitoring constructs are living in.

    :stability: experimental
    '''

    def __init__(self, scope: constructs.Construct, id: builtins.str) -> None:
        '''Creates a new construct node.

        :param scope: The scope in which to define this construct.
        :param id: The scoped construct ID. Must be unique amongst siblings. If the ID includes a path separator (``/``), then it will be replaced by double dash ``--``.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringScope.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        jsii.create(self.__class__, self, [scope, id])

    @jsii.member(jsii_name="createAlarmFactory")
    @abc.abstractmethod
    def create_alarm_factory(self, alarm_name_prefix: builtins.str) -> AlarmFactory:
        '''(experimental) Creates a new alarm factory.

        Alarms created will be named with the given prefix, unless a local name override is present.

        :param alarm_name_prefix: alarm name prefix.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createAwsConsoleUrlFactory")
    @abc.abstractmethod
    def create_aws_console_url_factory(self) -> AwsConsoleUrlFactory:
        '''(experimental) Creates a new factory that creates AWS Console URLs.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createMetricFactory")
    @abc.abstractmethod
    def create_metric_factory(self) -> MetricFactory:
        '''(experimental) Creates a new metric factory.

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="createWidgetFactory")
    @abc.abstractmethod
    def create_widget_factory(self) -> IWidgetFactory:
        '''(experimental) Creates a new widget factory.

        :stability: experimental
        '''
        ...


class _MonitoringScopeProxy(MonitoringScope):
    @jsii.member(jsii_name="createAlarmFactory")
    def create_alarm_factory(self, alarm_name_prefix: builtins.str) -> AlarmFactory:
        '''(experimental) Creates a new alarm factory.

        Alarms created will be named with the given prefix, unless a local name override is present.

        :param alarm_name_prefix: alarm name prefix.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringScope.create_alarm_factory)
            check_type(argname="argument alarm_name_prefix", value=alarm_name_prefix, expected_type=type_hints["alarm_name_prefix"])
        return typing.cast(AlarmFactory, jsii.invoke(self, "createAlarmFactory", [alarm_name_prefix]))

    @jsii.member(jsii_name="createAwsConsoleUrlFactory")
    def create_aws_console_url_factory(self) -> AwsConsoleUrlFactory:
        '''(experimental) Creates a new factory that creates AWS Console URLs.

        :stability: experimental
        '''
        return typing.cast(AwsConsoleUrlFactory, jsii.invoke(self, "createAwsConsoleUrlFactory", []))

    @jsii.member(jsii_name="createMetricFactory")
    def create_metric_factory(self) -> MetricFactory:
        '''(experimental) Creates a new metric factory.

        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.invoke(self, "createMetricFactory", []))

    @jsii.member(jsii_name="createWidgetFactory")
    def create_widget_factory(self) -> IWidgetFactory:
        '''(experimental) Creates a new widget factory.

        :stability: experimental
        '''
        return typing.cast(IWidgetFactory, jsii.invoke(self, "createWidgetFactory", []))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, MonitoringScope).__jsii_proxy_class__ = lambda : _MonitoringScopeProxy


@jsii.implements(IAlarmActionStrategy)
class MultipleAlarmActionStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MultipleAlarmActionStrategy",
):
    '''(experimental) Alarm action strategy that combines multiple actions in the same order as they were given.

    :stability: experimental
    '''

    def __init__(self, actions: typing.Sequence[IAlarmActionStrategy]) -> None:
        '''
        :param actions: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MultipleAlarmActionStrategy.__init__)
            check_type(argname="argument actions", value=actions, expected_type=type_hints["actions"])
        jsii.create(self.__class__, self, [actions])

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmActionStrategyProps(
            alarm=alarm,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarmActions", [props]))

    @builtins.property
    @jsii.member(jsii_name="actions")
    def actions(self) -> typing.List[IAlarmActionStrategy]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[IAlarmActionStrategy], jsii.get(self, "actions"))


@jsii.implements(ILoadBalancerMetricFactory)
class NetworkLoadBalancerMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.NetworkLoadBalancerMetricFactory",
):
    '''(experimental) Metric factory to create metrics for network load-balanced service.

    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
    ) -> None:
        '''
        :param metric_factory: -
        :param network_load_balancer: 
        :param network_target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = NetworkLoadBalancerMetricFactoryProps(
            network_load_balancer=network_load_balancer,
            network_target_group=network_target_group,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricActiveConnectionCount")
    def metric_active_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActiveConnectionCount", []))

    @jsii.member(jsii_name="metricHealthyTaskCount")
    def metric_healthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskCount", []))

    @jsii.member(jsii_name="metricHealthyTaskInPercent")
    def metric_healthy_task_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskInPercent", []))

    @jsii.member(jsii_name="metricNewConnectionCount")
    def metric_new_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNewConnectionCount", []))

    @jsii.member(jsii_name="metricProcessedBytesMin")
    def metric_processed_bytes_min(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProcessedBytesMin", []))

    @jsii.member(jsii_name="metricUnhealthyTaskCount")
    def metric_unhealthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUnhealthyTaskCount", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="networkLoadBalancer")
    def _network_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer, jsii.get(self, "networkLoadBalancer"))

    @builtins.property
    @jsii.member(jsii_name="networkTargetGroup")
    def _network_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup, jsii.get(self, "networkTargetGroup"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.NetworkLoadBalancerMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "network_load_balancer": "networkLoadBalancer",
        "network_target_group": "networkTargetGroup",
    },
)
class NetworkLoadBalancerMetricFactoryProps:
    def __init__(
        self,
        *,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
    ) -> None:
        '''(experimental) Props to create NetworkLoadBalancerMetricFactory.

        :param network_load_balancer: 
        :param network_target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMetricFactoryProps.__init__)
            check_type(argname="argument network_load_balancer", value=network_load_balancer, expected_type=type_hints["network_load_balancer"])
            check_type(argname="argument network_target_group", value=network_target_group, expected_type=type_hints["network_target_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "network_load_balancer": network_load_balancer,
            "network_target_group": network_target_group,
        }

    @builtins.property
    def network_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_load_balancer")
        assert result is not None, "Required property 'network_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer, result)

    @builtins.property
    def network_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_target_group")
        assert result is not None, "Required property 'network_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkLoadBalancerMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.NetworkLoadBalancerMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UnhealthyTaskCountThreshold", typing.Dict[str, typing.Any]]]] = None,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param network_load_balancer: 
        :param network_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = NetworkLoadBalancerMonitoringProps(
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            network_load_balancer=network_load_balancer,
            network_target_group=network_target_group,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createTaskHealthWidget")
    def _create_task_health_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMonitoring._create_task_health_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTaskHealthWidget", [width, height]))

    @jsii.member(jsii_name="createTcpFlowsWidget")
    def _create_tcp_flows_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMonitoring._create_tcp_flows_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTcpFlowsWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def _create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="activeTcpFlowCountMetric")
    def _active_tcp_flow_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "activeTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskCountMetric")
    def _healthy_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "healthyTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskPercentMetric")
    def _healthy_task_percent_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "healthyTaskPercentMetric"))

    @builtins.property
    @jsii.member(jsii_name="humanReadableName")
    def _human_readable_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "humanReadableName"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> NetworkLoadBalancerMetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(NetworkLoadBalancerMetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="newTcpFlowCountMetric")
    def _new_tcp_flow_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "newTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesAnnotations")
    def _processed_bytes_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "processedBytesAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesMetric")
    def _processed_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "processedBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAlarmFactory")
    def _task_health_alarm_factory(self) -> "TaskHealthAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("TaskHealthAlarmFactory", jsii.get(self, "taskHealthAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAnnotations")
    def _task_health_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "taskHealthAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="throughputAlarmFactory")
    def _throughput_alarm_factory(self) -> "ThroughputAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("ThroughputAlarmFactory", jsii.get(self, "throughputAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="unhealthyTaskCountMetric")
    def _unhealthy_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "unhealthyTaskCountMetric"))


@jsii.implements(IAlarmActionStrategy)
class NoopAlarmActionStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.NoopAlarmActionStrategy",
):
    '''(experimental) Alarm action strategy that does not add any actions.

    :stability: experimental
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        _props = AlarmActionStrategyProps(
            alarm=alarm,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarmActions", [_props]))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.NotificationsFailedThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_notifications_failed_count": "maxNotificationsFailedCount",
    },
)
class NotificationsFailedThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_notifications_failed_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_notifications_failed_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NotificationsFailedThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_notifications_failed_count", value=max_notifications_failed_count, expected_type=type_hints["max_notifications_failed_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_notifications_failed_count": max_notifications_failed_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_notifications_failed_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_notifications_failed_count")
        assert result is not None, "Required property 'max_notifications_failed_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NotificationsFailedThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OpenSearchBackportedMetrics(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.OpenSearchBackportedMetrics",
):
    '''(experimental) Backported set of metric functions added in @aws-cdk/aws-elasticsearch@1.65.0.

    :see: https://github.com/aws/aws-cdk/releases/tag/v1.73.0
    :stability: experimental
    '''

    def __init__(
        self,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
    ) -> None:
        '''
        :param domain: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchBackportedMetrics.__init__)
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
        jsii.create(self.__class__, self, [domain])

    @jsii.member(jsii_name="metric")
    def metric(
        self,
        metric_name: builtins.str,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Return the given named metric for this Domain.

        :param metric_name: -
        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchBackportedMetrics.metric)
            check_type(argname="argument metric_name", value=metric_name, expected_type=type_hints["metric_name"])
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metric", [metric_name, props]))

    @jsii.member(jsii_name="metricAutomatedSnapshotFailure")
    def metric_automated_snapshot_failure(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for automated snapshot failures.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricAutomatedSnapshotFailure", [props]))

    @jsii.member(jsii_name="metricClusterIndexWriteBlocked")
    def metric_cluster_index_write_blocked(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(deprecated) Metric for the cluster blocking index writes.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 1 minute

        :deprecated: use metricClusterIndexWritesBlocked instead.

        :stability: deprecated
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricClusterIndexWriteBlocked", [props]))

    @jsii.member(jsii_name="metricClusterIndexWritesBlocked")
    def metric_cluster_index_writes_blocked(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for the cluster blocking index writes.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 1 minute

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricClusterIndexWritesBlocked", [props]))

    @jsii.member(jsii_name="metricClusterStatusRed")
    def metric_cluster_status_red(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for the time the cluster status is red.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricClusterStatusRed", [props]))

    @jsii.member(jsii_name="metricClusterStatusYellow")
    def metric_cluster_status_yellow(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for the time the cluster status is yellow.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricClusterStatusYellow", [props]))

    @jsii.member(jsii_name="metricCPUUtilization")
    def metric_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for CPU utilization.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricCPUUtilization", [props]))

    @jsii.member(jsii_name="metricFreeStorageSpace")
    def metric_free_storage_space(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for the storage space of nodes in the cluster.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - minimum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricFreeStorageSpace", [props]))

    @jsii.member(jsii_name="metricIndexingLatency")
    def metric_indexing_latency(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for indexing latency.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - p99 over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricIndexingLatency", [props]))

    @jsii.member(jsii_name="metricJVMMemoryPressure")
    def metric_jvm_memory_pressure(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for JVM memory pressure.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricJVMMemoryPressure", [props]))

    @jsii.member(jsii_name="metricKMSKeyError")
    def metric_kms_key_error(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for KMS key errors.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricKMSKeyError", [props]))

    @jsii.member(jsii_name="metricKMSKeyInaccessible")
    def metric_kms_key_inaccessible(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for KMS key being inaccessible.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricKMSKeyInaccessible", [props]))

    @jsii.member(jsii_name="metricMasterCPUUtilization")
    def metric_master_cpu_utilization(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for master CPU utilization.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricMasterCPUUtilization", [props]))

    @jsii.member(jsii_name="metricMasterJVMMemoryPressure")
    def metric_master_jvm_memory_pressure(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for master JVM memory pressure.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricMasterJVMMemoryPressure", [props]))

    @jsii.member(jsii_name="metricNodes")
    def metric_nodes(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for the number of nodes.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - minimum over 1 hour

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricNodes", [props]))

    @jsii.member(jsii_name="metricSearchableDocuments")
    def metric_searchable_documents(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for number of searchable documents.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - maximum over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricSearchableDocuments", [props]))

    @jsii.member(jsii_name="metricSearchLatency")
    def metric_search_latency(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        color: typing.Optional[builtins.str] = None,
        dimensions_map: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        region: typing.Optional[builtins.str] = None,
        statistic: typing.Optional[builtins.str] = None,
        unit: typing.Optional[aws_cdk.aws_cloudwatch.Unit] = None,
    ) -> aws_cdk.aws_cloudwatch.Metric:
        '''(experimental) Metric for search latency.

        :param account: Account which this metric comes from. Default: - Deployment account.
        :param color: The hex color code, prefixed with '#' (e.g. '#00ff00'), to use when this metric is rendered on a graph. The ``Color`` class has a set of standard colors that can be used here. Default: - Automatic color
        :param dimensions_map: Dimensions of the metric. Default: - No dimensions.
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - No label
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param region: Region which this metric comes from. Default: - Deployment region.
        :param statistic: What function to use for aggregating. Can be one of the following: - "Minimum" | "min" - "Maximum" | "max" - "Average" | "avg" - "Sum" | "sum" - "SampleCount | "n" - "pNN.NN" Default: Average
        :param unit: Unit used to filter the metric stream. Only refer to datums emitted to the metric stream with the given unit and ignore all others. Only useful when datums are being emitted to the same metric stream under different units. The default is to use all matric datums in the stream, regardless of unit, which is recommended in nearly all cases. CloudWatch does not honor this property for graphs. Default: - All metric datums in the given metric stream

        :default: - p99 over 5 minutes

        :stability: experimental
        '''
        props = aws_cdk.aws_cloudwatch.MetricOptions(
            account=account,
            color=color,
            dimensions_map=dimensions_map,
            label=label,
            period=period,
            region=region,
            statistic=statistic,
            unit=unit,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricSearchLatency", [props]))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))


class OpenSearchClusterAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addAutomatedSnapshotFailureAlarm")
    def add_automated_snapshot_failure_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchClusterAutomatedSnapshotFailureThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_automated_snapshot_failure_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addAutomatedSnapshotFailureAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addClusterIndexWritesBlockedAlarm")
    def add_cluster_index_writes_blocked_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchClusterIndexWritesBlockedThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_cluster_index_writes_blocked_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addClusterIndexWritesBlockedAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addClusterNodeCountAlarm")
    def add_cluster_node_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchClusterNodesThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_cluster_node_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addClusterNodeCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addClusterStatusAlarm")
    def add_cluster_status_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchClusterStatusCustomization", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_cluster_status_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addClusterStatusAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addKmsKeyErrorAlarm")
    def add_kms_key_error_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchKmsKeyErrorThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_kms_key_error_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addKmsKeyErrorAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addKmsKeyInaccessibleAlarm")
    def add_kms_key_inaccessible_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["OpenSearchKmsKeyInaccessibleThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAlarmFactory.add_kms_key_inaccessible_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addKmsKeyInaccessibleAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterAutomatedSnapshotFailureThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_failures": "maxFailures",
    },
)
class OpenSearchClusterAutomatedSnapshotFailureThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_failures: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_failures: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterAutomatedSnapshotFailureThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_failures", value=max_failures, expected_type=type_hints["max_failures"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_failures": max_failures,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_failures(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_failures")
        assert result is not None, "Required property 'max_failures' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterAutomatedSnapshotFailureThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterIndexWritesBlockedThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_blocked_writes": "maxBlockedWrites",
    },
)
class OpenSearchClusterIndexWritesBlockedThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_blocked_writes: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_blocked_writes: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterIndexWritesBlockedThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_blocked_writes", value=max_blocked_writes, expected_type=type_hints["max_blocked_writes"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_blocked_writes": max_blocked_writes,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_blocked_writes(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_blocked_writes")
        assert result is not None, "Required property 'max_blocked_writes' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterIndexWritesBlockedThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OpenSearchClusterMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = OpenSearchClusterMetricFactoryProps(
            domain=domain,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAutomatedSnapshotFailure")
    def metric_automated_snapshot_failure(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAutomatedSnapshotFailure", []))

    @jsii.member(jsii_name="metricClusterIndexWriteBlocked")
    def metric_cluster_index_write_blocked(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricClusterIndexWritesBlocked instead

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterIndexWriteBlocked", []))

    @jsii.member(jsii_name="metricClusterIndexWritesBlocked")
    def metric_cluster_index_writes_blocked(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterIndexWritesBlocked", []))

    @jsii.member(jsii_name="metricClusterStatusRed")
    def metric_cluster_status_red(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterStatusRed", []))

    @jsii.member(jsii_name="metricClusterStatusYellow")
    def metric_cluster_status_yellow(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricClusterStatusYellow", []))

    @jsii.member(jsii_name="metricCpuUsage")
    def metric_cpu_usage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCpuUsage", []))

    @jsii.member(jsii_name="metricDiskSpaceUsageInPercent")
    def metric_disk_space_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDiskSpaceUsageInPercent", []))

    @jsii.member(jsii_name="metricIndexingLatencyP50InMillis")
    def metric_indexing_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIndexingLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricIndexingLatencyP90InMillis")
    def metric_indexing_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIndexingLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricIndexingLatencyP99InMillis")
    def metric_indexing_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIndexingLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricJvmMemoryPressure")
    def metric_jvm_memory_pressure(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricJvmMemoryPressure", []))

    @jsii.member(jsii_name="metricKmsKeyError")
    def metric_kms_key_error(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricKmsKeyError", []))

    @jsii.member(jsii_name="metricKmsKeyInaccessible")
    def metric_kms_key_inaccessible(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricKmsKeyInaccessible", []))

    @jsii.member(jsii_name="metricMasterCpuUsage")
    def metric_master_cpu_usage(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMasterCpuUsage", []))

    @jsii.member(jsii_name="metricMasterJvmMemoryPressure")
    def metric_master_jvm_memory_pressure(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMasterJvmMemoryPressure", []))

    @jsii.member(jsii_name="metricNodes")
    def metric_nodes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNodes", []))

    @jsii.member(jsii_name="metricSearchCount")
    def metric_search_count(self) -> aws_cdk.aws_cloudwatch.Metric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.Metric, jsii.invoke(self, "metricSearchCount", []))

    @jsii.member(jsii_name="metricSearchLatencyP50InMillis")
    def metric_search_latency_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSearchLatencyP50InMillis", []))

    @jsii.member(jsii_name="metricSearchLatencyP90InMillis")
    def metric_search_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSearchLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricSearchLatencyP99InMillis")
    def metric_search_latency_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSearchLatencyP99InMillis", []))

    @jsii.member(jsii_name="metricSearchRate")
    def metric_search_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSearchRate", []))

    @jsii.member(jsii_name="metricTps")
    def metric_tps(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :deprecated: use metricSearchRate

        :stability: deprecated
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTps", []))

    @builtins.property
    @jsii.member(jsii_name="domainMetrics")
    def _domain_metrics(self) -> OpenSearchBackportedMetrics:
        '''
        :stability: experimental
        '''
        return typing.cast(OpenSearchBackportedMetrics, jsii.get(self, "domainMetrics"))

    @builtins.property
    @jsii.member(jsii_name="fillTpsWithZeroes")
    def _fill_tps_with_zeroes(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "fillTpsWithZeroes"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> "RateComputationMethod":
        '''
        :stability: experimental
        '''
        return typing.cast("RateComputationMethod", jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "domain": "domain",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class OpenSearchClusterMetricFactoryProps:
    def __init__(
        self,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
    ) -> None:
        '''
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterMetricFactoryProps.__init__)
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "domain": domain,
        }
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def domain(
        self,
    ) -> typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain]:
        '''
        :stability: experimental
        '''
        result = self._values.get("domain")
        assert result is not None, "Required property 'domain' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional["RateComputationMethod"]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional["RateComputationMethod"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class OpenSearchClusterMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional["RateComputationMethod"] = None,
        add_cluster_automated_snapshot_failure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterAutomatedSnapshotFailureThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_index_writes_blocked_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterIndexWritesBlockedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_node_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["OpenSearchClusterNodesThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_cluster_status_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["OpenSearchClusterStatusCustomization", typing.Dict[str, typing.Any]]]] = None,
        add_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_error_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["OpenSearchKmsKeyErrorThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_inaccessible_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["OpenSearchKmsKeyInaccessibleThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_master_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_master_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add_cluster_automated_snapshot_failure_alarm: 
        :param add_cluster_index_writes_blocked_alarm: 
        :param add_cluster_node_count_alarm: 
        :param add_cluster_status_alarm: 
        :param add_cpu_space_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_indexing_latency_p50_alarm: 
        :param add_indexing_latency_p90_alarm: 
        :param add_indexing_latency_p99_alarm: 
        :param add_jvm_memory_pressure_alarm: 
        :param add_kms_key_error_alarm: 
        :param add_kms_key_inaccessible_alarm: 
        :param add_master_cpu_space_usage_alarm: 
        :param add_master_jvm_memory_pressure_alarm: 
        :param add_search_latency_p50_alarm: 
        :param add_search_latency_p90_alarm: 
        :param add_search_latency_p99_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = OpenSearchClusterMonitoringProps(
            domain=domain,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add_cluster_automated_snapshot_failure_alarm=add_cluster_automated_snapshot_failure_alarm,
            add_cluster_index_writes_blocked_alarm=add_cluster_index_writes_blocked_alarm,
            add_cluster_node_count_alarm=add_cluster_node_count_alarm,
            add_cluster_status_alarm=add_cluster_status_alarm,
            add_cpu_space_usage_alarm=add_cpu_space_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_indexing_latency_p50_alarm=add_indexing_latency_p50_alarm,
            add_indexing_latency_p90_alarm=add_indexing_latency_p90_alarm,
            add_indexing_latency_p99_alarm=add_indexing_latency_p99_alarm,
            add_jvm_memory_pressure_alarm=add_jvm_memory_pressure_alarm,
            add_kms_key_error_alarm=add_kms_key_error_alarm,
            add_kms_key_inaccessible_alarm=add_kms_key_inaccessible_alarm,
            add_master_cpu_space_usage_alarm=add_master_cpu_space_usage_alarm,
            add_master_jvm_memory_pressure_alarm=add_master_jvm_memory_pressure_alarm,
            add_search_latency_p50_alarm=add_search_latency_p50_alarm,
            add_search_latency_p90_alarm=add_search_latency_p90_alarm,
            add_search_latency_p99_alarm=add_search_latency_p99_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="automatedSnapshotFailureMetric")
    def automated_snapshot_failure_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "automatedSnapshotFailureMetric"))

    @builtins.property
    @jsii.member(jsii_name="clusterAlarmFactory")
    def cluster_alarm_factory(self) -> OpenSearchClusterAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(OpenSearchClusterAlarmFactory, jsii.get(self, "clusterAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="clusterAnnotations")
    def cluster_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "clusterAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="clusterStatusRedMetric")
    def cluster_status_red_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "clusterStatusRedMetric"))

    @builtins.property
    @jsii.member(jsii_name="clusterStatusYellowMetric")
    def cluster_status_yellow_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "clusterStatusYellowMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="diskSpaceUsageMetric")
    def disk_space_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "diskSpaceUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="indexingLatencyAlarmFactory")
    def indexing_latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "indexingLatencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="indexingLatencyAnnotations")
    def indexing_latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "indexingLatencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="indexWriteBlockedMetric")
    def index_write_blocked_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "indexWriteBlockedMetric"))

    @builtins.property
    @jsii.member(jsii_name="jvmMemoryPressureMetric")
    def jvm_memory_pressure_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "jvmMemoryPressureMetric"))

    @builtins.property
    @jsii.member(jsii_name="kmsKeyErrorMetric")
    def kms_key_error_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "kmsKeyErrorMetric"))

    @builtins.property
    @jsii.member(jsii_name="kmsKeyInaccessibleMetric")
    def kms_key_inaccessible_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "kmsKeyInaccessibleMetric"))

    @builtins.property
    @jsii.member(jsii_name="masterCpuUsageMetric")
    def master_cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "masterCpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="masterJvmMemoryPressureMetric")
    def master_jvm_memory_pressure_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "masterJvmMemoryPressureMetric"))

    @builtins.property
    @jsii.member(jsii_name="masterUsageAnnotations")
    def master_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "masterUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="nodeAnnotations")
    def node_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "nodeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="nodesMetric")
    def nodes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "nodesMetric"))

    @builtins.property
    @jsii.member(jsii_name="p50IndexingLatencyMetric")
    def p50_indexing_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50IndexingLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p50SearchLatencyMetric")
    def p50_search_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50SearchLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90IndexingLatencyMetric")
    def p90_indexing_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90IndexingLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90SearchLatencyMetric")
    def p90_search_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90SearchLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99IndexingLatencyMetric")
    def p99_indexing_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99IndexingLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99SearchLatencyMetric")
    def p99_search_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99SearchLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="searchLatencyAlarmFactory")
    def search_latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "searchLatencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="searchLatencyAnnotations")
    def search_latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "searchLatencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> "UsageAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("UsageAlarmFactory", jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="usageAnnotations")
    def usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "usageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "url"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterNodesThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_nodes": "minNodes",
    },
)
class OpenSearchClusterNodesThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_nodes: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_nodes: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterNodesThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_nodes", value=min_nodes, expected_type=type_hints["min_nodes"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_nodes": min_nodes,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_nodes(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_nodes")
        assert result is not None, "Required property 'min_nodes' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterNodesThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.OpenSearchClusterStatus")
class OpenSearchClusterStatus(enum.Enum):
    '''
    :stability: experimental
    '''

    RED = "RED"
    '''
    :stability: experimental
    '''
    YELLOW = "YELLOW"
    '''
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterStatusCustomization",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "status": "status",
    },
)
class OpenSearchClusterStatusCustomization(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        status: typing.Union[OpenSearchClusterStatus, ElasticsearchClusterStatus],
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param status: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterStatusCustomization.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument status", value=status, expected_type=type_hints["status"])
        self._values: typing.Dict[str, typing.Any] = {
            "status": status,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def status(
        self,
    ) -> typing.Union[OpenSearchClusterStatus, ElasticsearchClusterStatus]:
        '''
        :stability: experimental
        '''
        result = self._values.get("status")
        assert result is not None, "Required property 'status' is missing"
        return typing.cast(typing.Union[OpenSearchClusterStatus, ElasticsearchClusterStatus], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterStatusCustomization(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchKmsKeyErrorThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_errors": "maxErrors",
    },
)
class OpenSearchKmsKeyErrorThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_errors: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_errors: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchKmsKeyErrorThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_errors", value=max_errors, expected_type=type_hints["max_errors"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_errors": max_errors,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_errors(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_errors")
        assert result is not None, "Required property 'max_errors' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchKmsKeyErrorThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchKmsKeyInaccessibleThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_access_attempts": "maxAccessAttempts",
    },
)
class OpenSearchKmsKeyInaccessibleThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_access_attempts: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_access_attempts: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchKmsKeyInaccessibleThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_access_attempts", value=max_access_attempts, expected_type=type_hints["max_access_attempts"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_access_attempts": max_access_attempts,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_access_attempts(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_access_attempts")
        assert result is not None, "Required property 'max_access_attempts' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchKmsKeyInaccessibleThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAlarmActionStrategy)
class OpsItemAlarmActionStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.OpsItemAlarmActionStrategy",
):
    '''(experimental) Alarm action strategy that creates an AWS OpsCenter OpsItem.

    :stability: experimental
    '''

    def __init__(
        self,
        severity: aws_cdk.aws_cloudwatch_actions.OpsItemSeverity,
        category: typing.Optional[aws_cdk.aws_cloudwatch_actions.OpsItemCategory] = None,
    ) -> None:
        '''
        :param severity: -
        :param category: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpsItemAlarmActionStrategy.__init__)
            check_type(argname="argument severity", value=severity, expected_type=type_hints["severity"])
            check_type(argname="argument category", value=category, expected_type=type_hints["category"])
        jsii.create(self.__class__, self, [severity, category])

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmActionStrategyProps(
            alarm=alarm,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarmActions", [props]))

    @builtins.property
    @jsii.member(jsii_name="severity")
    def severity(self) -> aws_cdk.aws_cloudwatch_actions.OpsItemSeverity:
        '''(experimental) OPS Item Severity.

        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch_actions.OpsItemSeverity, jsii.get(self, "severity"))

    @builtins.property
    @jsii.member(jsii_name="category")
    def category(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch_actions.OpsItemCategory]:
        '''(experimental) OPS Item Category.

        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch_actions.OpsItemCategory], jsii.get(self, "category"))


class QueueAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.QueueAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxQueueIncomingMessagesCountAlarm")
    def add_max_queue_incoming_messages_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_max_queue_incoming_messages_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxQueueIncomingMessagesCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxQueueMessageAgeAlarm")
    def add_max_queue_message_age_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_max_queue_message_age_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxQueueMessageAgeAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxQueueMessageCountAlarm")
    def add_max_queue_message_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_max_queue_message_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxQueueMessageCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxQueueTimeToDrainMessagesAlarm")
    def add_max_queue_time_to_drain_messages_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_max_queue_time_to_drain_messages_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxQueueTimeToDrainMessagesAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinQueueIncomingMessagesCountAlarm")
    def add_min_queue_incoming_messages_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_min_queue_incoming_messages_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinQueueIncomingMessagesCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinQueueMessageCountAlarm")
    def add_min_queue_message_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(QueueAlarmFactory.add_min_queue_message_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinQueueMessageCountAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.enum(jsii_type="cdk-monitoring-constructs.RateComputationMethod")
class RateComputationMethod(enum.Enum):
    '''(experimental) Enumeration of different rate computation methods.

    :stability: experimental
    '''

    AVERAGE = "AVERAGE"
    '''(experimental) Number of occurrences relative to requests.

    Less sensitive than per-second when TPS > 1.

    :stability: experimental
    '''
    PER_SECOND = "PER_SECOND"
    '''(experimental) Number of occurrences per second.

    More sensitive than average when TPS > 1.

    :stability: experimental
    '''
    PER_MINUTE = "PER_MINUTE"
    '''(experimental) Number of occurrences per minute.

    :stability: experimental
    '''
    PER_HOUR = "PER_HOUR"
    '''(experimental) Number of occurrences per hour.

    :stability: experimental
    '''
    PER_DAY = "PER_DAY"
    '''(experimental) Number of occurrences per day.

    :stability: experimental
    '''


class RdsClusterMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.RdsClusterMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        cluster: typing.Optional[aws_cdk.aws_rds.IDatabaseCluster] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param cluster: (experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).
        :param cluster_identifier: (deprecated) database cluster identifier (either this or ``cluster`` need to be specified).

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = RdsClusterMetricFactoryProps(
            cluster=cluster, cluster_identifier=cluster_identifier
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageCpuUsageInPercent")
    def metric_average_cpu_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageCpuUsageInPercent", []))

    @jsii.member(jsii_name="metricCommitLatencyP90InMillis")
    def metric_commit_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricCommitLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricDeleteLatencyP90InMillis")
    def metric_delete_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDeleteLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricDiskSpaceUsageInPercent")
    def metric_disk_space_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDiskSpaceUsageInPercent", []))

    @jsii.member(jsii_name="metricFreeStorageInBytes")
    def metric_free_storage_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFreeStorageInBytes", []))

    @jsii.member(jsii_name="metricInsertLatencyP90InMillis")
    def metric_insert_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricInsertLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricSelectLatencyP90InMillis")
    def metric_select_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSelectLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricTotalConnectionCount")
    def metric_total_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalConnectionCount", []))

    @jsii.member(jsii_name="metricUpdateLatencyP90InMillis")
    def metric_update_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUpdateLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricUsedStorageInBytes")
    def metric_used_storage_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUsedStorageInBytes", []))

    @builtins.property
    @jsii.member(jsii_name="clusterIdentifier")
    def cluster_identifier(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "clusterIdentifier"))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RdsClusterMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"cluster": "cluster", "cluster_identifier": "clusterIdentifier"},
)
class RdsClusterMetricFactoryProps:
    def __init__(
        self,
        *,
        cluster: typing.Optional[aws_cdk.aws_rds.IDatabaseCluster] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param cluster: (experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).
        :param cluster_identifier: (deprecated) database cluster identifier (either this or ``cluster`` need to be specified).

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMetricFactoryProps.__init__)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cluster is not None:
            self._values["cluster"] = cluster
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier

    @builtins.property
    def cluster(self) -> typing.Optional[aws_cdk.aws_rds.IDatabaseCluster]:
        '''(experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).

        :stability: experimental
        '''
        result = self._values.get("cluster")
        return typing.cast(typing.Optional[aws_cdk.aws_rds.IDatabaseCluster], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(deprecated) database cluster identifier (either this or ``cluster`` need to be specified).

        :deprecated: please use ``cluster`` instead

        :stability: deprecated
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsClusterMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsClusterMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.RdsClusterMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        cluster: typing.Optional[aws_cdk.aws_rds.IDatabaseCluster] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param cluster: (experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).
        :param cluster_identifier: (deprecated) database cluster identifier (either this or ``cluster`` need to be specified).
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_min_connection_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = RdsClusterMonitoringProps(
            cluster=cluster,
            cluster_identifier=cluster_identifier,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_max_connection_count_alarm=add_max_connection_count_alarm,
            add_min_connection_count_alarm=add_min_connection_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createConnectionsWidget")
    def create_connections_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoring.create_connections_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createConnectionsWidget", [width, height]))

    @jsii.member(jsii_name="createCpuAndDiskUsageWidget")
    def create_cpu_and_disk_usage_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoring.create_cpu_and_disk_usage_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuAndDiskUsageWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="commitLatencyMetric")
    def commit_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "commitLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="connectionAlarmFactory")
    def connection_alarm_factory(self) -> ConnectionAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ConnectionAlarmFactory, jsii.get(self, "connectionAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="connectionAnnotations")
    def connection_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "connectionAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="connectionsMetric")
    def connections_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "connectionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="deleteLatencyMetric")
    def delete_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "deleteLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="diskSpaceUsageMetric")
    def disk_space_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "diskSpaceUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="insertLatencyMetric")
    def insert_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "insertLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="selectLatencyMetric")
    def select_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "selectLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="updateLatencyMetric")
    def update_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "updateLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> "UsageAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("UsageAlarmFactory", jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="usageAnnotations")
    def usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "usageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "url"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RecordsFailedThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_records_failed_threshold": "maxRecordsFailedThreshold",
    },
)
class RecordsFailedThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_records_failed_threshold: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_records_failed_threshold: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RecordsFailedThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_records_failed_threshold", value=max_records_failed_threshold, expected_type=type_hints["max_records_failed_threshold"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_records_failed_threshold": max_records_failed_threshold,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_records_failed_threshold(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_records_failed_threshold")
        assert result is not None, "Required property 'max_records_failed_threshold' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RecordsFailedThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RecordsThrottledThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_records_throttled_threshold": "maxRecordsThrottledThreshold",
    },
)
class RecordsThrottledThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_records_throttled_threshold: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_records_throttled_threshold: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RecordsThrottledThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_records_throttled_threshold", value=max_records_throttled_threshold, expected_type=type_hints["max_records_throttled_threshold"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_records_throttled_threshold": max_records_throttled_threshold,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_records_throttled_threshold(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_records_throttled_threshold")
        assert result is not None, "Required property 'max_records_throttled_threshold' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RecordsThrottledThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RedshiftClusterMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.RedshiftClusterMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        cluster_identifier: builtins.str,
    ) -> None:
        '''
        :param metric_factory: -
        :param cluster_identifier: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = RedshiftClusterMetricFactoryProps(
            cluster_identifier=cluster_identifier
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageCpuUsageInPercent")
    def metric_average_cpu_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageCpuUsageInPercent", []))

    @jsii.member(jsii_name="metricAverageDiskSpaceUsageInPercent")
    def metric_average_disk_space_usage_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageDiskSpaceUsageInPercent", []))

    @jsii.member(jsii_name="metricLongQueryDurationP90InMillis")
    def metric_long_query_duration_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLongQueryDurationP90InMillis", []))

    @jsii.member(jsii_name="metricMaintenanceModeEnabled")
    def metric_maintenance_mode_enabled(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMaintenanceModeEnabled", []))

    @jsii.member(jsii_name="metricMediumQueryDurationP90InMillis")
    def metric_medium_query_duration_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricMediumQueryDurationP90InMillis", []))

    @jsii.member(jsii_name="metricReadLatencyP90InMillis")
    def metric_read_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricReadLatencyP90InMillis", []))

    @jsii.member(jsii_name="metricShortQueryDurationP90InMillis")
    def metric_short_query_duration_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricShortQueryDurationP90InMillis", []))

    @jsii.member(jsii_name="metricTotalConnectionCount")
    def metric_total_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTotalConnectionCount", []))

    @jsii.member(jsii_name="metricWriteLatencyP90InMillis")
    def metric_write_latency_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricWriteLatencyP90InMillis", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RedshiftClusterMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"cluster_identifier": "clusterIdentifier"},
)
class RedshiftClusterMetricFactoryProps:
    def __init__(self, *, cluster_identifier: builtins.str) -> None:
        '''
        :param cluster_identifier: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMetricFactoryProps.__init__)
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_identifier": cluster_identifier,
        }

    @builtins.property
    def cluster_identifier(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        assert result is not None, "Required property 'cluster_identifier' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RedshiftClusterMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RedshiftClusterMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.RedshiftClusterMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        cluster_identifier: builtins.str,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union["UsageThreshold", typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_long_query_duration_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param cluster_identifier: 
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_max_long_query_duration_alarm: 
        :param add_min_connection_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = RedshiftClusterMonitoringProps(
            cluster_identifier=cluster_identifier,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_max_connection_count_alarm=add_max_connection_count_alarm,
            add_max_long_query_duration_alarm=add_max_long_query_duration_alarm,
            add_min_connection_count_alarm=add_min_connection_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createConnectionsWidget")
    def create_connections_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.create_connections_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createConnectionsWidget", [width, height]))

    @jsii.member(jsii_name="createCpuAndDiskUsageWidget")
    def create_cpu_and_disk_usage_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.create_cpu_and_disk_usage_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuAndDiskUsageWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createMaintenanceWidget")
    def create_maintenance_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.create_maintenance_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMaintenanceWidget", [width, height]))

    @jsii.member(jsii_name="createQueryDurationWidget")
    def create_query_duration_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoring.create_query_duration_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createQueryDurationWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="connectionAlarmFactory")
    def connection_alarm_factory(self) -> ConnectionAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ConnectionAlarmFactory, jsii.get(self, "connectionAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="connectionAnnotations")
    def connection_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "connectionAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="connectionsMetric")
    def connections_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "connectionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="diskSpaceUsageMetric")
    def disk_space_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "diskSpaceUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="longQueryDurationMetric")
    def long_query_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "longQueryDurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="maintenanceModeMetric")
    def maintenance_mode_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "maintenanceModeMetric"))

    @builtins.property
    @jsii.member(jsii_name="mediumQueryDurationMetric")
    def medium_query_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "mediumQueryDurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="queryDurationAnnotations")
    def query_duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "queryDurationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="readLatencyMetric")
    def read_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="shortQueryDurationMetric")
    def short_query_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "shortQueryDurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> "UsageAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("UsageAlarmFactory", jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="usageAnnotations")
    def usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "usageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="writeLatencyMetric")
    def write_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "url"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RunningTaskCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_running_tasks": "maxRunningTasks",
    },
)
class RunningTaskCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_running_tasks: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_running_tasks: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RunningTaskCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_running_tasks", value=max_running_tasks, expected_type=type_hints["max_running_tasks"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_running_tasks": max_running_tasks,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_running_tasks(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_running_tasks")
        assert result is not None, "Required property 'max_running_tasks' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunningTaskCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RunningTaskRateThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_running_task_rate": "maxRunningTaskRate",
    },
)
class RunningTaskRateThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_running_task_rate: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_running_task_rate: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RunningTaskRateThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_running_task_rate", value=max_running_task_rate, expected_type=type_hints["max_running_task_rate"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_running_task_rate": max_running_task_rate,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_running_task_rate(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_running_task_rate")
        assert result is not None, "Required property 'max_running_task_rate' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RunningTaskRateThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class S3BucketMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.S3BucketMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        bucket: aws_cdk.aws_s3.IBucket,
        storage_type: typing.Optional["StorageType"] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param bucket: 
        :param storage_type: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(S3BucketMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = S3BucketMetricFactoryProps(bucket=bucket, storage_type=storage_type)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricBucketSizeBytes")
    def metric_bucket_size_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricBucketSizeBytes", []))

    @jsii.member(jsii_name="metricNumberOfObjects")
    def metric_number_of_objects(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNumberOfObjects", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="props")
    def _props(self) -> "S3BucketMetricFactoryProps":
        '''
        :stability: experimental
        '''
        return typing.cast("S3BucketMetricFactoryProps", jsii.get(self, "props"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.S3BucketMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"bucket": "bucket", "storage_type": "storageType"},
)
class S3BucketMetricFactoryProps:
    def __init__(
        self,
        *,
        bucket: aws_cdk.aws_s3.IBucket,
        storage_type: typing.Optional["StorageType"] = None,
    ) -> None:
        '''
        :param bucket: 
        :param storage_type: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(S3BucketMetricFactoryProps.__init__)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
        self._values: typing.Dict[str, typing.Any] = {
            "bucket": bucket,
        }
        if storage_type is not None:
            self._values["storage_type"] = storage_type

    @builtins.property
    def bucket(self) -> aws_cdk.aws_s3.IBucket:
        '''
        :stability: experimental
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(aws_cdk.aws_s3.IBucket, result)

    @builtins.property
    def storage_type(self) -> typing.Optional["StorageType"]:
        '''
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional["StorageType"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3BucketMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class S3BucketMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.S3BucketMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        bucket: aws_cdk.aws_s3.IBucket,
        storage_type: typing.Optional["StorageType"] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param bucket: 
        :param storage_type: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(S3BucketMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = S3BucketMonitoringProps(
            bucket=bucket,
            storage_type=storage_type,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="bucketSizeBytesMetric")
    def _bucket_size_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "bucketSizeBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="numberOfObjectsMetric")
    def _number_of_objects_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "numberOfObjectsMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def _title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def _url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "url"))


class SecretsManagerMetricsPublisher(
    constructs.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SecretsManagerMetricsPublisher",
):
    '''
    :stability: experimental
    '''

    @jsii.member(jsii_name="getInstance")
    @builtins.classmethod
    def get_instance(cls, scope: MonitoringScope) -> "SecretsManagerMetricsPublisher":
        '''
        :param scope: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerMetricsPublisher.get_instance)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        return typing.cast("SecretsManagerMetricsPublisher", jsii.sinvoke(cls, "getInstance", [scope]))

    @jsii.member(jsii_name="addSecret")
    def add_secret(self, secret: aws_cdk.aws_secretsmanager.ISecret) -> None:
        '''
        :param secret: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerMetricsPublisher.add_secret)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        return typing.cast(None, jsii.invoke(self, "addSecret", [secret]))

    @builtins.property
    @jsii.member(jsii_name="lambda")
    def lambda_(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_lambda.IFunction, jsii.get(self, "lambda"))


class SecretsManagerSecretMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SecretsManagerSecretMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        secret: aws_cdk.aws_secretsmanager.ISecret,
    ) -> None:
        '''
        :param metric_factory: -
        :param secret: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = SecretsManagerSecretMetricFactoryProps(secret=secret)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricDaysSinceLastChange")
    def metric_days_since_last_change(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDaysSinceLastChange", []))

    @jsii.member(jsii_name="metricDaysSinceLastRotation")
    def metric_days_since_last_rotation(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDaysSinceLastRotation", []))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MetricNameDaysSinceLastChange")
    def METRIC_NAME_DAYS_SINCE_LAST_CHANGE(cls) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.sget(cls, "MetricNameDaysSinceLastChange"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="MetricNameDaysSinceLastRotation")
    def METRIC_NAME_DAYS_SINCE_LAST_ROTATION(cls) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.sget(cls, "MetricNameDaysSinceLastRotation"))

    @jsii.python.classproperty
    @jsii.member(jsii_name="Namespace")
    def NAMESPACE(cls) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.sget(cls, "Namespace"))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="secret")
    def _secret(self) -> aws_cdk.aws_secretsmanager.ISecret:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_secretsmanager.ISecret, jsii.get(self, "secret"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SecretsManagerSecretMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"secret": "secret"},
)
class SecretsManagerSecretMetricFactoryProps:
    def __init__(self, *, secret: aws_cdk.aws_secretsmanager.ISecret) -> None:
        '''
        :param secret: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretMetricFactoryProps.__init__)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret": secret,
        }

    @builtins.property
    def secret(self) -> aws_cdk.aws_secretsmanager.ISecret:
        '''
        :stability: experimental
        '''
        result = self._values.get("secret")
        assert result is not None, "Required property 'secret' is missing"
        return typing.cast(aws_cdk.aws_secretsmanager.ISecret, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretsManagerSecretMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SecretsManagerSecretMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SecretsManagerSecretMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        add_days_since_last_change_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_days_since_last_rotation_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        show_last_rotation_widget: typing.Optional[builtins.bool] = None,
        use_publisher: typing.Optional[IPublisherConsumer] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param secret: 
        :param add_days_since_last_change_alarm: 
        :param add_days_since_last_rotation_alarm: 
        :param show_last_rotation_widget: Default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.
        :param use_publisher: (experimental) Provides access to the underlying metrics publisher Lambda function. This may be useful if you want to monitor the function itself.
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = SecretsManagerSecretMonitoringProps(
            secret=secret,
            add_days_since_last_change_alarm=add_days_since_last_change_alarm,
            add_days_since_last_rotation_alarm=add_days_since_last_rotation_alarm,
            show_last_rotation_widget=show_last_rotation_widget,
            use_publisher=use_publisher,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createDaysSinceLastChangeWidget")
    def create_days_since_last_change_widget(
        self,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDaysSinceLastChangeWidget", []))

    @jsii.member(jsii_name="createDaysSinceLastRotationWidget")
    def create_days_since_last_rotation_widget(
        self,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDaysSinceLastRotationWidget", []))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="daysSinceLastChangeAnnotations")
    def days_since_last_change_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "daysSinceLastChangeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="daysSinceLastChangeMetric")
    def days_since_last_change_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "daysSinceLastChangeMetric"))

    @builtins.property
    @jsii.member(jsii_name="daysSinceLastRotationAnnotations")
    def days_since_last_rotation_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "daysSinceLastRotationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="daysSinceLastRotationMetric")
    def days_since_last_rotation_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "daysSinceLastRotationMetric"))

    @builtins.property
    @jsii.member(jsii_name="showLastRotationWidget")
    def show_last_rotation_widget(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "showLastRotationWidget"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


class SingleAxisGraphWidget(
    aws_cdk.aws_cloudwatch.GraphWidget,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SingleAxisGraphWidget",
):
    '''(experimental) Line graph widget with one axis only (left).

    If there is just one metric, it will hide the legend to save space.
    The purpose of this custom class is to make the properties more strict.
    It will avoid graphs with undefined axis and dimensions.

    :stability: experimental
    '''

    def __init__(
        self,
        *,
        height: jsii.Number,
        left_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        left_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        width: jsii.Number,
        left_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param height: 
        :param left_axis: 
        :param left_metrics: 
        :param width: 
        :param left_annotations: 
        :param title: 

        :stability: experimental
        '''
        props = SingleAxisGraphWidgetProps(
            height=height,
            left_axis=left_axis,
            left_metrics=left_metrics,
            width=width,
            left_annotations=left_annotations,
            title=title,
        )

        jsii.create(self.__class__, self, [props])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SingleAxisGraphWidgetProps",
    jsii_struct_bases=[],
    name_mapping={
        "height": "height",
        "left_axis": "leftAxis",
        "left_metrics": "leftMetrics",
        "width": "width",
        "left_annotations": "leftAnnotations",
        "title": "title",
    },
)
class SingleAxisGraphWidgetProps:
    def __init__(
        self,
        *,
        height: jsii.Number,
        left_axis: typing.Union[aws_cdk.aws_cloudwatch.YAxisProps, typing.Dict[str, typing.Any]],
        left_metrics: typing.Sequence[aws_cdk.aws_cloudwatch.IMetric],
        width: jsii.Number,
        left_annotations: typing.Optional[typing.Sequence[typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]]]] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param height: 
        :param left_axis: 
        :param left_metrics: 
        :param width: 
        :param left_annotations: 
        :param title: 

        :stability: experimental
        '''
        if isinstance(left_axis, dict):
            left_axis = aws_cdk.aws_cloudwatch.YAxisProps(**left_axis)
        if __debug__:
            type_hints = typing.get_type_hints(SingleAxisGraphWidgetProps.__init__)
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
            check_type(argname="argument left_axis", value=left_axis, expected_type=type_hints["left_axis"])
            check_type(argname="argument left_metrics", value=left_metrics, expected_type=type_hints["left_metrics"])
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument left_annotations", value=left_annotations, expected_type=type_hints["left_annotations"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        self._values: typing.Dict[str, typing.Any] = {
            "height": height,
            "left_axis": left_axis,
            "left_metrics": left_metrics,
            "width": width,
        }
        if left_annotations is not None:
            self._values["left_annotations"] = left_annotations
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def height(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("height")
        assert result is not None, "Required property 'height' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def left_axis(self) -> aws_cdk.aws_cloudwatch.YAxisProps:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_axis")
        assert result is not None, "Required property 'left_axis' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.YAxisProps, result)

    @builtins.property
    def left_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_metrics")
        assert result is not None, "Required property 'left_metrics' is missing"
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], result)

    @builtins.property
    def width(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("width")
        assert result is not None, "Required property 'width' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def left_annotations(
        self,
    ) -> typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("left_annotations")
        return typing.cast(typing.Optional[typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SingleAxisGraphWidgetProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDashboardSegment)
class SingleWidgetDashboardSegment(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SingleWidgetDashboardSegment",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        widget: aws_cdk.aws_cloudwatch.IWidget,
        add_to_summary: typing.Optional[builtins.bool] = None,
        add_to_alarm: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param widget: -
        :param add_to_summary: -
        :param add_to_alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SingleWidgetDashboardSegment.__init__)
            check_type(argname="argument widget", value=widget, expected_type=type_hints["widget"])
            check_type(argname="argument add_to_summary", value=add_to_summary, expected_type=type_hints["add_to_summary"])
            check_type(argname="argument add_to_alarm", value=add_to_alarm, expected_type=type_hints["add_to_alarm"])
        jsii.create(self.__class__, self, [widget, add_to_summary, add_to_alarm])

    @jsii.member(jsii_name="alarmWidgets")
    def alarm_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for all alarms.

        These should go to the runbook or service dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "alarmWidgets", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets for the summary.

        These should go to the team OPS dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns all widgets.

        These should go to the detailed service dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="addToAlarm")
    def _add_to_alarm(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "addToAlarm"))

    @builtins.property
    @jsii.member(jsii_name="addToSummary")
    def _add_to_summary(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "addToSummary"))

    @builtins.property
    @jsii.member(jsii_name="widget")
    def _widget(self) -> aws_cdk.aws_cloudwatch.IWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IWidget, jsii.get(self, "widget"))


@jsii.implements(IAlarmActionStrategy)
class SnsAlarmActionStrategy(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SnsAlarmActionStrategy",
):
    '''(experimental) Alarm action strategy that sends a notification to the specified SNS topic.

    :stability: experimental
    '''

    def __init__(
        self,
        *,
        on_alarm_topic: aws_cdk.aws_sns.ITopic,
        on_insufficient_data_topic: typing.Optional[aws_cdk.aws_sns.ITopic] = None,
        on_ok_topic: typing.Optional[aws_cdk.aws_sns.ITopic] = None,
    ) -> None:
        '''
        :param on_alarm_topic: (experimental) Target topic used when the alarm is triggered.
        :param on_insufficient_data_topic: (experimental) Optional target topic for when the alarm goes into the INSUFFICIENT_DATA state. Default: - no notification sent
        :param on_ok_topic: (experimental) Optional target topic for when the alarm goes into the OK state. Default: - no notification sent

        :stability: experimental
        '''
        props = SnsAlarmActionStrategyProps(
            on_alarm_topic=on_alarm_topic,
            on_insufficient_data_topic=on_insufficient_data_topic,
            on_ok_topic=on_ok_topic,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="addAlarmActions")
    def add_alarm_actions(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmActionStrategyProps(
            alarm=alarm,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(None, jsii.invoke(self, "addAlarmActions", [props]))

    @builtins.property
    @jsii.member(jsii_name="onAlarmTopic")
    def _on_alarm_topic(self) -> aws_cdk.aws_sns.ITopic:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_sns.ITopic, jsii.get(self, "onAlarmTopic"))

    @builtins.property
    @jsii.member(jsii_name="onInsufficientDataTopic")
    def _on_insufficient_data_topic(self) -> typing.Optional[aws_cdk.aws_sns.ITopic]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_sns.ITopic], jsii.get(self, "onInsufficientDataTopic"))

    @builtins.property
    @jsii.member(jsii_name="onOkTopic")
    def _on_ok_topic(self) -> typing.Optional[aws_cdk.aws_sns.ITopic]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_sns.ITopic], jsii.get(self, "onOkTopic"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SnsAlarmActionStrategyProps",
    jsii_struct_bases=[],
    name_mapping={
        "on_alarm_topic": "onAlarmTopic",
        "on_insufficient_data_topic": "onInsufficientDataTopic",
        "on_ok_topic": "onOkTopic",
    },
)
class SnsAlarmActionStrategyProps:
    def __init__(
        self,
        *,
        on_alarm_topic: aws_cdk.aws_sns.ITopic,
        on_insufficient_data_topic: typing.Optional[aws_cdk.aws_sns.ITopic] = None,
        on_ok_topic: typing.Optional[aws_cdk.aws_sns.ITopic] = None,
    ) -> None:
        '''
        :param on_alarm_topic: (experimental) Target topic used when the alarm is triggered.
        :param on_insufficient_data_topic: (experimental) Optional target topic for when the alarm goes into the INSUFFICIENT_DATA state. Default: - no notification sent
        :param on_ok_topic: (experimental) Optional target topic for when the alarm goes into the OK state. Default: - no notification sent

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsAlarmActionStrategyProps.__init__)
            check_type(argname="argument on_alarm_topic", value=on_alarm_topic, expected_type=type_hints["on_alarm_topic"])
            check_type(argname="argument on_insufficient_data_topic", value=on_insufficient_data_topic, expected_type=type_hints["on_insufficient_data_topic"])
            check_type(argname="argument on_ok_topic", value=on_ok_topic, expected_type=type_hints["on_ok_topic"])
        self._values: typing.Dict[str, typing.Any] = {
            "on_alarm_topic": on_alarm_topic,
        }
        if on_insufficient_data_topic is not None:
            self._values["on_insufficient_data_topic"] = on_insufficient_data_topic
        if on_ok_topic is not None:
            self._values["on_ok_topic"] = on_ok_topic

    @builtins.property
    def on_alarm_topic(self) -> aws_cdk.aws_sns.ITopic:
        '''(experimental) Target topic used when the alarm is triggered.

        :stability: experimental
        '''
        result = self._values.get("on_alarm_topic")
        assert result is not None, "Required property 'on_alarm_topic' is missing"
        return typing.cast(aws_cdk.aws_sns.ITopic, result)

    @builtins.property
    def on_insufficient_data_topic(self) -> typing.Optional[aws_cdk.aws_sns.ITopic]:
        '''(experimental) Optional target topic for when the alarm goes into the INSUFFICIENT_DATA state.

        :default: - no notification sent

        :stability: experimental
        '''
        result = self._values.get("on_insufficient_data_topic")
        return typing.cast(typing.Optional[aws_cdk.aws_sns.ITopic], result)

    @builtins.property
    def on_ok_topic(self) -> typing.Optional[aws_cdk.aws_sns.ITopic]:
        '''(experimental) Optional target topic for when the alarm goes into the OK state.

        :default: - no notification sent

        :stability: experimental
        '''
        result = self._values.get("on_ok_topic")
        return typing.cast(typing.Optional[aws_cdk.aws_sns.ITopic], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsAlarmActionStrategyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsTopicMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SnsTopicMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        topic: aws_cdk.aws_sns.ITopic,
    ) -> None:
        '''
        :param metric_factory: -
        :param topic: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = SnsTopicMetricFactoryProps(topic=topic)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAverageMessageSizeInBytes")
    def metric_average_message_size_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageMessageSizeInBytes", []))

    @jsii.member(jsii_name="metricIncomingMessageCount")
    def metric_incoming_message_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingMessageCount", []))

    @jsii.member(jsii_name="metricNumberOfNotificationsFailed")
    def metric_number_of_notifications_failed(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNumberOfNotificationsFailed", []))

    @jsii.member(jsii_name="metricOutgoingMessageCount")
    def metric_outgoing_message_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricOutgoingMessageCount", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="topic")
    def _topic(self) -> aws_cdk.aws_sns.ITopic:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_sns.ITopic, jsii.get(self, "topic"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SnsTopicMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"topic": "topic"},
)
class SnsTopicMetricFactoryProps:
    def __init__(self, *, topic: aws_cdk.aws_sns.ITopic) -> None:
        '''
        :param topic: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMetricFactoryProps.__init__)
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[str, typing.Any] = {
            "topic": topic,
        }

    @builtins.property
    def topic(self) -> aws_cdk.aws_sns.ITopic:
        '''
        :stability: experimental
        '''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(aws_cdk.aws_sns.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsTopicMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsTopicMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SnsTopicMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        topic: aws_cdk.aws_sns.ITopic,
        add_max_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_message_notifications_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[NotificationsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param topic: 
        :param add_max_number_of_messages_published_alarm: 
        :param add_message_notifications_failed_alarm: 
        :param add_min_number_of_messages_published_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = SnsTopicMonitoringProps(
            topic=topic,
            add_max_number_of_messages_published_alarm=add_max_number_of_messages_published_alarm,
            add_message_notifications_failed_alarm=add_message_notifications_failed_alarm,
            add_min_number_of_messages_published_alarm=add_min_number_of_messages_published_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createMessageCountWidget")
    def create_message_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoring.create_message_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageCountWidget", [width, height]))

    @jsii.member(jsii_name="createMessageFailedWidget")
    def create_message_failed_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoring.create_message_failed_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageFailedWidget", [width, height]))

    @jsii.member(jsii_name="createMessageSizeWidget")
    def create_message_size_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoring.create_message_size_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageSizeWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="failedDeliveryAnnotations")
    def failed_delivery_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "failedDeliveryAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="incomingMessagesAnnotations")
    def incoming_messages_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "incomingMessagesAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="incomingMessagesMetric")
    def incoming_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="messagesFailedMetric")
    def messages_failed_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "messagesFailedMetric"))

    @builtins.property
    @jsii.member(jsii_name="messageSizeMetric")
    def message_size_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "messageSizeMetric"))

    @builtins.property
    @jsii.member(jsii_name="outgoingMessagesMetric")
    def outgoing_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "outgoingMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="topicAlarmFactory")
    def topic_alarm_factory(self) -> "TopicAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("TopicAlarmFactory", jsii.get(self, "topicAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="topicUrl")
    def topic_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "topicUrl"))


class SqsQueueMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SqsQueueMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        queue: aws_cdk.aws_sqs.IQueue,
    ) -> None:
        '''
        :param metric_factory: -
        :param queue: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = SqsQueueMetricFactoryProps(queue=queue)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricApproximateAgeOfOldestMessageInSeconds")
    def metric_approximate_age_of_oldest_message_in_seconds(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricApproximateAgeOfOldestMessageInSeconds", []))

    @jsii.member(jsii_name="metricApproximateVisibleMessageCount")
    def metric_approximate_visible_message_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricApproximateVisibleMessageCount", []))

    @jsii.member(jsii_name="metricAverageMessageSizeInBytes")
    def metric_average_message_size_in_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAverageMessageSizeInBytes", []))

    @jsii.member(jsii_name="metricConsumptionRate")
    def metric_consumption_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricConsumptionRate", []))

    @jsii.member(jsii_name="metricDeletedMessageCount")
    def metric_deleted_message_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricDeletedMessageCount", []))

    @jsii.member(jsii_name="metricIncomingMessageCount")
    def metric_incoming_message_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricIncomingMessageCount", []))

    @jsii.member(jsii_name="metricProductionRate")
    def metric_production_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProductionRate", []))

    @jsii.member(jsii_name="metricTimeToDrain")
    def metric_time_to_drain(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricTimeToDrain", []))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="queue")
    def _queue(self) -> aws_cdk.aws_sqs.IQueue:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_sqs.IQueue, jsii.get(self, "queue"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SqsQueueMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"queue": "queue"},
)
class SqsQueueMetricFactoryProps:
    def __init__(self, *, queue: aws_cdk.aws_sqs.IQueue) -> None:
        '''
        :param queue: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMetricFactoryProps.__init__)
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[str, typing.Any] = {
            "queue": queue,
        }

    @builtins.property
    def queue(self) -> aws_cdk.aws_sqs.IQueue:
        '''
        :stability: experimental
        '''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(aws_cdk.aws_sqs.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsQueueMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsQueueMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SqsQueueMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        props: typing.Union["SqsQueueMonitoringProps", typing.Dict[str, typing.Any]],
        invoked_from_super: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param props: -
        :param invoked_from_super: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument invoked_from_super", value=invoked_from_super, expected_type=type_hints["invoked_from_super"])
        jsii.create(self.__class__, self, [scope, props, invoked_from_super])

    @jsii.member(jsii_name="createMessageAgeWidget")
    def create_message_age_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.create_message_age_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageAgeWidget", [width, height]))

    @jsii.member(jsii_name="createMessageCountWidget")
    def create_message_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.create_message_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageCountWidget", [width, height]))

    @jsii.member(jsii_name="createMessageSizeWidget")
    def create_message_size_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.create_message_size_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMessageSizeWidget", [width, height]))

    @jsii.member(jsii_name="createProducerAndConsumerRateWidget")
    def create_producer_and_consumer_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.create_producer_and_consumer_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createProducerAndConsumerRateWidget", [width, height]))

    @jsii.member(jsii_name="createTimeToDrainWidget")
    def create_time_to_drain_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring.create_time_to_drain_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTimeToDrainWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="resolveQueueName")
    def _resolve_queue_name(
        self,
        queue: aws_cdk.aws_sqs.IQueue,
    ) -> typing.Optional[builtins.str]:
        '''
        :param queue: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoring._resolve_queue_name)
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "resolveQueueName", [queue]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="ageAnnotations")
    def age_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "ageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="consumptionRateMetric")
    def consumption_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "consumptionRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="countAnnotations")
    def count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "countAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="deletedMessagesMetric")
    def deleted_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "deletedMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="incomingMessagesMetric")
    def incoming_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="messageSizeMetric")
    def message_size_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "messageSizeMetric"))

    @builtins.property
    @jsii.member(jsii_name="oldestMessageAgeMetric")
    def oldest_message_age_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "oldestMessageAgeMetric"))

    @builtins.property
    @jsii.member(jsii_name="productionRateMetric")
    def production_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "productionRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="queueAlarmFactory")
    def queue_alarm_factory(self) -> QueueAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(QueueAlarmFactory, jsii.get(self, "queueAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="timeToDrainAnnotations")
    def time_to_drain_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "timeToDrainAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="timeToDrainMetric")
    def time_to_drain_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "timeToDrainMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="visibleMessagesMetric")
    def visible_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "visibleMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="queueUrl")
    def queue_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "queueUrl"))


class SqsQueueMonitoringWithDlq(
    SqsQueueMonitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SqsQueueMonitoringWithDlq",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        dead_letter_queue: aws_cdk.aws_sqs.IQueue,
        add_dead_letter_queue_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        add_dead_letter_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        queue: aws_cdk.aws_sqs.IQueue,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param dead_letter_queue: 
        :param add_dead_letter_queue_to_summary_dashboard: (experimental) Indicates whether the DLQ monitoring should be added to summary dashboard. Default: - true
        :param add_dead_letter_queue_max_incoming_messages_alarm: (experimental) Alarm on the number of messages added to a queue. Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ as a result of a failed processing attempt.
        :param add_dead_letter_queue_max_message_age_alarm: 
        :param add_dead_letter_queue_max_size_alarm: 
        :param queue: 
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringWithDlq.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = SqsQueueMonitoringWithDlqProps(
            dead_letter_queue=dead_letter_queue,
            add_dead_letter_queue_to_summary_dashboard=add_dead_letter_queue_to_summary_dashboard,
            add_dead_letter_queue_max_incoming_messages_alarm=add_dead_letter_queue_max_incoming_messages_alarm,
            add_dead_letter_queue_max_message_age_alarm=add_dead_letter_queue_max_message_age_alarm,
            add_dead_letter_queue_max_size_alarm=add_dead_letter_queue_max_size_alarm,
            queue=queue,
            add_queue_max_incoming_messages_alarm=add_queue_max_incoming_messages_alarm,
            add_queue_max_message_age_alarm=add_queue_max_message_age_alarm,
            add_queue_max_size_alarm=add_queue_max_size_alarm,
            add_queue_max_time_to_drain_messages_alarm=add_queue_max_time_to_drain_messages_alarm,
            add_queue_min_incoming_messages_alarm=add_queue_min_incoming_messages_alarm,
            add_queue_min_size_alarm=add_queue_min_size_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createDeadLetterMessageAgeWidget")
    def _create_dead_letter_message_age_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringWithDlq._create_dead_letter_message_age_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDeadLetterMessageAgeWidget", [width, height]))

    @jsii.member(jsii_name="createDeadLetterMessageCountWidget")
    def _create_dead_letter_message_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringWithDlq._create_dead_letter_message_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDeadLetterMessageCountWidget", [width, height]))

    @jsii.member(jsii_name="createDeadLetterTitleWidget")
    def _create_dead_letter_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createDeadLetterTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="addDeadLetterQueueToSummaryDashboard")
    def _add_dead_letter_queue_to_summary_dashboard(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "addDeadLetterQueueToSummaryDashboard"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterAgeAnnotations")
    def _dead_letter_age_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "deadLetterAgeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterCountAnnotations")
    def _dead_letter_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "deadLetterCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueueAlarmFactory")
    def _dead_letter_queue_alarm_factory(self) -> QueueAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(QueueAlarmFactory, jsii.get(self, "deadLetterQueueAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueueIncomingMessagesMetric")
    def _dead_letter_queue_incoming_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "deadLetterQueueIncomingMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueueOldestMessageAgeMetric")
    def _dead_letter_queue_oldest_message_age_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "deadLetterQueueOldestMessageAgeMetric"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueueVisibleMessagesMetric")
    def _dead_letter_queue_visible_messages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "deadLetterQueueVisibleMessagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterTitle")
    def _dead_letter_title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "deadLetterTitle"))

    @builtins.property
    @jsii.member(jsii_name="deadLetterUrl")
    def _dead_letter_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "deadLetterUrl"))


class StepFunctionActivityMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionActivityMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        activity: aws_cdk.aws_stepfunctions.IActivity,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param activity: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionActivityMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = StepFunctionActivityMetricFactoryProps(
            activity=activity, rate_computation_method=rate_computation_method
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricActivitiesFailed")
    def metric_activities_failed(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesFailed", []))

    @jsii.member(jsii_name="metricActivitiesFailedRate")
    def metric_activities_failed_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesFailedRate", []))

    @jsii.member(jsii_name="metricActivitiesHeartbeatTimedOut")
    def metric_activities_heartbeat_timed_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesHeartbeatTimedOut", []))

    @jsii.member(jsii_name="metricActivitiesScheduled")
    def metric_activities_scheduled(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesScheduled", []))

    @jsii.member(jsii_name="metricActivitiesStarted")
    def metric_activities_started(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesStarted", []))

    @jsii.member(jsii_name="metricActivitiesSucceeded")
    def metric_activities_succeeded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesSucceeded", []))

    @jsii.member(jsii_name="metricActivitiesTimedOut")
    def metric_activities_timed_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivitiesTimedOut", []))

    @jsii.member(jsii_name="metricActivityRunTimeP50InMillis")
    def metric_activity_run_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityRunTimeP50InMillis", []))

    @jsii.member(jsii_name="metricActivityRunTimeP90InMillis")
    def metric_activity_run_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityRunTimeP90InMillis", []))

    @jsii.member(jsii_name="metricActivityRunTimeP99InMillis")
    def metric_activity_run_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityRunTimeP99InMillis", []))

    @jsii.member(jsii_name="metricActivityScheduleTimeP50InMillis")
    def metric_activity_schedule_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityScheduleTimeP50InMillis", []))

    @jsii.member(jsii_name="metricActivityScheduleTimeP90InMillis")
    def metric_activity_schedule_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityScheduleTimeP90InMillis", []))

    @jsii.member(jsii_name="metricActivityScheduleTimeP99InMillis")
    def metric_activity_schedule_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityScheduleTimeP99InMillis", []))

    @jsii.member(jsii_name="metricActivityTimeP50InMillis")
    def metric_activity_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityTimeP50InMillis", []))

    @jsii.member(jsii_name="metricActivityTimeP90InMillis")
    def metric_activity_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityTimeP90InMillis", []))

    @jsii.member(jsii_name="metricActivityTimeP99InMillis")
    def metric_activity_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActivityTimeP99InMillis", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> RateComputationMethod:
        '''
        :stability: experimental
        '''
        return typing.cast(RateComputationMethod, jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionActivityMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "activity": "activity",
        "rate_computation_method": "rateComputationMethod",
    },
)
class StepFunctionActivityMetricFactoryProps:
    def __init__(
        self,
        *,
        activity: aws_cdk.aws_stepfunctions.IActivity,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param activity: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionActivityMetricFactoryProps.__init__)
            check_type(argname="argument activity", value=activity, expected_type=type_hints["activity"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "activity": activity,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def activity(self) -> aws_cdk.aws_stepfunctions.IActivity:
        '''
        :stability: experimental
        '''
        result = self._values.get("activity")
        assert result is not None, "Required property 'activity' is missing"
        return typing.cast(aws_cdk.aws_stepfunctions.IActivity, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionActivityMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionActivityMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionActivityMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        activity: aws_cdk.aws_stepfunctions.IActivity,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_activities_count_alarm: 
        :param add_failed_activities_rate_alarm: 
        :param add_timed_out_activities_count_alarm: 
        :param activity: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionActivityMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = StepFunctionActivityMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_activities_count_alarm=add_failed_activities_count_alarm,
            add_failed_activities_rate_alarm=add_failed_activities_rate_alarm,
            add_timed_out_activities_count_alarm=add_timed_out_activities_count_alarm,
            activity=activity,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="durationAlarmFactory")
    def duration_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "durationAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="durationAnnotations")
    def duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "durationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedActivitiesMetric")
    def failed_activities_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedActivitiesMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedActivitiesRateMetric")
    def failed_activities_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedActivitiesRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="heartbeatTimedOutActivitiesMetrics")
    def heartbeat_timed_out_activities_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "heartbeatTimedOutActivitiesMetrics"))

    @builtins.property
    @jsii.member(jsii_name="p50DurationMetric")
    def p50_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90DurationMetric")
    def p90_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99DurationMetric")
    def p99_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="scheduledActivitiesMetric")
    def scheduled_activities_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "scheduledActivitiesMetric"))

    @builtins.property
    @jsii.member(jsii_name="startedActivitiesMetric")
    def started_activities_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "startedActivitiesMetric"))

    @builtins.property
    @jsii.member(jsii_name="succeededActivitiesMetric")
    def succeeded_activities_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "succeededActivitiesMetric"))

    @builtins.property
    @jsii.member(jsii_name="timedOutActivitiesMetrics")
    def timed_out_activities_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "timedOutActivitiesMetrics"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


class StepFunctionLambdaIntegrationMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionLambdaIntegrationMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param lambda_function: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionLambdaIntegrationMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = StepFunctionLambdaIntegrationMetricFactoryProps(
            lambda_function=lambda_function,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricFunctionRunTimeP50InMillis")
    def metric_function_run_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionRunTimeP50InMillis", []))

    @jsii.member(jsii_name="metricFunctionRunTimeP90InMillis")
    def metric_function_run_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionRunTimeP90InMillis", []))

    @jsii.member(jsii_name="metricFunctionRunTimeP99InMillis")
    def metric_function_run_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionRunTimeP99InMillis", []))

    @jsii.member(jsii_name="metricFunctionScheduleTimeP50InMillis")
    def metric_function_schedule_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionScheduleTimeP50InMillis", []))

    @jsii.member(jsii_name="metricFunctionScheduleTimeP90InMillis")
    def metric_function_schedule_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionScheduleTimeP90InMillis", []))

    @jsii.member(jsii_name="metricFunctionScheduleTimeP99InMillis")
    def metric_function_schedule_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionScheduleTimeP99InMillis", []))

    @jsii.member(jsii_name="metricFunctionsFailed")
    def metric_functions_failed(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsFailed", []))

    @jsii.member(jsii_name="metricFunctionsFailedRate")
    def metric_functions_failed_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsFailedRate", []))

    @jsii.member(jsii_name="metricFunctionsScheduled")
    def metric_functions_scheduled(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsScheduled", []))

    @jsii.member(jsii_name="metricFunctionsStarted")
    def metric_functions_started(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsStarted", []))

    @jsii.member(jsii_name="metricFunctionsSucceeded")
    def metric_functions_succeeded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsSucceeded", []))

    @jsii.member(jsii_name="metricFunctionsTimedOut")
    def metric_functions_timed_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionsTimedOut", []))

    @jsii.member(jsii_name="metricFunctionTimeP50InMillis")
    def metric_function_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionTimeP50InMillis", []))

    @jsii.member(jsii_name="metricFunctionTimeP90InMillis")
    def metric_function_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionTimeP90InMillis", []))

    @jsii.member(jsii_name="metricFunctionTimeP99InMillis")
    def metric_function_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricFunctionTimeP99InMillis", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> RateComputationMethod:
        '''
        :stability: experimental
        '''
        return typing.cast(RateComputationMethod, jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionLambdaIntegrationMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "lambda_function": "lambdaFunction",
        "rate_computation_method": "rateComputationMethod",
    },
)
class StepFunctionLambdaIntegrationMetricFactoryProps:
    def __init__(
        self,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param lambda_function: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionLambdaIntegrationMetricFactoryProps.__init__)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(aws_cdk.aws_lambda.IFunction, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionLambdaIntegrationMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionLambdaIntegrationMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionLambdaIntegrationMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_functions_count_alarm: 
        :param add_failed_functions_rate_alarm: 
        :param add_timed_out_functions_count_alarm: 
        :param lambda_function: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionLambdaIntegrationMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = StepFunctionLambdaIntegrationMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_functions_count_alarm=add_failed_functions_count_alarm,
            add_failed_functions_rate_alarm=add_failed_functions_rate_alarm,
            add_timed_out_functions_count_alarm=add_timed_out_functions_count_alarm,
            lambda_function=lambda_function,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="durationAlarmFactory")
    def duration_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "durationAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="durationAnnotations")
    def duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "durationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedFunctionRateMetric")
    def failed_function_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedFunctionRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedFunctionsMetric")
    def failed_functions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedFunctionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="p50DurationMetric")
    def p50_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90DurationMetric")
    def p90_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99DurationMetric")
    def p99_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="scheduledFunctionsMetric")
    def scheduled_functions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "scheduledFunctionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="startedFunctionsMetric")
    def started_functions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "startedFunctionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="succeededFunctionsMetric")
    def succeeded_functions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "succeededFunctionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="timedOutFunctionsMetrics")
    def timed_out_functions_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "timedOutFunctionsMetrics"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="functionUrl")
    def function_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "functionUrl"))


class StepFunctionMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        state_machine: aws_cdk.aws_stepfunctions.IStateMachine,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param state_machine: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = StepFunctionMetricFactoryProps(
            state_machine=state_machine,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricExecutionsAborted")
    def metric_executions_aborted(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsAborted", []))

    @jsii.member(jsii_name="metricExecutionsFailed")
    def metric_executions_failed(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsFailed", []))

    @jsii.member(jsii_name="metricExecutionsFailedRate")
    def metric_executions_failed_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsFailedRate", []))

    @jsii.member(jsii_name="metricExecutionsStarted")
    def metric_executions_started(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsStarted", []))

    @jsii.member(jsii_name="metricExecutionsSucceeded")
    def metric_executions_succeeded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsSucceeded", []))

    @jsii.member(jsii_name="metricExecutionsTimedOut")
    def metric_executions_timed_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionsTimedOut", []))

    @jsii.member(jsii_name="metricExecutionThrottled")
    def metric_execution_throttled(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionThrottled", []))

    @jsii.member(jsii_name="metricExecutionTimeP50InMillis")
    def metric_execution_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionTimeP50InMillis", []))

    @jsii.member(jsii_name="metricExecutionTimeP90InMillis")
    def metric_execution_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionTimeP90InMillis", []))

    @jsii.member(jsii_name="metricExecutionTimeP99InMillis")
    def metric_execution_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricExecutionTimeP99InMillis", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> RateComputationMethod:
        '''
        :stability: experimental
        '''
        return typing.cast(RateComputationMethod, jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "state_machine": "stateMachine",
        "rate_computation_method": "rateComputationMethod",
    },
)
class StepFunctionMetricFactoryProps:
    def __init__(
        self,
        *,
        state_machine: aws_cdk.aws_stepfunctions.IStateMachine,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param state_machine: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionMetricFactoryProps.__init__)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "state_machine": state_machine,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def state_machine(self) -> aws_cdk.aws_stepfunctions.IStateMachine:
        '''
        :stability: experimental
        '''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(aws_cdk.aws_stepfunctions.IStateMachine, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        state_machine: aws_cdk.aws_stepfunctions.IStateMachine,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_aborted_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_started_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinRunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param state_machine: 
        :param rate_computation_method: Default: - average
        :param add_aborted_execution_count_alarm: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_execution_count_alarm: 
        :param add_failed_execution_rate_alarm: 
        :param add_min_started_execution_count_alarm: (experimental) Add minimum started execution count alarm for the stepfunctions.
        :param add_throttled_execution_count_alarm: 
        :param add_timed_out_execution_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = StepFunctionMonitoringProps(
            state_machine=state_machine,
            rate_computation_method=rate_computation_method,
            add_aborted_execution_count_alarm=add_aborted_execution_count_alarm,
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_execution_count_alarm=add_failed_execution_count_alarm,
            add_failed_execution_rate_alarm=add_failed_execution_rate_alarm,
            add_min_started_execution_count_alarm=add_min_started_execution_count_alarm,
            add_throttled_execution_count_alarm=add_throttled_execution_count_alarm,
            add_timed_out_execution_count_alarm=add_timed_out_execution_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="abortedExecutionsMetric")
    def aborted_executions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "abortedExecutionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="durationAlarmFactory")
    def duration_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "durationAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="durationAnnotations")
    def duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "durationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedExecutionRateMetric")
    def failed_execution_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedExecutionRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedExecutionsMetric")
    def failed_executions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedExecutionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="p50DurationMetric")
    def p50_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90DurationMetric")
    def p90_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99DurationMetric")
    def p99_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="startedExecutionsMetric")
    def started_executions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "startedExecutionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="succeededExecutionsMetric")
    def succeeded_executions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "succeededExecutionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAlarmFactory")
    def task_health_alarm_factory(self) -> "TaskHealthAlarmFactory":
        '''
        :stability: experimental
        '''
        return typing.cast("TaskHealthAlarmFactory", jsii.get(self, "taskHealthAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="throttledExecutionsMetric")
    def throttled_executions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "throttledExecutionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="timedOutExecutionsMetrics")
    def timed_out_executions_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "timedOutExecutionsMetrics"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="stateMachineUrl")
    def state_machine_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "stateMachineUrl"))


class StepFunctionServiceIntegrationMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionServiceIntegrationMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        service_integration_resource_arn: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param service_integration_resource_arn: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionServiceIntegrationMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = StepFunctionServiceIntegrationMetricFactoryProps(
            service_integration_resource_arn=service_integration_resource_arn,
            rate_computation_method=rate_computation_method,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricServiceIntegrationRunTimeP50InMillis")
    def metric_service_integration_run_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationRunTimeP50InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationRunTimeP90InMillis")
    def metric_service_integration_run_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationRunTimeP90InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationRunTimeP99InMillis")
    def metric_service_integration_run_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationRunTimeP99InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationScheduleTimeP50InMillis")
    def metric_service_integration_schedule_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationScheduleTimeP50InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationScheduleTimeP90InMillis")
    def metric_service_integration_schedule_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationScheduleTimeP90InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationScheduleTimeP99InMillis")
    def metric_service_integration_schedule_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationScheduleTimeP99InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationsFailed")
    def metric_service_integrations_failed(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsFailed", []))

    @jsii.member(jsii_name="metricServiceIntegrationsFailedRate")
    def metric_service_integrations_failed_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsFailedRate", []))

    @jsii.member(jsii_name="metricServiceIntegrationsScheduled")
    def metric_service_integrations_scheduled(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsScheduled", []))

    @jsii.member(jsii_name="metricServiceIntegrationsStarted")
    def metric_service_integrations_started(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsStarted", []))

    @jsii.member(jsii_name="metricServiceIntegrationsSucceeded")
    def metric_service_integrations_succeeded(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsSucceeded", []))

    @jsii.member(jsii_name="metricServiceIntegrationsTimedOut")
    def metric_service_integrations_timed_out(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationsTimedOut", []))

    @jsii.member(jsii_name="metricServiceIntegrationTimeP50InMillis")
    def metric_service_integration_time_p50_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationTimeP50InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationTimeP90InMillis")
    def metric_service_integration_time_p90_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationTimeP90InMillis", []))

    @jsii.member(jsii_name="metricServiceIntegrationTimeP99InMillis")
    def metric_service_integration_time_p99_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricServiceIntegrationTimeP99InMillis", []))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> RateComputationMethod:
        '''
        :stability: experimental
        '''
        return typing.cast(RateComputationMethod, jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionServiceIntegrationMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "service_integration_resource_arn": "serviceIntegrationResourceArn",
        "rate_computation_method": "rateComputationMethod",
    },
)
class StepFunctionServiceIntegrationMetricFactoryProps:
    def __init__(
        self,
        *,
        service_integration_resource_arn: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param service_integration_resource_arn: 
        :param rate_computation_method: Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionServiceIntegrationMetricFactoryProps.__init__)
            check_type(argname="argument service_integration_resource_arn", value=service_integration_resource_arn, expected_type=type_hints["service_integration_resource_arn"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_integration_resource_arn": service_integration_resource_arn,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def service_integration_resource_arn(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("service_integration_resource_arn")
        assert result is not None, "Required property 'service_integration_resource_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionServiceIntegrationMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StepFunctionServiceIntegrationMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.StepFunctionServiceIntegrationMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        service_integration_resource_arn: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_service_integrations_count_alarm: 
        :param add_failed_service_integrations_rate_alarm: 
        :param add_timed_out_service_integrations_count_alarm: 
        :param service_integration_resource_arn: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionServiceIntegrationMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = StepFunctionServiceIntegrationMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_service_integrations_count_alarm=add_failed_service_integrations_count_alarm,
            add_failed_service_integrations_rate_alarm=add_failed_service_integrations_rate_alarm,
            add_timed_out_service_integrations_count_alarm=add_timed_out_service_integrations_count_alarm,
            service_integration_resource_arn=service_integration_resource_arn,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="durationAlarmFactory")
    def duration_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "durationAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="durationAnnotations")
    def duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "durationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedServiceIntegrationRateMetric")
    def failed_service_integration_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedServiceIntegrationRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedServiceIntegrationsMetric")
    def failed_service_integrations_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedServiceIntegrationsMetric"))

    @builtins.property
    @jsii.member(jsii_name="p50DurationMetric")
    def p50_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90DurationMetric")
    def p90_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99DurationMetric")
    def p99_duration_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99DurationMetric"))

    @builtins.property
    @jsii.member(jsii_name="scheduledServiceIntegrationsMetric")
    def scheduled_service_integrations_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "scheduledServiceIntegrationsMetric"))

    @builtins.property
    @jsii.member(jsii_name="startedServiceIntegrationsMetric")
    def started_service_integrations_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "startedServiceIntegrationsMetric"))

    @builtins.property
    @jsii.member(jsii_name="succeededServiceIntegrationsMetric")
    def succeeded_service_integrations_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "succeededServiceIntegrationsMetric"))

    @builtins.property
    @jsii.member(jsii_name="timedOutServiceIntegrationsMetrics")
    def timed_out_service_integrations_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "timedOutServiceIntegrationsMetrics"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


@jsii.enum(jsii_type="cdk-monitoring-constructs.StorageType")
class StorageType(enum.Enum):
    '''
    :stability: experimental
    '''

    DEEP_ARCHIVE_OBJECT_OVERHEAD = "DEEP_ARCHIVE_OBJECT_OVERHEAD"
    '''
    :stability: experimental
    '''
    DEEP_ARCHIVE_S3_OBJECT_OVERHEAD = "DEEP_ARCHIVE_S3_OBJECT_OVERHEAD"
    '''
    :stability: experimental
    '''
    DEEP_ARCHIVE_STAGING_STORAGE = "DEEP_ARCHIVE_STAGING_STORAGE"
    '''
    :stability: experimental
    '''
    DEEP_ARCHIVE_STORAGE = "DEEP_ARCHIVE_STORAGE"
    '''
    :stability: experimental
    '''
    GLACIER_OBJECT_OVERHEAD = "GLACIER_OBJECT_OVERHEAD"
    '''
    :stability: experimental
    '''
    GLACIER_S3_OBJECT_OVERHEAD = "GLACIER_S3_OBJECT_OVERHEAD"
    '''
    :stability: experimental
    '''
    GLACIER_STAGING_STORAGE = "GLACIER_STAGING_STORAGE"
    '''
    :stability: experimental
    '''
    GLACIER_STORAGE = "GLACIER_STORAGE"
    '''
    :stability: experimental
    '''
    INTELLIGENT_TIERING_FA_STORAGE = "INTELLIGENT_TIERING_FA_STORAGE"
    '''
    :stability: experimental
    '''
    INTELLIGENT_TIERING_IA_STORAGE = "INTELLIGENT_TIERING_IA_STORAGE"
    '''
    :stability: experimental
    '''
    ONE_ZONE_IA_SIZE_OVERHEAD = "ONE_ZONE_IA_SIZE_OVERHEAD"
    '''
    :stability: experimental
    '''
    ONE_ZONE_IA_STORAGE = "ONE_ZONE_IA_STORAGE"
    '''
    :stability: experimental
    '''
    REDUCED_REDUNDANCY_STORAGE = "REDUCED_REDUNDANCY_STORAGE"
    '''
    :stability: experimental
    '''
    STANDARD_IA_SIZE_OVERHEAD = "STANDARD_IA_SIZE_OVERHEAD"
    '''
    :stability: experimental
    '''
    STANDARD_IA_STORAGE = "STANDARD_IA_STORAGE"
    '''
    :stability: experimental
    '''
    STANDARD_STORAGE = "STANDARD_STORAGE"
    '''
    :stability: experimental
    '''


class SyntheticsCanaryMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SyntheticsCanaryMetricFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        canary: aws_cdk.aws_synthetics_alpha.Canary,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param canary: (experimental) CloudWatch Canary to monitor.
        :param rate_computation_method: (experimental) Method used to calculate relative rates. Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = SyntheticsCanaryMetricFactoryProps(
            canary=canary, rate_computation_method=rate_computation_method
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metric4xxErrorCount")
    def metric4xx_error_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4xxErrorCount", []))

    @jsii.member(jsii_name="metric4xxErrorRate")
    def metric4xx_error_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric4xxErrorRate", []))

    @jsii.member(jsii_name="metric5xxFaultCount")
    def metric5xx_fault_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5xxFaultCount", []))

    @jsii.member(jsii_name="metric5xxFaultRate")
    def metric5xx_fault_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metric5xxFaultRate", []))

    @jsii.member(jsii_name="metricLatencyAverageInMillis")
    def metric_latency_average_in_millis(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricLatencyAverageInMillis", []))

    @jsii.member(jsii_name="metricSuccessInPercent")
    def metric_success_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricSuccessInPercent", []))

    @builtins.property
    @jsii.member(jsii_name="canary")
    def _canary(self) -> aws_cdk.aws_synthetics_alpha.Canary:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_synthetics_alpha.Canary, jsii.get(self, "canary"))

    @builtins.property
    @jsii.member(jsii_name="dimensionsMap")
    def _dimensions_map(self) -> typing.Mapping[builtins.str, builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, builtins.str], jsii.get(self, "dimensionsMap"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="rateComputationMethod")
    def _rate_computation_method(self) -> RateComputationMethod:
        '''
        :stability: experimental
        '''
        return typing.cast(RateComputationMethod, jsii.get(self, "rateComputationMethod"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SyntheticsCanaryMetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={
        "canary": "canary",
        "rate_computation_method": "rateComputationMethod",
    },
)
class SyntheticsCanaryMetricFactoryProps:
    def __init__(
        self,
        *,
        canary: aws_cdk.aws_synthetics_alpha.Canary,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param canary: (experimental) CloudWatch Canary to monitor.
        :param rate_computation_method: (experimental) Method used to calculate relative rates. Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMetricFactoryProps.__init__)
            check_type(argname="argument canary", value=canary, expected_type=type_hints["canary"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "canary": canary,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def canary(self) -> aws_cdk.aws_synthetics_alpha.Canary:
        '''(experimental) CloudWatch Canary to monitor.

        :stability: experimental
        '''
        result = self._values.get("canary")
        assert result is not None, "Required property 'canary' is missing"
        return typing.cast(aws_cdk.aws_synthetics_alpha.Canary, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''(experimental) Method used to calculate relative rates.

        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsCanaryMetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SyntheticsCanaryMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.SyntheticsCanaryMonitoring",
):
    '''(experimental) Monitoring for CloudWatch Synthetics Canaries.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries.html
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        canary: aws_cdk.aws_synthetics_alpha.Canary,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param canary: (experimental) CloudWatch Canary to monitor.
        :param rate_computation_method: (experimental) Method used to calculate relative rates. Default: - average
        :param add4xx_error_count_alarm: 
        :param add4xx_error_rate_alarm: 
        :param add5xx_fault_count_alarm: 
        :param add5xx_fault_rate_alarm: 
        :param add_average_latency_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = SyntheticsCanaryMonitoringProps(
            canary=canary,
            rate_computation_method=rate_computation_method,
            add4xx_error_count_alarm=add4xx_error_count_alarm,
            add4xx_error_rate_alarm=add4xx_error_rate_alarm,
            add5xx_fault_count_alarm=add5xx_fault_count_alarm,
            add5xx_fault_rate_alarm=add5xx_fault_rate_alarm,
            add_average_latency_alarm=add_average_latency_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="averageLatencyMetric")
    def average_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "averageLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorCountMetric")
    def error_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "errorCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateMetric")
    def error_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "errorRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="faultCountMetric")
    def fault_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "faultCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="faultRateMetric")
    def fault_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "faultRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="humanReadableName")
    def human_readable_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "humanReadableName"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))


class TaskHealthAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.TaskHealthAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addAvailabilityAlarm")
    def add_availability_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["AvailabilityThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_availability_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addAvailabilityAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addHealthyTaskCountAlarm")
    def add_healthy_task_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_healthy_task_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addHealthyTaskCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addHealthyTaskPercentAlarm")
    def add_healthy_task_percent_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_healthy_task_percent_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addHealthyTaskPercentAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinRunningTaskCountAlarm")
    def add_min_running_task_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MinRunningTaskCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_min_running_task_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinRunningTaskCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addRunningTaskCountAlarm")
    def add_running_task_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_running_task_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addRunningTaskCountAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addRunningTaskRateAlarm")
    def add_running_task_rate_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[RunningTaskRateThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_running_task_rate_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addRunningTaskRateAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addUnhealthyTaskCountAlarm")
    def add_unhealthy_task_count_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UnhealthyTaskCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TaskHealthAlarmFactory.add_unhealthy_task_count_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addUnhealthyTaskCountAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ThrottledEventsThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_throttled_events_threshold": "maxThrottledEventsThreshold",
    },
)
class ThrottledEventsThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_throttled_events_threshold: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_throttled_events_threshold: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ThrottledEventsThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_throttled_events_threshold", value=max_throttled_events_threshold, expected_type=type_hints["max_throttled_events_threshold"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_throttled_events_threshold": max_throttled_events_threshold,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_throttled_events_threshold(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_throttled_events_threshold")
        assert result is not None, "Required property 'max_throttled_events_threshold' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ThrottledEventsThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ThroughputAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ThroughputAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ThroughputAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMinProcessedBytesAlarm")
    def add_min_processed_bytes_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ThroughputAlarmFactory.add_min_processed_bytes_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinProcessedBytesAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class TopicAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.TopicAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TopicAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxMessagesPublishedAlarm")
    def add_max_messages_published_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[HighMessagesPublishedThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TopicAlarmFactory.add_max_messages_published_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxMessagesPublishedAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMessageNotificationsFailedAlarm")
    def add_message_notifications_failed_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[NotificationsFailedThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TopicAlarmFactory.add_message_notifications_failed_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMessageNotificationsFailedAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinMessagesPublishedAlarm")
    def add_min_messages_published_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[LowMessagesPublishedThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TopicAlarmFactory.add_min_messages_published_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinMessagesPublishedAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


class TpsAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.TpsAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TpsAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxTpsAlarm")
    def add_max_tps_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TpsAlarmFactory.add_max_tps_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxTpsAlarm", [metric, props, disambiguator]))

    @jsii.member(jsii_name="addMinTpsAlarm")
    def add_min_tps_alarm(
        self,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(TpsAlarmFactory.add_min_tps_alarm)
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinTpsAlarm", [metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.UnhealthyTaskCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_unhealthy_tasks": "maxUnhealthyTasks",
    },
)
class UnhealthyTaskCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_unhealthy_tasks: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_unhealthy_tasks: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UnhealthyTaskCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_unhealthy_tasks", value=max_unhealthy_tasks, expected_type=type_hints["max_unhealthy_tasks"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_unhealthy_tasks": max_unhealthy_tasks,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_unhealthy_tasks(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_unhealthy_tasks")
        assert result is not None, "Required property 'max_unhealthy_tasks' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UnhealthyTaskCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class UsageAlarmFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.UsageAlarmFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self, alarm_factory: AlarmFactory) -> None:
        '''
        :param alarm_factory: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.__init__)
            check_type(argname="argument alarm_factory", value=alarm_factory, expected_type=type_hints["alarm_factory"])
        jsii.create(self.__class__, self, [alarm_factory])

    @jsii.member(jsii_name="addMaxCpuUsagePercentAlarm")
    def add_max_cpu_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_cpu_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxCpuUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxDiskUsagePercentAlarm")
    def add_max_disk_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_disk_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxDiskUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxFileDescriptorPercentAlarm")
    def add_max_file_descriptor_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_file_descriptor_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxFileDescriptorPercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxHeapMemoryAfterGCUsagePercentAlarm")
    def add_max_heap_memory_after_gc_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_heap_memory_after_gc_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxHeapMemoryAfterGCUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxMasterCpuUsagePercentAlarm")
    def add_max_master_cpu_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_master_cpu_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxMasterCpuUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxMasterMemoryUsagePercentAlarm")
    def add_max_master_memory_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_master_memory_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxMasterMemoryUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxMemoryUsagePercentAlarm")
    def add_max_memory_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_memory_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxMemoryUsagePercentAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMaxThreadCountUsageAlarm")
    def add_max_thread_count_usage_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageCountThreshold", typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_max_thread_count_usage_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMaxThreadCountUsageAlarm", [percent_metric, props, disambiguator]))

    @jsii.member(jsii_name="addMemoryUsagePercentAlarm")
    def add_memory_usage_percent_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union["UsageThreshold", typing.Dict[str, typing.Any]],
        usage_type: "UsageType",
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param usage_type: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_memory_usage_percent_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument usage_type", value=usage_type, expected_type=type_hints["usage_type"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMemoryUsagePercentAlarm", [percent_metric, props, usage_type, disambiguator]))

    @jsii.member(jsii_name="addMinUsageCountAlarm")
    def add_min_usage_count_alarm(
        self,
        percent_metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        props: typing.Union[MinUsageCountThreshold, typing.Dict[str, typing.Any]],
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> AlarmWithAnnotation:
        '''
        :param percent_metric: -
        :param props: -
        :param disambiguator: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageAlarmFactory.add_min_usage_count_alarm)
            check_type(argname="argument percent_metric", value=percent_metric, expected_type=type_hints["percent_metric"])
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(AlarmWithAnnotation, jsii.invoke(self, "addMinUsageCountAlarm", [percent_metric, props, disambiguator]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def _alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.UsageCountThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_usage_count": "maxUsageCount",
    },
)
class UsageCountThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_usage_count: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_usage_count: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageCountThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_usage_count", value=max_usage_count, expected_type=type_hints["max_usage_count"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_usage_count": max_usage_count,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_usage_count(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_usage_count")
        assert result is not None, "Required property 'max_usage_count' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UsageCountThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.UsageThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_usage_percent": "maxUsagePercent",
    },
)
class UsageThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_usage_percent: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_usage_percent: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UsageThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_usage_percent", value=max_usage_percent, expected_type=type_hints["max_usage_percent"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_usage_percent": max_usage_percent,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_usage_percent(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_usage_percent")
        assert result is not None, "Required property 'max_usage_percent' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UsageThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(jsii_type="cdk-monitoring-constructs.UsageType")
class UsageType(enum.Enum):
    '''
    :stability: experimental
    '''

    P50 = "P50"
    '''
    :stability: experimental
    '''
    P70 = "P70"
    '''
    :stability: experimental
    '''
    P90 = "P90"
    '''
    :stability: experimental
    '''
    P99 = "P99"
    '''
    :stability: experimental
    '''
    P999 = "P999"
    '''
    :stability: experimental
    '''
    P9999 = "P9999"
    '''
    :stability: experimental
    '''
    P100 = "P100"
    '''
    :stability: experimental
    '''
    AVERAGE = "AVERAGE"
    '''
    :stability: experimental
    '''
    MAX = "MAX"
    '''
    :stability: experimental
    '''


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.UserProvidedNames",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
    },
)
class UserProvidedNames:
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(UserProvidedNames.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "UserProvidedNames(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class WafV2MetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.WafV2MetricFactory",
):
    '''(experimental) https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html.

    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        acl: aws_cdk.aws_wafv2.CfnWebACL,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param metric_factory: -
        :param acl: 
        :param region: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2MetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = WafV2MetricFactoryProps(acl=acl, region=region)

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricAllowedRequests")
    def metric_allowed_requests(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricAllowedRequests", []))

    @jsii.member(jsii_name="metricBlockedRequests")
    def metric_blocked_requests(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricBlockedRequests", []))

    @jsii.member(jsii_name="metricBlockedRequestsRate")
    def metric_blocked_requests_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricBlockedRequestsRate", []))

    @builtins.property
    @jsii.member(jsii_name="dimensions")
    def _dimensions(self) -> typing.Mapping[builtins.str, typing.Any]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Any], jsii.get(self, "dimensions"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.WafV2MetricFactoryProps",
    jsii_struct_bases=[],
    name_mapping={"acl": "acl", "region": "region"},
)
class WafV2MetricFactoryProps:
    def __init__(
        self,
        *,
        acl: aws_cdk.aws_wafv2.CfnWebACL,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param acl: 
        :param region: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2MetricFactoryProps.__init__)
            check_type(argname="argument acl", value=acl, expected_type=type_hints["acl"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
        self._values: typing.Dict[str, typing.Any] = {
            "acl": acl,
        }
        if region is not None:
            self._values["region"] = region

    @builtins.property
    def acl(self) -> aws_cdk.aws_wafv2.CfnWebACL:
        '''
        :stability: experimental
        '''
        result = self._values.get("acl")
        assert result is not None, "Required property 'acl' is missing"
        return typing.cast(aws_cdk.aws_wafv2.CfnWebACL, result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WafV2MetricFactoryProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class WafV2Monitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.WafV2Monitoring",
):
    '''(experimental) Monitoring for AWS Web Application Firewall.

    :see: https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        acl: aws_cdk.aws_wafv2.CfnWebACL,
        region: typing.Optional[builtins.str] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param acl: 
        :param region: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2Monitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = WafV2MonitoringProps(
            acl=acl,
            region=region,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createAllowedRequestsWidget")
    def create_allowed_requests_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2Monitoring.create_allowed_requests_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createAllowedRequestsWidget", [width, height]))

    @jsii.member(jsii_name="createBlockedRequestsRateWidget")
    def create_blocked_requests_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2Monitoring.create_blocked_requests_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createBlockedRequestsRateWidget", [width, height]))

    @jsii.member(jsii_name="createBlockedRequestsWidget")
    def create_blocked_requests_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2Monitoring.create_blocked_requests_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createBlockedRequestsWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="allowedRequestsMetric")
    def allowed_requests_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "allowedRequestsMetric"))

    @builtins.property
    @jsii.member(jsii_name="blockedRequestsMetric")
    def blocked_requests_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "blockedRequestsMetric"))

    @builtins.property
    @jsii.member(jsii_name="blockedRequestsRateMetric")
    def blocked_requests_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "blockedRequestsRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="humanReadableName")
    def human_readable_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "humanReadableName"))


@jsii.implements(aws_cdk.aws_cloudwatch.IMetric)
class XaxrMathExpression(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.XaxrMathExpression",
):
    '''(experimental) Custom wrapper class for MathExpression that supports account and region specification.

    :see: https://github.com/aws/aws-cdk/issues/9039
    :stability: experimental
    '''

    def __init__(
        self,
        *,
        account: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
        expression: builtins.str,
        using_metrics: typing.Optional[typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric]] = None,
        color: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        search_account: typing.Optional[builtins.str] = None,
        search_region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param account: (experimental) (experimental) Account which this metric comes from. Default: - Deployment account.
        :param region: (experimental) (experimental) Region which this metric comes from. Default: - Deployment region.
        :param expression: The expression defining the metric. When an expression contains a SEARCH function, it cannot be used within an Alarm.
        :param using_metrics: The metrics used in the expression, in a map. The key is the identifier that represents the given metric in the expression, and the value is the actual Metric object. Default: - Empty map.
        :param color: Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - Expression value is used as label
        :param period: The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)
        :param search_account: Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.
        :param search_region: Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.

        :stability: experimental
        '''
        props = XaxrMathExpressionProps(
            account=account,
            region=region,
            expression=expression,
            using_metrics=using_metrics,
            color=color,
            label=label,
            period=period,
            search_account=search_account,
            search_region=search_region,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="toMetricConfig")
    def to_metric_config(self) -> aws_cdk.aws_cloudwatch.MetricConfig:
        '''(experimental) Inspect the details of the metric object.

        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.MetricConfig, jsii.invoke(self, "toMetricConfig", []))

    @jsii.member(jsii_name="with")
    def with_(
        self,
        *,
        color: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        search_account: typing.Optional[builtins.str] = None,
        search_region: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :param color: Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - Expression value is used as label
        :param period: The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)
        :param search_account: Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.
        :param search_region: Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.

        :stability: experimental
        '''
        options = aws_cdk.aws_cloudwatch.MathExpressionOptions(
            color=color,
            label=label,
            period=period,
            search_account=search_account,
            search_region=search_region,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.invoke(self, "with", [options]))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.XaxrMathExpressionProps",
    jsii_struct_bases=[aws_cdk.aws_cloudwatch.MathExpressionProps],
    name_mapping={
        "color": "color",
        "label": "label",
        "period": "period",
        "search_account": "searchAccount",
        "search_region": "searchRegion",
        "expression": "expression",
        "using_metrics": "usingMetrics",
        "account": "account",
        "region": "region",
    },
)
class XaxrMathExpressionProps(aws_cdk.aws_cloudwatch.MathExpressionProps):
    def __init__(
        self,
        *,
        color: typing.Optional[builtins.str] = None,
        label: typing.Optional[builtins.str] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        search_account: typing.Optional[builtins.str] = None,
        search_region: typing.Optional[builtins.str] = None,
        expression: builtins.str,
        using_metrics: typing.Optional[typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric]] = None,
        account: typing.Optional[builtins.str] = None,
        region: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(experimental) Custom wrapper class for MathExpressionProps that supports account and region customization.

        :param color: Color for this metric when added to a Graph in a Dashboard. Default: - Automatic color
        :param label: Label for this metric when added to a Graph in a Dashboard. Default: - Expression value is used as label
        :param period: The period over which the expression's statistics are applied. This period overrides all periods in the metrics used in this math expression. Default: Duration.minutes(5)
        :param search_account: Account to evaluate search expressions within. Specifying a searchAccount has no effect to the account used for metrics within the expression (passed via usingMetrics). Default: - Deployment account.
        :param search_region: Region to evaluate search expressions within. Specifying a searchRegion has no effect to the region used for metrics within the expression (passed via usingMetrics). Default: - Deployment region.
        :param expression: The expression defining the metric. When an expression contains a SEARCH function, it cannot be used within an Alarm.
        :param using_metrics: The metrics used in the expression, in a map. The key is the identifier that represents the given metric in the expression, and the value is the actual Metric object. Default: - Empty map.
        :param account: (experimental) (experimental) Account which this metric comes from. Default: - Deployment account.
        :param region: (experimental) (experimental) Region which this metric comes from. Default: - Deployment region.

        :see: https://github.com/aws/aws-cdk/issues/9039
        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(XaxrMathExpressionProps.__init__)
            check_type(argname="argument color", value=color, expected_type=type_hints["color"])
            check_type(argname="argument label", value=label, expected_type=type_hints["label"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument search_account", value=search_account, expected_type=type_hints["search_account"])
            check_type(argname="argument search_region", value=search_region, expected_type=type_hints["search_region"])
            check_type(argname="argument expression", value=expression, expected_type=type_hints["expression"])
            check_type(argname="argument using_metrics", value=using_metrics, expected_type=type_hints["using_metrics"])
            check_type(argname="argument account", value=account, expected_type=type_hints["account"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
        self._values: typing.Dict[str, typing.Any] = {
            "expression": expression,
        }
        if color is not None:
            self._values["color"] = color
        if label is not None:
            self._values["label"] = label
        if period is not None:
            self._values["period"] = period
        if search_account is not None:
            self._values["search_account"] = search_account
        if search_region is not None:
            self._values["search_region"] = search_region
        if using_metrics is not None:
            self._values["using_metrics"] = using_metrics
        if account is not None:
            self._values["account"] = account
        if region is not None:
            self._values["region"] = region

    @builtins.property
    def color(self) -> typing.Optional[builtins.str]:
        '''Color for this metric when added to a Graph in a Dashboard.

        :default: - Automatic color
        '''
        result = self._values.get("color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def label(self) -> typing.Optional[builtins.str]:
        '''Label for this metric when added to a Graph in a Dashboard.

        :default: - Expression value is used as label
        '''
        result = self._values.get("label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''The period over which the expression's statistics are applied.

        This period overrides all periods in the metrics used in this
        math expression.

        :default: Duration.minutes(5)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def search_account(self) -> typing.Optional[builtins.str]:
        '''Account to evaluate search expressions within.

        Specifying a searchAccount has no effect to the account used
        for metrics within the expression (passed via usingMetrics).

        :default: - Deployment account.
        '''
        result = self._values.get("search_account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def search_region(self) -> typing.Optional[builtins.str]:
        '''Region to evaluate search expressions within.

        Specifying a searchRegion has no effect to the region used
        for metrics within the expression (passed via usingMetrics).

        :default: - Deployment region.
        '''
        result = self._values.get("search_region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def expression(self) -> builtins.str:
        '''The expression defining the metric.

        When an expression contains a SEARCH function, it cannot be used
        within an Alarm.
        '''
        result = self._values.get("expression")
        assert result is not None, "Required property 'expression' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def using_metrics(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric]]:
        '''The metrics used in the expression, in a map.

        The key is the identifier that represents the given metric in the
        expression, and the value is the actual Metric object.

        :default: - Empty map.
        '''
        result = self._values.get("using_metrics")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, aws_cdk.aws_cloudwatch.IMetric]], result)

    @builtins.property
    def account(self) -> typing.Optional[builtins.str]:
        '''(experimental) (experimental) Account which this metric comes from.

        :default: - Deployment account.

        :stability: experimental
        '''
        result = self._values.get("account")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''(experimental) (experimental) Region which this metric comes from.

        :default: - Deployment region.

        :stability: experimental
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "XaxrMathExpressionProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmActionStrategyProps",
    jsii_struct_bases=[AlarmMetadata],
    name_mapping={
        "action": "action",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "dedupe_string": "dedupeString",
        "disambiguator": "disambiguator",
        "alarm": "alarm",
    },
)
class AlarmActionStrategyProps(AlarmMetadata):
    def __init__(
        self,
        *,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
    ) -> None:
        '''(experimental) Properties necessary to append actions to an alarm.

        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 
        :param alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmActionStrategyProps.__init__)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
            check_type(argname="argument alarm", value=alarm, expected_type=type_hints["alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
            "alarm": alarm,
        }
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator

    @builtins.property
    def action(self) -> IAlarmActionStrategy:
        '''
        :stability: experimental
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(IAlarmActionStrategy, result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm(self) -> aws_cdk.aws_cloudwatch.AlarmBase:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm")
        assert result is not None, "Required property 'alarm' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.AlarmBase, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmActionStrategyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AlarmAnnotationStrategyProps",
    jsii_struct_bases=[AlarmMetadata],
    name_mapping={
        "action": "action",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "dedupe_string": "dedupeString",
        "disambiguator": "disambiguator",
        "alarm": "alarm",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "metric": "metric",
        "threshold": "threshold",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "override_annotation_color": "overrideAnnotationColor",
        "override_annotation_label": "overrideAnnotationLabel",
        "override_annotation_visibility": "overrideAnnotationVisibility",
    },
)
class AlarmAnnotationStrategyProps(AlarmMetadata):
    def __init__(
        self,
        *,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AlarmAnnotationStrategyProps.__init__)
            check_type(argname="argument action", value=action, expected_type=type_hints["action"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
            check_type(argname="argument alarm", value=alarm, expected_type=type_hints["alarm"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument metric", value=metric, expected_type=type_hints["metric"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument override_annotation_color", value=override_annotation_color, expected_type=type_hints["override_annotation_color"])
            check_type(argname="argument override_annotation_label", value=override_annotation_label, expected_type=type_hints["override_annotation_label"])
            check_type(argname="argument override_annotation_visibility", value=override_annotation_visibility, expected_type=type_hints["override_annotation_visibility"])
        self._values: typing.Dict[str, typing.Any] = {
            "action": action,
            "alarm": alarm,
            "comparison_operator": comparison_operator,
            "datapoints_to_alarm": datapoints_to_alarm,
            "evaluation_periods": evaluation_periods,
            "fill_alarm_range": fill_alarm_range,
            "metric": metric,
            "threshold": threshold,
        }
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if dedupe_string is not None:
            self._values["dedupe_string"] = dedupe_string
        if disambiguator is not None:
            self._values["disambiguator"] = disambiguator
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if override_annotation_color is not None:
            self._values["override_annotation_color"] = override_annotation_color
        if override_annotation_label is not None:
            self._values["override_annotation_label"] = override_annotation_label
        if override_annotation_visibility is not None:
            self._values["override_annotation_visibility"] = override_annotation_visibility

    @builtins.property
    def action(self) -> IAlarmActionStrategy:
        '''
        :stability: experimental
        '''
        result = self._values.get("action")
        assert result is not None, "Required property 'action' is missing"
        return typing.cast(IAlarmActionStrategy, result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dedupe_string(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("dedupe_string")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def disambiguator(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("disambiguator")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm(self) -> aws_cdk.aws_cloudwatch.Alarm:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm")
        assert result is not None, "Required property 'alarm' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.Alarm, result)

    @builtins.property
    def comparison_operator(self) -> aws_cdk.aws_cloudwatch.ComparisonOperator:
        '''
        :stability: experimental
        '''
        result = self._values.get("comparison_operator")
        assert result is not None, "Required property 'comparison_operator' is missing"
        return typing.cast(aws_cdk.aws_cloudwatch.ComparisonOperator, result)

    @builtins.property
    def datapoints_to_alarm(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        assert result is not None, "Required property 'datapoints_to_alarm' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def evaluation_periods(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        assert result is not None, "Required property 'evaluation_periods' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def fill_alarm_range(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        assert result is not None, "Required property 'fill_alarm_range' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        result = self._values.get("metric")
        assert result is not None, "Required property 'metric' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def override_annotation_color(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("override_annotation_color")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_annotation_label(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("override_annotation_label")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def override_annotation_visibility(self) -> typing.Optional[builtins.bool]:
        '''
        :stability: experimental
        '''
        result = self._values.get("override_annotation_visibility")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmAnnotationStrategyProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AnomalyDetectionThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "alarm_when_above_the_band": "alarmWhenAboveTheBand",
        "alarm_when_below_the_band": "alarmWhenBelowTheBand",
        "standard_deviation_for_alarm": "standardDeviationForAlarm",
        "additional_description": "additionalDescription",
    },
)
class AnomalyDetectionThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        alarm_when_above_the_band: builtins.bool,
        alarm_when_below_the_band: builtins.bool,
        standard_deviation_for_alarm: jsii.Number,
        additional_description: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param alarm_when_above_the_band: 
        :param alarm_when_below_the_band: 
        :param standard_deviation_for_alarm: 
        :param additional_description: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AnomalyDetectionThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument alarm_when_above_the_band", value=alarm_when_above_the_band, expected_type=type_hints["alarm_when_above_the_band"])
            check_type(argname="argument alarm_when_below_the_band", value=alarm_when_below_the_band, expected_type=type_hints["alarm_when_below_the_band"])
            check_type(argname="argument standard_deviation_for_alarm", value=standard_deviation_for_alarm, expected_type=type_hints["standard_deviation_for_alarm"])
            check_type(argname="argument additional_description", value=additional_description, expected_type=type_hints["additional_description"])
        self._values: typing.Dict[str, typing.Any] = {
            "alarm_when_above_the_band": alarm_when_above_the_band,
            "alarm_when_below_the_band": alarm_when_below_the_band,
            "standard_deviation_for_alarm": standard_deviation_for_alarm,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override
        if additional_description is not None:
            self._values["additional_description"] = additional_description

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def alarm_when_above_the_band(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_when_above_the_band")
        assert result is not None, "Required property 'alarm_when_above_the_band' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def alarm_when_below_the_band(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        result = self._values.get("alarm_when_below_the_band")
        assert result is not None, "Required property 'alarm_when_below_the_band' is missing"
        return typing.cast(builtins.bool, result)

    @builtins.property
    def standard_deviation_for_alarm(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("standard_deviation_for_alarm")
        assert result is not None, "Required property 'standard_deviation_for_alarm' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def additional_description(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("additional_description")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AnomalyDetectionThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiGatewayMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ApiGatewayMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        api: aws_cdk.aws_apigateway.RestApiBase,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param api: (experimental) API to monitor (cannot use IRestApi, since it does not provide API name).
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - prod
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = ApiGatewayMonitoringProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add4_xx_error_count_alarm=add4_xx_error_count_alarm,
            add4_xx_error_rate_alarm=add4_xx_error_rate_alarm,
            add5_xx_fault_count_alarm=add5_xx_fault_count_alarm,
            add5_xx_fault_rate_alarm=add5_xx_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_average_alarm=add_latency_average_alarm,
            add_latency_p100_alarm=add_latency_p100_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p70_alarm=add_latency_p70_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p95_alarm=add_latency_p95_alarm,
            add_latency_p9999_alarm=add_latency_p9999_alarm,
            add_latency_p999_alarm=add_latency_p999_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_latency_tm50_alarm=add_latency_tm50_alarm,
            add_latency_tm70_alarm=add_latency_tm70_alarm,
            add_latency_tm90_alarm=add_latency_tm90_alarm,
            add_latency_tm95_alarm=add_latency_tm95_alarm,
            add_latency_tm9999_alarm=add_latency_tm9999_alarm,
            add_latency_tm999_alarm=add_latency_tm999_alarm,
            add_latency_tm99_alarm=add_latency_tm99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            latency_types_to_render=latency_types_to_render,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpsWidget")
    def create_tps_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoring.create_tps_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="error4XXCountMetric")
    def error4_xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4XXCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="error4XXRateMetric")
    def error4_xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4XXRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="fault5XXCountMetric")
    def fault5_xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "fault5XXCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="fault5XXRateMetric")
    def fault5_xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "fault5XXRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="latencyMetrics")
    def latency_metrics(
        self,
    ) -> typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "latencyMetrics"))

    @builtins.property
    @jsii.member(jsii_name="latencyTypesToRender")
    def latency_types_to_render(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "latencyTypesToRender"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsAlarmFactory")
    def tps_alarm_factory(self) -> TpsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TpsAlarmFactory, jsii.get(self, "tpsAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="tpsAnnotations")
    def tps_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "tpsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))


class ApiGatewayV2HttpApiMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ApiGatewayV2HttpApiMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        api: aws_cdk.aws_apigatewayv2_alpha.IHttpApi,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param api: 
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - $default
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add4xx_count_alarm: 
        :param add4xx_rate_alarm: 
        :param add5xx_count_alarm: 
        :param add5xx_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_integration_latency_average_alarm: 
        :param add_integration_latency_p100_alarm: 
        :param add_integration_latency_p50_alarm: 
        :param add_integration_latency_p70_alarm: 
        :param add_integration_latency_p90_alarm: 
        :param add_integration_latency_p95_alarm: 
        :param add_integration_latency_p9999_alarm: 
        :param add_integration_latency_p999_alarm: 
        :param add_integration_latency_p99_alarm: 
        :param add_integration_latency_tm50_alarm: 
        :param add_integration_latency_tm70_alarm: 
        :param add_integration_latency_tm90_alarm: 
        :param add_integration_latency_tm95_alarm: 
        :param add_integration_latency_tm9999_alarm: 
        :param add_integration_latency_tm999_alarm: 
        :param add_integration_latency_tm99_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = ApiGatewayV2HttpApiMonitoringProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add4xx_count_alarm=add4xx_count_alarm,
            add4xx_rate_alarm=add4xx_rate_alarm,
            add5xx_count_alarm=add5xx_count_alarm,
            add5xx_rate_alarm=add5xx_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_integration_latency_average_alarm=add_integration_latency_average_alarm,
            add_integration_latency_p100_alarm=add_integration_latency_p100_alarm,
            add_integration_latency_p50_alarm=add_integration_latency_p50_alarm,
            add_integration_latency_p70_alarm=add_integration_latency_p70_alarm,
            add_integration_latency_p90_alarm=add_integration_latency_p90_alarm,
            add_integration_latency_p95_alarm=add_integration_latency_p95_alarm,
            add_integration_latency_p9999_alarm=add_integration_latency_p9999_alarm,
            add_integration_latency_p999_alarm=add_integration_latency_p999_alarm,
            add_integration_latency_p99_alarm=add_integration_latency_p99_alarm,
            add_integration_latency_tm50_alarm=add_integration_latency_tm50_alarm,
            add_integration_latency_tm70_alarm=add_integration_latency_tm70_alarm,
            add_integration_latency_tm90_alarm=add_integration_latency_tm90_alarm,
            add_integration_latency_tm95_alarm=add_integration_latency_tm95_alarm,
            add_integration_latency_tm9999_alarm=add_integration_latency_tm9999_alarm,
            add_integration_latency_tm999_alarm=add_integration_latency_tm999_alarm,
            add_integration_latency_tm99_alarm=add_integration_latency_tm99_alarm,
            add_latency_average_alarm=add_latency_average_alarm,
            add_latency_p100_alarm=add_latency_p100_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p70_alarm=add_latency_p70_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p95_alarm=add_latency_p95_alarm,
            add_latency_p9999_alarm=add_latency_p9999_alarm,
            add_latency_p999_alarm=add_latency_p999_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_latency_tm50_alarm=add_latency_tm50_alarm,
            add_latency_tm70_alarm=add_latency_tm70_alarm,
            add_latency_tm90_alarm=add_latency_tm90_alarm,
            add_latency_tm95_alarm=add_latency_tm95_alarm,
            add_latency_tm9999_alarm=add_latency_tm9999_alarm,
            add_latency_tm999_alarm=add_latency_tm999_alarm,
            add_latency_tm99_alarm=add_latency_tm99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            latency_types_to_render=latency_types_to_render,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpsWidget")
    def create_tps_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoring.create_tps_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="error4xxCountMetric")
    def error4xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4xxCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="error4xxRateMetric")
    def error4xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4xxRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="error5xxCountMetric")
    def error5xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error5xxCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="error5xxRateMetric")
    def error5xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error5xxRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="integrationLatencyMetrics")
    def integration_latency_metrics(
        self,
    ) -> typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "integrationLatencyMetrics"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="latencyMetrics")
    def latency_metrics(
        self,
    ) -> typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "latencyMetrics"))

    @builtins.property
    @jsii.member(jsii_name="latencyTypesToRender")
    def latency_types_to_render(self) -> typing.List[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "latencyTypesToRender"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsAlarmFactory")
    def tps_alarm_factory(self) -> TpsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TpsAlarmFactory, jsii.get(self, "tpsAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="tpsAnnotations")
    def tps_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "tpsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))


class AppSyncMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AppSyncMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        api: aws_cdk.aws_appsync_alpha.GraphqlApi,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param api: (experimental) the GraphQL API to monitor.
        :param fill_tps_with_zeroes: (experimental) whether the TPS should be filled with zeroes. Default: - true
        :param rate_computation_method: (experimental) method to compute TPS. Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = AppSyncMonitoringProps(
            add4_xx_error_count_alarm=add4_xx_error_count_alarm,
            add4_xx_error_rate_alarm=add4_xx_error_rate_alarm,
            add5_xx_fault_count_alarm=add5_xx_fault_count_alarm,
            add5_xx_fault_rate_alarm=add5_xx_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            api=api,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createTpsWidget")
    def create_tps_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoring.create_tps_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpsWidget", [width, height]))

    @jsii.member(jsii_name="createtTitleWidget")
    def createt_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createtTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="error4xxCountMetric")
    def error4xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4xxCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="error4xxRateMetric")
    def error4xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4xxRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="fault5xxCountMetric")
    def fault5xx_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "fault5xxCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="fault5xxRateMetric")
    def fault5xx_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "fault5xxRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def metric_factory(self) -> AppSyncMetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AppSyncMetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="namingStrategy")
    def naming_strategy(self) -> MonitoringNamingStrategy:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringNamingStrategy, jsii.get(self, "namingStrategy"))

    @builtins.property
    @jsii.member(jsii_name="p50LatencyMetric")
    def p50_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90LatencyMetric")
    def p90_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99LatencyMetric")
    def p99_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsAlarmFactory")
    def tps_alarm_factory(self) -> TpsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TpsAlarmFactory, jsii.get(self, "tpsAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="tpsAnnotations")
    def tps_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "tpsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))


@jsii.implements(ILoadBalancerMetricFactory)
class ApplicationLoadBalancerMetricFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ApplicationLoadBalancerMetricFactory",
):
    '''(experimental) Metric factory to create metrics for application load-balanced service.

    :stability: experimental
    '''

    def __init__(
        self,
        metric_factory: MetricFactory,
        *,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
    ) -> None:
        '''
        :param metric_factory: -
        :param application_load_balancer: 
        :param application_target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApplicationLoadBalancerMetricFactory.__init__)
            check_type(argname="argument metric_factory", value=metric_factory, expected_type=type_hints["metric_factory"])
        props = ApplicationLoadBalancerMetricFactoryProps(
            application_load_balancer=application_load_balancer,
            application_target_group=application_target_group,
        )

        jsii.create(self.__class__, self, [metric_factory, props])

    @jsii.member(jsii_name="metricActiveConnectionCount")
    def metric_active_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricActiveConnectionCount", []))

    @jsii.member(jsii_name="metricHealthyTaskCount")
    def metric_healthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskCount", []))

    @jsii.member(jsii_name="metricHealthyTaskInPercent")
    def metric_healthy_task_in_percent(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricHealthyTaskInPercent", []))

    @jsii.member(jsii_name="metricNewConnectionCount")
    def metric_new_connection_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricNewConnectionCount", []))

    @jsii.member(jsii_name="metricProcessedBytesMin")
    def metric_processed_bytes_min(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricProcessedBytesMin", []))

    @jsii.member(jsii_name="metricUnhealthyTaskCount")
    def metric_unhealthy_task_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.invoke(self, "metricUnhealthyTaskCount", []))

    @builtins.property
    @jsii.member(jsii_name="applicationLoadBalancer")
    def _application_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, jsii.get(self, "applicationLoadBalancer"))

    @builtins.property
    @jsii.member(jsii_name="applicationTargetGroup")
    def _application_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, jsii.get(self, "applicationTargetGroup"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def _metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))


class AutoScalingGroupMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.AutoScalingGroupMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        auto_scaling_group: aws_cdk.aws_autoscaling.IAutoScalingGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param auto_scaling_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = AutoScalingGroupMonitoringProps(
            auto_scaling_group=auto_scaling_group,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createGroupSizeWidget")
    def create_group_size_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMonitoring.create_group_size_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createGroupSizeWidget", [width, height]))

    @jsii.member(jsii_name="createGroupStatusWidget")
    def create_group_status_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMonitoring.create_group_status_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createGroupStatusWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="groupDesiredSizeMetric")
    def group_desired_size_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "groupDesiredSizeMetric"))

    @builtins.property
    @jsii.member(jsii_name="groupMaxSizeMetric")
    def group_max_size_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "groupMaxSizeMetric"))

    @builtins.property
    @jsii.member(jsii_name="groupMinSizeMetric")
    def group_min_size_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "groupMinSizeMetric"))

    @builtins.property
    @jsii.member(jsii_name="instancesInServiceMetric")
    def instances_in_service_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "instancesInServiceMetric"))

    @builtins.property
    @jsii.member(jsii_name="instancesPendingMetric")
    def instances_pending_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "instancesPendingMetric"))

    @builtins.property
    @jsii.member(jsii_name="instancesStandbyMetric")
    def instances_standby_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "instancesStandbyMetric"))

    @builtins.property
    @jsii.member(jsii_name="instancesTerminatingMetric")
    def instances_terminating_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "instancesTerminatingMetric"))

    @builtins.property
    @jsii.member(jsii_name="instancesTotalMetric")
    def instances_total_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "instancesTotalMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AvailabilityThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "min_availability_percent": "minAvailabilityPercent",
    },
)
class AvailabilityThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        min_availability_percent: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param min_availability_percent: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AvailabilityThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument min_availability_percent", value=min_availability_percent, expected_type=type_hints["min_availability_percent"])
        self._values: typing.Dict[str, typing.Any] = {
            "min_availability_percent": min_availability_percent,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def min_availability_percent(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("min_availability_percent")
        assert result is not None, "Required property 'min_availability_percent' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AvailabilityThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BaseMonitoringProps",
    jsii_struct_bases=[UserProvidedNames, MonitoringDashboardsOverrideProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class BaseMonitoringProps(UserProvidedNames, MonitoringDashboardsOverrideProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''(experimental) Base class for properties passed to each monitoring construct.

        It contains (mostly optional) properties to specify naming, placement, and so on.

        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BaseMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BaseMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class BillingMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.BillingMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BillingMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = BillingMonitoringProps(
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createChargesByServiceWidget")
    def create_charges_by_service_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BillingMonitoring.create_charges_by_service_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createChargesByServiceWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTotalChargesWidget")
    def create_total_charges_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.SingleValueWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BillingMonitoring.create_total_charges_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.SingleValueWidget, jsii.invoke(self, "createTotalChargesWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="costByServiceMetric")
    def cost_by_service_metric(self) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.get(self, "costByServiceMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="totalCostMetric")
    def total_cost_metric(self) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.get(self, "totalCostMetric"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BillingMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class BillingMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BillingMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BillingMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.BillingMonitoringProps",
    jsii_struct_bases=[BillingMonitoringOptions],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class BillingMonitoringProps(BillingMonitoringOptions):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(BillingMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BillingMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CertificateManagerMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CertificateManagerMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_days_to_expiry_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysToExpiryThreshold, typing.Dict[str, typing.Any]]]] = None,
        certificate: aws_cdk.aws_certificatemanager.ICertificate,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_days_to_expiry_alarm: 
        :param certificate: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CertificateManagerMonitoringProps(
            add_days_to_expiry_alarm=add_days_to_expiry_alarm,
            certificate=certificate,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createDaysToExpiryWidget")
    def create_days_to_expiry_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMonitoring.create_days_to_expiry_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDaysToExpiryWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="daysToExpiryAnnotations")
    def days_to_expiry_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "daysToExpiryAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="daysToExpiryMetric")
    def days_to_expiry_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "daysToExpiryMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CertificateManagerMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_days_to_expiry_alarm": "addDaysToExpiryAlarm",
    },
)
class CertificateManagerMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_days_to_expiry_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysToExpiryThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_days_to_expiry_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_days_to_expiry_alarm", value=add_days_to_expiry_alarm, expected_type=type_hints["add_days_to_expiry_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_days_to_expiry_alarm is not None:
            self._values["add_days_to_expiry_alarm"] = add_days_to_expiry_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_days_to_expiry_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysToExpiryThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_to_expiry_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysToExpiryThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateManagerMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CertificateManagerMonitoringProps",
    jsii_struct_bases=[
        CertificateManagerMonitoringOptions, CertificateManagerMetricFactoryProps
    ],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_days_to_expiry_alarm": "addDaysToExpiryAlarm",
        "certificate": "certificate",
    },
)
class CertificateManagerMonitoringProps(
    CertificateManagerMonitoringOptions,
    CertificateManagerMetricFactoryProps,
):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_days_to_expiry_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysToExpiryThreshold, typing.Dict[str, typing.Any]]]] = None,
        certificate: aws_cdk.aws_certificatemanager.ICertificate,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_days_to_expiry_alarm: 
        :param certificate: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CertificateManagerMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_days_to_expiry_alarm", value=add_days_to_expiry_alarm, expected_type=type_hints["add_days_to_expiry_alarm"])
            check_type(argname="argument certificate", value=certificate, expected_type=type_hints["certificate"])
        self._values: typing.Dict[str, typing.Any] = {
            "certificate": certificate,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_days_to_expiry_alarm is not None:
            self._values["add_days_to_expiry_alarm"] = add_days_to_expiry_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_days_to_expiry_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysToExpiryThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_to_expiry_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysToExpiryThreshold]], result)

    @builtins.property
    def certificate(self) -> aws_cdk.aws_certificatemanager.ICertificate:
        '''
        :stability: experimental
        '''
        result = self._values.get("certificate")
        assert result is not None, "Required property 'certificate' is missing"
        return typing.cast(aws_cdk.aws_certificatemanager.ICertificate, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CertificateManagerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CloudFrontDistributionMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CloudFrontDistributionMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_error4xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault5xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        distribution: aws_cdk.aws_cloudfront.IDistribution,
        additional_metrics_enabled: typing.Optional[builtins.bool] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_error4xx_rate: 
        :param add_fault5xx_rate: 
        :param add_high_tps_alarm: 
        :param add_low_tps_alarm: 
        :param distribution: 
        :param additional_metrics_enabled: (experimental) Generate dashboard charts for additional CloudFront distribution metrics. To enable additional metrics on your CloudFront distribution, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional Default: - true
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CloudFrontDistributionMonitoringProps(
            add_error4xx_rate=add_error4xx_rate,
            add_fault5xx_rate=add_fault5xx_rate,
            add_high_tps_alarm=add_high_tps_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            distribution=distribution,
            additional_metrics_enabled=additional_metrics_enabled,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createCacheWidget")
    def create_cache_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoring.create_cache_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCacheWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpsWidget")
    def create_tps_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoring.create_tps_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpsWidget", [width, height]))

    @jsii.member(jsii_name="createTrafficWidget")
    def create_traffic_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoring.create_traffic_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTrafficWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="additionalMetricsEnabled")
    def additional_metrics_enabled(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "additionalMetricsEnabled"))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="downloadedBytesMetric")
    def downloaded_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "downloadedBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="error4xxRate")
    def error4xx_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error4xxRate"))

    @builtins.property
    @jsii.member(jsii_name="error5xxRate")
    def error5xx_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "error5xxRate"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="namingStrategy")
    def naming_strategy(self) -> MonitoringNamingStrategy:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringNamingStrategy, jsii.get(self, "namingStrategy"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsAlarmFactory")
    def tps_alarm_factory(self) -> TpsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TpsAlarmFactory, jsii.get(self, "tpsAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="tpsAnnotations")
    def tps_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "tpsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))

    @builtins.property
    @jsii.member(jsii_name="uploadedBytesMetric")
    def uploaded_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "uploadedBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="cacheHitRate")
    def cache_hit_rate(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "cacheHitRate"))

    @builtins.property
    @jsii.member(jsii_name="distributionUrl")
    def distribution_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "distributionUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CloudFrontDistributionMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class CloudFrontDistributionMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CloudFrontDistributionMonitoringProps",
    jsii_struct_bases=[
        CloudFrontDistributionMetricFactoryProps,
        CloudFrontDistributionMonitoringOptions,
    ],
    name_mapping={
        "distribution": "distribution",
        "additional_metrics_enabled": "additionalMetricsEnabled",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_error4xx_rate": "addError4xxRate",
        "add_fault5xx_rate": "addFault5xxRate",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
    },
)
class CloudFrontDistributionMonitoringProps(
    CloudFrontDistributionMetricFactoryProps,
    CloudFrontDistributionMonitoringOptions,
):
    def __init__(
        self,
        *,
        distribution: aws_cdk.aws_cloudfront.IDistribution,
        additional_metrics_enabled: typing.Optional[builtins.bool] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_error4xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault5xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param distribution: 
        :param additional_metrics_enabled: (experimental) Generate dashboard charts for additional CloudFront distribution metrics. To enable additional metrics on your CloudFront distribution, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional Default: - true
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_error4xx_rate: 
        :param add_fault5xx_rate: 
        :param add_high_tps_alarm: 
        :param add_low_tps_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CloudFrontDistributionMonitoringProps.__init__)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument additional_metrics_enabled", value=additional_metrics_enabled, expected_type=type_hints["additional_metrics_enabled"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_error4xx_rate", value=add_error4xx_rate, expected_type=type_hints["add_error4xx_rate"])
            check_type(argname="argument add_fault5xx_rate", value=add_fault5xx_rate, expected_type=type_hints["add_fault5xx_rate"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "distribution": distribution,
        }
        if additional_metrics_enabled is not None:
            self._values["additional_metrics_enabled"] = additional_metrics_enabled
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_error4xx_rate is not None:
            self._values["add_error4xx_rate"] = add_error4xx_rate
        if add_fault5xx_rate is not None:
            self._values["add_fault5xx_rate"] = add_fault5xx_rate
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm

    @builtins.property
    def distribution(self) -> aws_cdk.aws_cloudfront.IDistribution:
        '''
        :stability: experimental
        '''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(aws_cdk.aws_cloudfront.IDistribution, result)

    @builtins.property
    def additional_metrics_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Generate dashboard charts for additional CloudFront distribution metrics.

        To enable additional metrics on your CloudFront distribution, see
        https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("additional_metrics_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_error4xx_rate(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_error4xx_rate")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_fault5xx_rate(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_fault5xx_rate")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CodeBuildProjectMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CodeBuildProjectMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        project: aws_cdk.aws_codebuild.IProject,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param project: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_build_count_alarm: 
        :param add_failed_build_rate_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CodeBuildProjectMonitoringProps(
            project=project,
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_build_count_alarm=add_failed_build_count_alarm,
            add_failed_build_rate_alarm=add_failed_build_rate_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createBuildCountsWidget")
    def create_build_counts_widget(self) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createBuildCountsWidget", []))

    @jsii.member(jsii_name="createDurationWidget")
    def create_duration_widget(self) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDurationWidget", []))

    @jsii.member(jsii_name="createFailedBuildRateWidget")
    def create_failed_build_rate_widget(self) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createFailedBuildRateWidget", []))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="resolveProjectName")
    def _resolve_project_name(
        self,
        project: aws_cdk.aws_codebuild.IProject,
    ) -> typing.Optional[builtins.str]:
        '''
        :param project: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMonitoring._resolve_project_name)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
        return typing.cast(typing.Optional[builtins.str], jsii.invoke(self, "resolveProjectName", [project]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="buildCountMetric")
    def build_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "buildCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="durationAlarmFactory")
    def duration_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "durationAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="durationAnnotations")
    def duration_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "durationAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="durationP50InSecondsMetric")
    def duration_p50_in_seconds_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "durationP50InSecondsMetric"))

    @builtins.property
    @jsii.member(jsii_name="durationP90InSecondsMetric")
    def duration_p90_in_seconds_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "durationP90InSecondsMetric"))

    @builtins.property
    @jsii.member(jsii_name="durationP99InSecondsMetric")
    def duration_p99_in_seconds_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "durationP99InSecondsMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedBuildCountMetric")
    def failed_build_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedBuildCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedBuildRateMetric")
    def failed_build_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedBuildRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="succeededBuildCountMetric")
    def succeeded_build_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "succeededBuildCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="projectUrl")
    def project_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "projectUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CodeBuildProjectMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_build_count_alarm": "addFailedBuildCountAlarm",
        "add_failed_build_rate_alarm": "addFailedBuildRateAlarm",
    },
)
class CodeBuildProjectMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_build_count_alarm: 
        :param add_failed_build_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_build_count_alarm", value=add_failed_build_count_alarm, expected_type=type_hints["add_failed_build_count_alarm"])
            check_type(argname="argument add_failed_build_rate_alarm", value=add_failed_build_rate_alarm, expected_type=type_hints["add_failed_build_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_build_count_alarm is not None:
            self._values["add_failed_build_count_alarm"] = add_failed_build_count_alarm
        if add_failed_build_rate_alarm is not None:
            self._values["add_failed_build_rate_alarm"] = add_failed_build_rate_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_build_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_build_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_build_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_build_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CodeBuildProjectMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CodeBuildProjectMonitoringProps",
    jsii_struct_bases=[
        CodeBuildProjectMetricFactoryProps, CodeBuildProjectMonitoringOptions
    ],
    name_mapping={
        "project": "project",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_build_count_alarm": "addFailedBuildCountAlarm",
        "add_failed_build_rate_alarm": "addFailedBuildRateAlarm",
    },
)
class CodeBuildProjectMonitoringProps(
    CodeBuildProjectMetricFactoryProps,
    CodeBuildProjectMonitoringOptions,
):
    def __init__(
        self,
        *,
        project: aws_cdk.aws_codebuild.IProject,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for CodeBuild projects.

        :param project: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_build_count_alarm: 
        :param add_failed_build_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CodeBuildProjectMonitoringProps.__init__)
            check_type(argname="argument project", value=project, expected_type=type_hints["project"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_build_count_alarm", value=add_failed_build_count_alarm, expected_type=type_hints["add_failed_build_count_alarm"])
            check_type(argname="argument add_failed_build_rate_alarm", value=add_failed_build_rate_alarm, expected_type=type_hints["add_failed_build_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "project": project,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_build_count_alarm is not None:
            self._values["add_failed_build_count_alarm"] = add_failed_build_count_alarm
        if add_failed_build_rate_alarm is not None:
            self._values["add_failed_build_rate_alarm"] = add_failed_build_rate_alarm

    @builtins.property
    def project(self) -> aws_cdk.aws_codebuild.IProject:
        '''
        :stability: experimental
        '''
        result = self._values.get("project")
        assert result is not None, "Required property 'project' is missing"
        return typing.cast(aws_cdk.aws_codebuild.IProject, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_build_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_build_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_build_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_build_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CodeBuildProjectMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ConsumedCapacityThreshold",
    jsii_struct_bases=[CustomAlarmThreshold],
    name_mapping={
        "action_override": "actionOverride",
        "actions_enabled": "actionsEnabled",
        "alarm_description_override": "alarmDescriptionOverride",
        "alarm_name_override": "alarmNameOverride",
        "comparison_operator_override": "comparisonOperatorOverride",
        "custom_params": "customParams",
        "custom_tags": "customTags",
        "datapoints_to_alarm": "datapointsToAlarm",
        "dedupe_string_override": "dedupeStringOverride",
        "documentation_link": "documentationLink",
        "evaluate_low_sample_count_percentile": "evaluateLowSampleCountPercentile",
        "evaluation_periods": "evaluationPeriods",
        "fill_alarm_range": "fillAlarmRange",
        "min_metric_samples_to_alarm": "minMetricSamplesToAlarm",
        "period": "period",
        "runbook_link": "runbookLink",
        "treat_missing_data_override": "treatMissingDataOverride",
        "max_consumed_capacity_units": "maxConsumedCapacityUnits",
    },
)
class ConsumedCapacityThreshold(CustomAlarmThreshold):
    def __init__(
        self,
        *,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        comparison_operator_override: typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        evaluate_low_sample_count_percentile: typing.Optional[builtins.bool] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        period: typing.Optional[aws_cdk.Duration] = None,
        runbook_link: typing.Optional[builtins.str] = None,
        treat_missing_data_override: typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData] = None,
        max_consumed_capacity_units: jsii.Number,
    ) -> None:
        '''
        :param action_override: (experimental) Allows to override the default alarm action. Default: - undefined (default action will be used, if any)
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param comparison_operator_override: (experimental) Comparison operator used to compare actual value against the threshold. Default: - alarm-specific default
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param datapoints_to_alarm: (experimental) Number of breaches required to transition into an ALARM state. Default: - the same as monitoring facade default
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Dedupe strings are global and not unique per CTI. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param evaluate_low_sample_count_percentile: (experimental) Used only for alarms based on percentiles. If you specify false, the alarm state does not change during periods with too few data points to be statistically significant. If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available. Default: - true
        :param evaluation_periods: (experimental) Number of periods to consider when checking the number of breaching datapoints. Default: - the same as monitoring facade default
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param min_metric_samples_to_alarm: (experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm. If this property is specified, a composite alarm is created of the following: Default: - default behaviour - no condition on sample count will be added to the alarm
        :param period: (experimental) Period override for the metric to alarm on. Default: - the default specified in MetricFactory
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param treat_missing_data_override: (experimental) Behaviour in case the metric data is missing. Default: - alarm-specific default
        :param max_consumed_capacity_units: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ConsumedCapacityThreshold.__init__)
            check_type(argname="argument action_override", value=action_override, expected_type=type_hints["action_override"])
            check_type(argname="argument actions_enabled", value=actions_enabled, expected_type=type_hints["actions_enabled"])
            check_type(argname="argument alarm_description_override", value=alarm_description_override, expected_type=type_hints["alarm_description_override"])
            check_type(argname="argument alarm_name_override", value=alarm_name_override, expected_type=type_hints["alarm_name_override"])
            check_type(argname="argument comparison_operator_override", value=comparison_operator_override, expected_type=type_hints["comparison_operator_override"])
            check_type(argname="argument custom_params", value=custom_params, expected_type=type_hints["custom_params"])
            check_type(argname="argument custom_tags", value=custom_tags, expected_type=type_hints["custom_tags"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument dedupe_string_override", value=dedupe_string_override, expected_type=type_hints["dedupe_string_override"])
            check_type(argname="argument documentation_link", value=documentation_link, expected_type=type_hints["documentation_link"])
            check_type(argname="argument evaluate_low_sample_count_percentile", value=evaluate_low_sample_count_percentile, expected_type=type_hints["evaluate_low_sample_count_percentile"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument fill_alarm_range", value=fill_alarm_range, expected_type=type_hints["fill_alarm_range"])
            check_type(argname="argument min_metric_samples_to_alarm", value=min_metric_samples_to_alarm, expected_type=type_hints["min_metric_samples_to_alarm"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument runbook_link", value=runbook_link, expected_type=type_hints["runbook_link"])
            check_type(argname="argument treat_missing_data_override", value=treat_missing_data_override, expected_type=type_hints["treat_missing_data_override"])
            check_type(argname="argument max_consumed_capacity_units", value=max_consumed_capacity_units, expected_type=type_hints["max_consumed_capacity_units"])
        self._values: typing.Dict[str, typing.Any] = {
            "max_consumed_capacity_units": max_consumed_capacity_units,
        }
        if action_override is not None:
            self._values["action_override"] = action_override
        if actions_enabled is not None:
            self._values["actions_enabled"] = actions_enabled
        if alarm_description_override is not None:
            self._values["alarm_description_override"] = alarm_description_override
        if alarm_name_override is not None:
            self._values["alarm_name_override"] = alarm_name_override
        if comparison_operator_override is not None:
            self._values["comparison_operator_override"] = comparison_operator_override
        if custom_params is not None:
            self._values["custom_params"] = custom_params
        if custom_tags is not None:
            self._values["custom_tags"] = custom_tags
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if dedupe_string_override is not None:
            self._values["dedupe_string_override"] = dedupe_string_override
        if documentation_link is not None:
            self._values["documentation_link"] = documentation_link
        if evaluate_low_sample_count_percentile is not None:
            self._values["evaluate_low_sample_count_percentile"] = evaluate_low_sample_count_percentile
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if fill_alarm_range is not None:
            self._values["fill_alarm_range"] = fill_alarm_range
        if min_metric_samples_to_alarm is not None:
            self._values["min_metric_samples_to_alarm"] = min_metric_samples_to_alarm
        if period is not None:
            self._values["period"] = period
        if runbook_link is not None:
            self._values["runbook_link"] = runbook_link
        if treat_missing_data_override is not None:
            self._values["treat_missing_data_override"] = treat_missing_data_override

    @builtins.property
    def action_override(self) -> typing.Optional[IAlarmActionStrategy]:
        '''(experimental) Allows to override the default alarm action.

        :default: - undefined (default action will be used, if any)

        :stability: experimental
        '''
        result = self._values.get("action_override")
        return typing.cast(typing.Optional[IAlarmActionStrategy], result)

    @builtins.property
    def actions_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Enables the configured CloudWatch alarm ticketing actions.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("actions_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def alarm_description_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) A text included in the generated ticket description body, which fully replaces the generated text.

        :default: - default auto-generated content only

        :stability: experimental
        '''
        result = self._values.get("alarm_description_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm name is set to this exact value.

        Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.

        :stability: experimental
        '''
        result = self._values.get("alarm_name_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator]:
        '''(experimental) Comparison operator used to compare actual value against the threshold.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("comparison_operator_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.ComparisonOperator], result)

    @builtins.property
    def custom_params(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, typing.Any]]:
        '''(experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no parameters

        :stability: experimental
        '''
        result = self._values.get("custom_params")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, typing.Any]], result)

    @builtins.property
    def custom_tags(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method.

        :default: - no tags

        :stability: experimental
        '''
        result = self._values.get("custom_tags")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of breaches required to transition into an ALARM state.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def dedupe_string_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the alarm dedupe string is set to this exact value.

        Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        Dedupe strings are global and not unique per CTI.

        :default: - undefined (no override)

        :stability: experimental
        '''
        result = self._values.get("dedupe_string_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def documentation_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("documentation_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def evaluate_low_sample_count_percentile(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Used only for alarms based on percentiles.

        If you specify false, the alarm state does not change during periods with too few data points to be statistically significant.
        If you specify true, the alarm is always evaluated and possibly changes state no matter how many data points are available.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("evaluate_low_sample_count_percentile")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Number of periods to consider when checking the number of breaching datapoints.

        :default: - the same as monitoring facade default

        :stability: experimental
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fill_alarm_range(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the alarming range of values should be highlighted in the widget.

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("fill_alarm_range")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def min_metric_samples_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''(experimental) Specifies how many samples (N) of the metric is needed to trigger the alarm.

        If this property is specified, a composite alarm is created of the following:

        :default: - default behaviour - no condition on sample count will be added to the alarm

        :stability: experimental
        '''
        result = self._values.get("min_metric_samples_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[aws_cdk.Duration]:
        '''(experimental) Period override for the metric to alarm on.

        :default: - the default specified in MetricFactory

        :stability: experimental
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[aws_cdk.Duration], result)

    @builtins.property
    def runbook_link(self) -> typing.Optional[builtins.str]:
        '''(experimental) An optional link included in the generated ticket description body.

        :default: - no additional link will be added

        :stability: experimental
        '''
        result = self._values.get("runbook_link")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def treat_missing_data_override(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData]:
        '''(experimental) Behaviour in case the metric data is missing.

        :default: - alarm-specific default

        :stability: experimental
        '''
        result = self._values.get("treat_missing_data_override")
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.TreatMissingData], result)

    @builtins.property
    def max_consumed_capacity_units(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        result = self._values.get("max_consumed_capacity_units")
        assert result is not None, "Required property 'max_consumed_capacity_units' is missing"
        return typing.cast(jsii.Number, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ConsumedCapacityThreshold(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomEc2ServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseEc2ServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "ec2_service": "ec2Service",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
        "load_balancer": "loadBalancer",
        "target_group": "targetGroup",
    },
)
class CustomEc2ServiceMonitoringProps(BaseMonitoringProps, BaseEc2ServiceAlarms):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        load_balancer: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]] = None,
        target_group: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param load_balancer: 
        :param target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomEc2ServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm
        if load_balancer is not None:
            self._values["load_balancer"] = load_balancer
        if target_group is not None:
            self._values["target_group"] = target_group

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ec2_service(self) -> aws_cdk.aws_ecs.Ec2Service:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.Ec2Service, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    @builtins.property
    def load_balancer(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("load_balancer")
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]], result)

    @builtins.property
    def target_group(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("target_group")
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomEc2ServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomFargateServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseFargateServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "fargate_service": "fargateService",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
        "load_balancer": "loadBalancer",
        "target_group": "targetGroup",
    },
)
class CustomFargateServiceMonitoringProps(
    BaseMonitoringProps,
    BaseFargateServiceAlarms,
):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        load_balancer: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]] = None,
        target_group: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param load_balancer: 
        :param target_group: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomFargateServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[str, typing.Any] = {
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm
        if load_balancer is not None:
            self._values["load_balancer"] = load_balancer
        if target_group is not None:
            self._values["target_group"] = target_group

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fargate_service(self) -> aws_cdk.aws_ecs.FargateService:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.FargateService, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    @builtins.property
    def load_balancer(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("load_balancer")
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]], result)

    @builtins.property
    def target_group(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("target_group")
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomFargateServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CustomMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.CustomMonitoring",
):
    '''(experimental) Custom monitoring is a construct allowing you to monitor your own custom metrics.

    The entire construct consists of metric groups.
    Each metric group represents a single graph widget with multiple metrics.
    Each metric inside the metric group represents a single metric inside a graph.
    The widgets will be sized automatically to waste as little space as possible.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        metric_groups: typing.Sequence[typing.Union[CustomMetricGroup, typing.Dict[str, typing.Any]]],
        description: typing.Optional[builtins.str] = None,
        description_widget_height: typing.Optional[jsii.Number] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param metric_groups: 
        :param description: 
        :param description_widget_height: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CustomMonitoringProps(
            metric_groups=metric_groups,
            description=description,
            description_widget_height=description_widget_height,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="anomalyDetectingAlarmFactory")
    def anomaly_detecting_alarm_factory(self) -> AnomalyDetectingAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AnomalyDetectingAlarmFactory, jsii.get(self, "anomalyDetectingAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="customAlarmFactory")
    def custom_alarm_factory(self) -> CustomAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(CustomAlarmFactory, jsii.get(self, "customAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="metricGroups")
    def metric_groups(self) -> typing.List[CustomMetricGroupWithAnnotations]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[CustomMetricGroupWithAnnotations], jsii.get(self, "metricGroups"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="description")
    def description(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "description"))

    @builtins.property
    @jsii.member(jsii_name="descriptionWidgetHeight")
    def description_widget_height(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[jsii.Number], jsii.get(self, "descriptionWidgetHeight"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.CustomMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "metric_groups": "metricGroups",
        "description": "description",
        "description_widget_height": "descriptionWidgetHeight",
    },
)
class CustomMonitoringProps(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        metric_groups: typing.Sequence[typing.Union[CustomMetricGroup, typing.Dict[str, typing.Any]]],
        description: typing.Optional[builtins.str] = None,
        description_widget_height: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param metric_groups: 
        :param description: 
        :param description_widget_height: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(CustomMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument metric_groups", value=metric_groups, expected_type=type_hints["metric_groups"])
            check_type(argname="argument description", value=description, expected_type=type_hints["description"])
            check_type(argname="argument description_widget_height", value=description_widget_height, expected_type=type_hints["description_widget_height"])
        self._values: typing.Dict[str, typing.Any] = {
            "metric_groups": metric_groups,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if description is not None:
            self._values["description"] = description
        if description_widget_height is not None:
            self._values["description_widget_height"] = description_widget_height

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def metric_groups(self) -> typing.List[CustomMetricGroup]:
        '''
        :stability: experimental
        '''
        result = self._values.get("metric_groups")
        assert result is not None, "Required property 'metric_groups' is missing"
        return typing.cast(typing.List[CustomMetricGroup], result)

    @builtins.property
    def description(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def description_widget_height(self) -> typing.Optional[jsii.Number]:
        '''
        :stability: experimental
        '''
        result = self._values.get("description_widget_height")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CustomMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IDashboardFactory)
class DefaultDashboardFactory(
    constructs.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DefaultDashboardFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        dashboard_name_prefix: builtins.str,
        create_alarm_dashboard: typing.Optional[builtins.bool] = None,
        create_dashboard: typing.Optional[builtins.bool] = None,
        create_summary_dashboard: typing.Optional[builtins.bool] = None,
        detail_dashboard_period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        detail_dashboard_range: typing.Optional[aws_cdk.Duration] = None,
        rendering_preference: typing.Optional[DashboardRenderingPreference] = None,
        summary_dashboard_period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        summary_dashboard_range: typing.Optional[aws_cdk.Duration] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param dashboard_name_prefix: (experimental) Prefix added to each dashboard name. This allows to have all dashboards sorted close to each other and also separate multiple monitoring facades.
        :param create_alarm_dashboard: (experimental) Flag indicating whether the alarm dashboard should be created. This is independent on other create dashboard flags. Default: - false
        :param create_dashboard: (experimental) Flag indicating whether the default dashboard should be created. This is independent on other create dashboard flags. Default: - true
        :param create_summary_dashboard: (experimental) Flag indicating whether the summary dashboard should be created. This is independent on other create dashboard flags. Default: - false
        :param detail_dashboard_period_override: (experimental) Period override for the detail dashboard (and other auxiliary dashboards). Default: - respect individual graphs (PeriodOverride.INHERIT)
        :param detail_dashboard_range: (experimental) Range of the detail dashboard (and other auxiliary dashboards). Default: - 8 hours
        :param rendering_preference: (experimental) Dashboard rendering preference. Default: - DashboardRenderingPreference.INTERACTIVE_ONLY
        :param summary_dashboard_period_override: (experimental) Period override for the summary dashboard. Default: - respect individual graphs (PeriodOverride.INHERIT)
        :param summary_dashboard_range: (experimental) Range of the summary dashboard. Default: - 14 days

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DefaultDashboardFactory.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = MonitoringDashboardsProps(
            dashboard_name_prefix=dashboard_name_prefix,
            create_alarm_dashboard=create_alarm_dashboard,
            create_dashboard=create_dashboard,
            create_summary_dashboard=create_summary_dashboard,
            detail_dashboard_period_override=detail_dashboard_period_override,
            detail_dashboard_range=detail_dashboard_range,
            rendering_preference=rendering_preference,
            summary_dashboard_period_override=summary_dashboard_period_override,
            summary_dashboard_range=summary_dashboard_range,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addSegment")
    def add_segment(self, props: IDashboardFactoryProps) -> None:
        '''
        :param props: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DefaultDashboardFactory.add_segment)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(None, jsii.invoke(self, "addSegment", [props]))

    @jsii.member(jsii_name="createdAlarmDashboard")
    def created_alarm_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdAlarmDashboard", []))

    @jsii.member(jsii_name="createDashboard")
    def _create_dashboard(
        self,
        rendering_preference: DashboardRenderingPreference,
        id: builtins.str,
        *,
        dashboard_name: typing.Optional[builtins.str] = None,
        end: typing.Optional[builtins.str] = None,
        period_override: typing.Optional[aws_cdk.aws_cloudwatch.PeriodOverride] = None,
        start: typing.Optional[builtins.str] = None,
        widgets: typing.Optional[typing.Sequence[typing.Sequence[aws_cdk.aws_cloudwatch.IWidget]]] = None,
    ) -> aws_cdk.aws_cloudwatch.Dashboard:
        '''
        :param rendering_preference: -
        :param id: -
        :param dashboard_name: Name of the dashboard. If set, must only contain alphanumerics, dash (-) and underscore (_) Default: - automatically generated name
        :param end: The end of the time range to use for each widget on the dashboard when the dashboard loads. If you specify a value for end, you must also specify a value for start. Specify an absolute time in the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the end date will be the current time.
        :param period_override: Use this field to specify the period for the graphs when the dashboard loads. Specifying ``Auto`` causes the period of all graphs on the dashboard to automatically adapt to the time range of the dashboard. Specifying ``Inherit`` ensures that the period set for each graph is always obeyed. Default: Auto
        :param start: The start of the time range to use for each widget on the dashboard. You can specify start without specifying end to specify a relative time range that ends with the current time. In this case, the value of start must begin with -P, and you can use M, H, D, W and M as abbreviations for minutes, hours, days, weeks and months. For example, -PT8H shows the last 8 hours and -P3M shows the last three months. You can also use start along with an end field, to specify an absolute time range. When specifying an absolute time range, use the ISO 8601 format. For example, 2018-12-17T06:00:00.000Z. Default: When the dashboard loads, the start time will be the default time range.
        :param widgets: Initial set of widgets on the dashboard. One array represents a row of widgets. Default: - No widgets

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DefaultDashboardFactory._create_dashboard)
            check_type(argname="argument rendering_preference", value=rendering_preference, expected_type=type_hints["rendering_preference"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = aws_cdk.aws_cloudwatch.DashboardProps(
            dashboard_name=dashboard_name,
            end=end,
            period_override=period_override,
            start=start,
            widgets=widgets,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.Dashboard, jsii.invoke(self, "createDashboard", [rendering_preference, id, props]))

    @jsii.member(jsii_name="createdDashboard")
    def created_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdDashboard", []))

    @jsii.member(jsii_name="createdSummaryDashboard")
    def created_summary_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdSummaryDashboard", []))

    @builtins.property
    @jsii.member(jsii_name="anyDashboardCreated")
    def any_dashboard_created(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "anyDashboardCreated"))

    @builtins.property
    @jsii.member(jsii_name="alarmDashboard")
    def alarm_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.get(self, "alarmDashboard"))

    @builtins.property
    @jsii.member(jsii_name="dashboard")
    def dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.get(self, "dashboard"))

    @builtins.property
    @jsii.member(jsii_name="summaryDashboard")
    def summary_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.get(self, "summaryDashboard"))


@jsii.implements(IWidgetFactory)
class DefaultWidgetFactory(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DefaultWidgetFactory",
):
    '''
    :stability: experimental
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="createAlarmDetailWidget")
    def create_alarm_detail_widget(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.AlarmBase,
        alarm_description: builtins.str,
        alarm_label: builtins.str,
        alarm_name: builtins.str,
        alarm_name_suffix: builtins.str,
        alarm_rule_when_alarming: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_insufficient_data: aws_cdk.aws_cloudwatch.IAlarmRule,
        alarm_rule_when_ok: aws_cdk.aws_cloudwatch.IAlarmRule,
        annotation: typing.Union[aws_cdk.aws_cloudwatch.HorizontalAnnotation, typing.Dict[str, typing.Any]],
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.IWidget:
        '''(experimental) Create widget representing an alarm detail.

        :param alarm: 
        :param alarm_description: 
        :param alarm_label: 
        :param alarm_name: 
        :param alarm_name_suffix: 
        :param alarm_rule_when_alarming: 
        :param alarm_rule_when_insufficient_data: 
        :param alarm_rule_when_ok: 
        :param annotation: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        alarm_ = AlarmWithAnnotation(
            alarm=alarm,
            alarm_description=alarm_description,
            alarm_label=alarm_label,
            alarm_name=alarm_name,
            alarm_name_suffix=alarm_name_suffix,
            alarm_rule_when_alarming=alarm_rule_when_alarming,
            alarm_rule_when_insufficient_data=alarm_rule_when_insufficient_data,
            alarm_rule_when_ok=alarm_rule_when_ok,
            annotation=annotation,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.IWidget, jsii.invoke(self, "createAlarmDetailWidget", [alarm_]))


class DocumentDbMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DocumentDbMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        cluster: aws_cdk.aws_docdb.IDatabaseCluster,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param cluster: (experimental) database cluster.
        :param add_cpu_usage_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = DocumentDbMonitoringProps(
            cluster=cluster,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createConnectionsWidget")
    def create_connections_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoring.create_connections_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createConnectionsWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createResourceUsageWidget")
    def create_resource_usage_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoring.create_resource_usage_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createResourceUsageWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTransactionsWidget")
    def create_transactions_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoring.create_transactions_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTransactionsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="connectionsMetric")
    def connections_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "connectionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="cursorsMetric")
    def cursors_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cursorsMetric"))

    @builtins.property
    @jsii.member(jsii_name="readLatencyMetric")
    def read_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="throttledMetric")
    def throttled_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "throttledMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="transactionsMetric")
    def transactions_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "transactionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> UsageAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(UsageAlarmFactory, jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="usageAnnotations")
    def usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "usageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="writeLatencyMetric")
    def write_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeLatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="url")
    def url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "url"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DocumentDbMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
    },
)
class DocumentDbMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentDbMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DocumentDbMonitoringProps",
    jsii_struct_bases=[DocumentDbMetricFactoryProps, DocumentDbMonitoringOptions],
    name_mapping={
        "cluster": "cluster",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
    },
)
class DocumentDbMonitoringProps(
    DocumentDbMetricFactoryProps,
    DocumentDbMonitoringOptions,
):
    def __init__(
        self,
        *,
        cluster: aws_cdk.aws_docdb.IDatabaseCluster,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param cluster: (experimental) database cluster.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DocumentDbMonitoringProps.__init__)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster": cluster,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm

    @builtins.property
    def cluster(self) -> aws_cdk.aws_docdb.IDatabaseCluster:
        '''(experimental) database cluster.

        :stability: experimental
        '''
        result = self._values.get("cluster")
        assert result is not None, "Required property 'cluster' is missing"
        return typing.cast(aws_cdk.aws_docdb.IDatabaseCluster, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DocumentDbMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoTableGlobalSecondaryIndexMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DynamoTableGlobalSecondaryIndexMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        global_secondary_index_name: builtins.str,
        table: aws_cdk.aws_dynamodb.ITable,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param global_secondary_index_name: 
        :param table: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = DynamoTableGlobalSecondaryIndexMonitoringProps(
            global_secondary_index_name=global_secondary_index_name,
            table=table,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createReadCapacityWidget")
    def _create_read_capacity_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMonitoring._create_read_capacity_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createReadCapacityWidget", [width, height]))

    @jsii.member(jsii_name="createThrottlesWidget")
    def _create_throttles_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMonitoring._create_throttles_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createThrottlesWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def _create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createWriteCapacityWidget")
    def _create_write_capacity_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMonitoring._create_write_capacity_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createWriteCapacityWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="consumedReadUnitsMetric")
    def _consumed_read_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "consumedReadUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="consumedWriteUnitsMetric")
    def _consumed_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "consumedWriteUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="indexConsumedWriteUnitsMetric")
    def _index_consumed_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "indexConsumedWriteUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="indexThrottleCountMetric")
    def _index_throttle_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "indexThrottleCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="provisionedReadUnitsMetric")
    def _provisioned_read_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedReadUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="provisionedWriteUnitsMetric")
    def _provisioned_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedWriteUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="readThrottleCountMetric")
    def _read_throttle_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readThrottleCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def _title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="writeThrottleCountMetric")
    def _write_throttle_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeThrottleCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="tableUrl")
    def _table_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tableUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DynamoTableGlobalSecondaryIndexMonitoringProps",
    jsii_struct_bases=[
        DynamoTableGlobalSecondaryIndexMetricFactoryProps, BaseMonitoringProps
    ],
    name_mapping={
        "global_secondary_index_name": "globalSecondaryIndexName",
        "table": "table",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class DynamoTableGlobalSecondaryIndexMonitoringProps(
    DynamoTableGlobalSecondaryIndexMetricFactoryProps,
    BaseMonitoringProps,
):
    def __init__(
        self,
        *,
        global_secondary_index_name: builtins.str,
        table: aws_cdk.aws_dynamodb.ITable,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param global_secondary_index_name: 
        :param table: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableGlobalSecondaryIndexMonitoringProps.__init__)
            check_type(argname="argument global_secondary_index_name", value=global_secondary_index_name, expected_type=type_hints["global_secondary_index_name"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "global_secondary_index_name": global_secondary_index_name,
            "table": table,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def global_secondary_index_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("global_secondary_index_name")
        assert result is not None, "Required property 'global_secondary_index_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def table(self) -> aws_cdk.aws_dynamodb.ITable:
        '''
        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(aws_cdk.aws_dynamodb.ITable, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoTableGlobalSecondaryIndexMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoTableMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DynamoTableMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        table: aws_cdk.aws_dynamodb.ITable,
        billing_mode: typing.Optional[aws_cdk.aws_dynamodb.BillingMode] = None,
        add_average_successful_batch_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_batch_write_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_delete_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_records_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_put_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_query_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_scan_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_update_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_read_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_write_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_system_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param table: (experimental) table to monitor.
        :param billing_mode: (experimental) table billing mode. Default: - best effort auto-detection or PROVISIONED as a fallback
        :param add_average_successful_batch_get_item_latency_alarm: 
        :param add_average_successful_batch_write_item_latency_alarm: 
        :param add_average_successful_delete_item_latency_alarm: 
        :param add_average_successful_get_item_latency_alarm: 
        :param add_average_successful_get_records_latency_alarm: 
        :param add_average_successful_put_item_latency_alarm: 
        :param add_average_successful_query_latency_alarm: 
        :param add_average_successful_scan_latency_alarm: 
        :param add_average_successful_update_item_latency_alarm: 
        :param add_consumed_read_capacity_alarm: 
        :param add_consumed_write_capacity_alarm: 
        :param add_read_throttled_events_count_alarm: 
        :param add_system_error_count_alarm: 
        :param add_write_throttled_events_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = DynamoTableMonitoringProps(
            table=table,
            billing_mode=billing_mode,
            add_average_successful_batch_get_item_latency_alarm=add_average_successful_batch_get_item_latency_alarm,
            add_average_successful_batch_write_item_latency_alarm=add_average_successful_batch_write_item_latency_alarm,
            add_average_successful_delete_item_latency_alarm=add_average_successful_delete_item_latency_alarm,
            add_average_successful_get_item_latency_alarm=add_average_successful_get_item_latency_alarm,
            add_average_successful_get_records_latency_alarm=add_average_successful_get_records_latency_alarm,
            add_average_successful_put_item_latency_alarm=add_average_successful_put_item_latency_alarm,
            add_average_successful_query_latency_alarm=add_average_successful_query_latency_alarm,
            add_average_successful_scan_latency_alarm=add_average_successful_scan_latency_alarm,
            add_average_successful_update_item_latency_alarm=add_average_successful_update_item_latency_alarm,
            add_consumed_read_capacity_alarm=add_consumed_read_capacity_alarm,
            add_consumed_write_capacity_alarm=add_consumed_write_capacity_alarm,
            add_read_throttled_events_count_alarm=add_read_throttled_events_count_alarm,
            add_system_error_count_alarm=add_system_error_count_alarm,
            add_write_throttled_events_count_alarm=add_write_throttled_events_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorsWidget")
    def create_errors_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.create_errors_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorsWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createReadCapacityWidget")
    def create_read_capacity_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.create_read_capacity_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createReadCapacityWidget", [width, height]))

    @jsii.member(jsii_name="createThrottlesWidget")
    def create_throttles_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.create_throttles_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createThrottlesWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createWriteCapacityWidget")
    def create_write_capacity_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring.create_write_capacity_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createWriteCapacityWidget", [width, height]))

    @jsii.member(jsii_name="forEachOperationLatencyAlarmDefinition")
    def _for_each_operation_latency_alarm_definition(
        self,
        operation: aws_cdk.aws_dynamodb.Operation,
        alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param operation: -
        :param alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoring._for_each_operation_latency_alarm_definition)
            check_type(argname="argument operation", value=operation, expected_type=type_hints["operation"])
            check_type(argname="argument alarm", value=alarm, expected_type=type_hints["alarm"])
        return typing.cast(None, jsii.invoke(self, "forEachOperationLatencyAlarmDefinition", [operation, alarm]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="averagePerOperationLatencyMetrics")
    def average_per_operation_latency_metrics(
        self,
    ) -> typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Mapping[builtins.str, typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "averagePerOperationLatencyMetrics"))

    @builtins.property
    @jsii.member(jsii_name="consumedReadUnitsMetric")
    def consumed_read_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "consumedReadUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="consumedWriteUnitsMetric")
    def consumed_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "consumedWriteUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="dynamoCapacityAlarmFactory")
    def dynamo_capacity_alarm_factory(self) -> DynamoAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(DynamoAlarmFactory, jsii.get(self, "dynamoCapacityAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="dynamoReadCapacityAnnotations")
    def dynamo_read_capacity_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "dynamoReadCapacityAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="dynamoWriteCapacityAnnotations")
    def dynamo_write_capacity_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "dynamoWriteCapacityAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="latencyAverageSearchMetrics")
    def latency_average_search_metrics(self) -> aws_cdk.aws_cloudwatch.IMetric:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.IMetric, jsii.get(self, "latencyAverageSearchMetrics"))

    @builtins.property
    @jsii.member(jsii_name="provisionedReadUnitsMetric")
    def provisioned_read_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedReadUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="provisionedWriteUnitsMetric")
    def provisioned_write_units_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedWriteUnitsMetric"))

    @builtins.property
    @jsii.member(jsii_name="readCapacityUsageMetric")
    def read_capacity_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readCapacityUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="readThrottleCountMetric")
    def read_throttle_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readThrottleCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="systemErrorMetric")
    def system_error_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "systemErrorMetric"))

    @builtins.property
    @jsii.member(jsii_name="tableBillingMode")
    def table_billing_mode(self) -> aws_cdk.aws_dynamodb.BillingMode:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_dynamodb.BillingMode, jsii.get(self, "tableBillingMode"))

    @builtins.property
    @jsii.member(jsii_name="throttledEventsAnnotations")
    def throttled_events_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "throttledEventsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="writeCapacityUsageMetric")
    def write_capacity_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeCapacityUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="writeThrottleCountMetric")
    def write_throttle_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeThrottleCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="tableUrl")
    def table_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "tableUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DynamoTableMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_average_successful_batch_get_item_latency_alarm": "addAverageSuccessfulBatchGetItemLatencyAlarm",
        "add_average_successful_batch_write_item_latency_alarm": "addAverageSuccessfulBatchWriteItemLatencyAlarm",
        "add_average_successful_delete_item_latency_alarm": "addAverageSuccessfulDeleteItemLatencyAlarm",
        "add_average_successful_get_item_latency_alarm": "addAverageSuccessfulGetItemLatencyAlarm",
        "add_average_successful_get_records_latency_alarm": "addAverageSuccessfulGetRecordsLatencyAlarm",
        "add_average_successful_put_item_latency_alarm": "addAverageSuccessfulPutItemLatencyAlarm",
        "add_average_successful_query_latency_alarm": "addAverageSuccessfulQueryLatencyAlarm",
        "add_average_successful_scan_latency_alarm": "addAverageSuccessfulScanLatencyAlarm",
        "add_average_successful_update_item_latency_alarm": "addAverageSuccessfulUpdateItemLatencyAlarm",
        "add_consumed_read_capacity_alarm": "addConsumedReadCapacityAlarm",
        "add_consumed_write_capacity_alarm": "addConsumedWriteCapacityAlarm",
        "add_read_throttled_events_count_alarm": "addReadThrottledEventsCountAlarm",
        "add_system_error_count_alarm": "addSystemErrorCountAlarm",
        "add_write_throttled_events_count_alarm": "addWriteThrottledEventsCountAlarm",
    },
)
class DynamoTableMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_average_successful_batch_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_batch_write_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_delete_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_records_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_put_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_query_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_scan_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_update_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_read_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_write_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_system_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_average_successful_batch_get_item_latency_alarm: 
        :param add_average_successful_batch_write_item_latency_alarm: 
        :param add_average_successful_delete_item_latency_alarm: 
        :param add_average_successful_get_item_latency_alarm: 
        :param add_average_successful_get_records_latency_alarm: 
        :param add_average_successful_put_item_latency_alarm: 
        :param add_average_successful_query_latency_alarm: 
        :param add_average_successful_scan_latency_alarm: 
        :param add_average_successful_update_item_latency_alarm: 
        :param add_consumed_read_capacity_alarm: 
        :param add_consumed_write_capacity_alarm: 
        :param add_read_throttled_events_count_alarm: 
        :param add_system_error_count_alarm: 
        :param add_write_throttled_events_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_average_successful_batch_get_item_latency_alarm", value=add_average_successful_batch_get_item_latency_alarm, expected_type=type_hints["add_average_successful_batch_get_item_latency_alarm"])
            check_type(argname="argument add_average_successful_batch_write_item_latency_alarm", value=add_average_successful_batch_write_item_latency_alarm, expected_type=type_hints["add_average_successful_batch_write_item_latency_alarm"])
            check_type(argname="argument add_average_successful_delete_item_latency_alarm", value=add_average_successful_delete_item_latency_alarm, expected_type=type_hints["add_average_successful_delete_item_latency_alarm"])
            check_type(argname="argument add_average_successful_get_item_latency_alarm", value=add_average_successful_get_item_latency_alarm, expected_type=type_hints["add_average_successful_get_item_latency_alarm"])
            check_type(argname="argument add_average_successful_get_records_latency_alarm", value=add_average_successful_get_records_latency_alarm, expected_type=type_hints["add_average_successful_get_records_latency_alarm"])
            check_type(argname="argument add_average_successful_put_item_latency_alarm", value=add_average_successful_put_item_latency_alarm, expected_type=type_hints["add_average_successful_put_item_latency_alarm"])
            check_type(argname="argument add_average_successful_query_latency_alarm", value=add_average_successful_query_latency_alarm, expected_type=type_hints["add_average_successful_query_latency_alarm"])
            check_type(argname="argument add_average_successful_scan_latency_alarm", value=add_average_successful_scan_latency_alarm, expected_type=type_hints["add_average_successful_scan_latency_alarm"])
            check_type(argname="argument add_average_successful_update_item_latency_alarm", value=add_average_successful_update_item_latency_alarm, expected_type=type_hints["add_average_successful_update_item_latency_alarm"])
            check_type(argname="argument add_consumed_read_capacity_alarm", value=add_consumed_read_capacity_alarm, expected_type=type_hints["add_consumed_read_capacity_alarm"])
            check_type(argname="argument add_consumed_write_capacity_alarm", value=add_consumed_write_capacity_alarm, expected_type=type_hints["add_consumed_write_capacity_alarm"])
            check_type(argname="argument add_read_throttled_events_count_alarm", value=add_read_throttled_events_count_alarm, expected_type=type_hints["add_read_throttled_events_count_alarm"])
            check_type(argname="argument add_system_error_count_alarm", value=add_system_error_count_alarm, expected_type=type_hints["add_system_error_count_alarm"])
            check_type(argname="argument add_write_throttled_events_count_alarm", value=add_write_throttled_events_count_alarm, expected_type=type_hints["add_write_throttled_events_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_average_successful_batch_get_item_latency_alarm is not None:
            self._values["add_average_successful_batch_get_item_latency_alarm"] = add_average_successful_batch_get_item_latency_alarm
        if add_average_successful_batch_write_item_latency_alarm is not None:
            self._values["add_average_successful_batch_write_item_latency_alarm"] = add_average_successful_batch_write_item_latency_alarm
        if add_average_successful_delete_item_latency_alarm is not None:
            self._values["add_average_successful_delete_item_latency_alarm"] = add_average_successful_delete_item_latency_alarm
        if add_average_successful_get_item_latency_alarm is not None:
            self._values["add_average_successful_get_item_latency_alarm"] = add_average_successful_get_item_latency_alarm
        if add_average_successful_get_records_latency_alarm is not None:
            self._values["add_average_successful_get_records_latency_alarm"] = add_average_successful_get_records_latency_alarm
        if add_average_successful_put_item_latency_alarm is not None:
            self._values["add_average_successful_put_item_latency_alarm"] = add_average_successful_put_item_latency_alarm
        if add_average_successful_query_latency_alarm is not None:
            self._values["add_average_successful_query_latency_alarm"] = add_average_successful_query_latency_alarm
        if add_average_successful_scan_latency_alarm is not None:
            self._values["add_average_successful_scan_latency_alarm"] = add_average_successful_scan_latency_alarm
        if add_average_successful_update_item_latency_alarm is not None:
            self._values["add_average_successful_update_item_latency_alarm"] = add_average_successful_update_item_latency_alarm
        if add_consumed_read_capacity_alarm is not None:
            self._values["add_consumed_read_capacity_alarm"] = add_consumed_read_capacity_alarm
        if add_consumed_write_capacity_alarm is not None:
            self._values["add_consumed_write_capacity_alarm"] = add_consumed_write_capacity_alarm
        if add_read_throttled_events_count_alarm is not None:
            self._values["add_read_throttled_events_count_alarm"] = add_read_throttled_events_count_alarm
        if add_system_error_count_alarm is not None:
            self._values["add_system_error_count_alarm"] = add_system_error_count_alarm
        if add_write_throttled_events_count_alarm is not None:
            self._values["add_write_throttled_events_count_alarm"] = add_write_throttled_events_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_average_successful_batch_get_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_batch_get_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_batch_write_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_batch_write_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_delete_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_delete_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_get_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_get_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_get_records_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_get_records_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_put_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_put_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_query_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_query_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_scan_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_scan_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_update_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_update_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_consumed_read_capacity_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_consumed_read_capacity_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]], result)

    @builtins.property
    def add_consumed_write_capacity_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_consumed_write_capacity_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]], result)

    @builtins.property
    def add_read_throttled_events_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_read_throttled_events_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]], result)

    @builtins.property
    def add_system_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_system_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_write_throttled_events_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_write_throttled_events_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoTableMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.DynamoTableMonitoringProps",
    jsii_struct_bases=[DynamoTableMetricFactoryProps, DynamoTableMonitoringOptions],
    name_mapping={
        "table": "table",
        "billing_mode": "billingMode",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_average_successful_batch_get_item_latency_alarm": "addAverageSuccessfulBatchGetItemLatencyAlarm",
        "add_average_successful_batch_write_item_latency_alarm": "addAverageSuccessfulBatchWriteItemLatencyAlarm",
        "add_average_successful_delete_item_latency_alarm": "addAverageSuccessfulDeleteItemLatencyAlarm",
        "add_average_successful_get_item_latency_alarm": "addAverageSuccessfulGetItemLatencyAlarm",
        "add_average_successful_get_records_latency_alarm": "addAverageSuccessfulGetRecordsLatencyAlarm",
        "add_average_successful_put_item_latency_alarm": "addAverageSuccessfulPutItemLatencyAlarm",
        "add_average_successful_query_latency_alarm": "addAverageSuccessfulQueryLatencyAlarm",
        "add_average_successful_scan_latency_alarm": "addAverageSuccessfulScanLatencyAlarm",
        "add_average_successful_update_item_latency_alarm": "addAverageSuccessfulUpdateItemLatencyAlarm",
        "add_consumed_read_capacity_alarm": "addConsumedReadCapacityAlarm",
        "add_consumed_write_capacity_alarm": "addConsumedWriteCapacityAlarm",
        "add_read_throttled_events_count_alarm": "addReadThrottledEventsCountAlarm",
        "add_system_error_count_alarm": "addSystemErrorCountAlarm",
        "add_write_throttled_events_count_alarm": "addWriteThrottledEventsCountAlarm",
    },
)
class DynamoTableMonitoringProps(
    DynamoTableMetricFactoryProps,
    DynamoTableMonitoringOptions,
):
    def __init__(
        self,
        *,
        table: aws_cdk.aws_dynamodb.ITable,
        billing_mode: typing.Optional[aws_cdk.aws_dynamodb.BillingMode] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_average_successful_batch_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_batch_write_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_delete_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_records_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_put_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_query_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_scan_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_update_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_read_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_write_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_system_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param table: (experimental) table to monitor.
        :param billing_mode: (experimental) table billing mode. Default: - best effort auto-detection or PROVISIONED as a fallback
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_average_successful_batch_get_item_latency_alarm: 
        :param add_average_successful_batch_write_item_latency_alarm: 
        :param add_average_successful_delete_item_latency_alarm: 
        :param add_average_successful_get_item_latency_alarm: 
        :param add_average_successful_get_records_latency_alarm: 
        :param add_average_successful_put_item_latency_alarm: 
        :param add_average_successful_query_latency_alarm: 
        :param add_average_successful_scan_latency_alarm: 
        :param add_average_successful_update_item_latency_alarm: 
        :param add_consumed_read_capacity_alarm: 
        :param add_consumed_write_capacity_alarm: 
        :param add_read_throttled_events_count_alarm: 
        :param add_system_error_count_alarm: 
        :param add_write_throttled_events_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DynamoTableMonitoringProps.__init__)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument billing_mode", value=billing_mode, expected_type=type_hints["billing_mode"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_average_successful_batch_get_item_latency_alarm", value=add_average_successful_batch_get_item_latency_alarm, expected_type=type_hints["add_average_successful_batch_get_item_latency_alarm"])
            check_type(argname="argument add_average_successful_batch_write_item_latency_alarm", value=add_average_successful_batch_write_item_latency_alarm, expected_type=type_hints["add_average_successful_batch_write_item_latency_alarm"])
            check_type(argname="argument add_average_successful_delete_item_latency_alarm", value=add_average_successful_delete_item_latency_alarm, expected_type=type_hints["add_average_successful_delete_item_latency_alarm"])
            check_type(argname="argument add_average_successful_get_item_latency_alarm", value=add_average_successful_get_item_latency_alarm, expected_type=type_hints["add_average_successful_get_item_latency_alarm"])
            check_type(argname="argument add_average_successful_get_records_latency_alarm", value=add_average_successful_get_records_latency_alarm, expected_type=type_hints["add_average_successful_get_records_latency_alarm"])
            check_type(argname="argument add_average_successful_put_item_latency_alarm", value=add_average_successful_put_item_latency_alarm, expected_type=type_hints["add_average_successful_put_item_latency_alarm"])
            check_type(argname="argument add_average_successful_query_latency_alarm", value=add_average_successful_query_latency_alarm, expected_type=type_hints["add_average_successful_query_latency_alarm"])
            check_type(argname="argument add_average_successful_scan_latency_alarm", value=add_average_successful_scan_latency_alarm, expected_type=type_hints["add_average_successful_scan_latency_alarm"])
            check_type(argname="argument add_average_successful_update_item_latency_alarm", value=add_average_successful_update_item_latency_alarm, expected_type=type_hints["add_average_successful_update_item_latency_alarm"])
            check_type(argname="argument add_consumed_read_capacity_alarm", value=add_consumed_read_capacity_alarm, expected_type=type_hints["add_consumed_read_capacity_alarm"])
            check_type(argname="argument add_consumed_write_capacity_alarm", value=add_consumed_write_capacity_alarm, expected_type=type_hints["add_consumed_write_capacity_alarm"])
            check_type(argname="argument add_read_throttled_events_count_alarm", value=add_read_throttled_events_count_alarm, expected_type=type_hints["add_read_throttled_events_count_alarm"])
            check_type(argname="argument add_system_error_count_alarm", value=add_system_error_count_alarm, expected_type=type_hints["add_system_error_count_alarm"])
            check_type(argname="argument add_write_throttled_events_count_alarm", value=add_write_throttled_events_count_alarm, expected_type=type_hints["add_write_throttled_events_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "table": table,
        }
        if billing_mode is not None:
            self._values["billing_mode"] = billing_mode
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_average_successful_batch_get_item_latency_alarm is not None:
            self._values["add_average_successful_batch_get_item_latency_alarm"] = add_average_successful_batch_get_item_latency_alarm
        if add_average_successful_batch_write_item_latency_alarm is not None:
            self._values["add_average_successful_batch_write_item_latency_alarm"] = add_average_successful_batch_write_item_latency_alarm
        if add_average_successful_delete_item_latency_alarm is not None:
            self._values["add_average_successful_delete_item_latency_alarm"] = add_average_successful_delete_item_latency_alarm
        if add_average_successful_get_item_latency_alarm is not None:
            self._values["add_average_successful_get_item_latency_alarm"] = add_average_successful_get_item_latency_alarm
        if add_average_successful_get_records_latency_alarm is not None:
            self._values["add_average_successful_get_records_latency_alarm"] = add_average_successful_get_records_latency_alarm
        if add_average_successful_put_item_latency_alarm is not None:
            self._values["add_average_successful_put_item_latency_alarm"] = add_average_successful_put_item_latency_alarm
        if add_average_successful_query_latency_alarm is not None:
            self._values["add_average_successful_query_latency_alarm"] = add_average_successful_query_latency_alarm
        if add_average_successful_scan_latency_alarm is not None:
            self._values["add_average_successful_scan_latency_alarm"] = add_average_successful_scan_latency_alarm
        if add_average_successful_update_item_latency_alarm is not None:
            self._values["add_average_successful_update_item_latency_alarm"] = add_average_successful_update_item_latency_alarm
        if add_consumed_read_capacity_alarm is not None:
            self._values["add_consumed_read_capacity_alarm"] = add_consumed_read_capacity_alarm
        if add_consumed_write_capacity_alarm is not None:
            self._values["add_consumed_write_capacity_alarm"] = add_consumed_write_capacity_alarm
        if add_read_throttled_events_count_alarm is not None:
            self._values["add_read_throttled_events_count_alarm"] = add_read_throttled_events_count_alarm
        if add_system_error_count_alarm is not None:
            self._values["add_system_error_count_alarm"] = add_system_error_count_alarm
        if add_write_throttled_events_count_alarm is not None:
            self._values["add_write_throttled_events_count_alarm"] = add_write_throttled_events_count_alarm

    @builtins.property
    def table(self) -> aws_cdk.aws_dynamodb.ITable:
        '''(experimental) table to monitor.

        :stability: experimental
        '''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(aws_cdk.aws_dynamodb.ITable, result)

    @builtins.property
    def billing_mode(self) -> typing.Optional[aws_cdk.aws_dynamodb.BillingMode]:
        '''(experimental) table billing mode.

        :default: - best effort auto-detection or PROVISIONED as a fallback

        :stability: experimental
        '''
        result = self._values.get("billing_mode")
        return typing.cast(typing.Optional[aws_cdk.aws_dynamodb.BillingMode], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_average_successful_batch_get_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_batch_get_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_batch_write_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_batch_write_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_delete_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_delete_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_get_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_get_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_get_records_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_get_records_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_put_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_put_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_query_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_query_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_scan_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_scan_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_average_successful_update_item_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_successful_update_item_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_consumed_read_capacity_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_consumed_read_capacity_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]], result)

    @builtins.property
    def add_consumed_write_capacity_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_consumed_write_capacity_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ConsumedCapacityThreshold]], result)

    @builtins.property
    def add_read_throttled_events_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_read_throttled_events_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]], result)

    @builtins.property
    def add_system_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_system_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_write_throttled_events_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_write_throttled_events_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ThrottledEventsThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoTableMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EC2Monitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.EC2Monitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2Monitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = EC2MonitoringProps(
            auto_scaling_group=auto_scaling_group,
            instance_ids=instance_ids,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createCpuWidget")
    def create_cpu_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2Monitoring.create_cpu_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuWidget", [width, height]))

    @jsii.member(jsii_name="createDiskOpsWidget")
    def create_disk_ops_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2Monitoring.create_disk_ops_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDiskOpsWidget", [width, height]))

    @jsii.member(jsii_name="createDiskWidget")
    def create_disk_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2Monitoring.create_disk_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDiskWidget", [width, height]))

    @jsii.member(jsii_name="createNetworkWidget")
    def create_network_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2Monitoring.create_network_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createNetworkWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="cpuUtilisationMetrics")
    def cpu_utilisation_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "cpuUtilisationMetrics"))

    @builtins.property
    @jsii.member(jsii_name="diskReadBytesMetrics")
    def disk_read_bytes_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "diskReadBytesMetrics"))

    @builtins.property
    @jsii.member(jsii_name="diskReadOpsMetrics")
    def disk_read_ops_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "diskReadOpsMetrics"))

    @builtins.property
    @jsii.member(jsii_name="diskWriteBytesMetrics")
    def disk_write_bytes_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "diskWriteBytesMetrics"))

    @builtins.property
    @jsii.member(jsii_name="diskWriteOpsMetrics")
    def disk_write_ops_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "diskWriteOpsMetrics"))

    @builtins.property
    @jsii.member(jsii_name="family")
    def family(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "family"))

    @builtins.property
    @jsii.member(jsii_name="networkInMetrics")
    def network_in_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "networkInMetrics"))

    @builtins.property
    @jsii.member(jsii_name="networkOutMetrics")
    def network_out_metrics(self) -> typing.List[aws_cdk.aws_cloudwatch.IMetric]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IMetric], jsii.get(self, "networkOutMetrics"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.EC2MonitoringOptions",
    jsii_struct_bases=[EC2MetricFactoryProps, BaseMonitoringProps],
    name_mapping={
        "auto_scaling_group": "autoScalingGroup",
        "instance_ids": "instanceIds",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class EC2MonitoringOptions(EC2MetricFactoryProps, BaseMonitoringProps):
    def __init__(
        self,
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2MonitoringOptions.__init__)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auto_scaling_group is not None:
            self._values["auto_scaling_group"] = auto_scaling_group
        if instance_ids is not None:
            self._values["instance_ids"] = instance_ids
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def auto_scaling_group(
        self,
    ) -> typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup]:
        '''(experimental) Auto-Scaling Group to monitor.

        :default: - no Auto-Scaling Group filter

        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        return typing.cast(typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup], result)

    @builtins.property
    def instance_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Selected IDs of EC2 instances to monitor.

        :default: - no instance filter

        :stability: experimental
        '''
        result = self._values.get("instance_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EC2MonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.EC2MonitoringProps",
    jsii_struct_bases=[EC2MonitoringOptions],
    name_mapping={
        "auto_scaling_group": "autoScalingGroup",
        "instance_ids": "instanceIds",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class EC2MonitoringProps(EC2MonitoringOptions):
    def __init__(
        self,
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(EC2MonitoringProps.__init__)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument instance_ids", value=instance_ids, expected_type=type_hints["instance_ids"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if auto_scaling_group is not None:
            self._values["auto_scaling_group"] = auto_scaling_group
        if instance_ids is not None:
            self._values["instance_ids"] = instance_ids
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def auto_scaling_group(
        self,
    ) -> typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup]:
        '''(experimental) Auto-Scaling Group to monitor.

        :default: - no Auto-Scaling Group filter

        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        return typing.cast(typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup], result)

    @builtins.property
    def instance_ids(self) -> typing.Optional[typing.List[builtins.str]]:
        '''(experimental) Selected IDs of EC2 instances to monitor.

        :default: - no instance filter

        :stability: experimental
        '''
        result = self._values.get("instance_ids")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EC2MonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.Ec2ApplicationLoadBalancerMonitoringProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerMetricFactoryProps,
        BaseMonitoringProps,
        BaseEc2ServiceAlarms,
    ],
    name_mapping={
        "application_load_balancer": "applicationLoadBalancer",
        "application_target_group": "applicationTargetGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "ec2_service": "ec2Service",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class Ec2ApplicationLoadBalancerMonitoringProps(
    ApplicationLoadBalancerMetricFactoryProps,
    BaseMonitoringProps,
    BaseEc2ServiceAlarms,
):
    def __init__(
        self,
        *,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for EC2 service with application load balancer and plain service.

        :param application_load_balancer: 
        :param application_target_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ApplicationLoadBalancerMonitoringProps.__init__)
            check_type(argname="argument application_load_balancer", value=application_load_balancer, expected_type=type_hints["application_load_balancer"])
            check_type(argname="argument application_target_group", value=application_target_group, expected_type=type_hints["application_target_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "application_load_balancer": application_load_balancer,
            "application_target_group": application_target_group,
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def application_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_load_balancer")
        assert result is not None, "Required property 'application_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, result)

    @builtins.property
    def application_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_target_group")
        assert result is not None, "Required property 'application_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ec2_service(self) -> aws_cdk.aws_ecs.Ec2Service:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.Ec2Service, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2ApplicationLoadBalancerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.Ec2NetworkLoadBalancerMonitoringProps",
    jsii_struct_bases=[
        NetworkLoadBalancerMetricFactoryProps,
        BaseMonitoringProps,
        BaseEc2ServiceAlarms,
    ],
    name_mapping={
        "network_load_balancer": "networkLoadBalancer",
        "network_target_group": "networkTargetGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "ec2_service": "ec2Service",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class Ec2NetworkLoadBalancerMonitoringProps(
    NetworkLoadBalancerMetricFactoryProps,
    BaseMonitoringProps,
    BaseEc2ServiceAlarms,
):
    def __init__(
        self,
        *,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for EC2 service with network load balancer and plain service.

        :param network_load_balancer: 
        :param network_target_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2NetworkLoadBalancerMonitoringProps.__init__)
            check_type(argname="argument network_load_balancer", value=network_load_balancer, expected_type=type_hints["network_load_balancer"])
            check_type(argname="argument network_target_group", value=network_target_group, expected_type=type_hints["network_target_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "network_load_balancer": network_load_balancer,
            "network_target_group": network_target_group,
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def network_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_load_balancer")
        assert result is not None, "Required property 'network_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer, result)

    @builtins.property
    def network_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_target_group")
        assert result is not None, "Required property 'network_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ec2_service(self) -> aws_cdk.aws_ecs.Ec2Service:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.Ec2Service, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2NetworkLoadBalancerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ec2ServiceMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.Ec2ServiceMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        load_balancer: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]] = None,
        target_group: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param load_balancer: 
        :param target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CustomEc2ServiceMonitoringProps(
            ec2_service=ec2_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            load_balancer=load_balancer,
            target_group=target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createCpuWidget")
    def create_cpu_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoring.create_cpu_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuWidget", [width, height]))

    @jsii.member(jsii_name="createMemoryWidget")
    def create_memory_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoring.create_memory_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMemoryWidget", [width, height]))

    @jsii.member(jsii_name="createTaskHealthWidget")
    def create_task_health_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoring.create_task_health_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTaskHealthWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpcFlowsWidget")
    def create_tpc_flows_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoring.create_tpc_flows_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpcFlowsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="baseServiceMetricFactory")
    def base_service_metric_factory(self) -> BaseServiceMetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(BaseServiceMetricFactory, jsii.get(self, "baseServiceMetricFactory"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageAnnotations")
    def cpu_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "cpuUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="cpuUtilisationMetric")
    def cpu_utilisation_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUtilisationMetric"))

    @builtins.property
    @jsii.member(jsii_name="memoryUsageAnnotations")
    def memory_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "memoryUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="memoryUtilisationMetric")
    def memory_utilisation_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "memoryUtilisationMetric"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesAnnotations")
    def processed_bytes_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "processedBytesAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="runningTaskCountMetric")
    def running_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "runningTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAlarmFactory")
    def task_health_alarm_factory(self) -> TaskHealthAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TaskHealthAlarmFactory, jsii.get(self, "taskHealthAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAnnotations")
    def task_health_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "taskHealthAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="throughputAlarmFactory")
    def throughput_alarm_factory(self) -> ThroughputAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ThroughputAlarmFactory, jsii.get(self, "throughputAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> UsageAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(UsageAlarmFactory, jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="activeTcpFlowCountMetric")
    def active_tcp_flow_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "activeTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskCountMetric")
    def healthy_task_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "healthyTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskPercentMetric")
    def healthy_task_percent_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "healthyTaskPercentMetric"))

    @builtins.property
    @jsii.member(jsii_name="loadBalancerMetricFactory")
    def load_balancer_metric_factory(
        self,
    ) -> typing.Optional[ILoadBalancerMetricFactory]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[ILoadBalancerMetricFactory], jsii.get(self, "loadBalancerMetricFactory"))

    @builtins.property
    @jsii.member(jsii_name="newTcpFlowCountMetric")
    def new_tcp_flow_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "newTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesMetric")
    def processed_bytes_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "processedBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="unhealthyTaskCountMetric")
    def unhealthy_task_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "unhealthyTaskCountMetric"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.Ec2ServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseEc2ServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "ec2_service": "ec2Service",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class Ec2ServiceMonitoringProps(BaseMonitoringProps, BaseEc2ServiceAlarms):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        ec2_service: typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service],
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for load-balanced EC2 service.

        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(Ec2ServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ec2_service(
        self,
    ) -> typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service]:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service], result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2ServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheClusterMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ElastiCacheClusterMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        cluster_id: typing.Optional[builtins.str] = None,
        cluster_type: ElastiCacheClusterType,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_evicted_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_used_swap_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxUsedSwapMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_freeable_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinFreeableMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param cluster_id: (experimental) Cluster to monitor. Default: - monitor all clusters
        :param cluster_type: (experimental) Cluster type (needed, since each type has their own specific metrics).
        :param add_cpu_usage_alarm: (experimental) Add CPU usage alarm.
        :param add_max_evicted_items_count_alarm: (experimental) Add alarm on number of evicted items.
        :param add_max_items_count_alarm: (experimental) Add alarm on total number of items.
        :param add_max_used_swap_memory_alarm: (experimental) Add alarm on amount of used swap memory.
        :param add_min_freeable_memory_alarm: (experimental) Add alarm on amount of freeable memory.
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = ElastiCacheClusterMonitoringProps(
            cluster_id=cluster_id,
            cluster_type=cluster_type,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_max_evicted_items_count_alarm=add_max_evicted_items_count_alarm,
            add_max_items_count_alarm=add_max_items_count_alarm,
            add_max_used_swap_memory_alarm=add_max_used_swap_memory_alarm,
            add_min_freeable_memory_alarm=add_min_freeable_memory_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createConnectionsWidget")
    def create_connections_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoring.create_connections_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createConnectionsWidget", [width, height]))

    @jsii.member(jsii_name="createCpuUsageWidget")
    def create_cpu_usage_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoring.create_cpu_usage_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuUsageWidget", [width, height]))

    @jsii.member(jsii_name="createItemCountWidget")
    def create_item_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoring.create_item_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createItemCountWidget", [width, height]))

    @jsii.member(jsii_name="createMemoryUsageWidget")
    def create_memory_usage_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoring.create_memory_usage_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMemoryUsageWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="connectionsMetric")
    def connections_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "connectionsMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageAnnotations")
    def cpu_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "cpuUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="elastiCacheAlarmFactory")
    def elasti_cache_alarm_factory(self) -> ElastiCacheAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ElastiCacheAlarmFactory, jsii.get(self, "elastiCacheAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="evictedItemsCountAnnotations")
    def evicted_items_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "evictedItemsCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="freeableMemoryMetric")
    def freeable_memory_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "freeableMemoryMetric"))

    @builtins.property
    @jsii.member(jsii_name="itemsCountAnnotations")
    def items_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "itemsCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="itemsCountMetrics")
    def items_count_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "itemsCountMetrics"))

    @builtins.property
    @jsii.member(jsii_name="itemsEvictedMetrics")
    def items_evicted_metrics(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "itemsEvictedMetrics"))

    @builtins.property
    @jsii.member(jsii_name="itemsMemoryMetric")
    def items_memory_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "itemsMemoryMetric"))

    @builtins.property
    @jsii.member(jsii_name="memoryUsageAnnotations")
    def memory_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "memoryUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="swapMemoryMetric")
    def swap_memory_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "swapMemoryMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="unusedMemoryMetric")
    def unused_memory_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "unusedMemoryMetric"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> UsageAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(UsageAlarmFactory, jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="clusterUrl")
    def cluster_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "clusterUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ElastiCacheClusterMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "cluster_type": "clusterType",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_max_evicted_items_count_alarm": "addMaxEvictedItemsCountAlarm",
        "add_max_items_count_alarm": "addMaxItemsCountAlarm",
        "add_max_used_swap_memory_alarm": "addMaxUsedSwapMemoryAlarm",
        "add_min_freeable_memory_alarm": "addMinFreeableMemoryAlarm",
    },
)
class ElastiCacheClusterMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        cluster_type: ElastiCacheClusterType,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_evicted_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_used_swap_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxUsedSwapMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_freeable_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinFreeableMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param cluster_type: (experimental) Cluster type (needed, since each type has their own specific metrics).
        :param add_cpu_usage_alarm: (experimental) Add CPU usage alarm.
        :param add_max_evicted_items_count_alarm: (experimental) Add alarm on number of evicted items.
        :param add_max_items_count_alarm: (experimental) Add alarm on total number of items.
        :param add_max_used_swap_memory_alarm: (experimental) Add alarm on amount of used swap memory.
        :param add_min_freeable_memory_alarm: (experimental) Add alarm on amount of freeable memory.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument cluster_type", value=cluster_type, expected_type=type_hints["cluster_type"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_max_evicted_items_count_alarm", value=add_max_evicted_items_count_alarm, expected_type=type_hints["add_max_evicted_items_count_alarm"])
            check_type(argname="argument add_max_items_count_alarm", value=add_max_items_count_alarm, expected_type=type_hints["add_max_items_count_alarm"])
            check_type(argname="argument add_max_used_swap_memory_alarm", value=add_max_used_swap_memory_alarm, expected_type=type_hints["add_max_used_swap_memory_alarm"])
            check_type(argname="argument add_min_freeable_memory_alarm", value=add_min_freeable_memory_alarm, expected_type=type_hints["add_min_freeable_memory_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_type": cluster_type,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_max_evicted_items_count_alarm is not None:
            self._values["add_max_evicted_items_count_alarm"] = add_max_evicted_items_count_alarm
        if add_max_items_count_alarm is not None:
            self._values["add_max_items_count_alarm"] = add_max_items_count_alarm
        if add_max_used_swap_memory_alarm is not None:
            self._values["add_max_used_swap_memory_alarm"] = add_max_used_swap_memory_alarm
        if add_min_freeable_memory_alarm is not None:
            self._values["add_min_freeable_memory_alarm"] = add_min_freeable_memory_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def cluster_type(self) -> ElastiCacheClusterType:
        '''(experimental) Cluster type (needed, since each type has their own specific metrics).

        :stability: experimental
        '''
        result = self._values.get("cluster_type")
        assert result is not None, "Required property 'cluster_type' is missing"
        return typing.cast(ElastiCacheClusterType, result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''(experimental) Add CPU usage alarm.

        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_evicted_items_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]]:
        '''(experimental) Add alarm on number of evicted items.

        :stability: experimental
        '''
        result = self._values.get("add_max_evicted_items_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]], result)

    @builtins.property
    def add_max_items_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]]:
        '''(experimental) Add alarm on total number of items.

        :stability: experimental
        '''
        result = self._values.get("add_max_items_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]], result)

    @builtins.property
    def add_max_used_swap_memory_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxUsedSwapMemoryThreshold]]:
        '''(experimental) Add alarm on amount of used swap memory.

        :stability: experimental
        '''
        result = self._values.get("add_max_used_swap_memory_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxUsedSwapMemoryThreshold]], result)

    @builtins.property
    def add_min_freeable_memory_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinFreeableMemoryThreshold]]:
        '''(experimental) Add alarm on amount of freeable memory.

        :stability: experimental
        '''
        result = self._values.get("add_min_freeable_memory_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinFreeableMemoryThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ElastiCacheClusterMonitoringProps",
    jsii_struct_bases=[
        ElastiCacheClusterMetricFactoryProps, ElastiCacheClusterMonitoringOptions
    ],
    name_mapping={
        "cluster_id": "clusterId",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "cluster_type": "clusterType",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_max_evicted_items_count_alarm": "addMaxEvictedItemsCountAlarm",
        "add_max_items_count_alarm": "addMaxItemsCountAlarm",
        "add_max_used_swap_memory_alarm": "addMaxUsedSwapMemoryAlarm",
        "add_min_freeable_memory_alarm": "addMinFreeableMemoryAlarm",
    },
)
class ElastiCacheClusterMonitoringProps(
    ElastiCacheClusterMetricFactoryProps,
    ElastiCacheClusterMonitoringOptions,
):
    def __init__(
        self,
        *,
        cluster_id: typing.Optional[builtins.str] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        cluster_type: ElastiCacheClusterType,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_evicted_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_used_swap_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxUsedSwapMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_freeable_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinFreeableMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param cluster_id: (experimental) Cluster to monitor. Default: - monitor all clusters
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param cluster_type: (experimental) Cluster type (needed, since each type has their own specific metrics).
        :param add_cpu_usage_alarm: (experimental) Add CPU usage alarm.
        :param add_max_evicted_items_count_alarm: (experimental) Add alarm on number of evicted items.
        :param add_max_items_count_alarm: (experimental) Add alarm on total number of items.
        :param add_max_used_swap_memory_alarm: (experimental) Add alarm on amount of used swap memory.
        :param add_min_freeable_memory_alarm: (experimental) Add alarm on amount of freeable memory.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ElastiCacheClusterMonitoringProps.__init__)
            check_type(argname="argument cluster_id", value=cluster_id, expected_type=type_hints["cluster_id"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument cluster_type", value=cluster_type, expected_type=type_hints["cluster_type"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_max_evicted_items_count_alarm", value=add_max_evicted_items_count_alarm, expected_type=type_hints["add_max_evicted_items_count_alarm"])
            check_type(argname="argument add_max_items_count_alarm", value=add_max_items_count_alarm, expected_type=type_hints["add_max_items_count_alarm"])
            check_type(argname="argument add_max_used_swap_memory_alarm", value=add_max_used_swap_memory_alarm, expected_type=type_hints["add_max_used_swap_memory_alarm"])
            check_type(argname="argument add_min_freeable_memory_alarm", value=add_min_freeable_memory_alarm, expected_type=type_hints["add_min_freeable_memory_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_type": cluster_type,
        }
        if cluster_id is not None:
            self._values["cluster_id"] = cluster_id
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_max_evicted_items_count_alarm is not None:
            self._values["add_max_evicted_items_count_alarm"] = add_max_evicted_items_count_alarm
        if add_max_items_count_alarm is not None:
            self._values["add_max_items_count_alarm"] = add_max_items_count_alarm
        if add_max_used_swap_memory_alarm is not None:
            self._values["add_max_used_swap_memory_alarm"] = add_max_used_swap_memory_alarm
        if add_min_freeable_memory_alarm is not None:
            self._values["add_min_freeable_memory_alarm"] = add_min_freeable_memory_alarm

    @builtins.property
    def cluster_id(self) -> typing.Optional[builtins.str]:
        '''(experimental) Cluster to monitor.

        :default: - monitor all clusters

        :stability: experimental
        '''
        result = self._values.get("cluster_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def cluster_type(self) -> ElastiCacheClusterType:
        '''(experimental) Cluster type (needed, since each type has their own specific metrics).

        :stability: experimental
        '''
        result = self._values.get("cluster_type")
        assert result is not None, "Required property 'cluster_type' is missing"
        return typing.cast(ElastiCacheClusterType, result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''(experimental) Add CPU usage alarm.

        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_evicted_items_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]]:
        '''(experimental) Add alarm on number of evicted items.

        :stability: experimental
        '''
        result = self._values.get("add_max_evicted_items_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]], result)

    @builtins.property
    def add_max_items_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]]:
        '''(experimental) Add alarm on total number of items.

        :stability: experimental
        '''
        result = self._values.get("add_max_items_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxItemsCountThreshold]], result)

    @builtins.property
    def add_max_used_swap_memory_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxUsedSwapMemoryThreshold]]:
        '''(experimental) Add alarm on amount of used swap memory.

        :stability: experimental
        '''
        result = self._values.get("add_max_used_swap_memory_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxUsedSwapMemoryThreshold]], result)

    @builtins.property
    def add_min_freeable_memory_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinFreeableMemoryThreshold]]:
        '''(experimental) Add alarm on amount of freeable memory.

        :stability: experimental
        '''
        result = self._values.get("add_min_freeable_memory_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinFreeableMemoryThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAlarmDedupeStringProcessor)
class ExtendDedupeString(
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.ExtendDedupeString",
):
    '''(experimental) Dedupe string processor that adds prefix and/or suffix to the dedupe string.

    :stability: experimental
    '''

    def __init__(
        self,
        prefix: typing.Optional[builtins.str] = None,
        suffix: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param prefix: -
        :param suffix: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExtendDedupeString.__init__)
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument suffix", value=suffix, expected_type=type_hints["suffix"])
        jsii.create(self.__class__, self, [prefix, suffix])

    @jsii.member(jsii_name="processDedupeString")
    def process_dedupe_string(self, dedupe_string: builtins.str) -> builtins.str:
        '''(experimental) Process the dedupe string which was auto-generated.

        :param dedupe_string: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExtendDedupeString.process_dedupe_string)
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
        return typing.cast(builtins.str, jsii.invoke(self, "processDedupeString", [dedupe_string]))

    @jsii.member(jsii_name="processDedupeStringOverride")
    def process_dedupe_string_override(
        self,
        dedupe_string: builtins.str,
    ) -> builtins.str:
        '''(experimental) Process the dedupe string which was specified by the user as an override.

        :param dedupe_string: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ExtendDedupeString.process_dedupe_string_override)
            check_type(argname="argument dedupe_string", value=dedupe_string, expected_type=type_hints["dedupe_string"])
        return typing.cast(builtins.str, jsii.invoke(self, "processDedupeStringOverride", [dedupe_string]))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.FargateApplicationLoadBalancerMonitoringProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerMetricFactoryProps,
        BaseMonitoringProps,
        BaseFargateServiceAlarms,
    ],
    name_mapping={
        "application_load_balancer": "applicationLoadBalancer",
        "application_target_group": "applicationTargetGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "fargate_service": "fargateService",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class FargateApplicationLoadBalancerMonitoringProps(
    ApplicationLoadBalancerMetricFactoryProps,
    BaseMonitoringProps,
    BaseFargateServiceAlarms,
):
    def __init__(
        self,
        *,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for Fargate service with application load balancer and plain service.

        :param application_load_balancer: 
        :param application_target_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateApplicationLoadBalancerMonitoringProps.__init__)
            check_type(argname="argument application_load_balancer", value=application_load_balancer, expected_type=type_hints["application_load_balancer"])
            check_type(argname="argument application_target_group", value=application_target_group, expected_type=type_hints["application_target_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "application_load_balancer": application_load_balancer,
            "application_target_group": application_target_group,
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def application_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_load_balancer")
        assert result is not None, "Required property 'application_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, result)

    @builtins.property
    def application_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("application_target_group")
        assert result is not None, "Required property 'application_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fargate_service(self) -> aws_cdk.aws_ecs.FargateService:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.FargateService, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FargateApplicationLoadBalancerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.FargateNetworkLoadBalancerMonitoringProps",
    jsii_struct_bases=[
        NetworkLoadBalancerMetricFactoryProps,
        BaseMonitoringProps,
        BaseFargateServiceAlarms,
    ],
    name_mapping={
        "network_load_balancer": "networkLoadBalancer",
        "network_target_group": "networkTargetGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "fargate_service": "fargateService",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class FargateNetworkLoadBalancerMonitoringProps(
    NetworkLoadBalancerMetricFactoryProps,
    BaseMonitoringProps,
    BaseFargateServiceAlarms,
):
    def __init__(
        self,
        *,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for Fargate service with network load balancer and plain service.

        :param network_load_balancer: 
        :param network_target_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateNetworkLoadBalancerMonitoringProps.__init__)
            check_type(argname="argument network_load_balancer", value=network_load_balancer, expected_type=type_hints["network_load_balancer"])
            check_type(argname="argument network_target_group", value=network_target_group, expected_type=type_hints["network_target_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "network_load_balancer": network_load_balancer,
            "network_target_group": network_target_group,
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def network_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_load_balancer")
        assert result is not None, "Required property 'network_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer, result)

    @builtins.property
    def network_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_target_group")
        assert result is not None, "Required property 'network_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fargate_service(self) -> aws_cdk.aws_ecs.FargateService:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.FargateService, result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FargateNetworkLoadBalancerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FargateServiceMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.FargateServiceMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        load_balancer: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer, aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer]] = None,
        target_group: typing.Optional[typing.Union[aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup, aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param load_balancer: 
        :param target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = CustomFargateServiceMonitoringProps(
            fargate_service=fargate_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            load_balancer=load_balancer,
            target_group=target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createCpuWidget")
    def create_cpu_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoring.create_cpu_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCpuWidget", [width, height]))

    @jsii.member(jsii_name="createMemoryWidget")
    def create_memory_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoring.create_memory_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createMemoryWidget", [width, height]))

    @jsii.member(jsii_name="createTaskHealthWidget")
    def create_task_health_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoring.create_task_health_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTaskHealthWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpcFlowsWidget")
    def create_tpc_flows_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoring.create_tpc_flows_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpcFlowsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="baseServiceMetricFactory")
    def base_service_metric_factory(self) -> BaseServiceMetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(BaseServiceMetricFactory, jsii.get(self, "baseServiceMetricFactory"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageAnnotations")
    def cpu_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "cpuUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="cpuUtilisationMetric")
    def cpu_utilisation_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUtilisationMetric"))

    @builtins.property
    @jsii.member(jsii_name="memoryUsageAnnotations")
    def memory_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "memoryUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="memoryUtilisationMetric")
    def memory_utilisation_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "memoryUtilisationMetric"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def metric_factory(self) -> MetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesAnnotations")
    def processed_bytes_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "processedBytesAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="runningTaskCountMetric")
    def running_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "runningTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAlarmFactory")
    def task_health_alarm_factory(self) -> TaskHealthAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TaskHealthAlarmFactory, jsii.get(self, "taskHealthAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAnnotations")
    def task_health_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "taskHealthAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="throughputAlarmFactory")
    def throughput_alarm_factory(self) -> ThroughputAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ThroughputAlarmFactory, jsii.get(self, "throughputAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> UsageAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(UsageAlarmFactory, jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="activeTcpFlowCountMetric")
    def active_tcp_flow_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "activeTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskCountMetric")
    def healthy_task_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "healthyTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="healthyTaskPercentMetric")
    def healthy_task_percent_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "healthyTaskPercentMetric"))

    @builtins.property
    @jsii.member(jsii_name="loadBalancerMetricFactory")
    def load_balancer_metric_factory(
        self,
    ) -> typing.Optional[ILoadBalancerMetricFactory]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[ILoadBalancerMetricFactory], jsii.get(self, "loadBalancerMetricFactory"))

    @builtins.property
    @jsii.member(jsii_name="newTcpFlowCountMetric")
    def new_tcp_flow_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "newTcpFlowCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="processedBytesMetric")
    def processed_bytes_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "processedBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="unhealthyTaskCountMetric")
    def unhealthy_task_count_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "unhealthyTaskCountMetric"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.FargateServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseFargateServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "fargate_service": "fargateService",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class FargateServiceMonitoringProps(BaseMonitoringProps, BaseFargateServiceAlarms):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        fargate_service: typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService],
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''(experimental) Monitoring props for load-balanced Fargate service.

        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(FargateServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fargate_service(
        self,
    ) -> typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService]:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService], result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "FargateServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(IAlarmAnnotationStrategy)
class FillingAlarmAnnotationStrategy(
    metaclass=jsii.JSIIAbstractClass,
    jsii_type="cdk-monitoring-constructs.FillingAlarmAnnotationStrategy",
):
    '''(experimental) Annotation strategy that fills the annotation provided, using the input and user requirements.

    :stability: experimental
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="createAnnotation")
    def create_annotation(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''(experimental) Creates annotation based on the metric and alarm properties.

        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, jsii.invoke(self, "createAnnotation", [props]))

    @jsii.member(jsii_name="createAnnotationToFill")
    @abc.abstractmethod
    def _create_annotation_to_fill(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        ...

    @jsii.member(jsii_name="getAlarmingRangeShade")
    def _get_alarming_range_shade(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Shading]:
        '''
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Shading], jsii.invoke(self, "getAlarmingRangeShade", [props]))


class _FillingAlarmAnnotationStrategyProxy(FillingAlarmAnnotationStrategy):
    @jsii.member(jsii_name="createAnnotationToFill")
    def _create_annotation_to_fill(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, jsii.invoke(self, "createAnnotationToFill", [props]))

# Adding a "__jsii_proxy_class__(): typing.Type" function to the abstract class
typing.cast(typing.Any, FillingAlarmAnnotationStrategy).__jsii_proxy_class__ = lambda : _FillingAlarmAnnotationStrategyProxy


class GlueJobMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.GlueJobMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        add_failed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        job_name: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param add_failed_task_count_alarm: 
        :param add_failed_task_rate_alarm: 
        :param add_killed_task_count_alarm: 
        :param add_killed_task_rate_alarm: 
        :param job_name: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = GlueJobMonitoringProps(
            add_failed_task_count_alarm=add_failed_task_count_alarm,
            add_failed_task_rate_alarm=add_failed_task_rate_alarm,
            add_killed_task_count_alarm=add_killed_task_count_alarm,
            add_killed_task_rate_alarm=add_killed_task_rate_alarm,
            job_name=job_name,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createDataMovementWidget")
    def create_data_movement_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.create_data_movement_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDataMovementWidget", [width, height]))

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createJobExecutionWidget")
    def create_job_execution_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.create_job_execution_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createJobExecutionWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createUtilizationWidget")
    def create_utilization_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoring.create_utilization_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createUtilizationWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="activeExecutorsMetric")
    def active_executors_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "activeExecutorsMetric"))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="bytesReadFromS3Metric")
    def bytes_read_from_s3_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "bytesReadFromS3Metric"))

    @builtins.property
    @jsii.member(jsii_name="bytesWrittenToS3Metric")
    def bytes_written_to_s3_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "bytesWrittenToS3Metric"))

    @builtins.property
    @jsii.member(jsii_name="completedStagesMetric")
    def completed_stages_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "completedStagesMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuUsageMetric")
    def cpu_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="failedTaskCountMetric")
    def failed_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="failedTaskRateMetric")
    def failed_task_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedTaskRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="heapMemoryUsageMetric")
    def heap_memory_usage_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "heapMemoryUsageMetric"))

    @builtins.property
    @jsii.member(jsii_name="killedTaskCountMetric")
    def killed_task_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "killedTaskCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="killedTaskRateMetric")
    def killed_task_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "killedTaskRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="neededExecutorsMetric")
    def needed_executors_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "neededExecutorsMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.GlueJobMonitoringOptions",
    jsii_struct_bases=[GlueJobMetricFactoryProps, BaseMonitoringProps],
    name_mapping={
        "job_name": "jobName",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_failed_task_count_alarm": "addFailedTaskCountAlarm",
        "add_failed_task_rate_alarm": "addFailedTaskRateAlarm",
        "add_killed_task_count_alarm": "addKilledTaskCountAlarm",
        "add_killed_task_rate_alarm": "addKilledTaskRateAlarm",
    },
)
class GlueJobMonitoringOptions(GlueJobMetricFactoryProps, BaseMonitoringProps):
    def __init__(
        self,
        *,
        job_name: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_failed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param job_name: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_failed_task_count_alarm: 
        :param add_failed_task_rate_alarm: 
        :param add_killed_task_count_alarm: 
        :param add_killed_task_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoringOptions.__init__)
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_failed_task_count_alarm", value=add_failed_task_count_alarm, expected_type=type_hints["add_failed_task_count_alarm"])
            check_type(argname="argument add_failed_task_rate_alarm", value=add_failed_task_rate_alarm, expected_type=type_hints["add_failed_task_rate_alarm"])
            check_type(argname="argument add_killed_task_count_alarm", value=add_killed_task_count_alarm, expected_type=type_hints["add_killed_task_count_alarm"])
            check_type(argname="argument add_killed_task_rate_alarm", value=add_killed_task_rate_alarm, expected_type=type_hints["add_killed_task_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "job_name": job_name,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_failed_task_count_alarm is not None:
            self._values["add_failed_task_count_alarm"] = add_failed_task_count_alarm
        if add_failed_task_rate_alarm is not None:
            self._values["add_failed_task_rate_alarm"] = add_failed_task_rate_alarm
        if add_killed_task_count_alarm is not None:
            self._values["add_killed_task_count_alarm"] = add_killed_task_count_alarm
        if add_killed_task_rate_alarm is not None:
            self._values["add_killed_task_rate_alarm"] = add_killed_task_rate_alarm

    @builtins.property
    def job_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("job_name")
        assert result is not None, "Required property 'job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_failed_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_task_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_task_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_killed_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_killed_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_killed_task_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_killed_task_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GlueJobMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.GlueJobMonitoringProps",
    jsii_struct_bases=[GlueJobMonitoringOptions],
    name_mapping={
        "job_name": "jobName",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_failed_task_count_alarm": "addFailedTaskCountAlarm",
        "add_failed_task_rate_alarm": "addFailedTaskRateAlarm",
        "add_killed_task_count_alarm": "addKilledTaskCountAlarm",
        "add_killed_task_rate_alarm": "addKilledTaskRateAlarm",
    },
)
class GlueJobMonitoringProps(GlueJobMonitoringOptions):
    def __init__(
        self,
        *,
        job_name: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_failed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param job_name: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_failed_task_count_alarm: 
        :param add_failed_task_rate_alarm: 
        :param add_killed_task_count_alarm: 
        :param add_killed_task_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(GlueJobMonitoringProps.__init__)
            check_type(argname="argument job_name", value=job_name, expected_type=type_hints["job_name"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_failed_task_count_alarm", value=add_failed_task_count_alarm, expected_type=type_hints["add_failed_task_count_alarm"])
            check_type(argname="argument add_failed_task_rate_alarm", value=add_failed_task_rate_alarm, expected_type=type_hints["add_failed_task_rate_alarm"])
            check_type(argname="argument add_killed_task_count_alarm", value=add_killed_task_count_alarm, expected_type=type_hints["add_killed_task_count_alarm"])
            check_type(argname="argument add_killed_task_rate_alarm", value=add_killed_task_rate_alarm, expected_type=type_hints["add_killed_task_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "job_name": job_name,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_failed_task_count_alarm is not None:
            self._values["add_failed_task_count_alarm"] = add_failed_task_count_alarm
        if add_failed_task_rate_alarm is not None:
            self._values["add_failed_task_rate_alarm"] = add_failed_task_rate_alarm
        if add_killed_task_count_alarm is not None:
            self._values["add_killed_task_count_alarm"] = add_killed_task_count_alarm
        if add_killed_task_rate_alarm is not None:
            self._values["add_killed_task_rate_alarm"] = add_killed_task_rate_alarm

    @builtins.property
    def job_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("job_name")
        assert result is not None, "Required property 'job_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_failed_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_task_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_task_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_killed_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_killed_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_killed_task_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_killed_task_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "GlueJobMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class KinesisDataAnalyticsMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        application: builtins.str,
        add_downtime_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxDowntimeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_full_restart_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[FullRestartCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param application: 
        :param add_downtime_alarm: 
        :param add_full_restart_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = KinesisDataAnalyticsMonitoringProps(
            application=application,
            add_downtime_alarm=add_downtime_alarm,
            add_full_restart_count_alarm=add_full_restart_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createDownTimeWidget")
    def create_down_time_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_down_time_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createDownTimeWidget", [width, height]))

    @jsii.member(jsii_name="createFullRestartsWidget")
    def create_full_restarts_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_full_restarts_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createFullRestartsWidget", [width, height]))

    @jsii.member(jsii_name="createGarbageCollectionWidget")
    def create_garbage_collection_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_garbage_collection_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createGarbageCollectionWidget", [width, height]))

    @jsii.member(jsii_name="createKPUWidget")
    def create_kpu_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_kpu_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createKPUWidget", [width, height]))

    @jsii.member(jsii_name="createLastCheckpointDurationWidget")
    def create_last_checkpoint_duration_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_last_checkpoint_duration_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLastCheckpointDurationWidget", [width, height]))

    @jsii.member(jsii_name="createLastCheckpointSizeWidget")
    def create_last_checkpoint_size_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_last_checkpoint_size_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLastCheckpointSizeWidget", [width, height]))

    @jsii.member(jsii_name="createNumberOfFailedCheckpointsWidget")
    def create_number_of_failed_checkpoints_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_number_of_failed_checkpoints_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createNumberOfFailedCheckpointsWidget", [width, height]))

    @jsii.member(jsii_name="createResourceUtilizationWidget")
    def create_resource_utilization_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoring.create_resource_utilization_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createResourceUtilizationWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="cpuUtilizationPercentMetric")
    def cpu_utilization_percent_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "cpuUtilizationPercentMetric"))

    @builtins.property
    @jsii.member(jsii_name="downtimeAnnotations")
    def downtime_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "downtimeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="downtimeMsMetric")
    def downtime_ms_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "downtimeMsMetric"))

    @builtins.property
    @jsii.member(jsii_name="fullRestartAnnotations")
    def full_restart_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "fullRestartAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="fullRestartsCountMetric")
    def full_restarts_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "fullRestartsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="heapMemoryUtilizationPercentMetric")
    def heap_memory_utilization_percent_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "heapMemoryUtilizationPercentMetric"))

    @builtins.property
    @jsii.member(jsii_name="kdaAlarmFactory")
    def kda_alarm_factory(self) -> KinesisDataAnalyticsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(KinesisDataAnalyticsAlarmFactory, jsii.get(self, "kdaAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="kpusCountMetric")
    def kpus_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "kpusCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="lastCheckpointDurationMsMetric")
    def last_checkpoint_duration_ms_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "lastCheckpointDurationMsMetric"))

    @builtins.property
    @jsii.member(jsii_name="lastCheckpointSizeBytesMetric")
    def last_checkpoint_size_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "lastCheckpointSizeBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="numberOfFailedCheckpointsCountMetric")
    def number_of_failed_checkpoints_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "numberOfFailedCheckpointsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="oldGenerationGCCountMetric")
    def old_generation_gc_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "oldGenerationGCCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="oldGenerationGCTimeMsMetric")
    def old_generation_gc_time_ms_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "oldGenerationGCTimeMsMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="kinesisDataAnalyticsUrl")
    def kinesis_data_analytics_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "kinesisDataAnalyticsUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_downtime_alarm": "addDowntimeAlarm",
        "add_full_restart_count_alarm": "addFullRestartCountAlarm",
    },
)
class KinesisDataAnalyticsMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_downtime_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxDowntimeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_full_restart_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[FullRestartCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_downtime_alarm: 
        :param add_full_restart_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_downtime_alarm", value=add_downtime_alarm, expected_type=type_hints["add_downtime_alarm"])
            check_type(argname="argument add_full_restart_count_alarm", value=add_full_restart_count_alarm, expected_type=type_hints["add_full_restart_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_downtime_alarm is not None:
            self._values["add_downtime_alarm"] = add_downtime_alarm
        if add_full_restart_count_alarm is not None:
            self._values["add_full_restart_count_alarm"] = add_full_restart_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_downtime_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxDowntimeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_downtime_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxDowntimeThreshold]], result)

    @builtins.property
    def add_full_restart_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, FullRestartCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_full_restart_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, FullRestartCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataAnalyticsMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataAnalyticsMonitoringProps",
    jsii_struct_bases=[
        KinesisDataAnalyticsMetricFactoryProps, KinesisDataAnalyticsMonitoringOptions
    ],
    name_mapping={
        "application": "application",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_downtime_alarm": "addDowntimeAlarm",
        "add_full_restart_count_alarm": "addFullRestartCountAlarm",
    },
)
class KinesisDataAnalyticsMonitoringProps(
    KinesisDataAnalyticsMetricFactoryProps,
    KinesisDataAnalyticsMonitoringOptions,
):
    def __init__(
        self,
        *,
        application: builtins.str,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_downtime_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxDowntimeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_full_restart_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[FullRestartCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param application: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_downtime_alarm: 
        :param add_full_restart_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataAnalyticsMonitoringProps.__init__)
            check_type(argname="argument application", value=application, expected_type=type_hints["application"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_downtime_alarm", value=add_downtime_alarm, expected_type=type_hints["add_downtime_alarm"])
            check_type(argname="argument add_full_restart_count_alarm", value=add_full_restart_count_alarm, expected_type=type_hints["add_full_restart_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "application": application,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_downtime_alarm is not None:
            self._values["add_downtime_alarm"] = add_downtime_alarm
        if add_full_restart_count_alarm is not None:
            self._values["add_full_restart_count_alarm"] = add_full_restart_count_alarm

    @builtins.property
    def application(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("application")
        assert result is not None, "Required property 'application' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_downtime_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxDowntimeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_downtime_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxDowntimeThreshold]], result)

    @builtins.property
    def add_full_restart_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, FullRestartCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_full_restart_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, FullRestartCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataAnalyticsMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class KinesisDataStreamMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisDataStreamMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        stream_name: builtins.str,
        add_iterator_max_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIteratorAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_records_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param stream_name: 
        :param add_iterator_max_age_alarm: 
        :param add_put_records_failed_alarm: 
        :param add_put_records_throttled_alarm: 
        :param add_read_provisioned_throughput_exceeded_alarm: 
        :param add_throttled_records_alarm: 
        :param add_write_provisioned_throughput_exceeded_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = KinesisDataStreamMonitoringProps(
            stream_name=stream_name,
            add_iterator_max_age_alarm=add_iterator_max_age_alarm,
            add_put_records_failed_alarm=add_put_records_failed_alarm,
            add_put_records_throttled_alarm=add_put_records_throttled_alarm,
            add_read_provisioned_throughput_exceeded_alarm=add_read_provisioned_throughput_exceeded_alarm,
            add_throttled_records_alarm=add_throttled_records_alarm,
            add_write_provisioned_throughput_exceeded_alarm=add_write_provisioned_throughput_exceeded_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createCapacityWidget")
    def create_capacity_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_capacity_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createCapacityWidget", [width, height]))

    @jsii.member(jsii_name="createIncomingDataWidget")
    def create_incoming_data_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_incoming_data_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createIncomingDataWidget", [width, height]))

    @jsii.member(jsii_name="createIteratorAgeWidget")
    def create_iterator_age_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_iterator_age_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createIteratorAgeWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createOperationWidget")
    def create_operation_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_operation_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createOperationWidget", [width, height]))

    @jsii.member(jsii_name="createRecordNumberWidget")
    def create_record_number_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_record_number_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createRecordNumberWidget", [width, height]))

    @jsii.member(jsii_name="createRecordSizeWidget")
    def create_record_size_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoring.create_record_size_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createRecordSizeWidget", [width, height]))

    @jsii.member(jsii_name="createSecondAdditionalRow")
    def create_second_additional_row(self) -> aws_cdk.aws_cloudwatch.Row:
        '''
        :stability: experimental
        '''
        return typing.cast(aws_cdk.aws_cloudwatch.Row, jsii.invoke(self, "createSecondAdditionalRow", []))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="ageAnnotations")
    def age_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "ageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="incomingDataSumBytesMetric")
    def incoming_data_sum_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingDataSumBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="incomingDataSumCountMetric")
    def incoming_data_sum_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingDataSumCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="kinesisAlarmFactory")
    def kinesis_alarm_factory(self) -> KinesisAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(KinesisAlarmFactory, jsii.get(self, "kinesisAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="metricGetRecordsIteratorAge")
    def metric_get_records_iterator_age(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "metricGetRecordsIteratorAge"))

    @builtins.property
    @jsii.member(jsii_name="metricGetRecordsLatencyAverage")
    def metric_get_records_latency_average(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "metricGetRecordsLatencyAverage"))

    @builtins.property
    @jsii.member(jsii_name="metricGetRecordsSuccessCount")
    def metric_get_records_success_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "metricGetRecordsSuccessCount"))

    @builtins.property
    @jsii.member(jsii_name="metricGetRecordsSumCount")
    def metric_get_records_sum_count(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "metricGetRecordsSumCount"))

    @builtins.property
    @jsii.member(jsii_name="metricGetRecordSumBytes")
    def metric_get_record_sum_bytes(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "metricGetRecordSumBytes"))

    @builtins.property
    @jsii.member(jsii_name="provisionedCapacityAnnotations")
    def provisioned_capacity_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "provisionedCapacityAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="putRecordLatencyAverageMetric")
    def put_record_latency_average_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordLatencyAverageMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsFailedRecordsCountMetric")
    def put_records_failed_records_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsFailedRecordsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsLatencyAverageMetric")
    def put_records_latency_average_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsLatencyAverageMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsSuccessCountMetric")
    def put_records_success_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsSuccessCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsSuccessfulRecordsCountMetric")
    def put_records_successful_records_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsSuccessfulRecordsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsSumBytesMetric")
    def put_records_sum_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsSumBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsThrottledRecordsCountMetric")
    def put_records_throttled_records_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsThrottledRecordsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordsTotalRecordsCountMetric")
    def put_records_total_records_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordsTotalRecordsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordSuccessCountMetric")
    def put_record_success_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordSuccessCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="putRecordSumBytesMetric")
    def put_record_sum_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordSumBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="readProvisionedThroughputExceededMetric")
    def read_provisioned_throughput_exceeded_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "readProvisionedThroughputExceededMetric"))

    @builtins.property
    @jsii.member(jsii_name="recordCountAnnotations")
    def record_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "recordCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="writeProvisionedThroughputExceededMetric")
    def write_provisioned_throughput_exceeded_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "writeProvisionedThroughputExceededMetric"))

    @builtins.property
    @jsii.member(jsii_name="streamUrl")
    def stream_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "streamUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataStreamMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_iterator_max_age_alarm": "addIteratorMaxAgeAlarm",
        "add_put_records_failed_alarm": "addPutRecordsFailedAlarm",
        "add_put_records_throttled_alarm": "addPutRecordsThrottledAlarm",
        "add_read_provisioned_throughput_exceeded_alarm": "addReadProvisionedThroughputExceededAlarm",
        "add_throttled_records_alarm": "addThrottledRecordsAlarm",
        "add_write_provisioned_throughput_exceeded_alarm": "addWriteProvisionedThroughputExceededAlarm",
    },
)
class KinesisDataStreamMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_iterator_max_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIteratorAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_records_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_iterator_max_age_alarm: 
        :param add_put_records_failed_alarm: 
        :param add_put_records_throttled_alarm: 
        :param add_read_provisioned_throughput_exceeded_alarm: 
        :param add_throttled_records_alarm: 
        :param add_write_provisioned_throughput_exceeded_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_iterator_max_age_alarm", value=add_iterator_max_age_alarm, expected_type=type_hints["add_iterator_max_age_alarm"])
            check_type(argname="argument add_put_records_failed_alarm", value=add_put_records_failed_alarm, expected_type=type_hints["add_put_records_failed_alarm"])
            check_type(argname="argument add_put_records_throttled_alarm", value=add_put_records_throttled_alarm, expected_type=type_hints["add_put_records_throttled_alarm"])
            check_type(argname="argument add_read_provisioned_throughput_exceeded_alarm", value=add_read_provisioned_throughput_exceeded_alarm, expected_type=type_hints["add_read_provisioned_throughput_exceeded_alarm"])
            check_type(argname="argument add_throttled_records_alarm", value=add_throttled_records_alarm, expected_type=type_hints["add_throttled_records_alarm"])
            check_type(argname="argument add_write_provisioned_throughput_exceeded_alarm", value=add_write_provisioned_throughput_exceeded_alarm, expected_type=type_hints["add_write_provisioned_throughput_exceeded_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_iterator_max_age_alarm is not None:
            self._values["add_iterator_max_age_alarm"] = add_iterator_max_age_alarm
        if add_put_records_failed_alarm is not None:
            self._values["add_put_records_failed_alarm"] = add_put_records_failed_alarm
        if add_put_records_throttled_alarm is not None:
            self._values["add_put_records_throttled_alarm"] = add_put_records_throttled_alarm
        if add_read_provisioned_throughput_exceeded_alarm is not None:
            self._values["add_read_provisioned_throughput_exceeded_alarm"] = add_read_provisioned_throughput_exceeded_alarm
        if add_throttled_records_alarm is not None:
            self._values["add_throttled_records_alarm"] = add_throttled_records_alarm
        if add_write_provisioned_throughput_exceeded_alarm is not None:
            self._values["add_write_provisioned_throughput_exceeded_alarm"] = add_write_provisioned_throughput_exceeded_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_iterator_max_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIteratorAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_iterator_max_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIteratorAgeThreshold]], result)

    @builtins.property
    def add_put_records_failed_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsFailedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_put_records_failed_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsFailedThreshold]], result)

    @builtins.property
    def add_put_records_throttled_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_put_records_throttled_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_read_provisioned_throughput_exceeded_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_read_provisioned_throughput_exceeded_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_throttled_records_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttled_records_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_write_provisioned_throughput_exceeded_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_write_provisioned_throughput_exceeded_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataStreamMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisDataStreamMonitoringProps",
    jsii_struct_bases=[
        KinesisDataStreamMetricFactoryProps, KinesisDataStreamMonitoringOptions
    ],
    name_mapping={
        "stream_name": "streamName",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_iterator_max_age_alarm": "addIteratorMaxAgeAlarm",
        "add_put_records_failed_alarm": "addPutRecordsFailedAlarm",
        "add_put_records_throttled_alarm": "addPutRecordsThrottledAlarm",
        "add_read_provisioned_throughput_exceeded_alarm": "addReadProvisionedThroughputExceededAlarm",
        "add_throttled_records_alarm": "addThrottledRecordsAlarm",
        "add_write_provisioned_throughput_exceeded_alarm": "addWriteProvisionedThroughputExceededAlarm",
    },
)
class KinesisDataStreamMonitoringProps(
    KinesisDataStreamMetricFactoryProps,
    KinesisDataStreamMonitoringOptions,
):
    def __init__(
        self,
        *,
        stream_name: builtins.str,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_iterator_max_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIteratorAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_records_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param stream_name: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_iterator_max_age_alarm: 
        :param add_put_records_failed_alarm: 
        :param add_put_records_throttled_alarm: 
        :param add_read_provisioned_throughput_exceeded_alarm: 
        :param add_throttled_records_alarm: 
        :param add_write_provisioned_throughput_exceeded_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisDataStreamMonitoringProps.__init__)
            check_type(argname="argument stream_name", value=stream_name, expected_type=type_hints["stream_name"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_iterator_max_age_alarm", value=add_iterator_max_age_alarm, expected_type=type_hints["add_iterator_max_age_alarm"])
            check_type(argname="argument add_put_records_failed_alarm", value=add_put_records_failed_alarm, expected_type=type_hints["add_put_records_failed_alarm"])
            check_type(argname="argument add_put_records_throttled_alarm", value=add_put_records_throttled_alarm, expected_type=type_hints["add_put_records_throttled_alarm"])
            check_type(argname="argument add_read_provisioned_throughput_exceeded_alarm", value=add_read_provisioned_throughput_exceeded_alarm, expected_type=type_hints["add_read_provisioned_throughput_exceeded_alarm"])
            check_type(argname="argument add_throttled_records_alarm", value=add_throttled_records_alarm, expected_type=type_hints["add_throttled_records_alarm"])
            check_type(argname="argument add_write_provisioned_throughput_exceeded_alarm", value=add_write_provisioned_throughput_exceeded_alarm, expected_type=type_hints["add_write_provisioned_throughput_exceeded_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "stream_name": stream_name,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_iterator_max_age_alarm is not None:
            self._values["add_iterator_max_age_alarm"] = add_iterator_max_age_alarm
        if add_put_records_failed_alarm is not None:
            self._values["add_put_records_failed_alarm"] = add_put_records_failed_alarm
        if add_put_records_throttled_alarm is not None:
            self._values["add_put_records_throttled_alarm"] = add_put_records_throttled_alarm
        if add_read_provisioned_throughput_exceeded_alarm is not None:
            self._values["add_read_provisioned_throughput_exceeded_alarm"] = add_read_provisioned_throughput_exceeded_alarm
        if add_throttled_records_alarm is not None:
            self._values["add_throttled_records_alarm"] = add_throttled_records_alarm
        if add_write_provisioned_throughput_exceeded_alarm is not None:
            self._values["add_write_provisioned_throughput_exceeded_alarm"] = add_write_provisioned_throughput_exceeded_alarm

    @builtins.property
    def stream_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("stream_name")
        assert result is not None, "Required property 'stream_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_iterator_max_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIteratorAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_iterator_max_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIteratorAgeThreshold]], result)

    @builtins.property
    def add_put_records_failed_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsFailedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_put_records_failed_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsFailedThreshold]], result)

    @builtins.property
    def add_put_records_throttled_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_put_records_throttled_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_read_provisioned_throughput_exceeded_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_read_provisioned_throughput_exceeded_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_throttled_records_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttled_records_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    @builtins.property
    def add_write_provisioned_throughput_exceeded_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_write_provisioned_throughput_exceeded_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisDataStreamMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class KinesisFirehoseMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.KinesisFirehoseMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        delivery_stream_name: builtins.str,
        add_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param delivery_stream_name: 
        :param add_records_throttled_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = KinesisFirehoseMonitoringProps(
            delivery_stream_name=delivery_stream_name,
            add_records_throttled_alarm=add_records_throttled_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createConversionWidget")
    def create_conversion_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoring.create_conversion_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createConversionWidget", [width, height]))

    @jsii.member(jsii_name="createIncomingRecordWidget")
    def create_incoming_record_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoring.create_incoming_record_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createIncomingRecordWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createLimitWidget")
    def create_limit_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoring.create_limit_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLimitWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="failedConversionMetric")
    def failed_conversion_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "failedConversionMetric"))

    @builtins.property
    @jsii.member(jsii_name="incomingBytesMetric")
    def incoming_bytes_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingBytesMetric"))

    @builtins.property
    @jsii.member(jsii_name="incomingBytesToLimitRate")
    def incoming_bytes_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingBytesToLimitRate"))

    @builtins.property
    @jsii.member(jsii_name="incomingPutRequestsToLimitRate")
    def incoming_put_requests_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingPutRequestsToLimitRate"))

    @builtins.property
    @jsii.member(jsii_name="incomingRecordsMetric")
    def incoming_records_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingRecordsMetric"))

    @builtins.property
    @jsii.member(jsii_name="incomingRecordsToLimitRate")
    def incoming_records_to_limit_rate(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "incomingRecordsToLimitRate"))

    @builtins.property
    @jsii.member(jsii_name="kinesisAlarmFactory")
    def kinesis_alarm_factory(self) -> KinesisAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(KinesisAlarmFactory, jsii.get(self, "kinesisAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="putRecordBatchLatency")
    def put_record_batch_latency(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordBatchLatency"))

    @builtins.property
    @jsii.member(jsii_name="putRecordLatency")
    def put_record_latency(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "putRecordLatency"))

    @builtins.property
    @jsii.member(jsii_name="recordCountAnnotations")
    def record_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "recordCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="successfulConversionMetric")
    def successful_conversion_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "successfulConversionMetric"))

    @builtins.property
    @jsii.member(jsii_name="throttledRecordsMetric")
    def throttled_records_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "throttledRecordsMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="streamUrl")
    def stream_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "streamUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisFirehoseMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_records_throttled_alarm": "addRecordsThrottledAlarm",
    },
)
class KinesisFirehoseMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_records_throttled_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_records_throttled_alarm", value=add_records_throttled_alarm, expected_type=type_hints["add_records_throttled_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_records_throttled_alarm is not None:
            self._values["add_records_throttled_alarm"] = add_records_throttled_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_records_throttled_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_records_throttled_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisFirehoseMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.KinesisFirehoseMonitoringProps",
    jsii_struct_bases=[
        KinesisFirehoseMetricFactoryProps, KinesisFirehoseMonitoringOptions
    ],
    name_mapping={
        "delivery_stream_name": "deliveryStreamName",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_records_throttled_alarm": "addRecordsThrottledAlarm",
    },
)
class KinesisFirehoseMonitoringProps(
    KinesisFirehoseMetricFactoryProps,
    KinesisFirehoseMonitoringOptions,
):
    def __init__(
        self,
        *,
        delivery_stream_name: builtins.str,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param delivery_stream_name: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_records_throttled_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(KinesisFirehoseMonitoringProps.__init__)
            check_type(argname="argument delivery_stream_name", value=delivery_stream_name, expected_type=type_hints["delivery_stream_name"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_records_throttled_alarm", value=add_records_throttled_alarm, expected_type=type_hints["add_records_throttled_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "delivery_stream_name": delivery_stream_name,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_records_throttled_alarm is not None:
            self._values["add_records_throttled_alarm"] = add_records_throttled_alarm

    @builtins.property
    def delivery_stream_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("delivery_stream_name")
        assert result is not None, "Required property 'delivery_stream_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_records_throttled_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_records_throttled_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RecordsThrottledThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "KinesisFirehoseMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaFunctionMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LambdaFunctionMonitoring",
):
    '''
    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        lambda_insights_enabled: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_concurrent_executions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_iterator_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinUsageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param lambda_function: 
        :param fill_tps_with_zeroes: Default: - true
        :param lambda_insights_enabled: (experimental) Generate dashboard charts for Lambda Insights metrics. To enable Lambda Insights on your Lambda function, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html Default: - false
        :param rate_computation_method: Default: - average
        :param add_concurrent_executions_count_alarm: 
        :param add_enhanced_monitoring_avg_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_avg_memory_utilization_alarm: 
        :param add_enhanced_monitoring_max_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_max_memory_utilization_alarm: 
        :param add_enhanced_monitoring_p90_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_p90_memory_utilization_alarm: 
        :param add_fault_count_alarm: 
        :param add_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param add_max_iterator_age_alarm: 
        :param add_min_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_rate_alarm: 
        :param add_throttles_count_alarm: 
        :param add_throttles_rate_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = LambdaFunctionMonitoringProps(
            lambda_function=lambda_function,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            lambda_insights_enabled=lambda_insights_enabled,
            rate_computation_method=rate_computation_method,
            add_concurrent_executions_count_alarm=add_concurrent_executions_count_alarm,
            add_enhanced_monitoring_avg_cpu_total_time_alarm=add_enhanced_monitoring_avg_cpu_total_time_alarm,
            add_enhanced_monitoring_avg_memory_utilization_alarm=add_enhanced_monitoring_avg_memory_utilization_alarm,
            add_enhanced_monitoring_max_cpu_total_time_alarm=add_enhanced_monitoring_max_cpu_total_time_alarm,
            add_enhanced_monitoring_max_memory_utilization_alarm=add_enhanced_monitoring_max_memory_utilization_alarm,
            add_enhanced_monitoring_p90_cpu_total_time_alarm=add_enhanced_monitoring_p90_cpu_total_time_alarm,
            add_enhanced_monitoring_p90_memory_utilization_alarm=add_enhanced_monitoring_p90_memory_utilization_alarm,
            add_fault_count_alarm=add_fault_count_alarm,
            add_fault_rate_alarm=add_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            add_max_iterator_age_alarm=add_max_iterator_age_alarm,
            add_min_invocations_count_alarm=add_min_invocations_count_alarm,
            add_provisioned_concurrency_spillover_invocations_count_alarm=add_provisioned_concurrency_spillover_invocations_count_alarm,
            add_provisioned_concurrency_spillover_invocations_rate_alarm=add_provisioned_concurrency_spillover_invocations_rate_alarm,
            add_throttles_count_alarm=add_throttles_count_alarm,
            add_throttles_rate_alarm=add_throttles_rate_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="createErrorCountWidget")
    def create_error_count_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_error_count_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorCountWidget", [width, height]))

    @jsii.member(jsii_name="createErrorRateWidget")
    def create_error_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_error_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createErrorRateWidget", [width, height]))

    @jsii.member(jsii_name="createInvocationWidget")
    def create_invocation_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_invocation_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createInvocationWidget", [width, height]))

    @jsii.member(jsii_name="createIteratorAgeWidget")
    def create_iterator_age_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_iterator_age_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createIteratorAgeWidget", [width, height]))

    @jsii.member(jsii_name="createLambdaInsightsCpuWidget")
    def create_lambda_insights_cpu_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_lambda_insights_cpu_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLambdaInsightsCpuWidget", [width, height]))

    @jsii.member(jsii_name="createLambdaInsightsFunctionCostWidget")
    def create_lambda_insights_function_cost_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_lambda_insights_function_cost_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLambdaInsightsFunctionCostWidget", [width, height]))

    @jsii.member(jsii_name="createLambdaInsightsMemoryWidget")
    def create_lambda_insights_memory_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_lambda_insights_memory_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLambdaInsightsMemoryWidget", [width, height]))

    @jsii.member(jsii_name="createLatencyWidget")
    def create_latency_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_latency_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createLatencyWidget", [width, height]))

    @jsii.member(jsii_name="createRateWidget")
    def create_rate_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_rate_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createRateWidget", [width, height]))

    @jsii.member(jsii_name="createTitleWidget")
    def create_title_widget(self) -> MonitoringHeaderWidget:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringHeaderWidget, jsii.invoke(self, "createTitleWidget", []))

    @jsii.member(jsii_name="createTpsWidget")
    def create_tps_widget(
        self,
        width: jsii.Number,
        height: jsii.Number,
    ) -> aws_cdk.aws_cloudwatch.GraphWidget:
        '''
        :param width: -
        :param height: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoring.create_tps_widget)
            check_type(argname="argument width", value=width, expected_type=type_hints["width"])
            check_type(argname="argument height", value=height, expected_type=type_hints["height"])
        return typing.cast(aws_cdk.aws_cloudwatch.GraphWidget, jsii.invoke(self, "createTpsWidget", [width, height]))

    @jsii.member(jsii_name="summaryWidgets")
    def summary_widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the summary dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "summaryWidgets", []))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="ageAlarmFactory")
    def age_alarm_factory(self) -> AgeAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AgeAlarmFactory, jsii.get(self, "ageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="alarmFactory")
    def alarm_factory(self) -> AlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactory, jsii.get(self, "alarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="concurrentExecutionsCountMetric")
    def concurrent_executions_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "concurrentExecutionsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="cpuTotalTimeAnnotations")
    def cpu_total_time_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "cpuTotalTimeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorAlarmFactory")
    def error_alarm_factory(self) -> ErrorAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(ErrorAlarmFactory, jsii.get(self, "errorAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="errorCountAnnotations")
    def error_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="errorRateAnnotations")
    def error_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "errorRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="faultCountMetric")
    def fault_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "faultCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="faultRateMetric")
    def fault_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "faultRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="invocationCountAnnotations")
    def invocation_count_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "invocationCountAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="invocationCountMetric")
    def invocation_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "invocationCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="invocationRateAnnotations")
    def invocation_rate_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "invocationRateAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="lambdaInsightsEnabled")
    def lambda_insights_enabled(self) -> builtins.bool:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.bool, jsii.get(self, "lambdaInsightsEnabled"))

    @builtins.property
    @jsii.member(jsii_name="latencyAlarmFactory")
    def latency_alarm_factory(self) -> LatencyAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LatencyAlarmFactory, jsii.get(self, "latencyAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="latencyAnnotations")
    def latency_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "latencyAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="maxIteratorAgeAnnotations")
    def max_iterator_age_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "maxIteratorAgeAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="maxIteratorAgeMetric")
    def max_iterator_age_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "maxIteratorAgeMetric"))

    @builtins.property
    @jsii.member(jsii_name="memoryUsageAnnotations")
    def memory_usage_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "memoryUsageAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="metricFactory")
    def metric_factory(self) -> LambdaFunctionMetricFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(LambdaFunctionMetricFactory, jsii.get(self, "metricFactory"))

    @builtins.property
    @jsii.member(jsii_name="namingStrategy")
    def naming_strategy(self) -> MonitoringNamingStrategy:
        '''
        :stability: experimental
        '''
        return typing.cast(MonitoringNamingStrategy, jsii.get(self, "namingStrategy"))

    @builtins.property
    @jsii.member(jsii_name="p50LatencyMetric")
    def p50_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p50LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p90LatencyMetric")
    def p90_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p90LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="p99LatencyMetric")
    def p99_latency_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "p99LatencyMetric"))

    @builtins.property
    @jsii.member(jsii_name="provisionedConcurrencySpilloverInvocationsCountMetric")
    def provisioned_concurrency_spillover_invocations_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedConcurrencySpilloverInvocationsCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="provisionedConcurrencySpilloverInvocationsRateMetric")
    def provisioned_concurrency_spillover_invocations_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "provisionedConcurrencySpilloverInvocationsRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="taskHealthAlarmFactory")
    def task_health_alarm_factory(self) -> TaskHealthAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TaskHealthAlarmFactory, jsii.get(self, "taskHealthAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="throttlesCountMetric")
    def throttles_count_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "throttlesCountMetric"))

    @builtins.property
    @jsii.member(jsii_name="throttlesRateMetric")
    def throttles_rate_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "throttlesRateMetric"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "title"))

    @builtins.property
    @jsii.member(jsii_name="tpsAlarmFactory")
    def tps_alarm_factory(self) -> TpsAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(TpsAlarmFactory, jsii.get(self, "tpsAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="tpsAnnotations")
    def tps_annotations(
        self,
    ) -> typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.HorizontalAnnotation], jsii.get(self, "tpsAnnotations"))

    @builtins.property
    @jsii.member(jsii_name="tpsMetric")
    def tps_metric(
        self,
    ) -> typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression], jsii.get(self, "tpsMetric"))

    @builtins.property
    @jsii.member(jsii_name="usageAlarmFactory")
    def usage_alarm_factory(self) -> UsageAlarmFactory:
        '''
        :stability: experimental
        '''
        return typing.cast(UsageAlarmFactory, jsii.get(self, "usageAlarmFactory"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMetricFactory")
    def enhanced_metric_factory(
        self,
    ) -> typing.Optional[LambdaFunctionEnhancedMetricFactory]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[LambdaFunctionEnhancedMetricFactory], jsii.get(self, "enhancedMetricFactory"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMetricFunctionCostMetric")
    def enhanced_metric_function_cost_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMetricFunctionCostMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringAvgCpuTotalTimeMetric")
    def enhanced_monitoring_avg_cpu_total_time_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringAvgCpuTotalTimeMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringAvgMemoryUtilizationMetric")
    def enhanced_monitoring_avg_memory_utilization_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringAvgMemoryUtilizationMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringMaxCpuTotalTimeMetric")
    def enhanced_monitoring_max_cpu_total_time_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringMaxCpuTotalTimeMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringMaxMemoryUtilizationMetric")
    def enhanced_monitoring_max_memory_utilization_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringMaxMemoryUtilizationMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringP90CpuTotalTimeMetric")
    def enhanced_monitoring_p90_cpu_total_time_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringP90CpuTotalTimeMetric"))

    @builtins.property
    @jsii.member(jsii_name="enhancedMonitoringP90MemoryUtilizationMetric")
    def enhanced_monitoring_p90_memory_utilization_metric(
        self,
    ) -> typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression]], jsii.get(self, "enhancedMonitoringP90MemoryUtilizationMetric"))

    @builtins.property
    @jsii.member(jsii_name="functionUrl")
    def function_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "functionUrl"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LambdaFunctionMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_concurrent_executions_count_alarm": "addConcurrentExecutionsCountAlarm",
        "add_enhanced_monitoring_avg_cpu_total_time_alarm": "addEnhancedMonitoringAvgCpuTotalTimeAlarm",
        "add_enhanced_monitoring_avg_memory_utilization_alarm": "addEnhancedMonitoringAvgMemoryUtilizationAlarm",
        "add_enhanced_monitoring_max_cpu_total_time_alarm": "addEnhancedMonitoringMaxCpuTotalTimeAlarm",
        "add_enhanced_monitoring_max_memory_utilization_alarm": "addEnhancedMonitoringMaxMemoryUtilizationAlarm",
        "add_enhanced_monitoring_p90_cpu_total_time_alarm": "addEnhancedMonitoringP90CpuTotalTimeAlarm",
        "add_enhanced_monitoring_p90_memory_utilization_alarm": "addEnhancedMonitoringP90MemoryUtilizationAlarm",
        "add_fault_count_alarm": "addFaultCountAlarm",
        "add_fault_rate_alarm": "addFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "add_max_iterator_age_alarm": "addMaxIteratorAgeAlarm",
        "add_min_invocations_count_alarm": "addMinInvocationsCountAlarm",
        "add_provisioned_concurrency_spillover_invocations_count_alarm": "addProvisionedConcurrencySpilloverInvocationsCountAlarm",
        "add_provisioned_concurrency_spillover_invocations_rate_alarm": "addProvisionedConcurrencySpilloverInvocationsRateAlarm",
        "add_throttles_count_alarm": "addThrottlesCountAlarm",
        "add_throttles_rate_alarm": "addThrottlesRateAlarm",
    },
)
class LambdaFunctionMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_concurrent_executions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_iterator_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinUsageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_concurrent_executions_count_alarm: 
        :param add_enhanced_monitoring_avg_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_avg_memory_utilization_alarm: 
        :param add_enhanced_monitoring_max_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_max_memory_utilization_alarm: 
        :param add_enhanced_monitoring_p90_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_p90_memory_utilization_alarm: 
        :param add_fault_count_alarm: 
        :param add_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param add_max_iterator_age_alarm: 
        :param add_min_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_rate_alarm: 
        :param add_throttles_count_alarm: 
        :param add_throttles_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_concurrent_executions_count_alarm", value=add_concurrent_executions_count_alarm, expected_type=type_hints["add_concurrent_executions_count_alarm"])
            check_type(argname="argument add_enhanced_monitoring_avg_cpu_total_time_alarm", value=add_enhanced_monitoring_avg_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_avg_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_avg_memory_utilization_alarm", value=add_enhanced_monitoring_avg_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_avg_memory_utilization_alarm"])
            check_type(argname="argument add_enhanced_monitoring_max_cpu_total_time_alarm", value=add_enhanced_monitoring_max_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_max_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_max_memory_utilization_alarm", value=add_enhanced_monitoring_max_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_max_memory_utilization_alarm"])
            check_type(argname="argument add_enhanced_monitoring_p90_cpu_total_time_alarm", value=add_enhanced_monitoring_p90_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_p90_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_p90_memory_utilization_alarm", value=add_enhanced_monitoring_p90_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_p90_memory_utilization_alarm"])
            check_type(argname="argument add_fault_count_alarm", value=add_fault_count_alarm, expected_type=type_hints["add_fault_count_alarm"])
            check_type(argname="argument add_fault_rate_alarm", value=add_fault_rate_alarm, expected_type=type_hints["add_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument add_max_iterator_age_alarm", value=add_max_iterator_age_alarm, expected_type=type_hints["add_max_iterator_age_alarm"])
            check_type(argname="argument add_min_invocations_count_alarm", value=add_min_invocations_count_alarm, expected_type=type_hints["add_min_invocations_count_alarm"])
            check_type(argname="argument add_provisioned_concurrency_spillover_invocations_count_alarm", value=add_provisioned_concurrency_spillover_invocations_count_alarm, expected_type=type_hints["add_provisioned_concurrency_spillover_invocations_count_alarm"])
            check_type(argname="argument add_provisioned_concurrency_spillover_invocations_rate_alarm", value=add_provisioned_concurrency_spillover_invocations_rate_alarm, expected_type=type_hints["add_provisioned_concurrency_spillover_invocations_rate_alarm"])
            check_type(argname="argument add_throttles_count_alarm", value=add_throttles_count_alarm, expected_type=type_hints["add_throttles_count_alarm"])
            check_type(argname="argument add_throttles_rate_alarm", value=add_throttles_rate_alarm, expected_type=type_hints["add_throttles_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_concurrent_executions_count_alarm is not None:
            self._values["add_concurrent_executions_count_alarm"] = add_concurrent_executions_count_alarm
        if add_enhanced_monitoring_avg_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_avg_cpu_total_time_alarm"] = add_enhanced_monitoring_avg_cpu_total_time_alarm
        if add_enhanced_monitoring_avg_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_avg_memory_utilization_alarm"] = add_enhanced_monitoring_avg_memory_utilization_alarm
        if add_enhanced_monitoring_max_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_max_cpu_total_time_alarm"] = add_enhanced_monitoring_max_cpu_total_time_alarm
        if add_enhanced_monitoring_max_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_max_memory_utilization_alarm"] = add_enhanced_monitoring_max_memory_utilization_alarm
        if add_enhanced_monitoring_p90_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_p90_cpu_total_time_alarm"] = add_enhanced_monitoring_p90_cpu_total_time_alarm
        if add_enhanced_monitoring_p90_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_p90_memory_utilization_alarm"] = add_enhanced_monitoring_p90_memory_utilization_alarm
        if add_fault_count_alarm is not None:
            self._values["add_fault_count_alarm"] = add_fault_count_alarm
        if add_fault_rate_alarm is not None:
            self._values["add_fault_rate_alarm"] = add_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if add_max_iterator_age_alarm is not None:
            self._values["add_max_iterator_age_alarm"] = add_max_iterator_age_alarm
        if add_min_invocations_count_alarm is not None:
            self._values["add_min_invocations_count_alarm"] = add_min_invocations_count_alarm
        if add_provisioned_concurrency_spillover_invocations_count_alarm is not None:
            self._values["add_provisioned_concurrency_spillover_invocations_count_alarm"] = add_provisioned_concurrency_spillover_invocations_count_alarm
        if add_provisioned_concurrency_spillover_invocations_rate_alarm is not None:
            self._values["add_provisioned_concurrency_spillover_invocations_rate_alarm"] = add_provisioned_concurrency_spillover_invocations_rate_alarm
        if add_throttles_count_alarm is not None:
            self._values["add_throttles_count_alarm"] = add_throttles_count_alarm
        if add_throttles_rate_alarm is not None:
            self._values["add_throttles_rate_alarm"] = add_throttles_rate_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_concurrent_executions_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_concurrent_executions_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_avg_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_avg_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_avg_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_avg_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_max_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_max_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_max_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_max_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_p90_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_p90_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_p90_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_p90_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def add_max_iterator_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_iterator_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxAgeThreshold]], result)

    @builtins.property
    def add_min_invocations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinUsageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_invocations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinUsageCountThreshold]], result)

    @builtins.property
    def add_provisioned_concurrency_spillover_invocations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_provisioned_concurrency_spillover_invocations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def add_provisioned_concurrency_spillover_invocations_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_provisioned_concurrency_spillover_invocations_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskRateThreshold]], result)

    @builtins.property
    def add_throttles_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttles_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_throttles_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttles_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaFunctionMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LambdaFunctionMonitoringProps",
    jsii_struct_bases=[
        LambdaFunctionMetricFactoryProps, LambdaFunctionMonitoringOptions
    ],
    name_mapping={
        "lambda_function": "lambdaFunction",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "lambda_insights_enabled": "lambdaInsightsEnabled",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_concurrent_executions_count_alarm": "addConcurrentExecutionsCountAlarm",
        "add_enhanced_monitoring_avg_cpu_total_time_alarm": "addEnhancedMonitoringAvgCpuTotalTimeAlarm",
        "add_enhanced_monitoring_avg_memory_utilization_alarm": "addEnhancedMonitoringAvgMemoryUtilizationAlarm",
        "add_enhanced_monitoring_max_cpu_total_time_alarm": "addEnhancedMonitoringMaxCpuTotalTimeAlarm",
        "add_enhanced_monitoring_max_memory_utilization_alarm": "addEnhancedMonitoringMaxMemoryUtilizationAlarm",
        "add_enhanced_monitoring_p90_cpu_total_time_alarm": "addEnhancedMonitoringP90CpuTotalTimeAlarm",
        "add_enhanced_monitoring_p90_memory_utilization_alarm": "addEnhancedMonitoringP90MemoryUtilizationAlarm",
        "add_fault_count_alarm": "addFaultCountAlarm",
        "add_fault_rate_alarm": "addFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "add_max_iterator_age_alarm": "addMaxIteratorAgeAlarm",
        "add_min_invocations_count_alarm": "addMinInvocationsCountAlarm",
        "add_provisioned_concurrency_spillover_invocations_count_alarm": "addProvisionedConcurrencySpilloverInvocationsCountAlarm",
        "add_provisioned_concurrency_spillover_invocations_rate_alarm": "addProvisionedConcurrencySpilloverInvocationsRateAlarm",
        "add_throttles_count_alarm": "addThrottlesCountAlarm",
        "add_throttles_rate_alarm": "addThrottlesRateAlarm",
    },
)
class LambdaFunctionMonitoringProps(
    LambdaFunctionMetricFactoryProps,
    LambdaFunctionMonitoringOptions,
):
    def __init__(
        self,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        lambda_insights_enabled: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_concurrent_executions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_iterator_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinUsageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param lambda_function: 
        :param fill_tps_with_zeroes: Default: - true
        :param lambda_insights_enabled: (experimental) Generate dashboard charts for Lambda Insights metrics. To enable Lambda Insights on your Lambda function, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html Default: - false
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_concurrent_executions_count_alarm: 
        :param add_enhanced_monitoring_avg_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_avg_memory_utilization_alarm: 
        :param add_enhanced_monitoring_max_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_max_memory_utilization_alarm: 
        :param add_enhanced_monitoring_p90_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_p90_memory_utilization_alarm: 
        :param add_fault_count_alarm: 
        :param add_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param add_max_iterator_age_alarm: 
        :param add_min_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_rate_alarm: 
        :param add_throttles_count_alarm: 
        :param add_throttles_rate_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LambdaFunctionMonitoringProps.__init__)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument lambda_insights_enabled", value=lambda_insights_enabled, expected_type=type_hints["lambda_insights_enabled"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_concurrent_executions_count_alarm", value=add_concurrent_executions_count_alarm, expected_type=type_hints["add_concurrent_executions_count_alarm"])
            check_type(argname="argument add_enhanced_monitoring_avg_cpu_total_time_alarm", value=add_enhanced_monitoring_avg_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_avg_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_avg_memory_utilization_alarm", value=add_enhanced_monitoring_avg_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_avg_memory_utilization_alarm"])
            check_type(argname="argument add_enhanced_monitoring_max_cpu_total_time_alarm", value=add_enhanced_monitoring_max_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_max_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_max_memory_utilization_alarm", value=add_enhanced_monitoring_max_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_max_memory_utilization_alarm"])
            check_type(argname="argument add_enhanced_monitoring_p90_cpu_total_time_alarm", value=add_enhanced_monitoring_p90_cpu_total_time_alarm, expected_type=type_hints["add_enhanced_monitoring_p90_cpu_total_time_alarm"])
            check_type(argname="argument add_enhanced_monitoring_p90_memory_utilization_alarm", value=add_enhanced_monitoring_p90_memory_utilization_alarm, expected_type=type_hints["add_enhanced_monitoring_p90_memory_utilization_alarm"])
            check_type(argname="argument add_fault_count_alarm", value=add_fault_count_alarm, expected_type=type_hints["add_fault_count_alarm"])
            check_type(argname="argument add_fault_rate_alarm", value=add_fault_rate_alarm, expected_type=type_hints["add_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument add_max_iterator_age_alarm", value=add_max_iterator_age_alarm, expected_type=type_hints["add_max_iterator_age_alarm"])
            check_type(argname="argument add_min_invocations_count_alarm", value=add_min_invocations_count_alarm, expected_type=type_hints["add_min_invocations_count_alarm"])
            check_type(argname="argument add_provisioned_concurrency_spillover_invocations_count_alarm", value=add_provisioned_concurrency_spillover_invocations_count_alarm, expected_type=type_hints["add_provisioned_concurrency_spillover_invocations_count_alarm"])
            check_type(argname="argument add_provisioned_concurrency_spillover_invocations_rate_alarm", value=add_provisioned_concurrency_spillover_invocations_rate_alarm, expected_type=type_hints["add_provisioned_concurrency_spillover_invocations_rate_alarm"])
            check_type(argname="argument add_throttles_count_alarm", value=add_throttles_count_alarm, expected_type=type_hints["add_throttles_count_alarm"])
            check_type(argname="argument add_throttles_rate_alarm", value=add_throttles_rate_alarm, expected_type=type_hints["add_throttles_rate_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if lambda_insights_enabled is not None:
            self._values["lambda_insights_enabled"] = lambda_insights_enabled
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_concurrent_executions_count_alarm is not None:
            self._values["add_concurrent_executions_count_alarm"] = add_concurrent_executions_count_alarm
        if add_enhanced_monitoring_avg_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_avg_cpu_total_time_alarm"] = add_enhanced_monitoring_avg_cpu_total_time_alarm
        if add_enhanced_monitoring_avg_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_avg_memory_utilization_alarm"] = add_enhanced_monitoring_avg_memory_utilization_alarm
        if add_enhanced_monitoring_max_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_max_cpu_total_time_alarm"] = add_enhanced_monitoring_max_cpu_total_time_alarm
        if add_enhanced_monitoring_max_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_max_memory_utilization_alarm"] = add_enhanced_monitoring_max_memory_utilization_alarm
        if add_enhanced_monitoring_p90_cpu_total_time_alarm is not None:
            self._values["add_enhanced_monitoring_p90_cpu_total_time_alarm"] = add_enhanced_monitoring_p90_cpu_total_time_alarm
        if add_enhanced_monitoring_p90_memory_utilization_alarm is not None:
            self._values["add_enhanced_monitoring_p90_memory_utilization_alarm"] = add_enhanced_monitoring_p90_memory_utilization_alarm
        if add_fault_count_alarm is not None:
            self._values["add_fault_count_alarm"] = add_fault_count_alarm
        if add_fault_rate_alarm is not None:
            self._values["add_fault_rate_alarm"] = add_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if add_max_iterator_age_alarm is not None:
            self._values["add_max_iterator_age_alarm"] = add_max_iterator_age_alarm
        if add_min_invocations_count_alarm is not None:
            self._values["add_min_invocations_count_alarm"] = add_min_invocations_count_alarm
        if add_provisioned_concurrency_spillover_invocations_count_alarm is not None:
            self._values["add_provisioned_concurrency_spillover_invocations_count_alarm"] = add_provisioned_concurrency_spillover_invocations_count_alarm
        if add_provisioned_concurrency_spillover_invocations_rate_alarm is not None:
            self._values["add_provisioned_concurrency_spillover_invocations_rate_alarm"] = add_provisioned_concurrency_spillover_invocations_rate_alarm
        if add_throttles_count_alarm is not None:
            self._values["add_throttles_count_alarm"] = add_throttles_count_alarm
        if add_throttles_rate_alarm is not None:
            self._values["add_throttles_rate_alarm"] = add_throttles_rate_alarm

    @builtins.property
    def lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(aws_cdk.aws_lambda.IFunction, result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def lambda_insights_enabled(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Generate dashboard charts for Lambda Insights metrics.

        To enable Lambda Insights on your Lambda function, see
        https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html

        :default: - false

        :stability: experimental
        '''
        result = self._values.get("lambda_insights_enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_concurrent_executions_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_concurrent_executions_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_avg_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_avg_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_avg_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_avg_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_max_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_max_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_max_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_max_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_p90_cpu_total_time_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_p90_cpu_total_time_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_enhanced_monitoring_p90_memory_utilization_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_enhanced_monitoring_p90_memory_utilization_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def add_max_iterator_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_iterator_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxAgeThreshold]], result)

    @builtins.property
    def add_min_invocations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinUsageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_invocations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinUsageCountThreshold]], result)

    @builtins.property
    def add_provisioned_concurrency_spillover_invocations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_provisioned_concurrency_spillover_invocations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def add_provisioned_concurrency_spillover_invocations_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_provisioned_concurrency_spillover_invocations_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskRateThreshold]], result)

    @builtins.property
    def add_throttles_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttles_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_throttles_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttles_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaFunctionMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LogMonitoring(
    Monitoring,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.LogMonitoring",
):
    '''(experimental) Monitors a CloudWatch log group for various patterns.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: MonitoringScope,
        *,
        log_group_name: builtins.str,
        pattern: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param log_group_name: (experimental) name of the log group to analyze for the given pattern.
        :param pattern: (experimental) pattern to show, e.g. "ERROR".
        :param limit: (experimental) number of log messages to search for. Default: - 10
        :param title: (experimental) widget title. Default: - auto-generated title based on the pattern and limit
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogMonitoring.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        props = LogMonitoringProps(
            log_group_name=log_group_name,
            pattern=pattern,
            limit=limit,
            title=title,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        jsii.create(self.__class__, self, [scope, props])

    @jsii.member(jsii_name="resolveRecommendedHeight")
    def _resolve_recommended_height(self, num_rows: jsii.Number) -> jsii.Number:
        '''
        :param num_rows: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogMonitoring._resolve_recommended_height)
            check_type(argname="argument num_rows", value=num_rows, expected_type=type_hints["num_rows"])
        return typing.cast(jsii.Number, jsii.invoke(self, "resolveRecommendedHeight", [num_rows]))

    @jsii.member(jsii_name="widgets")
    def widgets(self) -> typing.List[aws_cdk.aws_cloudwatch.IWidget]:
        '''(experimental) Returns widgets to be placed on the main dashboard.

        :stability: experimental
        '''
        return typing.cast(typing.List[aws_cdk.aws_cloudwatch.IWidget], jsii.invoke(self, "widgets", []))

    @builtins.property
    @jsii.member(jsii_name="limit")
    def limit(self) -> jsii.Number:
        '''
        :stability: experimental
        '''
        return typing.cast(jsii.Number, jsii.get(self, "limit"))

    @builtins.property
    @jsii.member(jsii_name="logGroupName")
    def log_group_name(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "logGroupName"))

    @builtins.property
    @jsii.member(jsii_name="pattern")
    def pattern(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        return typing.cast(builtins.str, jsii.get(self, "pattern"))

    @builtins.property
    @jsii.member(jsii_name="logGroupUrl")
    def log_group_url(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "logGroupUrl"))

    @builtins.property
    @jsii.member(jsii_name="title")
    def title(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[builtins.str], jsii.get(self, "title"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.LogMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "log_group_name": "logGroupName",
        "pattern": "pattern",
        "limit": "limit",
        "title": "title",
    },
)
class LogMonitoringProps(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        log_group_name: builtins.str,
        pattern: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param log_group_name: (experimental) name of the log group to analyze for the given pattern.
        :param pattern: (experimental) pattern to show, e.g. "ERROR".
        :param limit: (experimental) number of log messages to search for. Default: - 10
        :param title: (experimental) widget title. Default: - auto-generated title based on the pattern and limit

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(LogMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument log_group_name", value=log_group_name, expected_type=type_hints["log_group_name"])
            check_type(argname="argument pattern", value=pattern, expected_type=type_hints["pattern"])
            check_type(argname="argument limit", value=limit, expected_type=type_hints["limit"])
            check_type(argname="argument title", value=title, expected_type=type_hints["title"])
        self._values: typing.Dict[str, typing.Any] = {
            "log_group_name": log_group_name,
            "pattern": pattern,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if limit is not None:
            self._values["limit"] = limit
        if title is not None:
            self._values["title"] = title

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def log_group_name(self) -> builtins.str:
        '''(experimental) name of the log group to analyze for the given pattern.

        :stability: experimental
        '''
        result = self._values.get("log_group_name")
        assert result is not None, "Required property 'log_group_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def pattern(self) -> builtins.str:
        '''(experimental) pattern to show, e.g. "ERROR".

        :stability: experimental
        '''
        result = self._values.get("pattern")
        assert result is not None, "Required property 'pattern' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def limit(self) -> typing.Optional[jsii.Number]:
        '''(experimental) number of log messages to search for.

        :default: - 10

        :stability: experimental
        '''
        result = self._values.get("limit")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def title(self) -> typing.Optional[builtins.str]:
        '''(experimental) widget title.

        :default: - auto-generated title based on the pattern and limit

        :stability: experimental
        '''
        result = self._values.get("title")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LogMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class MonitoringFacade(
    MonitoringScope,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.MonitoringFacade",
):
    '''(experimental) Main entry point to create your monitoring.

    :stability: experimental
    '''

    def __init__(
        self,
        scope: constructs.Construct,
        id: builtins.str,
        *,
        alarm_factory_defaults: typing.Optional[typing.Union[AlarmFactoryDefaults, typing.Dict[str, typing.Any]]] = None,
        dashboard_factory: typing.Optional[IDashboardFactory] = None,
        metric_factory_defaults: typing.Optional[typing.Union[MetricFactoryDefaults, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param alarm_factory_defaults: (experimental) Defaults for alarm factory. Default: - actions enabled, facade logical ID used as default alarm name prefix
        :param dashboard_factory: (experimental) Defaults for dashboard factory. Default: - ``DefaultDashboardFactory``; facade logical ID used as default name
        :param metric_factory_defaults: (experimental) Defaults for metric factory. Default: - empty (no preferences)

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.__init__)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = MonitoringFacadeProps(
            alarm_factory_defaults=alarm_factory_defaults,
            dashboard_factory=dashboard_factory,
            metric_factory_defaults=metric_factory_defaults,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="addLargeHeader")
    def add_large_header(
        self,
        text: builtins.str,
        add_to_summary: typing.Optional[builtins.bool] = None,
        add_to_alarm: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param text: -
        :param add_to_summary: -
        :param add_to_alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.add_large_header)
            check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            check_type(argname="argument add_to_summary", value=add_to_summary, expected_type=type_hints["add_to_summary"])
            check_type(argname="argument add_to_alarm", value=add_to_alarm, expected_type=type_hints["add_to_alarm"])
        return typing.cast("MonitoringFacade", jsii.invoke(self, "addLargeHeader", [text, add_to_summary, add_to_alarm]))

    @jsii.member(jsii_name="addMediumHeader")
    def add_medium_header(
        self,
        text: builtins.str,
        add_to_summary: typing.Optional[builtins.bool] = None,
        add_to_alarm: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param text: -
        :param add_to_summary: -
        :param add_to_alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.add_medium_header)
            check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            check_type(argname="argument add_to_summary", value=add_to_summary, expected_type=type_hints["add_to_summary"])
            check_type(argname="argument add_to_alarm", value=add_to_alarm, expected_type=type_hints["add_to_alarm"])
        return typing.cast("MonitoringFacade", jsii.invoke(self, "addMediumHeader", [text, add_to_summary, add_to_alarm]))

    @jsii.member(jsii_name="addSegment")
    def add_segment(
        self,
        segment: IDashboardSegment,
        *,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param segment: -
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.add_segment)
            check_type(argname="argument segment", value=segment, expected_type=type_hints["segment"])
        override_props = MonitoringDashboardsOverrideProps(
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "addSegment", [segment, override_props]))

    @jsii.member(jsii_name="addSmallHeader")
    def add_small_header(
        self,
        text: builtins.str,
        add_to_summary: typing.Optional[builtins.bool] = None,
        add_to_alarm: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param text: -
        :param add_to_summary: -
        :param add_to_alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.add_small_header)
            check_type(argname="argument text", value=text, expected_type=type_hints["text"])
            check_type(argname="argument add_to_summary", value=add_to_summary, expected_type=type_hints["add_to_summary"])
            check_type(argname="argument add_to_alarm", value=add_to_alarm, expected_type=type_hints["add_to_alarm"])
        return typing.cast("MonitoringFacade", jsii.invoke(self, "addSmallHeader", [text, add_to_summary, add_to_alarm]))

    @jsii.member(jsii_name="addWidget")
    def add_widget(
        self,
        widget: aws_cdk.aws_cloudwatch.IWidget,
        add_to_summary: typing.Optional[builtins.bool] = None,
        add_to_alarm: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param widget: -
        :param add_to_summary: -
        :param add_to_alarm: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.add_widget)
            check_type(argname="argument widget", value=widget, expected_type=type_hints["widget"])
            check_type(argname="argument add_to_summary", value=add_to_summary, expected_type=type_hints["add_to_summary"])
            check_type(argname="argument add_to_alarm", value=add_to_alarm, expected_type=type_hints["add_to_alarm"])
        return typing.cast("MonitoringFacade", jsii.invoke(self, "addWidget", [widget, add_to_summary, add_to_alarm]))

    @jsii.member(jsii_name="createAlarmFactory")
    def create_alarm_factory(self, alarm_name_prefix: builtins.str) -> AlarmFactory:
        '''(experimental) Creates a new alarm factory.

        Alarms created will be named with the given prefix, unless a local name override is present.

        :param alarm_name_prefix: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.create_alarm_factory)
            check_type(argname="argument alarm_name_prefix", value=alarm_name_prefix, expected_type=type_hints["alarm_name_prefix"])
        return typing.cast(AlarmFactory, jsii.invoke(self, "createAlarmFactory", [alarm_name_prefix]))

    @jsii.member(jsii_name="createAwsConsoleUrlFactory")
    def create_aws_console_url_factory(self) -> AwsConsoleUrlFactory:
        '''(experimental) Creates a new factory that creates AWS Console URLs.

        :stability: experimental
        '''
        return typing.cast(AwsConsoleUrlFactory, jsii.invoke(self, "createAwsConsoleUrlFactory", []))

    @jsii.member(jsii_name="createCompositeAlarmUsingDisambiguator")
    def create_composite_alarm_using_disambiguator(
        self,
        alarm_disambiguator: builtins.str,
        *,
        disambiguator: builtins.str,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        alarm_name_suffix: typing.Optional[builtins.str] = None,
        composite_operator: typing.Optional[CompositeAlarmOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.CompositeAlarm]:
        '''(experimental) Finds a subset of created alarms that are marked by a specific disambiguator and creates a composite alarm.

        This composite alarm is created with an 'OR' condition, so it triggers with any child alarm.
        NOTE: This composite alarm is not added among other alarms, so it is not returned by createdAlarms() calls.

        :param alarm_disambiguator: disambiguator to filter alarms by.
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible. Default: - no description
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique. Default: - no suffix
        :param composite_operator: (experimental) Logical operator used to aggregate the status individual alarms. Default: - OR
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.create_composite_alarm_using_disambiguator)
            check_type(argname="argument alarm_disambiguator", value=alarm_disambiguator, expected_type=type_hints["alarm_disambiguator"])
        props = AddCompositeAlarmProps(
            disambiguator=disambiguator,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_description=alarm_description,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            alarm_name_suffix=alarm_name_suffix,
            composite_operator=composite_operator,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            fill_alarm_range=fill_alarm_range,
            runbook_link=runbook_link,
        )

        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.CompositeAlarm], jsii.invoke(self, "createCompositeAlarmUsingDisambiguator", [alarm_disambiguator, props]))

    @jsii.member(jsii_name="createCompositeAlarmUsingTag")
    def create_composite_alarm_using_tag(
        self,
        custom_tag: builtins.str,
        *,
        disambiguator: builtins.str,
        action_override: typing.Optional[IAlarmActionStrategy] = None,
        actions_enabled: typing.Optional[builtins.bool] = None,
        alarm_dedupe_string_suffix: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_description_override: typing.Optional[builtins.str] = None,
        alarm_name_override: typing.Optional[builtins.str] = None,
        alarm_name_suffix: typing.Optional[builtins.str] = None,
        composite_operator: typing.Optional[CompositeAlarmOperator] = None,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string_override: typing.Optional[builtins.str] = None,
        documentation_link: typing.Optional[builtins.str] = None,
        fill_alarm_range: typing.Optional[builtins.bool] = None,
        runbook_link: typing.Optional[builtins.str] = None,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.CompositeAlarm]:
        '''(experimental) Finds a subset of created alarms that are marked by a specific custom tag and creates a composite alarm.

        This composite alarm is created with an 'OR' condition, so it triggers with any child alarm.
        NOTE: This composite alarm is not added among other alarms, so it is not returned by createdAlarms() calls.

        :param custom_tag: tag to filter alarms by.
        :param disambiguator: (experimental) Disambiguator is a string that differentiates this alarm from other similar ones.
        :param action_override: (experimental) Allows to override the default action strategy. Default: - default action will be used
        :param actions_enabled: (experimental) Enables the configured CloudWatch alarm ticketing actions. Default: - the same as monitoring facade default
        :param alarm_dedupe_string_suffix: (experimental) If this is defined, the default resource-specific alarm dedupe string will be set and this will be added as a suffix. This allows you to specify the same dedupe string for a family of alarms. Cannot be defined at the same time as alarmDedupeStringOverride. Default: - undefined (no suffix)
        :param alarm_description: (experimental) Alarm description is included in the ticket and therefore should describe what happened, with as much context as possible. Default: - no description
        :param alarm_description_override: (experimental) A text included in the generated ticket description body, which fully replaces the generated text. Default: - default auto-generated content only
        :param alarm_name_override: (experimental) If this is defined, the alarm name is set to this exact value. Please be aware that you need to specify prefix for different stages (Beta, Prod...) and realms (EU, NA...) manually.
        :param alarm_name_suffix: (experimental) Suffix added to base alarm name. Alarm names need to be unique. Default: - no suffix
        :param composite_operator: (experimental) Logical operator used to aggregate the status individual alarms. Default: - OR
        :param custom_params: (experimental) This allows user to attach custom parameters to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no parameters
        :param custom_tags: (experimental) This allows user to attach custom values to this alarm, which can later be accessed from the "useCreatedAlarms" method. Default: - no tags
        :param dedupe_string_override: (experimental) If this is defined, the alarm dedupe string is set to this exact value. Please be aware that you need to handle deduping for different stages (Beta, Prod...) and realms (EU, NA...) manually. Default: - undefined (no override)
        :param documentation_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added
        :param fill_alarm_range: (experimental) Indicates whether the alarming range of values should be highlighted in the widget. Default: - false
        :param runbook_link: (experimental) An optional link included in the generated ticket description body. Default: - no additional link will be added

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.create_composite_alarm_using_tag)
            check_type(argname="argument custom_tag", value=custom_tag, expected_type=type_hints["custom_tag"])
        props = AddCompositeAlarmProps(
            disambiguator=disambiguator,
            action_override=action_override,
            actions_enabled=actions_enabled,
            alarm_dedupe_string_suffix=alarm_dedupe_string_suffix,
            alarm_description=alarm_description,
            alarm_description_override=alarm_description_override,
            alarm_name_override=alarm_name_override,
            alarm_name_suffix=alarm_name_suffix,
            composite_operator=composite_operator,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string_override=dedupe_string_override,
            documentation_link=documentation_link,
            fill_alarm_range=fill_alarm_range,
            runbook_link=runbook_link,
        )

        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.CompositeAlarm], jsii.invoke(self, "createCompositeAlarmUsingTag", [custom_tag, props]))

    @jsii.member(jsii_name="createdAlarmDashboard")
    def created_alarm_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdAlarmDashboard", []))

    @jsii.member(jsii_name="createdAlarms")
    def created_alarms(self) -> typing.List[AlarmWithAnnotation]:
        '''(experimental) Returns the created alarms across all the monitorings added up until now.

        :stability: experimental
        '''
        return typing.cast(typing.List[AlarmWithAnnotation], jsii.invoke(self, "createdAlarms", []))

    @jsii.member(jsii_name="createdAlarmsWithDisambiguator")
    def created_alarms_with_disambiguator(
        self,
        disambiguator: builtins.str,
    ) -> typing.List[AlarmWithAnnotation]:
        '''(experimental) Returns a subset of created alarms that are marked by a specific disambiguator.

        :param disambiguator: disambiguator to filter alarms by.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.created_alarms_with_disambiguator)
            check_type(argname="argument disambiguator", value=disambiguator, expected_type=type_hints["disambiguator"])
        return typing.cast(typing.List[AlarmWithAnnotation], jsii.invoke(self, "createdAlarmsWithDisambiguator", [disambiguator]))

    @jsii.member(jsii_name="createdAlarmsWithTag")
    def created_alarms_with_tag(
        self,
        custom_tag: builtins.str,
    ) -> typing.List[AlarmWithAnnotation]:
        '''(experimental) Returns a subset of created alarms that are marked by a specific custom tag.

        :param custom_tag: tag to filter alarms by.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.created_alarms_with_tag)
            check_type(argname="argument custom_tag", value=custom_tag, expected_type=type_hints["custom_tag"])
        return typing.cast(typing.List[AlarmWithAnnotation], jsii.invoke(self, "createdAlarmsWithTag", [custom_tag]))

    @jsii.member(jsii_name="createdDashboard")
    def created_dashboard(self) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdDashboard", []))

    @jsii.member(jsii_name="createdMonitorings")
    def created_monitorings(self) -> typing.List[Monitoring]:
        '''(experimental) Returns the created monitorings added up until now.

        :stability: experimental
        '''
        return typing.cast(typing.List[Monitoring], jsii.invoke(self, "createdMonitorings", []))

    @jsii.member(jsii_name="createdSummaryDashboard")
    def created_summary_dashboard(
        self,
    ) -> typing.Optional[aws_cdk.aws_cloudwatch.Dashboard]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[aws_cdk.aws_cloudwatch.Dashboard], jsii.invoke(self, "createdSummaryDashboard", []))

    @jsii.member(jsii_name="createMetricFactory")
    def create_metric_factory(self) -> MetricFactory:
        '''(experimental) Creates a new metric factory.

        :stability: experimental
        '''
        return typing.cast(MetricFactory, jsii.invoke(self, "createMetricFactory", []))

    @jsii.member(jsii_name="createWidgetFactory")
    def create_widget_factory(self) -> IWidgetFactory:
        '''(experimental) Creates a new widget factory.

        :stability: experimental
        '''
        return typing.cast(IWidgetFactory, jsii.invoke(self, "createWidgetFactory", []))

    @jsii.member(jsii_name="monitorApiGateway")
    def monitor_api_gateway(
        self,
        *,
        api: aws_cdk.aws_apigateway.RestApiBase,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param api: (experimental) API to monitor (cannot use IRestApi, since it does not provide API name).
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - prod
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = ApiGatewayMonitoringProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add4_xx_error_count_alarm=add4_xx_error_count_alarm,
            add4_xx_error_rate_alarm=add4_xx_error_rate_alarm,
            add5_xx_fault_count_alarm=add5_xx_fault_count_alarm,
            add5_xx_fault_rate_alarm=add5_xx_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_average_alarm=add_latency_average_alarm,
            add_latency_p100_alarm=add_latency_p100_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p70_alarm=add_latency_p70_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p95_alarm=add_latency_p95_alarm,
            add_latency_p9999_alarm=add_latency_p9999_alarm,
            add_latency_p999_alarm=add_latency_p999_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_latency_tm50_alarm=add_latency_tm50_alarm,
            add_latency_tm70_alarm=add_latency_tm70_alarm,
            add_latency_tm90_alarm=add_latency_tm90_alarm,
            add_latency_tm95_alarm=add_latency_tm95_alarm,
            add_latency_tm9999_alarm=add_latency_tm9999_alarm,
            add_latency_tm999_alarm=add_latency_tm999_alarm,
            add_latency_tm99_alarm=add_latency_tm99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            latency_types_to_render=latency_types_to_render,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorApiGateway", [props]))

    @jsii.member(jsii_name="monitorApiGatewayV2HttpApi")
    def monitor_api_gateway_v2_http_api(
        self,
        *,
        api: aws_cdk.aws_apigatewayv2_alpha.IHttpApi,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param api: 
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - $default
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add4xx_count_alarm: 
        :param add4xx_rate_alarm: 
        :param add5xx_count_alarm: 
        :param add5xx_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_integration_latency_average_alarm: 
        :param add_integration_latency_p100_alarm: 
        :param add_integration_latency_p50_alarm: 
        :param add_integration_latency_p70_alarm: 
        :param add_integration_latency_p90_alarm: 
        :param add_integration_latency_p95_alarm: 
        :param add_integration_latency_p9999_alarm: 
        :param add_integration_latency_p999_alarm: 
        :param add_integration_latency_p99_alarm: 
        :param add_integration_latency_tm50_alarm: 
        :param add_integration_latency_tm70_alarm: 
        :param add_integration_latency_tm90_alarm: 
        :param add_integration_latency_tm95_alarm: 
        :param add_integration_latency_tm9999_alarm: 
        :param add_integration_latency_tm999_alarm: 
        :param add_integration_latency_tm99_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = ApiGatewayV2HttpApiMonitoringProps(
            api=api,
            api_method=api_method,
            api_resource=api_resource,
            api_stage=api_stage,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add4xx_count_alarm=add4xx_count_alarm,
            add4xx_rate_alarm=add4xx_rate_alarm,
            add5xx_count_alarm=add5xx_count_alarm,
            add5xx_rate_alarm=add5xx_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_integration_latency_average_alarm=add_integration_latency_average_alarm,
            add_integration_latency_p100_alarm=add_integration_latency_p100_alarm,
            add_integration_latency_p50_alarm=add_integration_latency_p50_alarm,
            add_integration_latency_p70_alarm=add_integration_latency_p70_alarm,
            add_integration_latency_p90_alarm=add_integration_latency_p90_alarm,
            add_integration_latency_p95_alarm=add_integration_latency_p95_alarm,
            add_integration_latency_p9999_alarm=add_integration_latency_p9999_alarm,
            add_integration_latency_p999_alarm=add_integration_latency_p999_alarm,
            add_integration_latency_p99_alarm=add_integration_latency_p99_alarm,
            add_integration_latency_tm50_alarm=add_integration_latency_tm50_alarm,
            add_integration_latency_tm70_alarm=add_integration_latency_tm70_alarm,
            add_integration_latency_tm90_alarm=add_integration_latency_tm90_alarm,
            add_integration_latency_tm95_alarm=add_integration_latency_tm95_alarm,
            add_integration_latency_tm9999_alarm=add_integration_latency_tm9999_alarm,
            add_integration_latency_tm999_alarm=add_integration_latency_tm999_alarm,
            add_integration_latency_tm99_alarm=add_integration_latency_tm99_alarm,
            add_latency_average_alarm=add_latency_average_alarm,
            add_latency_p100_alarm=add_latency_p100_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p70_alarm=add_latency_p70_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p95_alarm=add_latency_p95_alarm,
            add_latency_p9999_alarm=add_latency_p9999_alarm,
            add_latency_p999_alarm=add_latency_p999_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_latency_tm50_alarm=add_latency_tm50_alarm,
            add_latency_tm70_alarm=add_latency_tm70_alarm,
            add_latency_tm90_alarm=add_latency_tm90_alarm,
            add_latency_tm95_alarm=add_latency_tm95_alarm,
            add_latency_tm9999_alarm=add_latency_tm9999_alarm,
            add_latency_tm999_alarm=add_latency_tm999_alarm,
            add_latency_tm99_alarm=add_latency_tm99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            latency_types_to_render=latency_types_to_render,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorApiGatewayV2HttpApi", [props]))

    @jsii.member(jsii_name="monitorAppSyncApi")
    def monitor_app_sync_api(
        self,
        *,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        api: aws_cdk.aws_appsync_alpha.GraphqlApi,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param api: (experimental) the GraphQL API to monitor.
        :param fill_tps_with_zeroes: (experimental) whether the TPS should be filled with zeroes. Default: - true
        :param rate_computation_method: (experimental) method to compute TPS. Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = AppSyncMonitoringProps(
            add4_xx_error_count_alarm=add4_xx_error_count_alarm,
            add4_xx_error_rate_alarm=add4_xx_error_rate_alarm,
            add5_xx_fault_count_alarm=add5_xx_fault_count_alarm,
            add5_xx_fault_rate_alarm=add5_xx_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            api=api,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorAppSyncApi", [props]))

    @jsii.member(jsii_name="monitorAutoScalingGroup")
    def monitor_auto_scaling_group(
        self,
        *,
        auto_scaling_group: aws_cdk.aws_autoscaling.IAutoScalingGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param auto_scaling_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = AutoScalingGroupMonitoringProps(
            auto_scaling_group=auto_scaling_group,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorAutoScalingGroup", [props]))

    @jsii.member(jsii_name="monitorBilling")
    def monitor_billing(
        self,
        *,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = BillingMonitoringProps(
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorBilling", [props]))

    @jsii.member(jsii_name="monitorCertificate")
    def monitor_certificate(
        self,
        *,
        add_days_to_expiry_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysToExpiryThreshold, typing.Dict[str, typing.Any]]]] = None,
        certificate: aws_cdk.aws_certificatemanager.ICertificate,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_days_to_expiry_alarm: 
        :param certificate: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = CertificateManagerMonitoringProps(
            add_days_to_expiry_alarm=add_days_to_expiry_alarm,
            certificate=certificate,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorCertificate", [props]))

    @jsii.member(jsii_name="monitorCloudFrontDistribution")
    def monitor_cloud_front_distribution(
        self,
        *,
        add_error4xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault5xx_rate: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        distribution: aws_cdk.aws_cloudfront.IDistribution,
        additional_metrics_enabled: typing.Optional[builtins.bool] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_error4xx_rate: 
        :param add_fault5xx_rate: 
        :param add_high_tps_alarm: 
        :param add_low_tps_alarm: 
        :param distribution: 
        :param additional_metrics_enabled: (experimental) Generate dashboard charts for additional CloudFront distribution metrics. To enable additional metrics on your CloudFront distribution, see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/viewing-cloudfront-metrics.html#monitoring-console.distributions-additional Default: - true
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = CloudFrontDistributionMonitoringProps(
            add_error4xx_rate=add_error4xx_rate,
            add_fault5xx_rate=add_fault5xx_rate,
            add_high_tps_alarm=add_high_tps_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            distribution=distribution,
            additional_metrics_enabled=additional_metrics_enabled,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorCloudFrontDistribution", [props]))

    @jsii.member(jsii_name="monitorCodeBuildProject")
    def monitor_code_build_project(
        self,
        *,
        project: aws_cdk.aws_codebuild.IProject,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_build_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param project: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_build_count_alarm: 
        :param add_failed_build_rate_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = CodeBuildProjectMonitoringProps(
            project=project,
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_build_count_alarm=add_failed_build_count_alarm,
            add_failed_build_rate_alarm=add_failed_build_rate_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorCodeBuildProject", [props]))

    @jsii.member(jsii_name="monitorCustom")
    def monitor_custom(
        self,
        *,
        metric_groups: typing.Sequence[typing.Union[CustomMetricGroup, typing.Dict[str, typing.Any]]],
        description: typing.Optional[builtins.str] = None,
        description_widget_height: typing.Optional[jsii.Number] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param metric_groups: 
        :param description: 
        :param description_widget_height: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = CustomMonitoringProps(
            metric_groups=metric_groups,
            description=description,
            description_widget_height=description_widget_height,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorCustom", [props]))

    @jsii.member(jsii_name="monitorDocumentDbCluster")
    def monitor_document_db_cluster(
        self,
        *,
        cluster: aws_cdk.aws_docdb.IDatabaseCluster,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param cluster: (experimental) database cluster.
        :param add_cpu_usage_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = DocumentDbMonitoringProps(
            cluster=cluster,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorDocumentDbCluster", [props]))

    @jsii.member(jsii_name="monitorDynamoTable")
    def monitor_dynamo_table(
        self,
        *,
        table: aws_cdk.aws_dynamodb.ITable,
        billing_mode: typing.Optional[aws_cdk.aws_dynamodb.BillingMode] = None,
        add_average_successful_batch_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_batch_write_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_delete_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_get_records_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_put_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_query_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_scan_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_successful_update_item_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_read_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_consumed_write_capacity_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ConsumedCapacityThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_system_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_throttled_events_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ThrottledEventsThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param table: (experimental) table to monitor.
        :param billing_mode: (experimental) table billing mode. Default: - best effort auto-detection or PROVISIONED as a fallback
        :param add_average_successful_batch_get_item_latency_alarm: 
        :param add_average_successful_batch_write_item_latency_alarm: 
        :param add_average_successful_delete_item_latency_alarm: 
        :param add_average_successful_get_item_latency_alarm: 
        :param add_average_successful_get_records_latency_alarm: 
        :param add_average_successful_put_item_latency_alarm: 
        :param add_average_successful_query_latency_alarm: 
        :param add_average_successful_scan_latency_alarm: 
        :param add_average_successful_update_item_latency_alarm: 
        :param add_consumed_read_capacity_alarm: 
        :param add_consumed_write_capacity_alarm: 
        :param add_read_throttled_events_count_alarm: 
        :param add_system_error_count_alarm: 
        :param add_write_throttled_events_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = DynamoTableMonitoringProps(
            table=table,
            billing_mode=billing_mode,
            add_average_successful_batch_get_item_latency_alarm=add_average_successful_batch_get_item_latency_alarm,
            add_average_successful_batch_write_item_latency_alarm=add_average_successful_batch_write_item_latency_alarm,
            add_average_successful_delete_item_latency_alarm=add_average_successful_delete_item_latency_alarm,
            add_average_successful_get_item_latency_alarm=add_average_successful_get_item_latency_alarm,
            add_average_successful_get_records_latency_alarm=add_average_successful_get_records_latency_alarm,
            add_average_successful_put_item_latency_alarm=add_average_successful_put_item_latency_alarm,
            add_average_successful_query_latency_alarm=add_average_successful_query_latency_alarm,
            add_average_successful_scan_latency_alarm=add_average_successful_scan_latency_alarm,
            add_average_successful_update_item_latency_alarm=add_average_successful_update_item_latency_alarm,
            add_consumed_read_capacity_alarm=add_consumed_read_capacity_alarm,
            add_consumed_write_capacity_alarm=add_consumed_write_capacity_alarm,
            add_read_throttled_events_count_alarm=add_read_throttled_events_count_alarm,
            add_system_error_count_alarm=add_system_error_count_alarm,
            add_write_throttled_events_count_alarm=add_write_throttled_events_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorDynamoTable", [props]))

    @jsii.member(jsii_name="monitorDynamoTableGlobalSecondaryIndex")
    def monitor_dynamo_table_global_secondary_index(
        self,
        *,
        global_secondary_index_name: builtins.str,
        table: aws_cdk.aws_dynamodb.ITable,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param global_secondary_index_name: 
        :param table: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = DynamoTableGlobalSecondaryIndexMonitoringProps(
            global_secondary_index_name=global_secondary_index_name,
            table=table,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorDynamoTableGlobalSecondaryIndex", [props]))

    @jsii.member(jsii_name="monitorEc2ApplicationLoadBalancer")
    def monitor_ec2_application_load_balancer(
        self,
        *,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param application_load_balancer: 
        :param application_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = Ec2ApplicationLoadBalancerMonitoringProps(
            ec2_service=ec2_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            application_load_balancer=application_load_balancer,
            application_target_group=application_target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorEc2ApplicationLoadBalancer", [props]))

    @jsii.member(jsii_name="monitorEC2Instances")
    def monitor_ec2_instances(
        self,
        *,
        auto_scaling_group: typing.Optional[aws_cdk.aws_autoscaling.IAutoScalingGroup] = None,
        instance_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param auto_scaling_group: (experimental) Auto-Scaling Group to monitor. Default: - no Auto-Scaling Group filter
        :param instance_ids: (experimental) Selected IDs of EC2 instances to monitor. Default: - no instance filter
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = EC2MonitoringProps(
            auto_scaling_group=auto_scaling_group,
            instance_ids=instance_ids,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorEC2Instances", [props]))

    @jsii.member(jsii_name="monitorEc2NetworkLoadBalancer")
    def monitor_ec2_network_load_balancer(
        self,
        *,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param network_load_balancer: 
        :param network_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = Ec2NetworkLoadBalancerMonitoringProps(
            ec2_service=ec2_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            network_load_balancer=network_load_balancer,
            network_target_group=network_target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorEc2NetworkLoadBalancer", [props]))

    @jsii.member(jsii_name="monitorEc2Service")
    def monitor_ec2_service(
        self,
        *,
        ec2_service: typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedEc2Service, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedEc2Service],
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param ec2_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = Ec2ServiceMonitoringProps(
            ec2_service=ec2_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorEc2Service", [props]))

    @jsii.member(jsii_name="monitorElastiCacheCluster")
    def monitor_elasti_cache_cluster(
        self,
        *,
        cluster_id: typing.Optional[builtins.str] = None,
        cluster_type: ElastiCacheClusterType,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_evicted_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_items_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxItemsCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_used_swap_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxUsedSwapMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_freeable_memory_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinFreeableMemoryThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param cluster_id: (experimental) Cluster to monitor. Default: - monitor all clusters
        :param cluster_type: (experimental) Cluster type (needed, since each type has their own specific metrics).
        :param add_cpu_usage_alarm: (experimental) Add CPU usage alarm.
        :param add_max_evicted_items_count_alarm: (experimental) Add alarm on number of evicted items.
        :param add_max_items_count_alarm: (experimental) Add alarm on total number of items.
        :param add_max_used_swap_memory_alarm: (experimental) Add alarm on amount of used swap memory.
        :param add_min_freeable_memory_alarm: (experimental) Add alarm on amount of freeable memory.
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = ElastiCacheClusterMonitoringProps(
            cluster_id=cluster_id,
            cluster_type=cluster_type,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_max_evicted_items_count_alarm=add_max_evicted_items_count_alarm,
            add_max_items_count_alarm=add_max_items_count_alarm,
            add_max_used_swap_memory_alarm=add_max_used_swap_memory_alarm,
            add_min_freeable_memory_alarm=add_min_freeable_memory_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorElastiCacheCluster", [props]))

    @jsii.member(jsii_name="monitorElasticsearchCluster")
    def monitor_elasticsearch_cluster(
        self,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_cluster_automated_snapshot_failure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterAutomatedSnapshotFailureThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_index_writes_blocked_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterIndexWritesBlockedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_node_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterNodesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_status_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterStatusCustomization, typing.Dict[str, typing.Any]]]] = None,
        add_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_error_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyErrorThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_inaccessible_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyInaccessibleThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add_cluster_automated_snapshot_failure_alarm: 
        :param add_cluster_index_writes_blocked_alarm: 
        :param add_cluster_node_count_alarm: 
        :param add_cluster_status_alarm: 
        :param add_cpu_space_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_indexing_latency_p50_alarm: 
        :param add_indexing_latency_p90_alarm: 
        :param add_indexing_latency_p99_alarm: 
        :param add_jvm_memory_pressure_alarm: 
        :param add_kms_key_error_alarm: 
        :param add_kms_key_inaccessible_alarm: 
        :param add_master_cpu_space_usage_alarm: 
        :param add_master_jvm_memory_pressure_alarm: 
        :param add_search_latency_p50_alarm: 
        :param add_search_latency_p90_alarm: 
        :param add_search_latency_p99_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = OpenSearchClusterMonitoringProps(
            domain=domain,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add_cluster_automated_snapshot_failure_alarm=add_cluster_automated_snapshot_failure_alarm,
            add_cluster_index_writes_blocked_alarm=add_cluster_index_writes_blocked_alarm,
            add_cluster_node_count_alarm=add_cluster_node_count_alarm,
            add_cluster_status_alarm=add_cluster_status_alarm,
            add_cpu_space_usage_alarm=add_cpu_space_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_indexing_latency_p50_alarm=add_indexing_latency_p50_alarm,
            add_indexing_latency_p90_alarm=add_indexing_latency_p90_alarm,
            add_indexing_latency_p99_alarm=add_indexing_latency_p99_alarm,
            add_jvm_memory_pressure_alarm=add_jvm_memory_pressure_alarm,
            add_kms_key_error_alarm=add_kms_key_error_alarm,
            add_kms_key_inaccessible_alarm=add_kms_key_inaccessible_alarm,
            add_master_cpu_space_usage_alarm=add_master_cpu_space_usage_alarm,
            add_master_jvm_memory_pressure_alarm=add_master_jvm_memory_pressure_alarm,
            add_search_latency_p50_alarm=add_search_latency_p50_alarm,
            add_search_latency_p90_alarm=add_search_latency_p90_alarm,
            add_search_latency_p99_alarm=add_search_latency_p99_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorElasticsearchCluster", [props]))

    @jsii.member(jsii_name="monitorFargateApplicationLoadBalancer")
    def monitor_fargate_application_load_balancer(
        self,
        *,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        application_load_balancer: aws_cdk.aws_elasticloadbalancingv2.ApplicationLoadBalancer,
        application_target_group: aws_cdk.aws_elasticloadbalancingv2.ApplicationTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param application_load_balancer: 
        :param application_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = FargateApplicationLoadBalancerMonitoringProps(
            fargate_service=fargate_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            application_load_balancer=application_load_balancer,
            application_target_group=application_target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorFargateApplicationLoadBalancer", [props]))

    @jsii.member(jsii_name="monitorFargateNetworkLoadBalancer")
    def monitor_fargate_network_load_balancer(
        self,
        *,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param network_load_balancer: 
        :param network_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = FargateNetworkLoadBalancerMonitoringProps(
            fargate_service=fargate_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            network_load_balancer=network_load_balancer,
            network_target_group=network_target_group,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorFargateNetworkLoadBalancer", [props]))

    @jsii.member(jsii_name="monitorFargateService")
    def monitor_fargate_service(
        self,
        *,
        fargate_service: typing.Union[aws_cdk.aws_ecs_patterns.NetworkLoadBalancedFargateService, aws_cdk.aws_ecs_patterns.ApplicationLoadBalancedFargateService],
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param fargate_service: 
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = FargateServiceMonitoringProps(
            fargate_service=fargate_service,
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorFargateService", [props]))

    @jsii.member(jsii_name="monitorGlueJob")
    def monitor_glue_job(
        self,
        *,
        add_failed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_killed_task_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        job_name: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_failed_task_count_alarm: 
        :param add_failed_task_rate_alarm: 
        :param add_killed_task_count_alarm: 
        :param add_killed_task_rate_alarm: 
        :param job_name: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = GlueJobMonitoringProps(
            add_failed_task_count_alarm=add_failed_task_count_alarm,
            add_failed_task_rate_alarm=add_failed_task_rate_alarm,
            add_killed_task_count_alarm=add_killed_task_count_alarm,
            add_killed_task_rate_alarm=add_killed_task_rate_alarm,
            job_name=job_name,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorGlueJob", [props]))

    @jsii.member(jsii_name="monitorKinesisDataAnalytics")
    def monitor_kinesis_data_analytics(
        self,
        *,
        application: builtins.str,
        add_downtime_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxDowntimeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_full_restart_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[FullRestartCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param application: 
        :param add_downtime_alarm: 
        :param add_full_restart_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = KinesisDataAnalyticsMonitoringProps(
            application=application,
            add_downtime_alarm=add_downtime_alarm,
            add_full_restart_count_alarm=add_full_restart_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorKinesisDataAnalytics", [props]))

    @jsii.member(jsii_name="monitorKinesisDataStream")
    def monitor_kinesis_data_stream(
        self,
        *,
        stream_name: builtins.str,
        add_iterator_max_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIteratorAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_put_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_read_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_records_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_write_provisioned_throughput_exceeded_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param stream_name: 
        :param add_iterator_max_age_alarm: 
        :param add_put_records_failed_alarm: 
        :param add_put_records_throttled_alarm: 
        :param add_read_provisioned_throughput_exceeded_alarm: 
        :param add_throttled_records_alarm: 
        :param add_write_provisioned_throughput_exceeded_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = KinesisDataStreamMonitoringProps(
            stream_name=stream_name,
            add_iterator_max_age_alarm=add_iterator_max_age_alarm,
            add_put_records_failed_alarm=add_put_records_failed_alarm,
            add_put_records_throttled_alarm=add_put_records_throttled_alarm,
            add_read_provisioned_throughput_exceeded_alarm=add_read_provisioned_throughput_exceeded_alarm,
            add_throttled_records_alarm=add_throttled_records_alarm,
            add_write_provisioned_throughput_exceeded_alarm=add_write_provisioned_throughput_exceeded_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorKinesisDataStream", [props]))

    @jsii.member(jsii_name="monitorKinesisFirehose")
    def monitor_kinesis_firehose(
        self,
        *,
        delivery_stream_name: builtins.str,
        add_records_throttled_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RecordsThrottledThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param delivery_stream_name: 
        :param add_records_throttled_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = KinesisFirehoseMonitoringProps(
            delivery_stream_name=delivery_stream_name,
            add_records_throttled_alarm=add_records_throttled_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorKinesisFirehose", [props]))

    @jsii.member(jsii_name="monitorLambdaFunction")
    def monitor_lambda_function(
        self,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        lambda_insights_enabled: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_concurrent_executions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_avg_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_max_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_cpu_total_time_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_enhanced_monitoring_p90_memory_utilization_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_iterator_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinUsageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_provisioned_concurrency_spillover_invocations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttles_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param lambda_function: 
        :param fill_tps_with_zeroes: Default: - true
        :param lambda_insights_enabled: (experimental) Generate dashboard charts for Lambda Insights metrics. To enable Lambda Insights on your Lambda function, see https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Getting-Started-clouddevelopmentkit.html Default: - false
        :param rate_computation_method: Default: - average
        :param add_concurrent_executions_count_alarm: 
        :param add_enhanced_monitoring_avg_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_avg_memory_utilization_alarm: 
        :param add_enhanced_monitoring_max_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_max_memory_utilization_alarm: 
        :param add_enhanced_monitoring_p90_cpu_total_time_alarm: 
        :param add_enhanced_monitoring_p90_memory_utilization_alarm: 
        :param add_fault_count_alarm: 
        :param add_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param add_max_iterator_age_alarm: 
        :param add_min_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_count_alarm: 
        :param add_provisioned_concurrency_spillover_invocations_rate_alarm: 
        :param add_throttles_count_alarm: 
        :param add_throttles_rate_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = LambdaFunctionMonitoringProps(
            lambda_function=lambda_function,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            lambda_insights_enabled=lambda_insights_enabled,
            rate_computation_method=rate_computation_method,
            add_concurrent_executions_count_alarm=add_concurrent_executions_count_alarm,
            add_enhanced_monitoring_avg_cpu_total_time_alarm=add_enhanced_monitoring_avg_cpu_total_time_alarm,
            add_enhanced_monitoring_avg_memory_utilization_alarm=add_enhanced_monitoring_avg_memory_utilization_alarm,
            add_enhanced_monitoring_max_cpu_total_time_alarm=add_enhanced_monitoring_max_cpu_total_time_alarm,
            add_enhanced_monitoring_max_memory_utilization_alarm=add_enhanced_monitoring_max_memory_utilization_alarm,
            add_enhanced_monitoring_p90_cpu_total_time_alarm=add_enhanced_monitoring_p90_cpu_total_time_alarm,
            add_enhanced_monitoring_p90_memory_utilization_alarm=add_enhanced_monitoring_p90_memory_utilization_alarm,
            add_fault_count_alarm=add_fault_count_alarm,
            add_fault_rate_alarm=add_fault_rate_alarm,
            add_high_tps_alarm=add_high_tps_alarm,
            add_latency_p50_alarm=add_latency_p50_alarm,
            add_latency_p90_alarm=add_latency_p90_alarm,
            add_latency_p99_alarm=add_latency_p99_alarm,
            add_low_tps_alarm=add_low_tps_alarm,
            add_max_iterator_age_alarm=add_max_iterator_age_alarm,
            add_min_invocations_count_alarm=add_min_invocations_count_alarm,
            add_provisioned_concurrency_spillover_invocations_count_alarm=add_provisioned_concurrency_spillover_invocations_count_alarm,
            add_provisioned_concurrency_spillover_invocations_rate_alarm=add_provisioned_concurrency_spillover_invocations_rate_alarm,
            add_throttles_count_alarm=add_throttles_count_alarm,
            add_throttles_rate_alarm=add_throttles_rate_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorLambdaFunction", [props]))

    @jsii.member(jsii_name="monitorLog")
    def monitor_log(
        self,
        *,
        log_group_name: builtins.str,
        pattern: builtins.str,
        limit: typing.Optional[jsii.Number] = None,
        title: typing.Optional[builtins.str] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param log_group_name: (experimental) name of the log group to analyze for the given pattern.
        :param pattern: (experimental) pattern to show, e.g. "ERROR".
        :param limit: (experimental) number of log messages to search for. Default: - 10
        :param title: (experimental) widget title. Default: - auto-generated title based on the pattern and limit
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = LogMonitoringProps(
            log_group_name=log_group_name,
            pattern=pattern,
            limit=limit,
            title=title,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorLog", [props]))

    @jsii.member(jsii_name="monitorNetworkLoadBalancer")
    def monitor_network_load_balancer(
        self,
        *,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 
        :param network_load_balancer: 
        :param network_target_group: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = NetworkLoadBalancerMonitoringProps(
            add_healthy_task_count_alarm=add_healthy_task_count_alarm,
            add_healthy_task_percent_alarm=add_healthy_task_percent_alarm,
            add_min_processed_bytes_alarm=add_min_processed_bytes_alarm,
            add_unhealthy_task_count_alarm=add_unhealthy_task_count_alarm,
            network_load_balancer=network_load_balancer,
            network_target_group=network_target_group,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorNetworkLoadBalancer", [props]))

    @jsii.member(jsii_name="monitorOpenSearchCluster")
    def monitor_open_search_cluster(
        self,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_cluster_automated_snapshot_failure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterAutomatedSnapshotFailureThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_index_writes_blocked_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterIndexWritesBlockedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_node_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterNodesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_status_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterStatusCustomization, typing.Dict[str, typing.Any]]]] = None,
        add_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_error_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyErrorThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_inaccessible_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyInaccessibleThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param add_cluster_automated_snapshot_failure_alarm: 
        :param add_cluster_index_writes_blocked_alarm: 
        :param add_cluster_node_count_alarm: 
        :param add_cluster_status_alarm: 
        :param add_cpu_space_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_indexing_latency_p50_alarm: 
        :param add_indexing_latency_p90_alarm: 
        :param add_indexing_latency_p99_alarm: 
        :param add_jvm_memory_pressure_alarm: 
        :param add_kms_key_error_alarm: 
        :param add_kms_key_inaccessible_alarm: 
        :param add_master_cpu_space_usage_alarm: 
        :param add_master_jvm_memory_pressure_alarm: 
        :param add_search_latency_p50_alarm: 
        :param add_search_latency_p90_alarm: 
        :param add_search_latency_p99_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = OpenSearchClusterMonitoringProps(
            domain=domain,
            fill_tps_with_zeroes=fill_tps_with_zeroes,
            rate_computation_method=rate_computation_method,
            add_cluster_automated_snapshot_failure_alarm=add_cluster_automated_snapshot_failure_alarm,
            add_cluster_index_writes_blocked_alarm=add_cluster_index_writes_blocked_alarm,
            add_cluster_node_count_alarm=add_cluster_node_count_alarm,
            add_cluster_status_alarm=add_cluster_status_alarm,
            add_cpu_space_usage_alarm=add_cpu_space_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_indexing_latency_p50_alarm=add_indexing_latency_p50_alarm,
            add_indexing_latency_p90_alarm=add_indexing_latency_p90_alarm,
            add_indexing_latency_p99_alarm=add_indexing_latency_p99_alarm,
            add_jvm_memory_pressure_alarm=add_jvm_memory_pressure_alarm,
            add_kms_key_error_alarm=add_kms_key_error_alarm,
            add_kms_key_inaccessible_alarm=add_kms_key_inaccessible_alarm,
            add_master_cpu_space_usage_alarm=add_master_cpu_space_usage_alarm,
            add_master_jvm_memory_pressure_alarm=add_master_jvm_memory_pressure_alarm,
            add_search_latency_p50_alarm=add_search_latency_p50_alarm,
            add_search_latency_p90_alarm=add_search_latency_p90_alarm,
            add_search_latency_p99_alarm=add_search_latency_p99_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorOpenSearchCluster", [props]))

    @jsii.member(jsii_name="monitorQueueProcessingEc2Service")
    def monitor_queue_processing_ec2_service(
        self,
        *,
        ec2_service: aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service,
        add_dead_letter_queue_alarms: typing.Optional[typing.Union[BaseDlqAlarms, typing.Dict[str, typing.Any]]] = None,
        add_queue_alarms: typing.Optional[typing.Union[BaseSqsQueueAlarms, typing.Dict[str, typing.Any]]] = None,
        add_service_alarms: typing.Optional[typing.Union[BaseFargateServiceAlarms, typing.Dict[str, typing.Any]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param ec2_service: 
        :param add_dead_letter_queue_alarms: 
        :param add_queue_alarms: 
        :param add_service_alarms: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = QueueProcessingEc2ServiceMonitoringProps(
            ec2_service=ec2_service,
            add_dead_letter_queue_alarms=add_dead_letter_queue_alarms,
            add_queue_alarms=add_queue_alarms,
            add_service_alarms=add_service_alarms,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorQueueProcessingEc2Service", [props]))

    @jsii.member(jsii_name="monitorQueueProcessingFargateService")
    def monitor_queue_processing_fargate_service(
        self,
        *,
        fargate_service: aws_cdk.aws_ecs_patterns.QueueProcessingFargateService,
        add_dead_letter_queue_alarms: typing.Optional[typing.Union[BaseDlqAlarms, typing.Dict[str, typing.Any]]] = None,
        add_queue_alarms: typing.Optional[typing.Union[BaseSqsQueueAlarms, typing.Dict[str, typing.Any]]] = None,
        add_service_alarms: typing.Optional[typing.Union[BaseFargateServiceAlarms, typing.Dict[str, typing.Any]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param fargate_service: 
        :param add_dead_letter_queue_alarms: 
        :param add_queue_alarms: 
        :param add_service_alarms: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = QueueProcessingFargateServiceMonitoringProps(
            fargate_service=fargate_service,
            add_dead_letter_queue_alarms=add_dead_letter_queue_alarms,
            add_queue_alarms=add_queue_alarms,
            add_service_alarms=add_service_alarms,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorQueueProcessingFargateService", [props]))

    @jsii.member(jsii_name="monitorRdsCluster")
    def monitor_rds_cluster(
        self,
        *,
        cluster: typing.Optional[aws_cdk.aws_rds.IDatabaseCluster] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param cluster: (experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).
        :param cluster_identifier: (deprecated) database cluster identifier (either this or ``cluster`` need to be specified).
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_min_connection_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = RdsClusterMonitoringProps(
            cluster=cluster,
            cluster_identifier=cluster_identifier,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_max_connection_count_alarm=add_max_connection_count_alarm,
            add_min_connection_count_alarm=add_min_connection_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorRdsCluster", [props]))

    @jsii.member(jsii_name="monitorRedshiftCluster")
    def monitor_redshift_cluster(
        self,
        *,
        cluster_identifier: builtins.str,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_long_query_duration_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param cluster_identifier: 
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_max_long_query_duration_alarm: 
        :param add_min_connection_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = RedshiftClusterMonitoringProps(
            cluster_identifier=cluster_identifier,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_disk_space_usage_alarm=add_disk_space_usage_alarm,
            add_max_connection_count_alarm=add_max_connection_count_alarm,
            add_max_long_query_duration_alarm=add_max_long_query_duration_alarm,
            add_min_connection_count_alarm=add_min_connection_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorRedshiftCluster", [props]))

    @jsii.member(jsii_name="monitorS3Bucket")
    def monitor_s3_bucket(
        self,
        *,
        bucket: aws_cdk.aws_s3.IBucket,
        storage_type: typing.Optional[StorageType] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param bucket: 
        :param storage_type: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = S3BucketMonitoringProps(
            bucket=bucket,
            storage_type=storage_type,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorS3Bucket", [props]))

    @jsii.member(jsii_name="monitorScope")
    def monitor_scope(
        self,
        scope: constructs.Construct,
        *,
        acm: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        api_gateway: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        api_gateway_v2: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        app_sync: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        auto_scaling_group: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        billing: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        cloud_front: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        code_build: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        document_db: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        dynamo_db: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        ec2: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        elastic_cache: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        glue: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        kinesis_data_analytics: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        kinesis_data_stream: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        kinesis_firehose: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        lambda_: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        open_search: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        rds: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        redshift: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        s3: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        secrets_manager: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        sns: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        sqs: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        step_functions: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        synthetics_canaries: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
        web_application_firewall_acl_v2: typing.Optional[typing.Union[MonitoringAspectType, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''(experimental) Monitor all the resources in the given scope.

        :param scope: -
        :param acm: 
        :param api_gateway: 
        :param api_gateway_v2: 
        :param app_sync: 
        :param auto_scaling_group: 
        :param billing: 
        :param cloud_front: 
        :param code_build: 
        :param document_db: 
        :param dynamo_db: 
        :param ec2: 
        :param elastic_cache: 
        :param glue: 
        :param kinesis_data_analytics: 
        :param kinesis_data_stream: 
        :param kinesis_firehose: 
        :param lambda_: 
        :param open_search: 
        :param rds: 
        :param redshift: 
        :param s3: 
        :param secrets_manager: 
        :param sns: 
        :param sqs: 
        :param step_functions: 
        :param synthetics_canaries: 
        :param web_application_firewall_acl_v2: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(MonitoringFacade.monitor_scope)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
        aspect_props = MonitoringAspectProps(
            acm=acm,
            api_gateway=api_gateway,
            api_gateway_v2=api_gateway_v2,
            app_sync=app_sync,
            auto_scaling_group=auto_scaling_group,
            billing=billing,
            cloud_front=cloud_front,
            code_build=code_build,
            document_db=document_db,
            dynamo_db=dynamo_db,
            ec2=ec2,
            elastic_cache=elastic_cache,
            glue=glue,
            kinesis_data_analytics=kinesis_data_analytics,
            kinesis_data_stream=kinesis_data_stream,
            kinesis_firehose=kinesis_firehose,
            lambda_=lambda_,
            open_search=open_search,
            rds=rds,
            redshift=redshift,
            s3=s3,
            secrets_manager=secrets_manager,
            sns=sns,
            sqs=sqs,
            step_functions=step_functions,
            synthetics_canaries=synthetics_canaries,
            web_application_firewall_acl_v2=web_application_firewall_acl_v2,
        )

        return typing.cast(None, jsii.invoke(self, "monitorScope", [scope, aspect_props]))

    @jsii.member(jsii_name="monitorSecretsManagerSecret")
    def monitor_secrets_manager_secret(
        self,
        *,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        add_days_since_last_change_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_days_since_last_rotation_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        show_last_rotation_widget: typing.Optional[builtins.bool] = None,
        use_publisher: typing.Optional[IPublisherConsumer] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param secret: 
        :param add_days_since_last_change_alarm: 
        :param add_days_since_last_rotation_alarm: 
        :param show_last_rotation_widget: Default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.
        :param use_publisher: (experimental) Provides access to the underlying metrics publisher Lambda function. This may be useful if you want to monitor the function itself.
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SecretsManagerSecretMonitoringProps(
            secret=secret,
            add_days_since_last_change_alarm=add_days_since_last_change_alarm,
            add_days_since_last_rotation_alarm=add_days_since_last_rotation_alarm,
            show_last_rotation_widget=show_last_rotation_widget,
            use_publisher=use_publisher,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSecretsManagerSecret", [props]))

    @jsii.member(jsii_name="monitorSimpleEc2Service")
    def monitor_simple_ec2_service(
        self,
        *,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param ec2_service: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SimpleEc2ServiceMonitoringProps(
            ec2_service=ec2_service,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSimpleEc2Service", [props]))

    @jsii.member(jsii_name="monitorSimpleFargateService")
    def monitor_simple_fargate_service(
        self,
        *,
        fargate_service: aws_cdk.aws_ecs.FargateService,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param fargate_service: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SimpleFargateServiceMonitoringProps(
            fargate_service=fargate_service,
            use_created_alarms=use_created_alarms,
            add_cpu_usage_alarm=add_cpu_usage_alarm,
            add_memory_usage_alarm=add_memory_usage_alarm,
            add_running_task_count_alarm=add_running_task_count_alarm,
            max_auto_scaling_task_count=max_auto_scaling_task_count,
            min_auto_scaling_task_count=min_auto_scaling_task_count,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSimpleFargateService", [props]))

    @jsii.member(jsii_name="monitorSnsTopic")
    def monitor_sns_topic(
        self,
        *,
        topic: aws_cdk.aws_sns.ITopic,
        add_max_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_message_notifications_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[NotificationsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param topic: 
        :param add_max_number_of_messages_published_alarm: 
        :param add_message_notifications_failed_alarm: 
        :param add_min_number_of_messages_published_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SnsTopicMonitoringProps(
            topic=topic,
            add_max_number_of_messages_published_alarm=add_max_number_of_messages_published_alarm,
            add_message_notifications_failed_alarm=add_message_notifications_failed_alarm,
            add_min_number_of_messages_published_alarm=add_min_number_of_messages_published_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSnsTopic", [props]))

    @jsii.member(jsii_name="monitorSqsQueue")
    def monitor_sqs_queue(
        self,
        *,
        queue: aws_cdk.aws_sqs.IQueue,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param queue: 
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SqsQueueMonitoringProps(
            queue=queue,
            add_queue_max_incoming_messages_alarm=add_queue_max_incoming_messages_alarm,
            add_queue_max_message_age_alarm=add_queue_max_message_age_alarm,
            add_queue_max_size_alarm=add_queue_max_size_alarm,
            add_queue_max_time_to_drain_messages_alarm=add_queue_max_time_to_drain_messages_alarm,
            add_queue_min_incoming_messages_alarm=add_queue_min_incoming_messages_alarm,
            add_queue_min_size_alarm=add_queue_min_size_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSqsQueue", [props]))

    @jsii.member(jsii_name="monitorSqsQueueWithDlq")
    def monitor_sqs_queue_with_dlq(
        self,
        *,
        dead_letter_queue: aws_cdk.aws_sqs.IQueue,
        add_dead_letter_queue_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        add_dead_letter_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        queue: aws_cdk.aws_sqs.IQueue,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param dead_letter_queue: 
        :param add_dead_letter_queue_to_summary_dashboard: (experimental) Indicates whether the DLQ monitoring should be added to summary dashboard. Default: - true
        :param add_dead_letter_queue_max_incoming_messages_alarm: (experimental) Alarm on the number of messages added to a queue. Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ as a result of a failed processing attempt.
        :param add_dead_letter_queue_max_message_age_alarm: 
        :param add_dead_letter_queue_max_size_alarm: 
        :param queue: 
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SqsQueueMonitoringWithDlqProps(
            dead_letter_queue=dead_letter_queue,
            add_dead_letter_queue_to_summary_dashboard=add_dead_letter_queue_to_summary_dashboard,
            add_dead_letter_queue_max_incoming_messages_alarm=add_dead_letter_queue_max_incoming_messages_alarm,
            add_dead_letter_queue_max_message_age_alarm=add_dead_letter_queue_max_message_age_alarm,
            add_dead_letter_queue_max_size_alarm=add_dead_letter_queue_max_size_alarm,
            queue=queue,
            add_queue_max_incoming_messages_alarm=add_queue_max_incoming_messages_alarm,
            add_queue_max_message_age_alarm=add_queue_max_message_age_alarm,
            add_queue_max_size_alarm=add_queue_max_size_alarm,
            add_queue_max_time_to_drain_messages_alarm=add_queue_max_time_to_drain_messages_alarm,
            add_queue_min_incoming_messages_alarm=add_queue_min_incoming_messages_alarm,
            add_queue_min_size_alarm=add_queue_min_size_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSqsQueueWithDlq", [props]))

    @jsii.member(jsii_name="monitorStepFunction")
    def monitor_step_function(
        self,
        *,
        state_machine: aws_cdk.aws_stepfunctions.IStateMachine,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add_aborted_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_started_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinRunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param state_machine: 
        :param rate_computation_method: Default: - average
        :param add_aborted_execution_count_alarm: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_execution_count_alarm: 
        :param add_failed_execution_rate_alarm: 
        :param add_min_started_execution_count_alarm: (experimental) Add minimum started execution count alarm for the stepfunctions.
        :param add_throttled_execution_count_alarm: 
        :param add_timed_out_execution_count_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = StepFunctionMonitoringProps(
            state_machine=state_machine,
            rate_computation_method=rate_computation_method,
            add_aborted_execution_count_alarm=add_aborted_execution_count_alarm,
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_execution_count_alarm=add_failed_execution_count_alarm,
            add_failed_execution_rate_alarm=add_failed_execution_rate_alarm,
            add_min_started_execution_count_alarm=add_min_started_execution_count_alarm,
            add_throttled_execution_count_alarm=add_throttled_execution_count_alarm,
            add_timed_out_execution_count_alarm=add_timed_out_execution_count_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorStepFunction", [props]))

    @jsii.member(jsii_name="monitorStepFunctionActivity")
    def monitor_step_function_activity(
        self,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        activity: aws_cdk.aws_stepfunctions.IActivity,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_activities_count_alarm: 
        :param add_failed_activities_rate_alarm: 
        :param add_timed_out_activities_count_alarm: 
        :param activity: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = StepFunctionActivityMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_activities_count_alarm=add_failed_activities_count_alarm,
            add_failed_activities_rate_alarm=add_failed_activities_rate_alarm,
            add_timed_out_activities_count_alarm=add_timed_out_activities_count_alarm,
            activity=activity,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorStepFunctionActivity", [props]))

    @jsii.member(jsii_name="monitorStepFunctionLambdaIntegration")
    def monitor_step_function_lambda_integration(
        self,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_functions_count_alarm: 
        :param add_failed_functions_rate_alarm: 
        :param add_timed_out_functions_count_alarm: 
        :param lambda_function: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = StepFunctionLambdaIntegrationMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_functions_count_alarm=add_failed_functions_count_alarm,
            add_failed_functions_rate_alarm=add_failed_functions_rate_alarm,
            add_timed_out_functions_count_alarm=add_timed_out_functions_count_alarm,
            lambda_function=lambda_function,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorStepFunctionLambdaIntegration", [props]))

    @jsii.member(jsii_name="monitorStepFunctionServiceIntegration")
    def monitor_step_function_service_integration(
        self,
        *,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        service_integration_resource_arn: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_service_integrations_count_alarm: 
        :param add_failed_service_integrations_rate_alarm: 
        :param add_timed_out_service_integrations_count_alarm: 
        :param service_integration_resource_arn: 
        :param rate_computation_method: Default: - average
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = StepFunctionServiceIntegrationMonitoringProps(
            add_duration_p50_alarm=add_duration_p50_alarm,
            add_duration_p90_alarm=add_duration_p90_alarm,
            add_duration_p99_alarm=add_duration_p99_alarm,
            add_failed_service_integrations_count_alarm=add_failed_service_integrations_count_alarm,
            add_failed_service_integrations_rate_alarm=add_failed_service_integrations_rate_alarm,
            add_timed_out_service_integrations_count_alarm=add_timed_out_service_integrations_count_alarm,
            service_integration_resource_arn=service_integration_resource_arn,
            rate_computation_method=rate_computation_method,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorStepFunctionServiceIntegration", [props]))

    @jsii.member(jsii_name="monitorSyntheticsCanary")
    def monitor_synthetics_canary(
        self,
        *,
        canary: aws_cdk.aws_synthetics_alpha.Canary,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        add4xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param canary: (experimental) CloudWatch Canary to monitor.
        :param rate_computation_method: (experimental) Method used to calculate relative rates. Default: - average
        :param add4xx_error_count_alarm: 
        :param add4xx_error_rate_alarm: 
        :param add5xx_fault_count_alarm: 
        :param add5xx_fault_rate_alarm: 
        :param add_average_latency_alarm: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = SyntheticsCanaryMonitoringProps(
            canary=canary,
            rate_computation_method=rate_computation_method,
            add4xx_error_count_alarm=add4xx_error_count_alarm,
            add4xx_error_rate_alarm=add4xx_error_rate_alarm,
            add5xx_fault_count_alarm=add5xx_fault_count_alarm,
            add5xx_fault_rate_alarm=add5xx_fault_rate_alarm,
            add_average_latency_alarm=add_average_latency_alarm,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorSyntheticsCanary", [props]))

    @jsii.member(jsii_name="monitorWebApplicationFirewallAclV2")
    def monitor_web_application_firewall_acl_v2(
        self,
        *,
        acl: aws_cdk.aws_wafv2.CfnWebACL,
        region: typing.Optional[builtins.str] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> "MonitoringFacade":
        '''
        :param acl: 
        :param region: 
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        props = WafV2MonitoringProps(
            acl=acl,
            region=region,
            use_created_alarms=use_created_alarms,
            alarm_friendly_name=alarm_friendly_name,
            human_readable_name=human_readable_name,
            local_alarm_name_prefix_override=local_alarm_name_prefix_override,
            add_to_alarm_dashboard=add_to_alarm_dashboard,
            add_to_detail_dashboard=add_to_detail_dashboard,
            add_to_summary_dashboard=add_to_summary_dashboard,
        )

        return typing.cast("MonitoringFacade", jsii.invoke(self, "monitorWebApplicationFirewallAclV2", [props]))

    @builtins.property
    @jsii.member(jsii_name="alarmFactoryDefaults")
    def _alarm_factory_defaults(self) -> AlarmFactoryDefaults:
        '''
        :stability: experimental
        '''
        return typing.cast(AlarmFactoryDefaults, jsii.get(self, "alarmFactoryDefaults"))

    @builtins.property
    @jsii.member(jsii_name="createdSegments")
    def _created_segments(self) -> typing.List[IDashboardSegment]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.List[IDashboardSegment], jsii.get(self, "createdSegments"))

    @builtins.property
    @jsii.member(jsii_name="metricFactoryDefaults")
    def _metric_factory_defaults(self) -> MetricFactoryDefaults:
        '''
        :stability: experimental
        '''
        return typing.cast(MetricFactoryDefaults, jsii.get(self, "metricFactoryDefaults"))

    @builtins.property
    @jsii.member(jsii_name="dashboardFactory")
    def _dashboard_factory(self) -> typing.Optional[IDashboardFactory]:
        '''
        :stability: experimental
        '''
        return typing.cast(typing.Optional[IDashboardFactory], jsii.get(self, "dashboardFactory"))


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.NameResolutionInput",
    jsii_struct_bases=[UserProvidedNames],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "fallback_construct_name": "fallbackConstructName",
        "named_construct": "namedConstruct",
    },
)
class NameResolutionInput(UserProvidedNames):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        fallback_construct_name: typing.Optional[builtins.str] = None,
        named_construct: typing.Optional[constructs.IConstruct] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param fallback_construct_name: (experimental) Fallback name before we fallback to extracting name from the construct itself. This might be some construct reference, such is cluster ID, stream name, and so on. Default: - use namedConstruct to extract the name
        :param named_construct: (experimental) Construct that this naming strategy is naming. It is used as a last resort for naming.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NameResolutionInput.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument fallback_construct_name", value=fallback_construct_name, expected_type=type_hints["fallback_construct_name"])
            check_type(argname="argument named_construct", value=named_construct, expected_type=type_hints["named_construct"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if fallback_construct_name is not None:
            self._values["fallback_construct_name"] = fallback_construct_name
        if named_construct is not None:
            self._values["named_construct"] = named_construct

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fallback_construct_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Fallback name before we fallback to extracting name from the construct itself.

        This might be some construct reference, such is cluster ID, stream name, and so on.

        :default: - use namedConstruct to extract the name

        :stability: experimental
        '''
        result = self._values.get("fallback_construct_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def named_construct(self) -> typing.Optional[constructs.IConstruct]:
        '''(experimental) Construct that this naming strategy is naming.

        It is used as a last resort for naming.

        :stability: experimental
        '''
        result = self._values.get("named_construct")
        return typing.cast(typing.Optional[constructs.IConstruct], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NameResolutionInput(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.NetworkLoadBalancerMonitoringProps",
    jsii_struct_bases=[NetworkLoadBalancerMetricFactoryProps, BaseMonitoringProps],
    name_mapping={
        "network_load_balancer": "networkLoadBalancer",
        "network_target_group": "networkTargetGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_healthy_task_count_alarm": "addHealthyTaskCountAlarm",
        "add_healthy_task_percent_alarm": "addHealthyTaskPercentAlarm",
        "add_min_processed_bytes_alarm": "addMinProcessedBytesAlarm",
        "add_unhealthy_task_count_alarm": "addUnhealthyTaskCountAlarm",
    },
)
class NetworkLoadBalancerMonitoringProps(
    NetworkLoadBalancerMetricFactoryProps,
    BaseMonitoringProps,
):
    def __init__(
        self,
        *,
        network_load_balancer: aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer,
        network_target_group: aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_healthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_healthy_task_percent_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HealthyTaskPercentThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_processed_bytes_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinProcessedBytesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_unhealthy_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UnhealthyTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param network_load_balancer: 
        :param network_target_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_healthy_task_count_alarm: 
        :param add_healthy_task_percent_alarm: 
        :param add_min_processed_bytes_alarm: 
        :param add_unhealthy_task_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(NetworkLoadBalancerMonitoringProps.__init__)
            check_type(argname="argument network_load_balancer", value=network_load_balancer, expected_type=type_hints["network_load_balancer"])
            check_type(argname="argument network_target_group", value=network_target_group, expected_type=type_hints["network_target_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_healthy_task_count_alarm", value=add_healthy_task_count_alarm, expected_type=type_hints["add_healthy_task_count_alarm"])
            check_type(argname="argument add_healthy_task_percent_alarm", value=add_healthy_task_percent_alarm, expected_type=type_hints["add_healthy_task_percent_alarm"])
            check_type(argname="argument add_min_processed_bytes_alarm", value=add_min_processed_bytes_alarm, expected_type=type_hints["add_min_processed_bytes_alarm"])
            check_type(argname="argument add_unhealthy_task_count_alarm", value=add_unhealthy_task_count_alarm, expected_type=type_hints["add_unhealthy_task_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "network_load_balancer": network_load_balancer,
            "network_target_group": network_target_group,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_healthy_task_count_alarm is not None:
            self._values["add_healthy_task_count_alarm"] = add_healthy_task_count_alarm
        if add_healthy_task_percent_alarm is not None:
            self._values["add_healthy_task_percent_alarm"] = add_healthy_task_percent_alarm
        if add_min_processed_bytes_alarm is not None:
            self._values["add_min_processed_bytes_alarm"] = add_min_processed_bytes_alarm
        if add_unhealthy_task_count_alarm is not None:
            self._values["add_unhealthy_task_count_alarm"] = add_unhealthy_task_count_alarm

    @builtins.property
    def network_load_balancer(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_load_balancer")
        assert result is not None, "Required property 'network_load_balancer' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkLoadBalancer, result)

    @builtins.property
    def network_target_group(
        self,
    ) -> aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("network_target_group")
        assert result is not None, "Required property 'network_target_group' is missing"
        return typing.cast(aws_cdk.aws_elasticloadbalancingv2.NetworkTargetGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_healthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskCountThreshold]], result)

    @builtins.property
    def add_healthy_task_percent_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_healthy_task_percent_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HealthyTaskPercentThreshold]], result)

    @builtins.property
    def add_min_processed_bytes_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_processed_bytes_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinProcessedBytesThreshold]], result)

    @builtins.property
    def add_unhealthy_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_unhealthy_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UnhealthyTaskCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cluster_automated_snapshot_failure_alarm": "addClusterAutomatedSnapshotFailureAlarm",
        "add_cluster_index_writes_blocked_alarm": "addClusterIndexWritesBlockedAlarm",
        "add_cluster_node_count_alarm": "addClusterNodeCountAlarm",
        "add_cluster_status_alarm": "addClusterStatusAlarm",
        "add_cpu_space_usage_alarm": "addCpuSpaceUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_indexing_latency_p50_alarm": "addIndexingLatencyP50Alarm",
        "add_indexing_latency_p90_alarm": "addIndexingLatencyP90Alarm",
        "add_indexing_latency_p99_alarm": "addIndexingLatencyP99Alarm",
        "add_jvm_memory_pressure_alarm": "addJvmMemoryPressureAlarm",
        "add_kms_key_error_alarm": "addKmsKeyErrorAlarm",
        "add_kms_key_inaccessible_alarm": "addKmsKeyInaccessibleAlarm",
        "add_master_cpu_space_usage_alarm": "addMasterCpuSpaceUsageAlarm",
        "add_master_jvm_memory_pressure_alarm": "addMasterJvmMemoryPressureAlarm",
        "add_search_latency_p50_alarm": "addSearchLatencyP50Alarm",
        "add_search_latency_p90_alarm": "addSearchLatencyP90Alarm",
        "add_search_latency_p99_alarm": "addSearchLatencyP99Alarm",
    },
)
class OpenSearchClusterMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cluster_automated_snapshot_failure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterAutomatedSnapshotFailureThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_index_writes_blocked_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterIndexWritesBlockedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_node_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterNodesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_status_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterStatusCustomization, typing.Dict[str, typing.Any]]]] = None,
        add_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_error_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyErrorThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_inaccessible_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyInaccessibleThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cluster_automated_snapshot_failure_alarm: 
        :param add_cluster_index_writes_blocked_alarm: 
        :param add_cluster_node_count_alarm: 
        :param add_cluster_status_alarm: 
        :param add_cpu_space_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_indexing_latency_p50_alarm: 
        :param add_indexing_latency_p90_alarm: 
        :param add_indexing_latency_p99_alarm: 
        :param add_jvm_memory_pressure_alarm: 
        :param add_kms_key_error_alarm: 
        :param add_kms_key_inaccessible_alarm: 
        :param add_master_cpu_space_usage_alarm: 
        :param add_master_jvm_memory_pressure_alarm: 
        :param add_search_latency_p50_alarm: 
        :param add_search_latency_p90_alarm: 
        :param add_search_latency_p99_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cluster_automated_snapshot_failure_alarm", value=add_cluster_automated_snapshot_failure_alarm, expected_type=type_hints["add_cluster_automated_snapshot_failure_alarm"])
            check_type(argname="argument add_cluster_index_writes_blocked_alarm", value=add_cluster_index_writes_blocked_alarm, expected_type=type_hints["add_cluster_index_writes_blocked_alarm"])
            check_type(argname="argument add_cluster_node_count_alarm", value=add_cluster_node_count_alarm, expected_type=type_hints["add_cluster_node_count_alarm"])
            check_type(argname="argument add_cluster_status_alarm", value=add_cluster_status_alarm, expected_type=type_hints["add_cluster_status_alarm"])
            check_type(argname="argument add_cpu_space_usage_alarm", value=add_cpu_space_usage_alarm, expected_type=type_hints["add_cpu_space_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_indexing_latency_p50_alarm", value=add_indexing_latency_p50_alarm, expected_type=type_hints["add_indexing_latency_p50_alarm"])
            check_type(argname="argument add_indexing_latency_p90_alarm", value=add_indexing_latency_p90_alarm, expected_type=type_hints["add_indexing_latency_p90_alarm"])
            check_type(argname="argument add_indexing_latency_p99_alarm", value=add_indexing_latency_p99_alarm, expected_type=type_hints["add_indexing_latency_p99_alarm"])
            check_type(argname="argument add_jvm_memory_pressure_alarm", value=add_jvm_memory_pressure_alarm, expected_type=type_hints["add_jvm_memory_pressure_alarm"])
            check_type(argname="argument add_kms_key_error_alarm", value=add_kms_key_error_alarm, expected_type=type_hints["add_kms_key_error_alarm"])
            check_type(argname="argument add_kms_key_inaccessible_alarm", value=add_kms_key_inaccessible_alarm, expected_type=type_hints["add_kms_key_inaccessible_alarm"])
            check_type(argname="argument add_master_cpu_space_usage_alarm", value=add_master_cpu_space_usage_alarm, expected_type=type_hints["add_master_cpu_space_usage_alarm"])
            check_type(argname="argument add_master_jvm_memory_pressure_alarm", value=add_master_jvm_memory_pressure_alarm, expected_type=type_hints["add_master_jvm_memory_pressure_alarm"])
            check_type(argname="argument add_search_latency_p50_alarm", value=add_search_latency_p50_alarm, expected_type=type_hints["add_search_latency_p50_alarm"])
            check_type(argname="argument add_search_latency_p90_alarm", value=add_search_latency_p90_alarm, expected_type=type_hints["add_search_latency_p90_alarm"])
            check_type(argname="argument add_search_latency_p99_alarm", value=add_search_latency_p99_alarm, expected_type=type_hints["add_search_latency_p99_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cluster_automated_snapshot_failure_alarm is not None:
            self._values["add_cluster_automated_snapshot_failure_alarm"] = add_cluster_automated_snapshot_failure_alarm
        if add_cluster_index_writes_blocked_alarm is not None:
            self._values["add_cluster_index_writes_blocked_alarm"] = add_cluster_index_writes_blocked_alarm
        if add_cluster_node_count_alarm is not None:
            self._values["add_cluster_node_count_alarm"] = add_cluster_node_count_alarm
        if add_cluster_status_alarm is not None:
            self._values["add_cluster_status_alarm"] = add_cluster_status_alarm
        if add_cpu_space_usage_alarm is not None:
            self._values["add_cpu_space_usage_alarm"] = add_cpu_space_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_indexing_latency_p50_alarm is not None:
            self._values["add_indexing_latency_p50_alarm"] = add_indexing_latency_p50_alarm
        if add_indexing_latency_p90_alarm is not None:
            self._values["add_indexing_latency_p90_alarm"] = add_indexing_latency_p90_alarm
        if add_indexing_latency_p99_alarm is not None:
            self._values["add_indexing_latency_p99_alarm"] = add_indexing_latency_p99_alarm
        if add_jvm_memory_pressure_alarm is not None:
            self._values["add_jvm_memory_pressure_alarm"] = add_jvm_memory_pressure_alarm
        if add_kms_key_error_alarm is not None:
            self._values["add_kms_key_error_alarm"] = add_kms_key_error_alarm
        if add_kms_key_inaccessible_alarm is not None:
            self._values["add_kms_key_inaccessible_alarm"] = add_kms_key_inaccessible_alarm
        if add_master_cpu_space_usage_alarm is not None:
            self._values["add_master_cpu_space_usage_alarm"] = add_master_cpu_space_usage_alarm
        if add_master_jvm_memory_pressure_alarm is not None:
            self._values["add_master_jvm_memory_pressure_alarm"] = add_master_jvm_memory_pressure_alarm
        if add_search_latency_p50_alarm is not None:
            self._values["add_search_latency_p50_alarm"] = add_search_latency_p50_alarm
        if add_search_latency_p90_alarm is not None:
            self._values["add_search_latency_p90_alarm"] = add_search_latency_p90_alarm
        if add_search_latency_p99_alarm is not None:
            self._values["add_search_latency_p99_alarm"] = add_search_latency_p99_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cluster_automated_snapshot_failure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterAutomatedSnapshotFailureThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_automated_snapshot_failure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterAutomatedSnapshotFailureThreshold]], result)

    @builtins.property
    def add_cluster_index_writes_blocked_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterIndexWritesBlockedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_index_writes_blocked_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterIndexWritesBlockedThreshold]], result)

    @builtins.property
    def add_cluster_node_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterNodesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_node_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterNodesThreshold]], result)

    @builtins.property
    def add_cluster_status_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterStatusCustomization]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_status_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterStatusCustomization]], result)

    @builtins.property
    def add_cpu_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_indexing_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_indexing_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_indexing_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_jvm_memory_pressure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_jvm_memory_pressure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_kms_key_error_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyErrorThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_kms_key_error_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyErrorThreshold]], result)

    @builtins.property
    def add_kms_key_inaccessible_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyInaccessibleThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_kms_key_inaccessible_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyInaccessibleThreshold]], result)

    @builtins.property
    def add_master_cpu_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_master_cpu_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_master_jvm_memory_pressure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_master_jvm_memory_pressure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_search_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_search_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_search_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.OpenSearchClusterMonitoringProps",
    jsii_struct_bases=[
        OpenSearchClusterMetricFactoryProps, OpenSearchClusterMonitoringOptions
    ],
    name_mapping={
        "domain": "domain",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cluster_automated_snapshot_failure_alarm": "addClusterAutomatedSnapshotFailureAlarm",
        "add_cluster_index_writes_blocked_alarm": "addClusterIndexWritesBlockedAlarm",
        "add_cluster_node_count_alarm": "addClusterNodeCountAlarm",
        "add_cluster_status_alarm": "addClusterStatusAlarm",
        "add_cpu_space_usage_alarm": "addCpuSpaceUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_indexing_latency_p50_alarm": "addIndexingLatencyP50Alarm",
        "add_indexing_latency_p90_alarm": "addIndexingLatencyP90Alarm",
        "add_indexing_latency_p99_alarm": "addIndexingLatencyP99Alarm",
        "add_jvm_memory_pressure_alarm": "addJvmMemoryPressureAlarm",
        "add_kms_key_error_alarm": "addKmsKeyErrorAlarm",
        "add_kms_key_inaccessible_alarm": "addKmsKeyInaccessibleAlarm",
        "add_master_cpu_space_usage_alarm": "addMasterCpuSpaceUsageAlarm",
        "add_master_jvm_memory_pressure_alarm": "addMasterJvmMemoryPressureAlarm",
        "add_search_latency_p50_alarm": "addSearchLatencyP50Alarm",
        "add_search_latency_p90_alarm": "addSearchLatencyP90Alarm",
        "add_search_latency_p99_alarm": "addSearchLatencyP99Alarm",
    },
)
class OpenSearchClusterMonitoringProps(
    OpenSearchClusterMetricFactoryProps,
    OpenSearchClusterMonitoringOptions,
):
    def __init__(
        self,
        *,
        domain: typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain],
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cluster_automated_snapshot_failure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterAutomatedSnapshotFailureThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_index_writes_blocked_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterIndexWritesBlockedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_node_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterNodesThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_cluster_status_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchClusterStatusCustomization, typing.Dict[str, typing.Any]]]] = None,
        add_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_indexing_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_error_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyErrorThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_kms_key_inaccessible_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[OpenSearchKmsKeyInaccessibleThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_cpu_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_master_jvm_memory_pressure_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_search_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param domain: 
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cluster_automated_snapshot_failure_alarm: 
        :param add_cluster_index_writes_blocked_alarm: 
        :param add_cluster_node_count_alarm: 
        :param add_cluster_status_alarm: 
        :param add_cpu_space_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_indexing_latency_p50_alarm: 
        :param add_indexing_latency_p90_alarm: 
        :param add_indexing_latency_p99_alarm: 
        :param add_jvm_memory_pressure_alarm: 
        :param add_kms_key_error_alarm: 
        :param add_kms_key_inaccessible_alarm: 
        :param add_master_cpu_space_usage_alarm: 
        :param add_master_jvm_memory_pressure_alarm: 
        :param add_search_latency_p50_alarm: 
        :param add_search_latency_p90_alarm: 
        :param add_search_latency_p99_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(OpenSearchClusterMonitoringProps.__init__)
            check_type(argname="argument domain", value=domain, expected_type=type_hints["domain"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cluster_automated_snapshot_failure_alarm", value=add_cluster_automated_snapshot_failure_alarm, expected_type=type_hints["add_cluster_automated_snapshot_failure_alarm"])
            check_type(argname="argument add_cluster_index_writes_blocked_alarm", value=add_cluster_index_writes_blocked_alarm, expected_type=type_hints["add_cluster_index_writes_blocked_alarm"])
            check_type(argname="argument add_cluster_node_count_alarm", value=add_cluster_node_count_alarm, expected_type=type_hints["add_cluster_node_count_alarm"])
            check_type(argname="argument add_cluster_status_alarm", value=add_cluster_status_alarm, expected_type=type_hints["add_cluster_status_alarm"])
            check_type(argname="argument add_cpu_space_usage_alarm", value=add_cpu_space_usage_alarm, expected_type=type_hints["add_cpu_space_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_indexing_latency_p50_alarm", value=add_indexing_latency_p50_alarm, expected_type=type_hints["add_indexing_latency_p50_alarm"])
            check_type(argname="argument add_indexing_latency_p90_alarm", value=add_indexing_latency_p90_alarm, expected_type=type_hints["add_indexing_latency_p90_alarm"])
            check_type(argname="argument add_indexing_latency_p99_alarm", value=add_indexing_latency_p99_alarm, expected_type=type_hints["add_indexing_latency_p99_alarm"])
            check_type(argname="argument add_jvm_memory_pressure_alarm", value=add_jvm_memory_pressure_alarm, expected_type=type_hints["add_jvm_memory_pressure_alarm"])
            check_type(argname="argument add_kms_key_error_alarm", value=add_kms_key_error_alarm, expected_type=type_hints["add_kms_key_error_alarm"])
            check_type(argname="argument add_kms_key_inaccessible_alarm", value=add_kms_key_inaccessible_alarm, expected_type=type_hints["add_kms_key_inaccessible_alarm"])
            check_type(argname="argument add_master_cpu_space_usage_alarm", value=add_master_cpu_space_usage_alarm, expected_type=type_hints["add_master_cpu_space_usage_alarm"])
            check_type(argname="argument add_master_jvm_memory_pressure_alarm", value=add_master_jvm_memory_pressure_alarm, expected_type=type_hints["add_master_jvm_memory_pressure_alarm"])
            check_type(argname="argument add_search_latency_p50_alarm", value=add_search_latency_p50_alarm, expected_type=type_hints["add_search_latency_p50_alarm"])
            check_type(argname="argument add_search_latency_p90_alarm", value=add_search_latency_p90_alarm, expected_type=type_hints["add_search_latency_p90_alarm"])
            check_type(argname="argument add_search_latency_p99_alarm", value=add_search_latency_p99_alarm, expected_type=type_hints["add_search_latency_p99_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "domain": domain,
        }
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cluster_automated_snapshot_failure_alarm is not None:
            self._values["add_cluster_automated_snapshot_failure_alarm"] = add_cluster_automated_snapshot_failure_alarm
        if add_cluster_index_writes_blocked_alarm is not None:
            self._values["add_cluster_index_writes_blocked_alarm"] = add_cluster_index_writes_blocked_alarm
        if add_cluster_node_count_alarm is not None:
            self._values["add_cluster_node_count_alarm"] = add_cluster_node_count_alarm
        if add_cluster_status_alarm is not None:
            self._values["add_cluster_status_alarm"] = add_cluster_status_alarm
        if add_cpu_space_usage_alarm is not None:
            self._values["add_cpu_space_usage_alarm"] = add_cpu_space_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_indexing_latency_p50_alarm is not None:
            self._values["add_indexing_latency_p50_alarm"] = add_indexing_latency_p50_alarm
        if add_indexing_latency_p90_alarm is not None:
            self._values["add_indexing_latency_p90_alarm"] = add_indexing_latency_p90_alarm
        if add_indexing_latency_p99_alarm is not None:
            self._values["add_indexing_latency_p99_alarm"] = add_indexing_latency_p99_alarm
        if add_jvm_memory_pressure_alarm is not None:
            self._values["add_jvm_memory_pressure_alarm"] = add_jvm_memory_pressure_alarm
        if add_kms_key_error_alarm is not None:
            self._values["add_kms_key_error_alarm"] = add_kms_key_error_alarm
        if add_kms_key_inaccessible_alarm is not None:
            self._values["add_kms_key_inaccessible_alarm"] = add_kms_key_inaccessible_alarm
        if add_master_cpu_space_usage_alarm is not None:
            self._values["add_master_cpu_space_usage_alarm"] = add_master_cpu_space_usage_alarm
        if add_master_jvm_memory_pressure_alarm is not None:
            self._values["add_master_jvm_memory_pressure_alarm"] = add_master_jvm_memory_pressure_alarm
        if add_search_latency_p50_alarm is not None:
            self._values["add_search_latency_p50_alarm"] = add_search_latency_p50_alarm
        if add_search_latency_p90_alarm is not None:
            self._values["add_search_latency_p90_alarm"] = add_search_latency_p90_alarm
        if add_search_latency_p99_alarm is not None:
            self._values["add_search_latency_p99_alarm"] = add_search_latency_p99_alarm

    @builtins.property
    def domain(
        self,
    ) -> typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain]:
        '''
        :stability: experimental
        '''
        result = self._values.get("domain")
        assert result is not None, "Required property 'domain' is missing"
        return typing.cast(typing.Union[aws_cdk.aws_elasticsearch.IDomain, aws_cdk.aws_elasticsearch.CfnDomain, aws_cdk.aws_opensearchservice.IDomain, aws_cdk.aws_opensearchservice.CfnDomain], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cluster_automated_snapshot_failure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterAutomatedSnapshotFailureThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_automated_snapshot_failure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterAutomatedSnapshotFailureThreshold]], result)

    @builtins.property
    def add_cluster_index_writes_blocked_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterIndexWritesBlockedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_index_writes_blocked_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterIndexWritesBlockedThreshold]], result)

    @builtins.property
    def add_cluster_node_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterNodesThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_node_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterNodesThreshold]], result)

    @builtins.property
    def add_cluster_status_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterStatusCustomization]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cluster_status_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchClusterStatusCustomization]], result)

    @builtins.property
    def add_cpu_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_indexing_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_indexing_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_indexing_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_indexing_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_jvm_memory_pressure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_jvm_memory_pressure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_kms_key_error_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyErrorThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_kms_key_error_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyErrorThreshold]], result)

    @builtins.property
    def add_kms_key_inaccessible_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyInaccessibleThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_kms_key_inaccessible_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, OpenSearchKmsKeyInaccessibleThreshold]], result)

    @builtins.property
    def add_master_cpu_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_master_cpu_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_master_jvm_memory_pressure_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_master_jvm_memory_pressure_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_search_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_search_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_search_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_search_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "OpenSearchClusterMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.QueueProcessingEc2ServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "ec2_service": "ec2Service",
        "add_dead_letter_queue_alarms": "addDeadLetterQueueAlarms",
        "add_queue_alarms": "addQueueAlarms",
        "add_service_alarms": "addServiceAlarms",
    },
)
class QueueProcessingEc2ServiceMonitoringProps(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        ec2_service: aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service,
        add_dead_letter_queue_alarms: typing.Optional[typing.Union[BaseDlqAlarms, typing.Dict[str, typing.Any]]] = None,
        add_queue_alarms: typing.Optional[typing.Union[BaseSqsQueueAlarms, typing.Dict[str, typing.Any]]] = None,
        add_service_alarms: typing.Optional[typing.Union[BaseFargateServiceAlarms, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param ec2_service: 
        :param add_dead_letter_queue_alarms: 
        :param add_queue_alarms: 
        :param add_service_alarms: 

        :stability: experimental
        '''
        if isinstance(add_dead_letter_queue_alarms, dict):
            add_dead_letter_queue_alarms = BaseDlqAlarms(**add_dead_letter_queue_alarms)
        if isinstance(add_queue_alarms, dict):
            add_queue_alarms = BaseSqsQueueAlarms(**add_queue_alarms)
        if isinstance(add_service_alarms, dict):
            add_service_alarms = BaseFargateServiceAlarms(**add_service_alarms)
        if __debug__:
            type_hints = typing.get_type_hints(QueueProcessingEc2ServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
            check_type(argname="argument add_dead_letter_queue_alarms", value=add_dead_letter_queue_alarms, expected_type=type_hints["add_dead_letter_queue_alarms"])
            check_type(argname="argument add_queue_alarms", value=add_queue_alarms, expected_type=type_hints["add_queue_alarms"])
            check_type(argname="argument add_service_alarms", value=add_service_alarms, expected_type=type_hints["add_service_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_dead_letter_queue_alarms is not None:
            self._values["add_dead_letter_queue_alarms"] = add_dead_letter_queue_alarms
        if add_queue_alarms is not None:
            self._values["add_queue_alarms"] = add_queue_alarms
        if add_service_alarms is not None:
            self._values["add_service_alarms"] = add_service_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def ec2_service(self) -> aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(aws_cdk.aws_ecs_patterns.QueueProcessingEc2Service, result)

    @builtins.property
    def add_dead_letter_queue_alarms(self) -> typing.Optional[BaseDlqAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_alarms")
        return typing.cast(typing.Optional[BaseDlqAlarms], result)

    @builtins.property
    def add_queue_alarms(self) -> typing.Optional[BaseSqsQueueAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_alarms")
        return typing.cast(typing.Optional[BaseSqsQueueAlarms], result)

    @builtins.property
    def add_service_alarms(self) -> typing.Optional[BaseFargateServiceAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_service_alarms")
        return typing.cast(typing.Optional[BaseFargateServiceAlarms], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "QueueProcessingEc2ServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.QueueProcessingFargateServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "fargate_service": "fargateService",
        "add_dead_letter_queue_alarms": "addDeadLetterQueueAlarms",
        "add_queue_alarms": "addQueueAlarms",
        "add_service_alarms": "addServiceAlarms",
    },
)
class QueueProcessingFargateServiceMonitoringProps(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        fargate_service: aws_cdk.aws_ecs_patterns.QueueProcessingFargateService,
        add_dead_letter_queue_alarms: typing.Optional[typing.Union[BaseDlqAlarms, typing.Dict[str, typing.Any]]] = None,
        add_queue_alarms: typing.Optional[typing.Union[BaseSqsQueueAlarms, typing.Dict[str, typing.Any]]] = None,
        add_service_alarms: typing.Optional[typing.Union[BaseFargateServiceAlarms, typing.Dict[str, typing.Any]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param fargate_service: 
        :param add_dead_letter_queue_alarms: 
        :param add_queue_alarms: 
        :param add_service_alarms: 

        :stability: experimental
        '''
        if isinstance(add_dead_letter_queue_alarms, dict):
            add_dead_letter_queue_alarms = BaseDlqAlarms(**add_dead_letter_queue_alarms)
        if isinstance(add_queue_alarms, dict):
            add_queue_alarms = BaseSqsQueueAlarms(**add_queue_alarms)
        if isinstance(add_service_alarms, dict):
            add_service_alarms = BaseFargateServiceAlarms(**add_service_alarms)
        if __debug__:
            type_hints = typing.get_type_hints(QueueProcessingFargateServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
            check_type(argname="argument add_dead_letter_queue_alarms", value=add_dead_letter_queue_alarms, expected_type=type_hints["add_dead_letter_queue_alarms"])
            check_type(argname="argument add_queue_alarms", value=add_queue_alarms, expected_type=type_hints["add_queue_alarms"])
            check_type(argname="argument add_service_alarms", value=add_service_alarms, expected_type=type_hints["add_service_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_dead_letter_queue_alarms is not None:
            self._values["add_dead_letter_queue_alarms"] = add_dead_letter_queue_alarms
        if add_queue_alarms is not None:
            self._values["add_queue_alarms"] = add_queue_alarms
        if add_service_alarms is not None:
            self._values["add_service_alarms"] = add_service_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def fargate_service(self) -> aws_cdk.aws_ecs_patterns.QueueProcessingFargateService:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(aws_cdk.aws_ecs_patterns.QueueProcessingFargateService, result)

    @builtins.property
    def add_dead_letter_queue_alarms(self) -> typing.Optional[BaseDlqAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_alarms")
        return typing.cast(typing.Optional[BaseDlqAlarms], result)

    @builtins.property
    def add_queue_alarms(self) -> typing.Optional[BaseSqsQueueAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_alarms")
        return typing.cast(typing.Optional[BaseSqsQueueAlarms], result)

    @builtins.property
    def add_service_alarms(self) -> typing.Optional[BaseFargateServiceAlarms]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_service_alarms")
        return typing.cast(typing.Optional[BaseFargateServiceAlarms], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "QueueProcessingFargateServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RdsClusterMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_max_connection_count_alarm": "addMaxConnectionCountAlarm",
        "add_min_connection_count_alarm": "addMinConnectionCountAlarm",
    },
)
class RdsClusterMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_min_connection_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_max_connection_count_alarm", value=add_max_connection_count_alarm, expected_type=type_hints["add_max_connection_count_alarm"])
            check_type(argname="argument add_min_connection_count_alarm", value=add_min_connection_count_alarm, expected_type=type_hints["add_min_connection_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_max_connection_count_alarm is not None:
            self._values["add_max_connection_count_alarm"] = add_max_connection_count_alarm
        if add_min_connection_count_alarm is not None:
            self._values["add_min_connection_count_alarm"] = add_min_connection_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]], result)

    @builtins.property
    def add_min_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsClusterMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RdsClusterMonitoringProps",
    jsii_struct_bases=[RdsClusterMetricFactoryProps, RdsClusterMonitoringOptions],
    name_mapping={
        "cluster": "cluster",
        "cluster_identifier": "clusterIdentifier",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_max_connection_count_alarm": "addMaxConnectionCountAlarm",
        "add_min_connection_count_alarm": "addMinConnectionCountAlarm",
    },
)
class RdsClusterMonitoringProps(
    RdsClusterMetricFactoryProps,
    RdsClusterMonitoringOptions,
):
    def __init__(
        self,
        *,
        cluster: typing.Optional[aws_cdk.aws_rds.IDatabaseCluster] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param cluster: (experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).
        :param cluster_identifier: (deprecated) database cluster identifier (either this or ``cluster`` need to be specified).
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_min_connection_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RdsClusterMonitoringProps.__init__)
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_max_connection_count_alarm", value=add_max_connection_count_alarm, expected_type=type_hints["add_max_connection_count_alarm"])
            check_type(argname="argument add_min_connection_count_alarm", value=add_min_connection_count_alarm, expected_type=type_hints["add_min_connection_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if cluster is not None:
            self._values["cluster"] = cluster
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_max_connection_count_alarm is not None:
            self._values["add_max_connection_count_alarm"] = add_max_connection_count_alarm
        if add_min_connection_count_alarm is not None:
            self._values["add_min_connection_count_alarm"] = add_min_connection_count_alarm

    @builtins.property
    def cluster(self) -> typing.Optional[aws_cdk.aws_rds.IDatabaseCluster]:
        '''(experimental) database cluster (either this or ``clusterIdentifier`` need to be specified).

        :stability: experimental
        '''
        result = self._values.get("cluster")
        return typing.cast(typing.Optional[aws_cdk.aws_rds.IDatabaseCluster], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''(deprecated) database cluster identifier (either this or ``cluster`` need to be specified).

        :deprecated: please use ``cluster`` instead

        :stability: deprecated
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]], result)

    @builtins.property
    def add_min_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsClusterMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RedshiftClusterMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_max_connection_count_alarm": "addMaxConnectionCountAlarm",
        "add_max_long_query_duration_alarm": "addMaxLongQueryDurationAlarm",
        "add_min_connection_count_alarm": "addMinConnectionCountAlarm",
    },
)
class RedshiftClusterMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_long_query_duration_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_max_long_query_duration_alarm: 
        :param add_min_connection_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_max_connection_count_alarm", value=add_max_connection_count_alarm, expected_type=type_hints["add_max_connection_count_alarm"])
            check_type(argname="argument add_max_long_query_duration_alarm", value=add_max_long_query_duration_alarm, expected_type=type_hints["add_max_long_query_duration_alarm"])
            check_type(argname="argument add_min_connection_count_alarm", value=add_min_connection_count_alarm, expected_type=type_hints["add_min_connection_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_max_connection_count_alarm is not None:
            self._values["add_max_connection_count_alarm"] = add_max_connection_count_alarm
        if add_max_long_query_duration_alarm is not None:
            self._values["add_max_long_query_duration_alarm"] = add_max_long_query_duration_alarm
        if add_min_connection_count_alarm is not None:
            self._values["add_min_connection_count_alarm"] = add_min_connection_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]], result)

    @builtins.property
    def add_max_long_query_duration_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_long_query_duration_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_min_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RedshiftClusterMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.RedshiftClusterMonitoringProps",
    jsii_struct_bases=[
        RedshiftClusterMetricFactoryProps, RedshiftClusterMonitoringOptions
    ],
    name_mapping={
        "cluster_identifier": "clusterIdentifier",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_disk_space_usage_alarm": "addDiskSpaceUsageAlarm",
        "add_max_connection_count_alarm": "addMaxConnectionCountAlarm",
        "add_max_long_query_duration_alarm": "addMaxLongQueryDurationAlarm",
        "add_min_connection_count_alarm": "addMinConnectionCountAlarm",
    },
)
class RedshiftClusterMonitoringProps(
    RedshiftClusterMetricFactoryProps,
    RedshiftClusterMonitoringOptions,
):
    def __init__(
        self,
        *,
        cluster_identifier: builtins.str,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_disk_space_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_max_long_query_duration_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_connection_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowConnectionCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param cluster_identifier: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_disk_space_usage_alarm: 
        :param add_max_connection_count_alarm: 
        :param add_max_long_query_duration_alarm: 
        :param add_min_connection_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(RedshiftClusterMonitoringProps.__init__)
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_disk_space_usage_alarm", value=add_disk_space_usage_alarm, expected_type=type_hints["add_disk_space_usage_alarm"])
            check_type(argname="argument add_max_connection_count_alarm", value=add_max_connection_count_alarm, expected_type=type_hints["add_max_connection_count_alarm"])
            check_type(argname="argument add_max_long_query_duration_alarm", value=add_max_long_query_duration_alarm, expected_type=type_hints["add_max_long_query_duration_alarm"])
            check_type(argname="argument add_min_connection_count_alarm", value=add_min_connection_count_alarm, expected_type=type_hints["add_min_connection_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "cluster_identifier": cluster_identifier,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_disk_space_usage_alarm is not None:
            self._values["add_disk_space_usage_alarm"] = add_disk_space_usage_alarm
        if add_max_connection_count_alarm is not None:
            self._values["add_max_connection_count_alarm"] = add_max_connection_count_alarm
        if add_max_long_query_duration_alarm is not None:
            self._values["add_max_long_query_duration_alarm"] = add_max_long_query_duration_alarm
        if add_min_connection_count_alarm is not None:
            self._values["add_min_connection_count_alarm"] = add_min_connection_count_alarm

    @builtins.property
    def cluster_identifier(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("cluster_identifier")
        assert result is not None, "Required property 'cluster_identifier' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_disk_space_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_disk_space_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_max_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighConnectionCountThreshold]], result)

    @builtins.property
    def add_max_long_query_duration_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_long_query_duration_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_min_connection_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_connection_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowConnectionCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RedshiftClusterMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.S3BucketMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class S3BucketMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(S3BucketMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3BucketMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.S3BucketMonitoringProps",
    jsii_struct_bases=[S3BucketMetricFactoryProps, S3BucketMonitoringOptions],
    name_mapping={
        "bucket": "bucket",
        "storage_type": "storageType",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class S3BucketMonitoringProps(S3BucketMetricFactoryProps, S3BucketMonitoringOptions):
    def __init__(
        self,
        *,
        bucket: aws_cdk.aws_s3.IBucket,
        storage_type: typing.Optional[StorageType] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param bucket: 
        :param storage_type: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(S3BucketMonitoringProps.__init__)
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
            check_type(argname="argument storage_type", value=storage_type, expected_type=type_hints["storage_type"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "bucket": bucket,
        }
        if storage_type is not None:
            self._values["storage_type"] = storage_type
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def bucket(self) -> aws_cdk.aws_s3.IBucket:
        '''
        :stability: experimental
        '''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(aws_cdk.aws_s3.IBucket, result)

    @builtins.property
    def storage_type(self) -> typing.Optional[StorageType]:
        '''
        :stability: experimental
        '''
        result = self._values.get("storage_type")
        return typing.cast(typing.Optional[StorageType], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3BucketMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SecretsManagerSecretMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_days_since_last_change_alarm": "addDaysSinceLastChangeAlarm",
        "add_days_since_last_rotation_alarm": "addDaysSinceLastRotationAlarm",
        "show_last_rotation_widget": "showLastRotationWidget",
        "use_publisher": "usePublisher",
    },
)
class SecretsManagerSecretMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_days_since_last_change_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_days_since_last_rotation_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        show_last_rotation_widget: typing.Optional[builtins.bool] = None,
        use_publisher: typing.Optional[IPublisherConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_days_since_last_change_alarm: 
        :param add_days_since_last_rotation_alarm: 
        :param show_last_rotation_widget: Default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.
        :param use_publisher: (experimental) Provides access to the underlying metrics publisher Lambda function. This may be useful if you want to monitor the function itself.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_days_since_last_change_alarm", value=add_days_since_last_change_alarm, expected_type=type_hints["add_days_since_last_change_alarm"])
            check_type(argname="argument add_days_since_last_rotation_alarm", value=add_days_since_last_rotation_alarm, expected_type=type_hints["add_days_since_last_rotation_alarm"])
            check_type(argname="argument show_last_rotation_widget", value=show_last_rotation_widget, expected_type=type_hints["show_last_rotation_widget"])
            check_type(argname="argument use_publisher", value=use_publisher, expected_type=type_hints["use_publisher"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_days_since_last_change_alarm is not None:
            self._values["add_days_since_last_change_alarm"] = add_days_since_last_change_alarm
        if add_days_since_last_rotation_alarm is not None:
            self._values["add_days_since_last_rotation_alarm"] = add_days_since_last_rotation_alarm
        if show_last_rotation_widget is not None:
            self._values["show_last_rotation_widget"] = show_last_rotation_widget
        if use_publisher is not None:
            self._values["use_publisher"] = use_publisher

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_days_since_last_change_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_since_last_change_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]], result)

    @builtins.property
    def add_days_since_last_rotation_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_since_last_rotation_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]], result)

    @builtins.property
    def show_last_rotation_widget(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.

        :stability: experimental
        '''
        result = self._values.get("show_last_rotation_widget")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_publisher(self) -> typing.Optional[IPublisherConsumer]:
        '''(experimental) Provides access to the underlying metrics publisher Lambda function.

        This may be useful if you want to monitor the function itself.

        :stability: experimental
        '''
        result = self._values.get("use_publisher")
        return typing.cast(typing.Optional[IPublisherConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretsManagerSecretMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SecretsManagerSecretMonitoringProps",
    jsii_struct_bases=[
        SecretsManagerSecretMetricFactoryProps, SecretsManagerSecretMonitoringOptions
    ],
    name_mapping={
        "secret": "secret",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_days_since_last_change_alarm": "addDaysSinceLastChangeAlarm",
        "add_days_since_last_rotation_alarm": "addDaysSinceLastRotationAlarm",
        "show_last_rotation_widget": "showLastRotationWidget",
        "use_publisher": "usePublisher",
    },
)
class SecretsManagerSecretMonitoringProps(
    SecretsManagerSecretMetricFactoryProps,
    SecretsManagerSecretMonitoringOptions,
):
    def __init__(
        self,
        *,
        secret: aws_cdk.aws_secretsmanager.ISecret,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_days_since_last_change_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_days_since_last_rotation_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DaysSinceUpdateThreshold, typing.Dict[str, typing.Any]]]] = None,
        show_last_rotation_widget: typing.Optional[builtins.bool] = None,
        use_publisher: typing.Optional[IPublisherConsumer] = None,
    ) -> None:
        '''(experimental) Monitoring props for Secrets Manager secrets.

        :param secret: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_days_since_last_change_alarm: 
        :param add_days_since_last_rotation_alarm: 
        :param show_last_rotation_widget: Default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.
        :param use_publisher: (experimental) Provides access to the underlying metrics publisher Lambda function. This may be useful if you want to monitor the function itself.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SecretsManagerSecretMonitoringProps.__init__)
            check_type(argname="argument secret", value=secret, expected_type=type_hints["secret"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_days_since_last_change_alarm", value=add_days_since_last_change_alarm, expected_type=type_hints["add_days_since_last_change_alarm"])
            check_type(argname="argument add_days_since_last_rotation_alarm", value=add_days_since_last_rotation_alarm, expected_type=type_hints["add_days_since_last_rotation_alarm"])
            check_type(argname="argument show_last_rotation_widget", value=show_last_rotation_widget, expected_type=type_hints["show_last_rotation_widget"])
            check_type(argname="argument use_publisher", value=use_publisher, expected_type=type_hints["use_publisher"])
        self._values: typing.Dict[str, typing.Any] = {
            "secret": secret,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_days_since_last_change_alarm is not None:
            self._values["add_days_since_last_change_alarm"] = add_days_since_last_change_alarm
        if add_days_since_last_rotation_alarm is not None:
            self._values["add_days_since_last_rotation_alarm"] = add_days_since_last_rotation_alarm
        if show_last_rotation_widget is not None:
            self._values["show_last_rotation_widget"] = show_last_rotation_widget
        if use_publisher is not None:
            self._values["use_publisher"] = use_publisher

    @builtins.property
    def secret(self) -> aws_cdk.aws_secretsmanager.ISecret:
        '''
        :stability: experimental
        '''
        result = self._values.get("secret")
        assert result is not None, "Required property 'secret' is missing"
        return typing.cast(aws_cdk.aws_secretsmanager.ISecret, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_days_since_last_change_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_since_last_change_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]], result)

    @builtins.property
    def add_days_since_last_rotation_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_days_since_last_rotation_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DaysSinceUpdateThreshold]], result)

    @builtins.property
    def show_last_rotation_widget(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true, if ``addDaysSinceLastRotationAlarm`` is set, otherwise ``false``.

        :stability: experimental
        '''
        result = self._values.get("show_last_rotation_widget")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_publisher(self) -> typing.Optional[IPublisherConsumer]:
        '''(experimental) Provides access to the underlying metrics publisher Lambda function.

        This may be useful if you want to monitor the function itself.

        :stability: experimental
        '''
        result = self._values.get("use_publisher")
        return typing.cast(typing.Optional[IPublisherConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SecretsManagerSecretMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SimpleEc2ServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseEc2ServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "ec2_service": "ec2Service",
    },
)
class SimpleEc2ServiceMonitoringProps(BaseMonitoringProps, BaseEc2ServiceAlarms):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        ec2_service: aws_cdk.aws_ecs.Ec2Service,
    ) -> None:
        '''(experimental) Monitoring props for Simple EC2 service.

        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param ec2_service: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SimpleEc2ServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument ec2_service", value=ec2_service, expected_type=type_hints["ec2_service"])
        self._values: typing.Dict[str, typing.Any] = {
            "ec2_service": ec2_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ec2_service(self) -> aws_cdk.aws_ecs.Ec2Service:
        '''
        :stability: experimental
        '''
        result = self._values.get("ec2_service")
        assert result is not None, "Required property 'ec2_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.Ec2Service, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SimpleEc2ServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SimpleFargateServiceMonitoringProps",
    jsii_struct_bases=[BaseMonitoringProps, BaseFargateServiceAlarms],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_cpu_usage_alarm": "addCpuUsageAlarm",
        "add_memory_usage_alarm": "addMemoryUsageAlarm",
        "add_running_task_count_alarm": "addRunningTaskCountAlarm",
        "max_auto_scaling_task_count": "maxAutoScalingTaskCount",
        "min_auto_scaling_task_count": "minAutoScalingTaskCount",
        "fargate_service": "fargateService",
    },
)
class SimpleFargateServiceMonitoringProps(
    BaseMonitoringProps,
    BaseFargateServiceAlarms,
):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_cpu_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_memory_usage_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[UsageThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_running_task_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[RunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        max_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        min_auto_scaling_task_count: typing.Optional[jsii.Number] = None,
        fargate_service: aws_cdk.aws_ecs.FargateService,
    ) -> None:
        '''(experimental) Monitoring props for Simple Fargate service.

        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_cpu_usage_alarm: 
        :param add_memory_usage_alarm: 
        :param add_running_task_count_alarm: (experimental) Container Insights needs to be enabled for the cluster for this alarm.
        :param max_auto_scaling_task_count: (experimental) maximum number of tasks, as specified in your auto scaling config.
        :param min_auto_scaling_task_count: (experimental) minimum number of tasks, as specified in your auto scaling config.
        :param fargate_service: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SimpleFargateServiceMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_cpu_usage_alarm", value=add_cpu_usage_alarm, expected_type=type_hints["add_cpu_usage_alarm"])
            check_type(argname="argument add_memory_usage_alarm", value=add_memory_usage_alarm, expected_type=type_hints["add_memory_usage_alarm"])
            check_type(argname="argument add_running_task_count_alarm", value=add_running_task_count_alarm, expected_type=type_hints["add_running_task_count_alarm"])
            check_type(argname="argument max_auto_scaling_task_count", value=max_auto_scaling_task_count, expected_type=type_hints["max_auto_scaling_task_count"])
            check_type(argname="argument min_auto_scaling_task_count", value=min_auto_scaling_task_count, expected_type=type_hints["min_auto_scaling_task_count"])
            check_type(argname="argument fargate_service", value=fargate_service, expected_type=type_hints["fargate_service"])
        self._values: typing.Dict[str, typing.Any] = {
            "fargate_service": fargate_service,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_cpu_usage_alarm is not None:
            self._values["add_cpu_usage_alarm"] = add_cpu_usage_alarm
        if add_memory_usage_alarm is not None:
            self._values["add_memory_usage_alarm"] = add_memory_usage_alarm
        if add_running_task_count_alarm is not None:
            self._values["add_running_task_count_alarm"] = add_running_task_count_alarm
        if max_auto_scaling_task_count is not None:
            self._values["max_auto_scaling_task_count"] = max_auto_scaling_task_count
        if min_auto_scaling_task_count is not None:
            self._values["min_auto_scaling_task_count"] = min_auto_scaling_task_count

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_cpu_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_cpu_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_memory_usage_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, UsageThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_memory_usage_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, UsageThreshold]], result)

    @builtins.property
    def add_running_task_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]]:
        '''(experimental) Container Insights needs to be enabled for the cluster for this alarm.

        :stability: experimental
        '''
        result = self._values.get("add_running_task_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, RunningTaskCountThreshold]], result)

    @builtins.property
    def max_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) maximum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("max_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_auto_scaling_task_count(self) -> typing.Optional[jsii.Number]:
        '''(experimental) minimum number of tasks, as specified in your auto scaling config.

        :stability: experimental
        '''
        result = self._values.get("min_auto_scaling_task_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def fargate_service(self) -> aws_cdk.aws_ecs.FargateService:
        '''
        :stability: experimental
        '''
        result = self._values.get("fargate_service")
        assert result is not None, "Required property 'fargate_service' is missing"
        return typing.cast(aws_cdk.aws_ecs.FargateService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SimpleFargateServiceMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SnsTopicMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_max_number_of_messages_published_alarm": "addMaxNumberOfMessagesPublishedAlarm",
        "add_message_notifications_failed_alarm": "addMessageNotificationsFailedAlarm",
        "add_min_number_of_messages_published_alarm": "addMinNumberOfMessagesPublishedAlarm",
    },
)
class SnsTopicMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_max_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_message_notifications_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[NotificationsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_max_number_of_messages_published_alarm: 
        :param add_message_notifications_failed_alarm: 
        :param add_min_number_of_messages_published_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_max_number_of_messages_published_alarm", value=add_max_number_of_messages_published_alarm, expected_type=type_hints["add_max_number_of_messages_published_alarm"])
            check_type(argname="argument add_message_notifications_failed_alarm", value=add_message_notifications_failed_alarm, expected_type=type_hints["add_message_notifications_failed_alarm"])
            check_type(argname="argument add_min_number_of_messages_published_alarm", value=add_min_number_of_messages_published_alarm, expected_type=type_hints["add_min_number_of_messages_published_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_max_number_of_messages_published_alarm is not None:
            self._values["add_max_number_of_messages_published_alarm"] = add_max_number_of_messages_published_alarm
        if add_message_notifications_failed_alarm is not None:
            self._values["add_message_notifications_failed_alarm"] = add_message_notifications_failed_alarm
        if add_min_number_of_messages_published_alarm is not None:
            self._values["add_min_number_of_messages_published_alarm"] = add_min_number_of_messages_published_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_max_number_of_messages_published_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighMessagesPublishedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_number_of_messages_published_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighMessagesPublishedThreshold]], result)

    @builtins.property
    def add_message_notifications_failed_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, NotificationsFailedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_message_notifications_failed_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, NotificationsFailedThreshold]], result)

    @builtins.property
    def add_min_number_of_messages_published_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowMessagesPublishedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_number_of_messages_published_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowMessagesPublishedThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsTopicMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SnsTopicMonitoringProps",
    jsii_struct_bases=[SnsTopicMetricFactoryProps, SnsTopicMonitoringOptions],
    name_mapping={
        "topic": "topic",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_max_number_of_messages_published_alarm": "addMaxNumberOfMessagesPublishedAlarm",
        "add_message_notifications_failed_alarm": "addMessageNotificationsFailedAlarm",
        "add_min_number_of_messages_published_alarm": "addMinNumberOfMessagesPublishedAlarm",
    },
)
class SnsTopicMonitoringProps(SnsTopicMetricFactoryProps, SnsTopicMonitoringOptions):
    def __init__(
        self,
        *,
        topic: aws_cdk.aws_sns.ITopic,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_max_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_message_notifications_failed_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[NotificationsFailedThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_number_of_messages_published_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowMessagesPublishedThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param topic: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_max_number_of_messages_published_alarm: 
        :param add_message_notifications_failed_alarm: 
        :param add_min_number_of_messages_published_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SnsTopicMonitoringProps.__init__)
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_max_number_of_messages_published_alarm", value=add_max_number_of_messages_published_alarm, expected_type=type_hints["add_max_number_of_messages_published_alarm"])
            check_type(argname="argument add_message_notifications_failed_alarm", value=add_message_notifications_failed_alarm, expected_type=type_hints["add_message_notifications_failed_alarm"])
            check_type(argname="argument add_min_number_of_messages_published_alarm", value=add_min_number_of_messages_published_alarm, expected_type=type_hints["add_min_number_of_messages_published_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "topic": topic,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_max_number_of_messages_published_alarm is not None:
            self._values["add_max_number_of_messages_published_alarm"] = add_max_number_of_messages_published_alarm
        if add_message_notifications_failed_alarm is not None:
            self._values["add_message_notifications_failed_alarm"] = add_message_notifications_failed_alarm
        if add_min_number_of_messages_published_alarm is not None:
            self._values["add_min_number_of_messages_published_alarm"] = add_min_number_of_messages_published_alarm

    @builtins.property
    def topic(self) -> aws_cdk.aws_sns.ITopic:
        '''
        :stability: experimental
        '''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(aws_cdk.aws_sns.ITopic, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_max_number_of_messages_published_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighMessagesPublishedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_max_number_of_messages_published_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighMessagesPublishedThreshold]], result)

    @builtins.property
    def add_message_notifications_failed_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, NotificationsFailedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_message_notifications_failed_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, NotificationsFailedThreshold]], result)

    @builtins.property
    def add_min_number_of_messages_published_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowMessagesPublishedThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_min_number_of_messages_published_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowMessagesPublishedThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsTopicMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SqsQueueMonitoringOptions",
    jsii_struct_bases=[BaseSqsQueueAlarms, BaseMonitoringProps],
    name_mapping={
        "add_queue_max_incoming_messages_alarm": "addQueueMaxIncomingMessagesAlarm",
        "add_queue_max_message_age_alarm": "addQueueMaxMessageAgeAlarm",
        "add_queue_max_size_alarm": "addQueueMaxSizeAlarm",
        "add_queue_max_time_to_drain_messages_alarm": "addQueueMaxTimeToDrainMessagesAlarm",
        "add_queue_min_incoming_messages_alarm": "addQueueMinIncomingMessagesAlarm",
        "add_queue_min_size_alarm": "addQueueMinSizeAlarm",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class SqsQueueMonitoringOptions(BaseSqsQueueAlarms, BaseMonitoringProps):
    def __init__(
        self,
        *,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringOptions.__init__)
            check_type(argname="argument add_queue_max_incoming_messages_alarm", value=add_queue_max_incoming_messages_alarm, expected_type=type_hints["add_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_queue_max_message_age_alarm", value=add_queue_max_message_age_alarm, expected_type=type_hints["add_queue_max_message_age_alarm"])
            check_type(argname="argument add_queue_max_size_alarm", value=add_queue_max_size_alarm, expected_type=type_hints["add_queue_max_size_alarm"])
            check_type(argname="argument add_queue_max_time_to_drain_messages_alarm", value=add_queue_max_time_to_drain_messages_alarm, expected_type=type_hints["add_queue_max_time_to_drain_messages_alarm"])
            check_type(argname="argument add_queue_min_incoming_messages_alarm", value=add_queue_min_incoming_messages_alarm, expected_type=type_hints["add_queue_min_incoming_messages_alarm"])
            check_type(argname="argument add_queue_min_size_alarm", value=add_queue_min_size_alarm, expected_type=type_hints["add_queue_min_size_alarm"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if add_queue_max_incoming_messages_alarm is not None:
            self._values["add_queue_max_incoming_messages_alarm"] = add_queue_max_incoming_messages_alarm
        if add_queue_max_message_age_alarm is not None:
            self._values["add_queue_max_message_age_alarm"] = add_queue_max_message_age_alarm
        if add_queue_max_size_alarm is not None:
            self._values["add_queue_max_size_alarm"] = add_queue_max_size_alarm
        if add_queue_max_time_to_drain_messages_alarm is not None:
            self._values["add_queue_max_time_to_drain_messages_alarm"] = add_queue_max_time_to_drain_messages_alarm
        if add_queue_min_incoming_messages_alarm is not None:
            self._values["add_queue_min_incoming_messages_alarm"] = add_queue_min_incoming_messages_alarm
        if add_queue_min_size_alarm is not None:
            self._values["add_queue_min_size_alarm"] = add_queue_min_size_alarm
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def add_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]], result)

    @builtins.property
    def add_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]], result)

    @builtins.property
    def add_queue_max_time_to_drain_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_time_to_drain_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]], result)

    @builtins.property
    def add_queue_min_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_min_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsQueueMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SqsQueueMonitoringProps",
    jsii_struct_bases=[SqsQueueMetricFactoryProps, SqsQueueMonitoringOptions],
    name_mapping={
        "queue": "queue",
        "add_queue_max_incoming_messages_alarm": "addQueueMaxIncomingMessagesAlarm",
        "add_queue_max_message_age_alarm": "addQueueMaxMessageAgeAlarm",
        "add_queue_max_size_alarm": "addQueueMaxSizeAlarm",
        "add_queue_max_time_to_drain_messages_alarm": "addQueueMaxTimeToDrainMessagesAlarm",
        "add_queue_min_incoming_messages_alarm": "addQueueMinIncomingMessagesAlarm",
        "add_queue_min_size_alarm": "addQueueMinSizeAlarm",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class SqsQueueMonitoringProps(SqsQueueMetricFactoryProps, SqsQueueMonitoringOptions):
    def __init__(
        self,
        *,
        queue: aws_cdk.aws_sqs.IQueue,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param queue: 
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringProps.__init__)
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
            check_type(argname="argument add_queue_max_incoming_messages_alarm", value=add_queue_max_incoming_messages_alarm, expected_type=type_hints["add_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_queue_max_message_age_alarm", value=add_queue_max_message_age_alarm, expected_type=type_hints["add_queue_max_message_age_alarm"])
            check_type(argname="argument add_queue_max_size_alarm", value=add_queue_max_size_alarm, expected_type=type_hints["add_queue_max_size_alarm"])
            check_type(argname="argument add_queue_max_time_to_drain_messages_alarm", value=add_queue_max_time_to_drain_messages_alarm, expected_type=type_hints["add_queue_max_time_to_drain_messages_alarm"])
            check_type(argname="argument add_queue_min_incoming_messages_alarm", value=add_queue_min_incoming_messages_alarm, expected_type=type_hints["add_queue_min_incoming_messages_alarm"])
            check_type(argname="argument add_queue_min_size_alarm", value=add_queue_min_size_alarm, expected_type=type_hints["add_queue_min_size_alarm"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "queue": queue,
        }
        if add_queue_max_incoming_messages_alarm is not None:
            self._values["add_queue_max_incoming_messages_alarm"] = add_queue_max_incoming_messages_alarm
        if add_queue_max_message_age_alarm is not None:
            self._values["add_queue_max_message_age_alarm"] = add_queue_max_message_age_alarm
        if add_queue_max_size_alarm is not None:
            self._values["add_queue_max_size_alarm"] = add_queue_max_size_alarm
        if add_queue_max_time_to_drain_messages_alarm is not None:
            self._values["add_queue_max_time_to_drain_messages_alarm"] = add_queue_max_time_to_drain_messages_alarm
        if add_queue_min_incoming_messages_alarm is not None:
            self._values["add_queue_min_incoming_messages_alarm"] = add_queue_min_incoming_messages_alarm
        if add_queue_min_size_alarm is not None:
            self._values["add_queue_min_size_alarm"] = add_queue_min_size_alarm
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def queue(self) -> aws_cdk.aws_sqs.IQueue:
        '''
        :stability: experimental
        '''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(aws_cdk.aws_sqs.IQueue, result)

    @builtins.property
    def add_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]], result)

    @builtins.property
    def add_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]], result)

    @builtins.property
    def add_queue_max_time_to_drain_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_time_to_drain_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]], result)

    @builtins.property
    def add_queue_min_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_min_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsQueueMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SqsQueueMonitoringWithDlqProps",
    jsii_struct_bases=[SqsQueueMonitoringProps, BaseDlqAlarms],
    name_mapping={
        "queue": "queue",
        "add_queue_max_incoming_messages_alarm": "addQueueMaxIncomingMessagesAlarm",
        "add_queue_max_message_age_alarm": "addQueueMaxMessageAgeAlarm",
        "add_queue_max_size_alarm": "addQueueMaxSizeAlarm",
        "add_queue_max_time_to_drain_messages_alarm": "addQueueMaxTimeToDrainMessagesAlarm",
        "add_queue_min_incoming_messages_alarm": "addQueueMinIncomingMessagesAlarm",
        "add_queue_min_size_alarm": "addQueueMinSizeAlarm",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_dead_letter_queue_max_incoming_messages_alarm": "addDeadLetterQueueMaxIncomingMessagesAlarm",
        "add_dead_letter_queue_max_message_age_alarm": "addDeadLetterQueueMaxMessageAgeAlarm",
        "add_dead_letter_queue_max_size_alarm": "addDeadLetterQueueMaxSizeAlarm",
        "dead_letter_queue": "deadLetterQueue",
        "add_dead_letter_queue_to_summary_dashboard": "addDeadLetterQueueToSummaryDashboard",
    },
)
class SqsQueueMonitoringWithDlqProps(SqsQueueMonitoringProps, BaseDlqAlarms):
    def __init__(
        self,
        *,
        queue: aws_cdk.aws_sqs.IQueue,
        add_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_max_time_to_drain_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxTimeToDrainThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_queue_min_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_dead_letter_queue_max_incoming_messages_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxIncomingMessagesCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_message_age_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageAgeThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_dead_letter_queue_max_size_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MaxMessageCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        dead_letter_queue: aws_cdk.aws_sqs.IQueue,
        add_dead_letter_queue_to_summary_dashboard: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param queue: 
        :param add_queue_max_incoming_messages_alarm: 
        :param add_queue_max_message_age_alarm: 
        :param add_queue_max_size_alarm: 
        :param add_queue_max_time_to_drain_messages_alarm: 
        :param add_queue_min_incoming_messages_alarm: 
        :param add_queue_min_size_alarm: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_dead_letter_queue_max_incoming_messages_alarm: (experimental) Alarm on the number of messages added to a queue. Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ as a result of a failed processing attempt.
        :param add_dead_letter_queue_max_message_age_alarm: 
        :param add_dead_letter_queue_max_size_alarm: 
        :param dead_letter_queue: 
        :param add_dead_letter_queue_to_summary_dashboard: (experimental) Indicates whether the DLQ monitoring should be added to summary dashboard. Default: - true

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SqsQueueMonitoringWithDlqProps.__init__)
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
            check_type(argname="argument add_queue_max_incoming_messages_alarm", value=add_queue_max_incoming_messages_alarm, expected_type=type_hints["add_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_queue_max_message_age_alarm", value=add_queue_max_message_age_alarm, expected_type=type_hints["add_queue_max_message_age_alarm"])
            check_type(argname="argument add_queue_max_size_alarm", value=add_queue_max_size_alarm, expected_type=type_hints["add_queue_max_size_alarm"])
            check_type(argname="argument add_queue_max_time_to_drain_messages_alarm", value=add_queue_max_time_to_drain_messages_alarm, expected_type=type_hints["add_queue_max_time_to_drain_messages_alarm"])
            check_type(argname="argument add_queue_min_incoming_messages_alarm", value=add_queue_min_incoming_messages_alarm, expected_type=type_hints["add_queue_min_incoming_messages_alarm"])
            check_type(argname="argument add_queue_min_size_alarm", value=add_queue_min_size_alarm, expected_type=type_hints["add_queue_min_size_alarm"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_dead_letter_queue_max_incoming_messages_alarm", value=add_dead_letter_queue_max_incoming_messages_alarm, expected_type=type_hints["add_dead_letter_queue_max_incoming_messages_alarm"])
            check_type(argname="argument add_dead_letter_queue_max_message_age_alarm", value=add_dead_letter_queue_max_message_age_alarm, expected_type=type_hints["add_dead_letter_queue_max_message_age_alarm"])
            check_type(argname="argument add_dead_letter_queue_max_size_alarm", value=add_dead_letter_queue_max_size_alarm, expected_type=type_hints["add_dead_letter_queue_max_size_alarm"])
            check_type(argname="argument dead_letter_queue", value=dead_letter_queue, expected_type=type_hints["dead_letter_queue"])
            check_type(argname="argument add_dead_letter_queue_to_summary_dashboard", value=add_dead_letter_queue_to_summary_dashboard, expected_type=type_hints["add_dead_letter_queue_to_summary_dashboard"])
        self._values: typing.Dict[str, typing.Any] = {
            "queue": queue,
            "dead_letter_queue": dead_letter_queue,
        }
        if add_queue_max_incoming_messages_alarm is not None:
            self._values["add_queue_max_incoming_messages_alarm"] = add_queue_max_incoming_messages_alarm
        if add_queue_max_message_age_alarm is not None:
            self._values["add_queue_max_message_age_alarm"] = add_queue_max_message_age_alarm
        if add_queue_max_size_alarm is not None:
            self._values["add_queue_max_size_alarm"] = add_queue_max_size_alarm
        if add_queue_max_time_to_drain_messages_alarm is not None:
            self._values["add_queue_max_time_to_drain_messages_alarm"] = add_queue_max_time_to_drain_messages_alarm
        if add_queue_min_incoming_messages_alarm is not None:
            self._values["add_queue_min_incoming_messages_alarm"] = add_queue_min_incoming_messages_alarm
        if add_queue_min_size_alarm is not None:
            self._values["add_queue_min_size_alarm"] = add_queue_min_size_alarm
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_dead_letter_queue_max_incoming_messages_alarm is not None:
            self._values["add_dead_letter_queue_max_incoming_messages_alarm"] = add_dead_letter_queue_max_incoming_messages_alarm
        if add_dead_letter_queue_max_message_age_alarm is not None:
            self._values["add_dead_letter_queue_max_message_age_alarm"] = add_dead_letter_queue_max_message_age_alarm
        if add_dead_letter_queue_max_size_alarm is not None:
            self._values["add_dead_letter_queue_max_size_alarm"] = add_dead_letter_queue_max_size_alarm
        if add_dead_letter_queue_to_summary_dashboard is not None:
            self._values["add_dead_letter_queue_to_summary_dashboard"] = add_dead_letter_queue_to_summary_dashboard

    @builtins.property
    def queue(self) -> aws_cdk.aws_sqs.IQueue:
        '''
        :stability: experimental
        '''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(aws_cdk.aws_sqs.IQueue, result)

    @builtins.property
    def add_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]], result)

    @builtins.property
    def add_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]], result)

    @builtins.property
    def add_queue_max_time_to_drain_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_max_time_to_drain_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxTimeToDrainThreshold]], result)

    @builtins.property
    def add_queue_min_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_queue_min_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_queue_min_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinMessageCountThreshold]], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_dead_letter_queue_max_incoming_messages_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]]:
        '''(experimental) Alarm on the number of messages added to a queue.

        Note that this corresponds with the NumberOfMessagesSent metric, which does not capture messages sent to the DLQ
        as a result of a failed processing attempt.

        :see: https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html#sqs-dlq-number-of-messages
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_incoming_messages_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxIncomingMessagesCountThreshold]], result)

    @builtins.property
    def add_dead_letter_queue_max_message_age_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_message_age_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageAgeThreshold]], result)

    @builtins.property
    def add_dead_letter_queue_max_size_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_max_size_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MaxMessageCountThreshold]], result)

    @builtins.property
    def dead_letter_queue(self) -> aws_cdk.aws_sqs.IQueue:
        '''
        :stability: experimental
        '''
        result = self._values.get("dead_letter_queue")
        assert result is not None, "Required property 'dead_letter_queue' is missing"
        return typing.cast(aws_cdk.aws_sqs.IQueue, result)

    @builtins.property
    def add_dead_letter_queue_to_summary_dashboard(
        self,
    ) -> typing.Optional[builtins.bool]:
        '''(experimental) Indicates whether the DLQ monitoring should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_dead_letter_queue_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsQueueMonitoringWithDlqProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionActivityMonitoringProps",
    jsii_struct_bases=[StepFunctionActivityMetricFactoryProps, BaseMonitoringProps],
    name_mapping={
        "activity": "activity",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_activities_count_alarm": "addFailedActivitiesCountAlarm",
        "add_failed_activities_rate_alarm": "addFailedActivitiesRateAlarm",
        "add_timed_out_activities_count_alarm": "addTimedOutActivitiesCountAlarm",
    },
)
class StepFunctionActivityMonitoringProps(
    StepFunctionActivityMetricFactoryProps,
    BaseMonitoringProps,
):
    def __init__(
        self,
        *,
        activity: aws_cdk.aws_stepfunctions.IActivity,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_activities_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_activities_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param activity: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_activities_count_alarm: 
        :param add_failed_activities_rate_alarm: 
        :param add_timed_out_activities_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionActivityMonitoringProps.__init__)
            check_type(argname="argument activity", value=activity, expected_type=type_hints["activity"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_activities_count_alarm", value=add_failed_activities_count_alarm, expected_type=type_hints["add_failed_activities_count_alarm"])
            check_type(argname="argument add_failed_activities_rate_alarm", value=add_failed_activities_rate_alarm, expected_type=type_hints["add_failed_activities_rate_alarm"])
            check_type(argname="argument add_timed_out_activities_count_alarm", value=add_timed_out_activities_count_alarm, expected_type=type_hints["add_timed_out_activities_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "activity": activity,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_activities_count_alarm is not None:
            self._values["add_failed_activities_count_alarm"] = add_failed_activities_count_alarm
        if add_failed_activities_rate_alarm is not None:
            self._values["add_failed_activities_rate_alarm"] = add_failed_activities_rate_alarm
        if add_timed_out_activities_count_alarm is not None:
            self._values["add_timed_out_activities_count_alarm"] = add_timed_out_activities_count_alarm

    @builtins.property
    def activity(self) -> aws_cdk.aws_stepfunctions.IActivity:
        '''
        :stability: experimental
        '''
        result = self._values.get("activity")
        assert result is not None, "Required property 'activity' is missing"
        return typing.cast(aws_cdk.aws_stepfunctions.IActivity, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_activities_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_activities_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_activities_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_activities_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_timed_out_activities_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_timed_out_activities_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionActivityMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionLambdaIntegrationMonitoringProps",
    jsii_struct_bases=[
        StepFunctionLambdaIntegrationMetricFactoryProps, BaseMonitoringProps
    ],
    name_mapping={
        "lambda_function": "lambdaFunction",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_functions_count_alarm": "addFailedFunctionsCountAlarm",
        "add_failed_functions_rate_alarm": "addFailedFunctionsRateAlarm",
        "add_timed_out_functions_count_alarm": "addTimedOutFunctionsCountAlarm",
    },
)
class StepFunctionLambdaIntegrationMonitoringProps(
    StepFunctionLambdaIntegrationMetricFactoryProps,
    BaseMonitoringProps,
):
    def __init__(
        self,
        *,
        lambda_function: aws_cdk.aws_lambda.IFunction,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_functions_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_functions_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param lambda_function: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_functions_count_alarm: 
        :param add_failed_functions_rate_alarm: 
        :param add_timed_out_functions_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionLambdaIntegrationMonitoringProps.__init__)
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_functions_count_alarm", value=add_failed_functions_count_alarm, expected_type=type_hints["add_failed_functions_count_alarm"])
            check_type(argname="argument add_failed_functions_rate_alarm", value=add_failed_functions_rate_alarm, expected_type=type_hints["add_failed_functions_rate_alarm"])
            check_type(argname="argument add_timed_out_functions_count_alarm", value=add_timed_out_functions_count_alarm, expected_type=type_hints["add_timed_out_functions_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_functions_count_alarm is not None:
            self._values["add_failed_functions_count_alarm"] = add_failed_functions_count_alarm
        if add_failed_functions_rate_alarm is not None:
            self._values["add_failed_functions_rate_alarm"] = add_failed_functions_rate_alarm
        if add_timed_out_functions_count_alarm is not None:
            self._values["add_timed_out_functions_count_alarm"] = add_timed_out_functions_count_alarm

    @builtins.property
    def lambda_function(self) -> aws_cdk.aws_lambda.IFunction:
        '''
        :stability: experimental
        '''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(aws_cdk.aws_lambda.IFunction, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_functions_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_functions_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_functions_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_functions_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_timed_out_functions_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_timed_out_functions_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionLambdaIntegrationMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_aborted_execution_count_alarm": "addAbortedExecutionCountAlarm",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_execution_count_alarm": "addFailedExecutionCountAlarm",
        "add_failed_execution_rate_alarm": "addFailedExecutionRateAlarm",
        "add_min_started_execution_count_alarm": "addMinStartedExecutionCountAlarm",
        "add_throttled_execution_count_alarm": "addThrottledExecutionCountAlarm",
        "add_timed_out_execution_count_alarm": "addTimedOutExecutionCountAlarm",
    },
)
class StepFunctionMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_aborted_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_started_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinRunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_aborted_execution_count_alarm: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_execution_count_alarm: 
        :param add_failed_execution_rate_alarm: 
        :param add_min_started_execution_count_alarm: (experimental) Add minimum started execution count alarm for the stepfunctions.
        :param add_throttled_execution_count_alarm: 
        :param add_timed_out_execution_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_aborted_execution_count_alarm", value=add_aborted_execution_count_alarm, expected_type=type_hints["add_aborted_execution_count_alarm"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_execution_count_alarm", value=add_failed_execution_count_alarm, expected_type=type_hints["add_failed_execution_count_alarm"])
            check_type(argname="argument add_failed_execution_rate_alarm", value=add_failed_execution_rate_alarm, expected_type=type_hints["add_failed_execution_rate_alarm"])
            check_type(argname="argument add_min_started_execution_count_alarm", value=add_min_started_execution_count_alarm, expected_type=type_hints["add_min_started_execution_count_alarm"])
            check_type(argname="argument add_throttled_execution_count_alarm", value=add_throttled_execution_count_alarm, expected_type=type_hints["add_throttled_execution_count_alarm"])
            check_type(argname="argument add_timed_out_execution_count_alarm", value=add_timed_out_execution_count_alarm, expected_type=type_hints["add_timed_out_execution_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_aborted_execution_count_alarm is not None:
            self._values["add_aborted_execution_count_alarm"] = add_aborted_execution_count_alarm
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_execution_count_alarm is not None:
            self._values["add_failed_execution_count_alarm"] = add_failed_execution_count_alarm
        if add_failed_execution_rate_alarm is not None:
            self._values["add_failed_execution_rate_alarm"] = add_failed_execution_rate_alarm
        if add_min_started_execution_count_alarm is not None:
            self._values["add_min_started_execution_count_alarm"] = add_min_started_execution_count_alarm
        if add_throttled_execution_count_alarm is not None:
            self._values["add_throttled_execution_count_alarm"] = add_throttled_execution_count_alarm
        if add_timed_out_execution_count_alarm is not None:
            self._values["add_timed_out_execution_count_alarm"] = add_timed_out_execution_count_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_aborted_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_aborted_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_execution_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_execution_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_min_started_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinRunningTaskCountThreshold]]:
        '''(experimental) Add minimum started execution count alarm for the stepfunctions.

        :stability: experimental
        '''
        result = self._values.get("add_min_started_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinRunningTaskCountThreshold]], result)

    @builtins.property
    def add_throttled_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttled_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_timed_out_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_timed_out_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionMonitoringProps",
    jsii_struct_bases=[StepFunctionMetricFactoryProps, StepFunctionMonitoringOptions],
    name_mapping={
        "state_machine": "stateMachine",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_aborted_execution_count_alarm": "addAbortedExecutionCountAlarm",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_execution_count_alarm": "addFailedExecutionCountAlarm",
        "add_failed_execution_rate_alarm": "addFailedExecutionRateAlarm",
        "add_min_started_execution_count_alarm": "addMinStartedExecutionCountAlarm",
        "add_throttled_execution_count_alarm": "addThrottledExecutionCountAlarm",
        "add_timed_out_execution_count_alarm": "addTimedOutExecutionCountAlarm",
    },
)
class StepFunctionMonitoringProps(
    StepFunctionMetricFactoryProps,
    StepFunctionMonitoringOptions,
):
    def __init__(
        self,
        *,
        state_machine: aws_cdk.aws_stepfunctions.IStateMachine,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_aborted_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_execution_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_min_started_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[MinRunningTaskCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_throttled_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_execution_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param state_machine: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_aborted_execution_count_alarm: 
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_execution_count_alarm: 
        :param add_failed_execution_rate_alarm: 
        :param add_min_started_execution_count_alarm: (experimental) Add minimum started execution count alarm for the stepfunctions.
        :param add_throttled_execution_count_alarm: 
        :param add_timed_out_execution_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionMonitoringProps.__init__)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_aborted_execution_count_alarm", value=add_aborted_execution_count_alarm, expected_type=type_hints["add_aborted_execution_count_alarm"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_execution_count_alarm", value=add_failed_execution_count_alarm, expected_type=type_hints["add_failed_execution_count_alarm"])
            check_type(argname="argument add_failed_execution_rate_alarm", value=add_failed_execution_rate_alarm, expected_type=type_hints["add_failed_execution_rate_alarm"])
            check_type(argname="argument add_min_started_execution_count_alarm", value=add_min_started_execution_count_alarm, expected_type=type_hints["add_min_started_execution_count_alarm"])
            check_type(argname="argument add_throttled_execution_count_alarm", value=add_throttled_execution_count_alarm, expected_type=type_hints["add_throttled_execution_count_alarm"])
            check_type(argname="argument add_timed_out_execution_count_alarm", value=add_timed_out_execution_count_alarm, expected_type=type_hints["add_timed_out_execution_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "state_machine": state_machine,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_aborted_execution_count_alarm is not None:
            self._values["add_aborted_execution_count_alarm"] = add_aborted_execution_count_alarm
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_execution_count_alarm is not None:
            self._values["add_failed_execution_count_alarm"] = add_failed_execution_count_alarm
        if add_failed_execution_rate_alarm is not None:
            self._values["add_failed_execution_rate_alarm"] = add_failed_execution_rate_alarm
        if add_min_started_execution_count_alarm is not None:
            self._values["add_min_started_execution_count_alarm"] = add_min_started_execution_count_alarm
        if add_throttled_execution_count_alarm is not None:
            self._values["add_throttled_execution_count_alarm"] = add_throttled_execution_count_alarm
        if add_timed_out_execution_count_alarm is not None:
            self._values["add_timed_out_execution_count_alarm"] = add_timed_out_execution_count_alarm

    @builtins.property
    def state_machine(self) -> aws_cdk.aws_stepfunctions.IStateMachine:
        '''
        :stability: experimental
        '''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(aws_cdk.aws_stepfunctions.IStateMachine, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_aborted_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_aborted_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_execution_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_execution_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_min_started_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, MinRunningTaskCountThreshold]]:
        '''(experimental) Add minimum started execution count alarm for the stepfunctions.

        :stability: experimental
        '''
        result = self._values.get("add_min_started_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, MinRunningTaskCountThreshold]], result)

    @builtins.property
    def add_throttled_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_throttled_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_timed_out_execution_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_timed_out_execution_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.StepFunctionServiceIntegrationMonitoringProps",
    jsii_struct_bases=[
        StepFunctionServiceIntegrationMetricFactoryProps, BaseMonitoringProps
    ],
    name_mapping={
        "service_integration_resource_arn": "serviceIntegrationResourceArn",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add_duration_p50_alarm": "addDurationP50Alarm",
        "add_duration_p90_alarm": "addDurationP90Alarm",
        "add_duration_p99_alarm": "addDurationP99Alarm",
        "add_failed_service_integrations_count_alarm": "addFailedServiceIntegrationsCountAlarm",
        "add_failed_service_integrations_rate_alarm": "addFailedServiceIntegrationsRateAlarm",
        "add_timed_out_service_integrations_count_alarm": "addTimedOutServiceIntegrationsCountAlarm",
    },
)
class StepFunctionServiceIntegrationMonitoringProps(
    StepFunctionServiceIntegrationMetricFactoryProps,
    BaseMonitoringProps,
):
    def __init__(
        self,
        *,
        service_integration_resource_arn: builtins.str,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add_duration_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_duration_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[DurationThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_failed_service_integrations_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_timed_out_service_integrations_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param service_integration_resource_arn: 
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add_duration_p50_alarm: 
        :param add_duration_p90_alarm: 
        :param add_duration_p99_alarm: 
        :param add_failed_service_integrations_count_alarm: 
        :param add_failed_service_integrations_rate_alarm: 
        :param add_timed_out_service_integrations_count_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(StepFunctionServiceIntegrationMonitoringProps.__init__)
            check_type(argname="argument service_integration_resource_arn", value=service_integration_resource_arn, expected_type=type_hints["service_integration_resource_arn"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add_duration_p50_alarm", value=add_duration_p50_alarm, expected_type=type_hints["add_duration_p50_alarm"])
            check_type(argname="argument add_duration_p90_alarm", value=add_duration_p90_alarm, expected_type=type_hints["add_duration_p90_alarm"])
            check_type(argname="argument add_duration_p99_alarm", value=add_duration_p99_alarm, expected_type=type_hints["add_duration_p99_alarm"])
            check_type(argname="argument add_failed_service_integrations_count_alarm", value=add_failed_service_integrations_count_alarm, expected_type=type_hints["add_failed_service_integrations_count_alarm"])
            check_type(argname="argument add_failed_service_integrations_rate_alarm", value=add_failed_service_integrations_rate_alarm, expected_type=type_hints["add_failed_service_integrations_rate_alarm"])
            check_type(argname="argument add_timed_out_service_integrations_count_alarm", value=add_timed_out_service_integrations_count_alarm, expected_type=type_hints["add_timed_out_service_integrations_count_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "service_integration_resource_arn": service_integration_resource_arn,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add_duration_p50_alarm is not None:
            self._values["add_duration_p50_alarm"] = add_duration_p50_alarm
        if add_duration_p90_alarm is not None:
            self._values["add_duration_p90_alarm"] = add_duration_p90_alarm
        if add_duration_p99_alarm is not None:
            self._values["add_duration_p99_alarm"] = add_duration_p99_alarm
        if add_failed_service_integrations_count_alarm is not None:
            self._values["add_failed_service_integrations_count_alarm"] = add_failed_service_integrations_count_alarm
        if add_failed_service_integrations_rate_alarm is not None:
            self._values["add_failed_service_integrations_rate_alarm"] = add_failed_service_integrations_rate_alarm
        if add_timed_out_service_integrations_count_alarm is not None:
            self._values["add_timed_out_service_integrations_count_alarm"] = add_timed_out_service_integrations_count_alarm

    @builtins.property
    def service_integration_resource_arn(self) -> builtins.str:
        '''
        :stability: experimental
        '''
        result = self._values.get("service_integration_resource_arn")
        assert result is not None, "Required property 'service_integration_resource_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add_duration_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_duration_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, DurationThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_duration_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, DurationThreshold]], result)

    @builtins.property
    def add_failed_service_integrations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_service_integrations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add_failed_service_integrations_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_failed_service_integrations_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_timed_out_service_integrations_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_timed_out_service_integrations_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StepFunctionServiceIntegrationMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SyntheticsCanaryMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4xx_error_count_alarm": "add4xxErrorCountAlarm",
        "add4xx_error_rate_alarm": "add4xxErrorRateAlarm",
        "add5xx_fault_count_alarm": "add5xxFaultCountAlarm",
        "add5xx_fault_rate_alarm": "add5xxFaultRateAlarm",
        "add_average_latency_alarm": "addAverageLatencyAlarm",
    },
)
class SyntheticsCanaryMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4xx_error_count_alarm: 
        :param add4xx_error_rate_alarm: 
        :param add5xx_fault_count_alarm: 
        :param add5xx_fault_rate_alarm: 
        :param add_average_latency_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4xx_error_count_alarm", value=add4xx_error_count_alarm, expected_type=type_hints["add4xx_error_count_alarm"])
            check_type(argname="argument add4xx_error_rate_alarm", value=add4xx_error_rate_alarm, expected_type=type_hints["add4xx_error_rate_alarm"])
            check_type(argname="argument add5xx_fault_count_alarm", value=add5xx_fault_count_alarm, expected_type=type_hints["add5xx_fault_count_alarm"])
            check_type(argname="argument add5xx_fault_rate_alarm", value=add5xx_fault_rate_alarm, expected_type=type_hints["add5xx_fault_rate_alarm"])
            check_type(argname="argument add_average_latency_alarm", value=add_average_latency_alarm, expected_type=type_hints["add_average_latency_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4xx_error_count_alarm is not None:
            self._values["add4xx_error_count_alarm"] = add4xx_error_count_alarm
        if add4xx_error_rate_alarm is not None:
            self._values["add4xx_error_rate_alarm"] = add4xx_error_rate_alarm
        if add5xx_fault_count_alarm is not None:
            self._values["add5xx_fault_count_alarm"] = add5xx_fault_count_alarm
        if add5xx_fault_rate_alarm is not None:
            self._values["add5xx_fault_rate_alarm"] = add5xx_fault_rate_alarm
        if add_average_latency_alarm is not None:
            self._values["add_average_latency_alarm"] = add_average_latency_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_average_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsCanaryMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.SyntheticsCanaryMonitoringProps",
    jsii_struct_bases=[
        SyntheticsCanaryMetricFactoryProps, SyntheticsCanaryMonitoringOptions
    ],
    name_mapping={
        "canary": "canary",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4xx_error_count_alarm": "add4xxErrorCountAlarm",
        "add4xx_error_rate_alarm": "add4xxErrorRateAlarm",
        "add5xx_fault_count_alarm": "add5xxFaultCountAlarm",
        "add5xx_fault_rate_alarm": "add5xxFaultRateAlarm",
        "add_average_latency_alarm": "addAverageLatencyAlarm",
    },
)
class SyntheticsCanaryMonitoringProps(
    SyntheticsCanaryMetricFactoryProps,
    SyntheticsCanaryMonitoringOptions,
):
    def __init__(
        self,
        *,
        canary: aws_cdk.aws_synthetics_alpha.Canary,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_average_latency_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param canary: (experimental) CloudWatch Canary to monitor.
        :param rate_computation_method: (experimental) Method used to calculate relative rates. Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4xx_error_count_alarm: 
        :param add4xx_error_rate_alarm: 
        :param add5xx_fault_count_alarm: 
        :param add5xx_fault_rate_alarm: 
        :param add_average_latency_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(SyntheticsCanaryMonitoringProps.__init__)
            check_type(argname="argument canary", value=canary, expected_type=type_hints["canary"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4xx_error_count_alarm", value=add4xx_error_count_alarm, expected_type=type_hints["add4xx_error_count_alarm"])
            check_type(argname="argument add4xx_error_rate_alarm", value=add4xx_error_rate_alarm, expected_type=type_hints["add4xx_error_rate_alarm"])
            check_type(argname="argument add5xx_fault_count_alarm", value=add5xx_fault_count_alarm, expected_type=type_hints["add5xx_fault_count_alarm"])
            check_type(argname="argument add5xx_fault_rate_alarm", value=add5xx_fault_rate_alarm, expected_type=type_hints["add5xx_fault_rate_alarm"])
            check_type(argname="argument add_average_latency_alarm", value=add_average_latency_alarm, expected_type=type_hints["add_average_latency_alarm"])
        self._values: typing.Dict[str, typing.Any] = {
            "canary": canary,
        }
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4xx_error_count_alarm is not None:
            self._values["add4xx_error_count_alarm"] = add4xx_error_count_alarm
        if add4xx_error_rate_alarm is not None:
            self._values["add4xx_error_rate_alarm"] = add4xx_error_rate_alarm
        if add5xx_fault_count_alarm is not None:
            self._values["add5xx_fault_count_alarm"] = add5xx_fault_count_alarm
        if add5xx_fault_rate_alarm is not None:
            self._values["add5xx_fault_rate_alarm"] = add5xx_fault_rate_alarm
        if add_average_latency_alarm is not None:
            self._values["add_average_latency_alarm"] = add_average_latency_alarm

    @builtins.property
    def canary(self) -> aws_cdk.aws_synthetics_alpha.Canary:
        '''(experimental) CloudWatch Canary to monitor.

        :stability: experimental
        '''
        result = self._values.get("canary")
        assert result is not None, "Required property 'canary' is missing"
        return typing.cast(aws_cdk.aws_synthetics_alpha.Canary, result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''(experimental) Method used to calculate relative rates.

        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_average_latency_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_average_latency_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SyntheticsCanaryMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.WafV2MonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class WafV2MonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2MonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WafV2MonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.WafV2MonitoringProps",
    jsii_struct_bases=[WafV2MetricFactoryProps, WafV2MonitoringOptions],
    name_mapping={
        "acl": "acl",
        "region": "region",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class WafV2MonitoringProps(WafV2MetricFactoryProps, WafV2MonitoringOptions):
    def __init__(
        self,
        *,
        acl: aws_cdk.aws_wafv2.CfnWebACL,
        region: typing.Optional[builtins.str] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param acl: 
        :param region: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(WafV2MonitoringProps.__init__)
            check_type(argname="argument acl", value=acl, expected_type=type_hints["acl"])
            check_type(argname="argument region", value=region, expected_type=type_hints["region"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "acl": acl,
        }
        if region is not None:
            self._values["region"] = region
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def acl(self) -> aws_cdk.aws_wafv2.CfnWebACL:
        '''
        :stability: experimental
        '''
        result = self._values.get("acl")
        assert result is not None, "Required property 'acl' is missing"
        return typing.cast(aws_cdk.aws_wafv2.CfnWebACL, result)

    @builtins.property
    def region(self) -> typing.Optional[builtins.str]:
        '''
        :stability: experimental
        '''
        result = self._values.get("region")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WafV2MonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4_xx_error_count_alarm": "add4XXErrorCountAlarm",
        "add4_xx_error_rate_alarm": "add4XXErrorRateAlarm",
        "add5_xx_fault_count_alarm": "add5XXFaultCountAlarm",
        "add5_xx_fault_rate_alarm": "add5XXFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_average_alarm": "addLatencyAverageAlarm",
        "add_latency_p100_alarm": "addLatencyP100Alarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p70_alarm": "addLatencyP70Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p95_alarm": "addLatencyP95Alarm",
        "add_latency_p9999_alarm": "addLatencyP9999Alarm",
        "add_latency_p999_alarm": "addLatencyP999Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_latency_tm50_alarm": "addLatencyTM50Alarm",
        "add_latency_tm70_alarm": "addLatencyTM70Alarm",
        "add_latency_tm90_alarm": "addLatencyTM90Alarm",
        "add_latency_tm95_alarm": "addLatencyTM95Alarm",
        "add_latency_tm9999_alarm": "addLatencyTM9999Alarm",
        "add_latency_tm999_alarm": "addLatencyTM999Alarm",
        "add_latency_tm99_alarm": "addLatencyTM99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "latency_types_to_render": "latencyTypesToRender",
    },
)
class ApiGatewayMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4_xx_error_count_alarm", value=add4_xx_error_count_alarm, expected_type=type_hints["add4_xx_error_count_alarm"])
            check_type(argname="argument add4_xx_error_rate_alarm", value=add4_xx_error_rate_alarm, expected_type=type_hints["add4_xx_error_rate_alarm"])
            check_type(argname="argument add5_xx_fault_count_alarm", value=add5_xx_fault_count_alarm, expected_type=type_hints["add5_xx_fault_count_alarm"])
            check_type(argname="argument add5_xx_fault_rate_alarm", value=add5_xx_fault_rate_alarm, expected_type=type_hints["add5_xx_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_average_alarm", value=add_latency_average_alarm, expected_type=type_hints["add_latency_average_alarm"])
            check_type(argname="argument add_latency_p100_alarm", value=add_latency_p100_alarm, expected_type=type_hints["add_latency_p100_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p70_alarm", value=add_latency_p70_alarm, expected_type=type_hints["add_latency_p70_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p95_alarm", value=add_latency_p95_alarm, expected_type=type_hints["add_latency_p95_alarm"])
            check_type(argname="argument add_latency_p9999_alarm", value=add_latency_p9999_alarm, expected_type=type_hints["add_latency_p9999_alarm"])
            check_type(argname="argument add_latency_p999_alarm", value=add_latency_p999_alarm, expected_type=type_hints["add_latency_p999_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_latency_tm50_alarm", value=add_latency_tm50_alarm, expected_type=type_hints["add_latency_tm50_alarm"])
            check_type(argname="argument add_latency_tm70_alarm", value=add_latency_tm70_alarm, expected_type=type_hints["add_latency_tm70_alarm"])
            check_type(argname="argument add_latency_tm90_alarm", value=add_latency_tm90_alarm, expected_type=type_hints["add_latency_tm90_alarm"])
            check_type(argname="argument add_latency_tm95_alarm", value=add_latency_tm95_alarm, expected_type=type_hints["add_latency_tm95_alarm"])
            check_type(argname="argument add_latency_tm9999_alarm", value=add_latency_tm9999_alarm, expected_type=type_hints["add_latency_tm9999_alarm"])
            check_type(argname="argument add_latency_tm999_alarm", value=add_latency_tm999_alarm, expected_type=type_hints["add_latency_tm999_alarm"])
            check_type(argname="argument add_latency_tm99_alarm", value=add_latency_tm99_alarm, expected_type=type_hints["add_latency_tm99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument latency_types_to_render", value=latency_types_to_render, expected_type=type_hints["latency_types_to_render"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4_xx_error_count_alarm is not None:
            self._values["add4_xx_error_count_alarm"] = add4_xx_error_count_alarm
        if add4_xx_error_rate_alarm is not None:
            self._values["add4_xx_error_rate_alarm"] = add4_xx_error_rate_alarm
        if add5_xx_fault_count_alarm is not None:
            self._values["add5_xx_fault_count_alarm"] = add5_xx_fault_count_alarm
        if add5_xx_fault_rate_alarm is not None:
            self._values["add5_xx_fault_rate_alarm"] = add5_xx_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_average_alarm is not None:
            self._values["add_latency_average_alarm"] = add_latency_average_alarm
        if add_latency_p100_alarm is not None:
            self._values["add_latency_p100_alarm"] = add_latency_p100_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p70_alarm is not None:
            self._values["add_latency_p70_alarm"] = add_latency_p70_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p95_alarm is not None:
            self._values["add_latency_p95_alarm"] = add_latency_p95_alarm
        if add_latency_p9999_alarm is not None:
            self._values["add_latency_p9999_alarm"] = add_latency_p9999_alarm
        if add_latency_p999_alarm is not None:
            self._values["add_latency_p999_alarm"] = add_latency_p999_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_latency_tm50_alarm is not None:
            self._values["add_latency_tm50_alarm"] = add_latency_tm50_alarm
        if add_latency_tm70_alarm is not None:
            self._values["add_latency_tm70_alarm"] = add_latency_tm70_alarm
        if add_latency_tm90_alarm is not None:
            self._values["add_latency_tm90_alarm"] = add_latency_tm90_alarm
        if add_latency_tm95_alarm is not None:
            self._values["add_latency_tm95_alarm"] = add_latency_tm95_alarm
        if add_latency_tm9999_alarm is not None:
            self._values["add_latency_tm9999_alarm"] = add_latency_tm9999_alarm
        if add_latency_tm999_alarm is not None:
            self._values["add_latency_tm999_alarm"] = add_latency_tm999_alarm
        if add_latency_tm99_alarm is not None:
            self._values["add_latency_tm99_alarm"] = add_latency_tm99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if latency_types_to_render is not None:
            self._values["latency_types_to_render"] = latency_types_to_render

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4_xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4_xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5_xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5_xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def latency_types_to_render(self) -> typing.Optional[typing.List[LatencyType]]:
        '''(experimental) You can specify what latency types you want to be rendered in the dashboards.

        Note: any latency type with an alarm will be also added automatically.
        If the list is undefined, default values will be shown.
        If the list is empty, only the latency types with an alarm will be shown (if any).

        :default: - p50, p90, p99 (

        :see: DefaultLatencyTypesToRender)
        :stability: experimental
        '''
        result = self._values.get("latency_types_to_render")
        return typing.cast(typing.Optional[typing.List[LatencyType]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayMonitoringProps",
    jsii_struct_bases=[ApiGatewayMetricFactoryProps, ApiGatewayMonitoringOptions],
    name_mapping={
        "api": "api",
        "api_method": "apiMethod",
        "api_resource": "apiResource",
        "api_stage": "apiStage",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4_xx_error_count_alarm": "add4XXErrorCountAlarm",
        "add4_xx_error_rate_alarm": "add4XXErrorRateAlarm",
        "add5_xx_fault_count_alarm": "add5XXFaultCountAlarm",
        "add5_xx_fault_rate_alarm": "add5XXFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_average_alarm": "addLatencyAverageAlarm",
        "add_latency_p100_alarm": "addLatencyP100Alarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p70_alarm": "addLatencyP70Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p95_alarm": "addLatencyP95Alarm",
        "add_latency_p9999_alarm": "addLatencyP9999Alarm",
        "add_latency_p999_alarm": "addLatencyP999Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_latency_tm50_alarm": "addLatencyTM50Alarm",
        "add_latency_tm70_alarm": "addLatencyTM70Alarm",
        "add_latency_tm90_alarm": "addLatencyTM90Alarm",
        "add_latency_tm95_alarm": "addLatencyTM95Alarm",
        "add_latency_tm9999_alarm": "addLatencyTM9999Alarm",
        "add_latency_tm999_alarm": "addLatencyTM999Alarm",
        "add_latency_tm99_alarm": "addLatencyTM99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "latency_types_to_render": "latencyTypesToRender",
    },
)
class ApiGatewayMonitoringProps(
    ApiGatewayMetricFactoryProps,
    ApiGatewayMonitoringOptions,
):
    def __init__(
        self,
        *,
        api: aws_cdk.aws_apigateway.RestApiBase,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
    ) -> None:
        '''
        :param api: (experimental) API to monitor (cannot use IRestApi, since it does not provide API name).
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - prod
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayMonitoringProps.__init__)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument api_method", value=api_method, expected_type=type_hints["api_method"])
            check_type(argname="argument api_resource", value=api_resource, expected_type=type_hints["api_resource"])
            check_type(argname="argument api_stage", value=api_stage, expected_type=type_hints["api_stage"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4_xx_error_count_alarm", value=add4_xx_error_count_alarm, expected_type=type_hints["add4_xx_error_count_alarm"])
            check_type(argname="argument add4_xx_error_rate_alarm", value=add4_xx_error_rate_alarm, expected_type=type_hints["add4_xx_error_rate_alarm"])
            check_type(argname="argument add5_xx_fault_count_alarm", value=add5_xx_fault_count_alarm, expected_type=type_hints["add5_xx_fault_count_alarm"])
            check_type(argname="argument add5_xx_fault_rate_alarm", value=add5_xx_fault_rate_alarm, expected_type=type_hints["add5_xx_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_average_alarm", value=add_latency_average_alarm, expected_type=type_hints["add_latency_average_alarm"])
            check_type(argname="argument add_latency_p100_alarm", value=add_latency_p100_alarm, expected_type=type_hints["add_latency_p100_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p70_alarm", value=add_latency_p70_alarm, expected_type=type_hints["add_latency_p70_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p95_alarm", value=add_latency_p95_alarm, expected_type=type_hints["add_latency_p95_alarm"])
            check_type(argname="argument add_latency_p9999_alarm", value=add_latency_p9999_alarm, expected_type=type_hints["add_latency_p9999_alarm"])
            check_type(argname="argument add_latency_p999_alarm", value=add_latency_p999_alarm, expected_type=type_hints["add_latency_p999_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_latency_tm50_alarm", value=add_latency_tm50_alarm, expected_type=type_hints["add_latency_tm50_alarm"])
            check_type(argname="argument add_latency_tm70_alarm", value=add_latency_tm70_alarm, expected_type=type_hints["add_latency_tm70_alarm"])
            check_type(argname="argument add_latency_tm90_alarm", value=add_latency_tm90_alarm, expected_type=type_hints["add_latency_tm90_alarm"])
            check_type(argname="argument add_latency_tm95_alarm", value=add_latency_tm95_alarm, expected_type=type_hints["add_latency_tm95_alarm"])
            check_type(argname="argument add_latency_tm9999_alarm", value=add_latency_tm9999_alarm, expected_type=type_hints["add_latency_tm9999_alarm"])
            check_type(argname="argument add_latency_tm999_alarm", value=add_latency_tm999_alarm, expected_type=type_hints["add_latency_tm999_alarm"])
            check_type(argname="argument add_latency_tm99_alarm", value=add_latency_tm99_alarm, expected_type=type_hints["add_latency_tm99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument latency_types_to_render", value=latency_types_to_render, expected_type=type_hints["latency_types_to_render"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if api_method is not None:
            self._values["api_method"] = api_method
        if api_resource is not None:
            self._values["api_resource"] = api_resource
        if api_stage is not None:
            self._values["api_stage"] = api_stage
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4_xx_error_count_alarm is not None:
            self._values["add4_xx_error_count_alarm"] = add4_xx_error_count_alarm
        if add4_xx_error_rate_alarm is not None:
            self._values["add4_xx_error_rate_alarm"] = add4_xx_error_rate_alarm
        if add5_xx_fault_count_alarm is not None:
            self._values["add5_xx_fault_count_alarm"] = add5_xx_fault_count_alarm
        if add5_xx_fault_rate_alarm is not None:
            self._values["add5_xx_fault_rate_alarm"] = add5_xx_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_average_alarm is not None:
            self._values["add_latency_average_alarm"] = add_latency_average_alarm
        if add_latency_p100_alarm is not None:
            self._values["add_latency_p100_alarm"] = add_latency_p100_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p70_alarm is not None:
            self._values["add_latency_p70_alarm"] = add_latency_p70_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p95_alarm is not None:
            self._values["add_latency_p95_alarm"] = add_latency_p95_alarm
        if add_latency_p9999_alarm is not None:
            self._values["add_latency_p9999_alarm"] = add_latency_p9999_alarm
        if add_latency_p999_alarm is not None:
            self._values["add_latency_p999_alarm"] = add_latency_p999_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_latency_tm50_alarm is not None:
            self._values["add_latency_tm50_alarm"] = add_latency_tm50_alarm
        if add_latency_tm70_alarm is not None:
            self._values["add_latency_tm70_alarm"] = add_latency_tm70_alarm
        if add_latency_tm90_alarm is not None:
            self._values["add_latency_tm90_alarm"] = add_latency_tm90_alarm
        if add_latency_tm95_alarm is not None:
            self._values["add_latency_tm95_alarm"] = add_latency_tm95_alarm
        if add_latency_tm9999_alarm is not None:
            self._values["add_latency_tm9999_alarm"] = add_latency_tm9999_alarm
        if add_latency_tm999_alarm is not None:
            self._values["add_latency_tm999_alarm"] = add_latency_tm999_alarm
        if add_latency_tm99_alarm is not None:
            self._values["add_latency_tm99_alarm"] = add_latency_tm99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if latency_types_to_render is not None:
            self._values["latency_types_to_render"] = latency_types_to_render

    @builtins.property
    def api(self) -> aws_cdk.aws_apigateway.RestApiBase:
        '''(experimental) API to monitor (cannot use IRestApi, since it does not provide API name).

        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_apigateway.RestApiBase, result)

    @builtins.property
    def api_method(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_resource(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_resource")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_stage(self) -> typing.Optional[builtins.str]:
        '''
        :default: - prod

        :stability: experimental
        '''
        result = self._values.get("api_stage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4_xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4_xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5_xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5_xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def latency_types_to_render(self) -> typing.Optional[typing.List[LatencyType]]:
        '''(experimental) You can specify what latency types you want to be rendered in the dashboards.

        Note: any latency type with an alarm will be also added automatically.
        If the list is undefined, default values will be shown.
        If the list is empty, only the latency types with an alarm will be shown (if any).

        :default: - p50, p90, p99 (

        :see: DefaultLatencyTypesToRender)
        :stability: experimental
        '''
        result = self._values.get("latency_types_to_render")
        return typing.cast(typing.Optional[typing.List[LatencyType]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayV2MonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4xx_count_alarm": "add4xxCountAlarm",
        "add4xx_rate_alarm": "add4xxRateAlarm",
        "add5xx_count_alarm": "add5xxCountAlarm",
        "add5xx_rate_alarm": "add5xxRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_integration_latency_average_alarm": "addIntegrationLatencyAverageAlarm",
        "add_integration_latency_p100_alarm": "addIntegrationLatencyP100Alarm",
        "add_integration_latency_p50_alarm": "addIntegrationLatencyP50Alarm",
        "add_integration_latency_p70_alarm": "addIntegrationLatencyP70Alarm",
        "add_integration_latency_p90_alarm": "addIntegrationLatencyP90Alarm",
        "add_integration_latency_p95_alarm": "addIntegrationLatencyP95Alarm",
        "add_integration_latency_p9999_alarm": "addIntegrationLatencyP9999Alarm",
        "add_integration_latency_p999_alarm": "addIntegrationLatencyP999Alarm",
        "add_integration_latency_p99_alarm": "addIntegrationLatencyP99Alarm",
        "add_integration_latency_tm50_alarm": "addIntegrationLatencyTM50Alarm",
        "add_integration_latency_tm70_alarm": "addIntegrationLatencyTM70Alarm",
        "add_integration_latency_tm90_alarm": "addIntegrationLatencyTM90Alarm",
        "add_integration_latency_tm95_alarm": "addIntegrationLatencyTM95Alarm",
        "add_integration_latency_tm9999_alarm": "addIntegrationLatencyTM9999Alarm",
        "add_integration_latency_tm999_alarm": "addIntegrationLatencyTM999Alarm",
        "add_integration_latency_tm99_alarm": "addIntegrationLatencyTM99Alarm",
        "add_latency_average_alarm": "addLatencyAverageAlarm",
        "add_latency_p100_alarm": "addLatencyP100Alarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p70_alarm": "addLatencyP70Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p95_alarm": "addLatencyP95Alarm",
        "add_latency_p9999_alarm": "addLatencyP9999Alarm",
        "add_latency_p999_alarm": "addLatencyP999Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_latency_tm50_alarm": "addLatencyTM50Alarm",
        "add_latency_tm70_alarm": "addLatencyTM70Alarm",
        "add_latency_tm90_alarm": "addLatencyTM90Alarm",
        "add_latency_tm95_alarm": "addLatencyTM95Alarm",
        "add_latency_tm9999_alarm": "addLatencyTM9999Alarm",
        "add_latency_tm999_alarm": "addLatencyTM999Alarm",
        "add_latency_tm99_alarm": "addLatencyTM99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "latency_types_to_render": "latencyTypesToRender",
    },
)
class ApiGatewayV2MonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4xx_count_alarm: 
        :param add4xx_rate_alarm: 
        :param add5xx_count_alarm: 
        :param add5xx_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_integration_latency_average_alarm: 
        :param add_integration_latency_p100_alarm: 
        :param add_integration_latency_p50_alarm: 
        :param add_integration_latency_p70_alarm: 
        :param add_integration_latency_p90_alarm: 
        :param add_integration_latency_p95_alarm: 
        :param add_integration_latency_p9999_alarm: 
        :param add_integration_latency_p999_alarm: 
        :param add_integration_latency_p99_alarm: 
        :param add_integration_latency_tm50_alarm: 
        :param add_integration_latency_tm70_alarm: 
        :param add_integration_latency_tm90_alarm: 
        :param add_integration_latency_tm95_alarm: 
        :param add_integration_latency_tm9999_alarm: 
        :param add_integration_latency_tm999_alarm: 
        :param add_integration_latency_tm99_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2MonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4xx_count_alarm", value=add4xx_count_alarm, expected_type=type_hints["add4xx_count_alarm"])
            check_type(argname="argument add4xx_rate_alarm", value=add4xx_rate_alarm, expected_type=type_hints["add4xx_rate_alarm"])
            check_type(argname="argument add5xx_count_alarm", value=add5xx_count_alarm, expected_type=type_hints["add5xx_count_alarm"])
            check_type(argname="argument add5xx_rate_alarm", value=add5xx_rate_alarm, expected_type=type_hints["add5xx_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_integration_latency_average_alarm", value=add_integration_latency_average_alarm, expected_type=type_hints["add_integration_latency_average_alarm"])
            check_type(argname="argument add_integration_latency_p100_alarm", value=add_integration_latency_p100_alarm, expected_type=type_hints["add_integration_latency_p100_alarm"])
            check_type(argname="argument add_integration_latency_p50_alarm", value=add_integration_latency_p50_alarm, expected_type=type_hints["add_integration_latency_p50_alarm"])
            check_type(argname="argument add_integration_latency_p70_alarm", value=add_integration_latency_p70_alarm, expected_type=type_hints["add_integration_latency_p70_alarm"])
            check_type(argname="argument add_integration_latency_p90_alarm", value=add_integration_latency_p90_alarm, expected_type=type_hints["add_integration_latency_p90_alarm"])
            check_type(argname="argument add_integration_latency_p95_alarm", value=add_integration_latency_p95_alarm, expected_type=type_hints["add_integration_latency_p95_alarm"])
            check_type(argname="argument add_integration_latency_p9999_alarm", value=add_integration_latency_p9999_alarm, expected_type=type_hints["add_integration_latency_p9999_alarm"])
            check_type(argname="argument add_integration_latency_p999_alarm", value=add_integration_latency_p999_alarm, expected_type=type_hints["add_integration_latency_p999_alarm"])
            check_type(argname="argument add_integration_latency_p99_alarm", value=add_integration_latency_p99_alarm, expected_type=type_hints["add_integration_latency_p99_alarm"])
            check_type(argname="argument add_integration_latency_tm50_alarm", value=add_integration_latency_tm50_alarm, expected_type=type_hints["add_integration_latency_tm50_alarm"])
            check_type(argname="argument add_integration_latency_tm70_alarm", value=add_integration_latency_tm70_alarm, expected_type=type_hints["add_integration_latency_tm70_alarm"])
            check_type(argname="argument add_integration_latency_tm90_alarm", value=add_integration_latency_tm90_alarm, expected_type=type_hints["add_integration_latency_tm90_alarm"])
            check_type(argname="argument add_integration_latency_tm95_alarm", value=add_integration_latency_tm95_alarm, expected_type=type_hints["add_integration_latency_tm95_alarm"])
            check_type(argname="argument add_integration_latency_tm9999_alarm", value=add_integration_latency_tm9999_alarm, expected_type=type_hints["add_integration_latency_tm9999_alarm"])
            check_type(argname="argument add_integration_latency_tm999_alarm", value=add_integration_latency_tm999_alarm, expected_type=type_hints["add_integration_latency_tm999_alarm"])
            check_type(argname="argument add_integration_latency_tm99_alarm", value=add_integration_latency_tm99_alarm, expected_type=type_hints["add_integration_latency_tm99_alarm"])
            check_type(argname="argument add_latency_average_alarm", value=add_latency_average_alarm, expected_type=type_hints["add_latency_average_alarm"])
            check_type(argname="argument add_latency_p100_alarm", value=add_latency_p100_alarm, expected_type=type_hints["add_latency_p100_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p70_alarm", value=add_latency_p70_alarm, expected_type=type_hints["add_latency_p70_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p95_alarm", value=add_latency_p95_alarm, expected_type=type_hints["add_latency_p95_alarm"])
            check_type(argname="argument add_latency_p9999_alarm", value=add_latency_p9999_alarm, expected_type=type_hints["add_latency_p9999_alarm"])
            check_type(argname="argument add_latency_p999_alarm", value=add_latency_p999_alarm, expected_type=type_hints["add_latency_p999_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_latency_tm50_alarm", value=add_latency_tm50_alarm, expected_type=type_hints["add_latency_tm50_alarm"])
            check_type(argname="argument add_latency_tm70_alarm", value=add_latency_tm70_alarm, expected_type=type_hints["add_latency_tm70_alarm"])
            check_type(argname="argument add_latency_tm90_alarm", value=add_latency_tm90_alarm, expected_type=type_hints["add_latency_tm90_alarm"])
            check_type(argname="argument add_latency_tm95_alarm", value=add_latency_tm95_alarm, expected_type=type_hints["add_latency_tm95_alarm"])
            check_type(argname="argument add_latency_tm9999_alarm", value=add_latency_tm9999_alarm, expected_type=type_hints["add_latency_tm9999_alarm"])
            check_type(argname="argument add_latency_tm999_alarm", value=add_latency_tm999_alarm, expected_type=type_hints["add_latency_tm999_alarm"])
            check_type(argname="argument add_latency_tm99_alarm", value=add_latency_tm99_alarm, expected_type=type_hints["add_latency_tm99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument latency_types_to_render", value=latency_types_to_render, expected_type=type_hints["latency_types_to_render"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4xx_count_alarm is not None:
            self._values["add4xx_count_alarm"] = add4xx_count_alarm
        if add4xx_rate_alarm is not None:
            self._values["add4xx_rate_alarm"] = add4xx_rate_alarm
        if add5xx_count_alarm is not None:
            self._values["add5xx_count_alarm"] = add5xx_count_alarm
        if add5xx_rate_alarm is not None:
            self._values["add5xx_rate_alarm"] = add5xx_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_integration_latency_average_alarm is not None:
            self._values["add_integration_latency_average_alarm"] = add_integration_latency_average_alarm
        if add_integration_latency_p100_alarm is not None:
            self._values["add_integration_latency_p100_alarm"] = add_integration_latency_p100_alarm
        if add_integration_latency_p50_alarm is not None:
            self._values["add_integration_latency_p50_alarm"] = add_integration_latency_p50_alarm
        if add_integration_latency_p70_alarm is not None:
            self._values["add_integration_latency_p70_alarm"] = add_integration_latency_p70_alarm
        if add_integration_latency_p90_alarm is not None:
            self._values["add_integration_latency_p90_alarm"] = add_integration_latency_p90_alarm
        if add_integration_latency_p95_alarm is not None:
            self._values["add_integration_latency_p95_alarm"] = add_integration_latency_p95_alarm
        if add_integration_latency_p9999_alarm is not None:
            self._values["add_integration_latency_p9999_alarm"] = add_integration_latency_p9999_alarm
        if add_integration_latency_p999_alarm is not None:
            self._values["add_integration_latency_p999_alarm"] = add_integration_latency_p999_alarm
        if add_integration_latency_p99_alarm is not None:
            self._values["add_integration_latency_p99_alarm"] = add_integration_latency_p99_alarm
        if add_integration_latency_tm50_alarm is not None:
            self._values["add_integration_latency_tm50_alarm"] = add_integration_latency_tm50_alarm
        if add_integration_latency_tm70_alarm is not None:
            self._values["add_integration_latency_tm70_alarm"] = add_integration_latency_tm70_alarm
        if add_integration_latency_tm90_alarm is not None:
            self._values["add_integration_latency_tm90_alarm"] = add_integration_latency_tm90_alarm
        if add_integration_latency_tm95_alarm is not None:
            self._values["add_integration_latency_tm95_alarm"] = add_integration_latency_tm95_alarm
        if add_integration_latency_tm9999_alarm is not None:
            self._values["add_integration_latency_tm9999_alarm"] = add_integration_latency_tm9999_alarm
        if add_integration_latency_tm999_alarm is not None:
            self._values["add_integration_latency_tm999_alarm"] = add_integration_latency_tm999_alarm
        if add_integration_latency_tm99_alarm is not None:
            self._values["add_integration_latency_tm99_alarm"] = add_integration_latency_tm99_alarm
        if add_latency_average_alarm is not None:
            self._values["add_latency_average_alarm"] = add_latency_average_alarm
        if add_latency_p100_alarm is not None:
            self._values["add_latency_p100_alarm"] = add_latency_p100_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p70_alarm is not None:
            self._values["add_latency_p70_alarm"] = add_latency_p70_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p95_alarm is not None:
            self._values["add_latency_p95_alarm"] = add_latency_p95_alarm
        if add_latency_p9999_alarm is not None:
            self._values["add_latency_p9999_alarm"] = add_latency_p9999_alarm
        if add_latency_p999_alarm is not None:
            self._values["add_latency_p999_alarm"] = add_latency_p999_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_latency_tm50_alarm is not None:
            self._values["add_latency_tm50_alarm"] = add_latency_tm50_alarm
        if add_latency_tm70_alarm is not None:
            self._values["add_latency_tm70_alarm"] = add_latency_tm70_alarm
        if add_latency_tm90_alarm is not None:
            self._values["add_latency_tm90_alarm"] = add_latency_tm90_alarm
        if add_latency_tm95_alarm is not None:
            self._values["add_latency_tm95_alarm"] = add_latency_tm95_alarm
        if add_latency_tm9999_alarm is not None:
            self._values["add_latency_tm9999_alarm"] = add_latency_tm9999_alarm
        if add_latency_tm999_alarm is not None:
            self._values["add_latency_tm999_alarm"] = add_latency_tm999_alarm
        if add_latency_tm99_alarm is not None:
            self._values["add_latency_tm99_alarm"] = add_latency_tm99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if latency_types_to_render is not None:
            self._values["latency_types_to_render"] = latency_types_to_render

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4xx_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4xx_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5xx_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5xx_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_integration_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def latency_types_to_render(self) -> typing.Optional[typing.List[LatencyType]]:
        '''(experimental) You can specify what latency types you want to be rendered in the dashboards.

        Note: any latency type with an alarm will be also added automatically.
        If the list is undefined, default values will be shown.
        If the list is empty, only the latency types with an alarm will be shown (if any).

        :default: - p50, p90, p99 (

        :see: DefaultLatencyTypesShown)
        :stability: experimental
        '''
        result = self._values.get("latency_types_to_render")
        return typing.cast(typing.Optional[typing.List[LatencyType]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayV2MonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AppSyncMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4_xx_error_count_alarm": "add4XXErrorCountAlarm",
        "add4_xx_error_rate_alarm": "add4XXErrorRateAlarm",
        "add5_xx_fault_count_alarm": "add5XXFaultCountAlarm",
        "add5_xx_fault_rate_alarm": "add5XXFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
    },
)
class AppSyncMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4_xx_error_count_alarm", value=add4_xx_error_count_alarm, expected_type=type_hints["add4_xx_error_count_alarm"])
            check_type(argname="argument add4_xx_error_rate_alarm", value=add4_xx_error_rate_alarm, expected_type=type_hints["add4_xx_error_rate_alarm"])
            check_type(argname="argument add5_xx_fault_count_alarm", value=add5_xx_fault_count_alarm, expected_type=type_hints["add5_xx_fault_count_alarm"])
            check_type(argname="argument add5_xx_fault_rate_alarm", value=add5_xx_fault_rate_alarm, expected_type=type_hints["add5_xx_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4_xx_error_count_alarm is not None:
            self._values["add4_xx_error_count_alarm"] = add4_xx_error_count_alarm
        if add4_xx_error_rate_alarm is not None:
            self._values["add4_xx_error_rate_alarm"] = add4_xx_error_rate_alarm
        if add5_xx_fault_count_alarm is not None:
            self._values["add5_xx_fault_count_alarm"] = add5_xx_fault_count_alarm
        if add5_xx_fault_rate_alarm is not None:
            self._values["add5_xx_fault_rate_alarm"] = add5_xx_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4_xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4_xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5_xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5_xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSyncMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AppSyncMonitoringProps",
    jsii_struct_bases=[AppSyncMonitoringOptions, AppSyncMetricFactoryProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4_xx_error_count_alarm": "add4XXErrorCountAlarm",
        "add4_xx_error_rate_alarm": "add4XXErrorRateAlarm",
        "add5_xx_fault_count_alarm": "add5XXFaultCountAlarm",
        "add5_xx_fault_rate_alarm": "add5XXFaultRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "api": "api",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
    },
)
class AppSyncMonitoringProps(AppSyncMonitoringOptions, AppSyncMetricFactoryProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4_xx_error_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4_xx_error_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5_xx_fault_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        api: aws_cdk.aws_appsync_alpha.GraphqlApi,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4_xx_error_count_alarm: 
        :param add4_xx_error_rate_alarm: 
        :param add5_xx_fault_count_alarm: 
        :param add5_xx_fault_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p99_alarm: 
        :param add_low_tps_alarm: 
        :param api: (experimental) the GraphQL API to monitor.
        :param fill_tps_with_zeroes: (experimental) whether the TPS should be filled with zeroes. Default: - true
        :param rate_computation_method: (experimental) method to compute TPS. Default: - average

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AppSyncMonitoringProps.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4_xx_error_count_alarm", value=add4_xx_error_count_alarm, expected_type=type_hints["add4_xx_error_count_alarm"])
            check_type(argname="argument add4_xx_error_rate_alarm", value=add4_xx_error_rate_alarm, expected_type=type_hints["add4_xx_error_rate_alarm"])
            check_type(argname="argument add5_xx_fault_count_alarm", value=add5_xx_fault_count_alarm, expected_type=type_hints["add5_xx_fault_count_alarm"])
            check_type(argname="argument add5_xx_fault_rate_alarm", value=add5_xx_fault_rate_alarm, expected_type=type_hints["add5_xx_fault_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4_xx_error_count_alarm is not None:
            self._values["add4_xx_error_count_alarm"] = add4_xx_error_count_alarm
        if add4_xx_error_rate_alarm is not None:
            self._values["add4_xx_error_rate_alarm"] = add4_xx_error_rate_alarm
        if add5_xx_fault_count_alarm is not None:
            self._values["add5_xx_fault_count_alarm"] = add5_xx_fault_count_alarm
        if add5_xx_fault_rate_alarm is not None:
            self._values["add5_xx_fault_rate_alarm"] = add5_xx_fault_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4_xx_error_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4_xx_error_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4_xx_error_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5_xx_fault_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5_xx_fault_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5_xx_fault_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def api(self) -> aws_cdk.aws_appsync_alpha.GraphqlApi:
        '''(experimental) the GraphQL API to monitor.

        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_appsync_alpha.GraphqlApi, result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''(experimental) whether the TPS should be filled with zeroes.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''(experimental) method to compute TPS.

        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AppSyncMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AutoScalingGroupMonitoringOptions",
    jsii_struct_bases=[BaseMonitoringProps],
    name_mapping={
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class AutoScalingGroupMonitoringOptions(BaseMonitoringProps):
    def __init__(
        self,
        *,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMonitoringOptions.__init__)
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {}
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupMonitoringOptions(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.AutoScalingGroupMonitoringProps",
    jsii_struct_bases=[
        AutoScalingGroupMetricFactoryProps, AutoScalingGroupMonitoringOptions
    ],
    name_mapping={
        "auto_scaling_group": "autoScalingGroup",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
    },
)
class AutoScalingGroupMonitoringProps(
    AutoScalingGroupMetricFactoryProps,
    AutoScalingGroupMonitoringOptions,
):
    def __init__(
        self,
        *,
        auto_scaling_group: aws_cdk.aws_autoscaling.IAutoScalingGroup,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
    ) -> None:
        '''
        :param auto_scaling_group: 
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(AutoScalingGroupMonitoringProps.__init__)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
        self._values: typing.Dict[str, typing.Any] = {
            "auto_scaling_group": auto_scaling_group,
        }
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms

    @builtins.property
    def auto_scaling_group(self) -> aws_cdk.aws_autoscaling.IAutoScalingGroup:
        '''
        :stability: experimental
        '''
        result = self._values.get("auto_scaling_group")
        assert result is not None, "Required property 'auto_scaling_group' is missing"
        return typing.cast(aws_cdk.aws_autoscaling.IAutoScalingGroup, result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DefaultAlarmAnnotationStrategy(
    FillingAlarmAnnotationStrategy,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DefaultAlarmAnnotationStrategy",
):
    '''(experimental) Default annotation strategy that returns the built-in alarm annotation.

    :stability: experimental
    '''

    def __init__(self) -> None:
        '''
        :stability: experimental
        '''
        jsii.create(self.__class__, self, [])

    @jsii.member(jsii_name="createAnnotationToFill")
    def _create_annotation_to_fill(
        self,
        *,
        alarm: aws_cdk.aws_cloudwatch.Alarm,
        comparison_operator: aws_cdk.aws_cloudwatch.ComparisonOperator,
        datapoints_to_alarm: jsii.Number,
        evaluation_periods: jsii.Number,
        fill_alarm_range: builtins.bool,
        metric: typing.Union[aws_cdk.aws_cloudwatch.Metric, aws_cdk.aws_cloudwatch.MathExpression],
        threshold: jsii.Number,
        min_metric_samples_to_alarm: typing.Optional[jsii.Number] = None,
        override_annotation_color: typing.Optional[builtins.str] = None,
        override_annotation_label: typing.Optional[builtins.str] = None,
        override_annotation_visibility: typing.Optional[builtins.bool] = None,
        action: IAlarmActionStrategy,
        custom_params: typing.Optional[typing.Mapping[builtins.str, typing.Any]] = None,
        custom_tags: typing.Optional[typing.Sequence[builtins.str]] = None,
        dedupe_string: typing.Optional[builtins.str] = None,
        disambiguator: typing.Optional[builtins.str] = None,
    ) -> aws_cdk.aws_cloudwatch.HorizontalAnnotation:
        '''
        :param alarm: 
        :param comparison_operator: 
        :param datapoints_to_alarm: 
        :param evaluation_periods: 
        :param fill_alarm_range: 
        :param metric: 
        :param threshold: 
        :param min_metric_samples_to_alarm: 
        :param override_annotation_color: 
        :param override_annotation_label: 
        :param override_annotation_visibility: 
        :param action: 
        :param custom_params: 
        :param custom_tags: 
        :param dedupe_string: 
        :param disambiguator: 

        :stability: experimental
        '''
        props = AlarmAnnotationStrategyProps(
            alarm=alarm,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            fill_alarm_range=fill_alarm_range,
            metric=metric,
            threshold=threshold,
            min_metric_samples_to_alarm=min_metric_samples_to_alarm,
            override_annotation_color=override_annotation_color,
            override_annotation_label=override_annotation_label,
            override_annotation_visibility=override_annotation_visibility,
            action=action,
            custom_params=custom_params,
            custom_tags=custom_tags,
            dedupe_string=dedupe_string,
            disambiguator=disambiguator,
        )

        return typing.cast(aws_cdk.aws_cloudwatch.HorizontalAnnotation, jsii.invoke(self, "createAnnotationToFill", [props]))


class DoNotModifyDedupeString(
    ExtendDedupeString,
    metaclass=jsii.JSIIMeta,
    jsii_type="cdk-monitoring-constructs.DoNotModifyDedupeString",
):
    '''(experimental) Default dedupe strategy - does not add any prefix nor suffix.

    :stability: experimental
    '''

    def __init__(
        self,
        prefix: typing.Optional[builtins.str] = None,
        suffix: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param prefix: -
        :param suffix: -

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(DoNotModifyDedupeString.__init__)
            check_type(argname="argument prefix", value=prefix, expected_type=type_hints["prefix"])
            check_type(argname="argument suffix", value=suffix, expected_type=type_hints["suffix"])
        jsii.create(self.__class__, self, [prefix, suffix])


@jsii.data_type(
    jsii_type="cdk-monitoring-constructs.ApiGatewayV2HttpApiMonitoringProps",
    jsii_struct_bases=[
        ApiGatewayV2HttpApiMetricFactoryProps, ApiGatewayV2MonitoringOptions
    ],
    name_mapping={
        "api": "api",
        "api_method": "apiMethod",
        "api_resource": "apiResource",
        "api_stage": "apiStage",
        "fill_tps_with_zeroes": "fillTpsWithZeroes",
        "rate_computation_method": "rateComputationMethod",
        "alarm_friendly_name": "alarmFriendlyName",
        "human_readable_name": "humanReadableName",
        "local_alarm_name_prefix_override": "localAlarmNamePrefixOverride",
        "add_to_alarm_dashboard": "addToAlarmDashboard",
        "add_to_detail_dashboard": "addToDetailDashboard",
        "add_to_summary_dashboard": "addToSummaryDashboard",
        "use_created_alarms": "useCreatedAlarms",
        "add4xx_count_alarm": "add4xxCountAlarm",
        "add4xx_rate_alarm": "add4xxRateAlarm",
        "add5xx_count_alarm": "add5xxCountAlarm",
        "add5xx_rate_alarm": "add5xxRateAlarm",
        "add_high_tps_alarm": "addHighTpsAlarm",
        "add_integration_latency_average_alarm": "addIntegrationLatencyAverageAlarm",
        "add_integration_latency_p100_alarm": "addIntegrationLatencyP100Alarm",
        "add_integration_latency_p50_alarm": "addIntegrationLatencyP50Alarm",
        "add_integration_latency_p70_alarm": "addIntegrationLatencyP70Alarm",
        "add_integration_latency_p90_alarm": "addIntegrationLatencyP90Alarm",
        "add_integration_latency_p95_alarm": "addIntegrationLatencyP95Alarm",
        "add_integration_latency_p9999_alarm": "addIntegrationLatencyP9999Alarm",
        "add_integration_latency_p999_alarm": "addIntegrationLatencyP999Alarm",
        "add_integration_latency_p99_alarm": "addIntegrationLatencyP99Alarm",
        "add_integration_latency_tm50_alarm": "addIntegrationLatencyTM50Alarm",
        "add_integration_latency_tm70_alarm": "addIntegrationLatencyTM70Alarm",
        "add_integration_latency_tm90_alarm": "addIntegrationLatencyTM90Alarm",
        "add_integration_latency_tm95_alarm": "addIntegrationLatencyTM95Alarm",
        "add_integration_latency_tm9999_alarm": "addIntegrationLatencyTM9999Alarm",
        "add_integration_latency_tm999_alarm": "addIntegrationLatencyTM999Alarm",
        "add_integration_latency_tm99_alarm": "addIntegrationLatencyTM99Alarm",
        "add_latency_average_alarm": "addLatencyAverageAlarm",
        "add_latency_p100_alarm": "addLatencyP100Alarm",
        "add_latency_p50_alarm": "addLatencyP50Alarm",
        "add_latency_p70_alarm": "addLatencyP70Alarm",
        "add_latency_p90_alarm": "addLatencyP90Alarm",
        "add_latency_p95_alarm": "addLatencyP95Alarm",
        "add_latency_p9999_alarm": "addLatencyP9999Alarm",
        "add_latency_p999_alarm": "addLatencyP999Alarm",
        "add_latency_p99_alarm": "addLatencyP99Alarm",
        "add_latency_tm50_alarm": "addLatencyTM50Alarm",
        "add_latency_tm70_alarm": "addLatencyTM70Alarm",
        "add_latency_tm90_alarm": "addLatencyTM90Alarm",
        "add_latency_tm95_alarm": "addLatencyTM95Alarm",
        "add_latency_tm9999_alarm": "addLatencyTM9999Alarm",
        "add_latency_tm999_alarm": "addLatencyTM999Alarm",
        "add_latency_tm99_alarm": "addLatencyTM99Alarm",
        "add_low_tps_alarm": "addLowTpsAlarm",
        "latency_types_to_render": "latencyTypesToRender",
    },
)
class ApiGatewayV2HttpApiMonitoringProps(
    ApiGatewayV2HttpApiMetricFactoryProps,
    ApiGatewayV2MonitoringOptions,
):
    def __init__(
        self,
        *,
        api: aws_cdk.aws_apigatewayv2_alpha.IHttpApi,
        api_method: typing.Optional[builtins.str] = None,
        api_resource: typing.Optional[builtins.str] = None,
        api_stage: typing.Optional[builtins.str] = None,
        fill_tps_with_zeroes: typing.Optional[builtins.bool] = None,
        rate_computation_method: typing.Optional[RateComputationMethod] = None,
        alarm_friendly_name: typing.Optional[builtins.str] = None,
        human_readable_name: typing.Optional[builtins.str] = None,
        local_alarm_name_prefix_override: typing.Optional[builtins.str] = None,
        add_to_alarm_dashboard: typing.Optional[builtins.bool] = None,
        add_to_detail_dashboard: typing.Optional[builtins.bool] = None,
        add_to_summary_dashboard: typing.Optional[builtins.bool] = None,
        use_created_alarms: typing.Optional[IAlarmConsumer] = None,
        add4xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add4xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_count_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorCountThreshold, typing.Dict[str, typing.Any]]]] = None,
        add5xx_rate_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[ErrorRateThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_high_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[HighTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_integration_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_average_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p100_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_p99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm50_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm70_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm90_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm95_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm9999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm999_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_latency_tm99_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LatencyThreshold, typing.Dict[str, typing.Any]]]] = None,
        add_low_tps_alarm: typing.Optional[typing.Mapping[builtins.str, typing.Union[LowTpsThreshold, typing.Dict[str, typing.Any]]]] = None,
        latency_types_to_render: typing.Optional[typing.Sequence[LatencyType]] = None,
    ) -> None:
        '''
        :param api: 
        :param api_method: (experimental) On undefined value is not set in dimensions.
        :param api_resource: (experimental) On undefined value is not set in dimensions.
        :param api_stage: Default: - $default
        :param fill_tps_with_zeroes: Default: - true
        :param rate_computation_method: Default: - average
        :param alarm_friendly_name: (experimental) Plain name, used in naming alarms. This unique among other resources, and respect the AWS CDK restriction posed on alarm names. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens. Default: - derives name from the construct itself
        :param human_readable_name: (experimental) Human-readable name is a freeform string, used as a caption or description. There are no limitations on what it can be. Default: - use alarmFriendlyName
        :param local_alarm_name_prefix_override: (experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value. The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.
        :param add_to_alarm_dashboard: (experimental) Flag indicating if the widgets should be added to alarm dashboard. Default: - true
        :param add_to_detail_dashboard: (experimental) Flag indicating if the widgets should be added to detailed dashboard. Default: - true
        :param add_to_summary_dashboard: (experimental) Flag indicating if the widgets should be added to summary dashboard. Default: - true
        :param use_created_alarms: (experimental) Calls provided function to process all alarms created.
        :param add4xx_count_alarm: 
        :param add4xx_rate_alarm: 
        :param add5xx_count_alarm: 
        :param add5xx_rate_alarm: 
        :param add_high_tps_alarm: 
        :param add_integration_latency_average_alarm: 
        :param add_integration_latency_p100_alarm: 
        :param add_integration_latency_p50_alarm: 
        :param add_integration_latency_p70_alarm: 
        :param add_integration_latency_p90_alarm: 
        :param add_integration_latency_p95_alarm: 
        :param add_integration_latency_p9999_alarm: 
        :param add_integration_latency_p999_alarm: 
        :param add_integration_latency_p99_alarm: 
        :param add_integration_latency_tm50_alarm: 
        :param add_integration_latency_tm70_alarm: 
        :param add_integration_latency_tm90_alarm: 
        :param add_integration_latency_tm95_alarm: 
        :param add_integration_latency_tm9999_alarm: 
        :param add_integration_latency_tm999_alarm: 
        :param add_integration_latency_tm99_alarm: 
        :param add_latency_average_alarm: 
        :param add_latency_p100_alarm: 
        :param add_latency_p50_alarm: 
        :param add_latency_p70_alarm: 
        :param add_latency_p90_alarm: 
        :param add_latency_p95_alarm: 
        :param add_latency_p9999_alarm: 
        :param add_latency_p999_alarm: 
        :param add_latency_p99_alarm: 
        :param add_latency_tm50_alarm: 
        :param add_latency_tm70_alarm: 
        :param add_latency_tm90_alarm: 
        :param add_latency_tm95_alarm: 
        :param add_latency_tm9999_alarm: 
        :param add_latency_tm999_alarm: 
        :param add_latency_tm99_alarm: 
        :param add_low_tps_alarm: 
        :param latency_types_to_render: (experimental) You can specify what latency types you want to be rendered in the dashboards. Note: any latency type with an alarm will be also added automatically. If the list is undefined, default values will be shown. If the list is empty, only the latency types with an alarm will be shown (if any). Default: - p50, p90, p99 (

        :stability: experimental
        '''
        if __debug__:
            type_hints = typing.get_type_hints(ApiGatewayV2HttpApiMonitoringProps.__init__)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument api_method", value=api_method, expected_type=type_hints["api_method"])
            check_type(argname="argument api_resource", value=api_resource, expected_type=type_hints["api_resource"])
            check_type(argname="argument api_stage", value=api_stage, expected_type=type_hints["api_stage"])
            check_type(argname="argument fill_tps_with_zeroes", value=fill_tps_with_zeroes, expected_type=type_hints["fill_tps_with_zeroes"])
            check_type(argname="argument rate_computation_method", value=rate_computation_method, expected_type=type_hints["rate_computation_method"])
            check_type(argname="argument alarm_friendly_name", value=alarm_friendly_name, expected_type=type_hints["alarm_friendly_name"])
            check_type(argname="argument human_readable_name", value=human_readable_name, expected_type=type_hints["human_readable_name"])
            check_type(argname="argument local_alarm_name_prefix_override", value=local_alarm_name_prefix_override, expected_type=type_hints["local_alarm_name_prefix_override"])
            check_type(argname="argument add_to_alarm_dashboard", value=add_to_alarm_dashboard, expected_type=type_hints["add_to_alarm_dashboard"])
            check_type(argname="argument add_to_detail_dashboard", value=add_to_detail_dashboard, expected_type=type_hints["add_to_detail_dashboard"])
            check_type(argname="argument add_to_summary_dashboard", value=add_to_summary_dashboard, expected_type=type_hints["add_to_summary_dashboard"])
            check_type(argname="argument use_created_alarms", value=use_created_alarms, expected_type=type_hints["use_created_alarms"])
            check_type(argname="argument add4xx_count_alarm", value=add4xx_count_alarm, expected_type=type_hints["add4xx_count_alarm"])
            check_type(argname="argument add4xx_rate_alarm", value=add4xx_rate_alarm, expected_type=type_hints["add4xx_rate_alarm"])
            check_type(argname="argument add5xx_count_alarm", value=add5xx_count_alarm, expected_type=type_hints["add5xx_count_alarm"])
            check_type(argname="argument add5xx_rate_alarm", value=add5xx_rate_alarm, expected_type=type_hints["add5xx_rate_alarm"])
            check_type(argname="argument add_high_tps_alarm", value=add_high_tps_alarm, expected_type=type_hints["add_high_tps_alarm"])
            check_type(argname="argument add_integration_latency_average_alarm", value=add_integration_latency_average_alarm, expected_type=type_hints["add_integration_latency_average_alarm"])
            check_type(argname="argument add_integration_latency_p100_alarm", value=add_integration_latency_p100_alarm, expected_type=type_hints["add_integration_latency_p100_alarm"])
            check_type(argname="argument add_integration_latency_p50_alarm", value=add_integration_latency_p50_alarm, expected_type=type_hints["add_integration_latency_p50_alarm"])
            check_type(argname="argument add_integration_latency_p70_alarm", value=add_integration_latency_p70_alarm, expected_type=type_hints["add_integration_latency_p70_alarm"])
            check_type(argname="argument add_integration_latency_p90_alarm", value=add_integration_latency_p90_alarm, expected_type=type_hints["add_integration_latency_p90_alarm"])
            check_type(argname="argument add_integration_latency_p95_alarm", value=add_integration_latency_p95_alarm, expected_type=type_hints["add_integration_latency_p95_alarm"])
            check_type(argname="argument add_integration_latency_p9999_alarm", value=add_integration_latency_p9999_alarm, expected_type=type_hints["add_integration_latency_p9999_alarm"])
            check_type(argname="argument add_integration_latency_p999_alarm", value=add_integration_latency_p999_alarm, expected_type=type_hints["add_integration_latency_p999_alarm"])
            check_type(argname="argument add_integration_latency_p99_alarm", value=add_integration_latency_p99_alarm, expected_type=type_hints["add_integration_latency_p99_alarm"])
            check_type(argname="argument add_integration_latency_tm50_alarm", value=add_integration_latency_tm50_alarm, expected_type=type_hints["add_integration_latency_tm50_alarm"])
            check_type(argname="argument add_integration_latency_tm70_alarm", value=add_integration_latency_tm70_alarm, expected_type=type_hints["add_integration_latency_tm70_alarm"])
            check_type(argname="argument add_integration_latency_tm90_alarm", value=add_integration_latency_tm90_alarm, expected_type=type_hints["add_integration_latency_tm90_alarm"])
            check_type(argname="argument add_integration_latency_tm95_alarm", value=add_integration_latency_tm95_alarm, expected_type=type_hints["add_integration_latency_tm95_alarm"])
            check_type(argname="argument add_integration_latency_tm9999_alarm", value=add_integration_latency_tm9999_alarm, expected_type=type_hints["add_integration_latency_tm9999_alarm"])
            check_type(argname="argument add_integration_latency_tm999_alarm", value=add_integration_latency_tm999_alarm, expected_type=type_hints["add_integration_latency_tm999_alarm"])
            check_type(argname="argument add_integration_latency_tm99_alarm", value=add_integration_latency_tm99_alarm, expected_type=type_hints["add_integration_latency_tm99_alarm"])
            check_type(argname="argument add_latency_average_alarm", value=add_latency_average_alarm, expected_type=type_hints["add_latency_average_alarm"])
            check_type(argname="argument add_latency_p100_alarm", value=add_latency_p100_alarm, expected_type=type_hints["add_latency_p100_alarm"])
            check_type(argname="argument add_latency_p50_alarm", value=add_latency_p50_alarm, expected_type=type_hints["add_latency_p50_alarm"])
            check_type(argname="argument add_latency_p70_alarm", value=add_latency_p70_alarm, expected_type=type_hints["add_latency_p70_alarm"])
            check_type(argname="argument add_latency_p90_alarm", value=add_latency_p90_alarm, expected_type=type_hints["add_latency_p90_alarm"])
            check_type(argname="argument add_latency_p95_alarm", value=add_latency_p95_alarm, expected_type=type_hints["add_latency_p95_alarm"])
            check_type(argname="argument add_latency_p9999_alarm", value=add_latency_p9999_alarm, expected_type=type_hints["add_latency_p9999_alarm"])
            check_type(argname="argument add_latency_p999_alarm", value=add_latency_p999_alarm, expected_type=type_hints["add_latency_p999_alarm"])
            check_type(argname="argument add_latency_p99_alarm", value=add_latency_p99_alarm, expected_type=type_hints["add_latency_p99_alarm"])
            check_type(argname="argument add_latency_tm50_alarm", value=add_latency_tm50_alarm, expected_type=type_hints["add_latency_tm50_alarm"])
            check_type(argname="argument add_latency_tm70_alarm", value=add_latency_tm70_alarm, expected_type=type_hints["add_latency_tm70_alarm"])
            check_type(argname="argument add_latency_tm90_alarm", value=add_latency_tm90_alarm, expected_type=type_hints["add_latency_tm90_alarm"])
            check_type(argname="argument add_latency_tm95_alarm", value=add_latency_tm95_alarm, expected_type=type_hints["add_latency_tm95_alarm"])
            check_type(argname="argument add_latency_tm9999_alarm", value=add_latency_tm9999_alarm, expected_type=type_hints["add_latency_tm9999_alarm"])
            check_type(argname="argument add_latency_tm999_alarm", value=add_latency_tm999_alarm, expected_type=type_hints["add_latency_tm999_alarm"])
            check_type(argname="argument add_latency_tm99_alarm", value=add_latency_tm99_alarm, expected_type=type_hints["add_latency_tm99_alarm"])
            check_type(argname="argument add_low_tps_alarm", value=add_low_tps_alarm, expected_type=type_hints["add_low_tps_alarm"])
            check_type(argname="argument latency_types_to_render", value=latency_types_to_render, expected_type=type_hints["latency_types_to_render"])
        self._values: typing.Dict[str, typing.Any] = {
            "api": api,
        }
        if api_method is not None:
            self._values["api_method"] = api_method
        if api_resource is not None:
            self._values["api_resource"] = api_resource
        if api_stage is not None:
            self._values["api_stage"] = api_stage
        if fill_tps_with_zeroes is not None:
            self._values["fill_tps_with_zeroes"] = fill_tps_with_zeroes
        if rate_computation_method is not None:
            self._values["rate_computation_method"] = rate_computation_method
        if alarm_friendly_name is not None:
            self._values["alarm_friendly_name"] = alarm_friendly_name
        if human_readable_name is not None:
            self._values["human_readable_name"] = human_readable_name
        if local_alarm_name_prefix_override is not None:
            self._values["local_alarm_name_prefix_override"] = local_alarm_name_prefix_override
        if add_to_alarm_dashboard is not None:
            self._values["add_to_alarm_dashboard"] = add_to_alarm_dashboard
        if add_to_detail_dashboard is not None:
            self._values["add_to_detail_dashboard"] = add_to_detail_dashboard
        if add_to_summary_dashboard is not None:
            self._values["add_to_summary_dashboard"] = add_to_summary_dashboard
        if use_created_alarms is not None:
            self._values["use_created_alarms"] = use_created_alarms
        if add4xx_count_alarm is not None:
            self._values["add4xx_count_alarm"] = add4xx_count_alarm
        if add4xx_rate_alarm is not None:
            self._values["add4xx_rate_alarm"] = add4xx_rate_alarm
        if add5xx_count_alarm is not None:
            self._values["add5xx_count_alarm"] = add5xx_count_alarm
        if add5xx_rate_alarm is not None:
            self._values["add5xx_rate_alarm"] = add5xx_rate_alarm
        if add_high_tps_alarm is not None:
            self._values["add_high_tps_alarm"] = add_high_tps_alarm
        if add_integration_latency_average_alarm is not None:
            self._values["add_integration_latency_average_alarm"] = add_integration_latency_average_alarm
        if add_integration_latency_p100_alarm is not None:
            self._values["add_integration_latency_p100_alarm"] = add_integration_latency_p100_alarm
        if add_integration_latency_p50_alarm is not None:
            self._values["add_integration_latency_p50_alarm"] = add_integration_latency_p50_alarm
        if add_integration_latency_p70_alarm is not None:
            self._values["add_integration_latency_p70_alarm"] = add_integration_latency_p70_alarm
        if add_integration_latency_p90_alarm is not None:
            self._values["add_integration_latency_p90_alarm"] = add_integration_latency_p90_alarm
        if add_integration_latency_p95_alarm is not None:
            self._values["add_integration_latency_p95_alarm"] = add_integration_latency_p95_alarm
        if add_integration_latency_p9999_alarm is not None:
            self._values["add_integration_latency_p9999_alarm"] = add_integration_latency_p9999_alarm
        if add_integration_latency_p999_alarm is not None:
            self._values["add_integration_latency_p999_alarm"] = add_integration_latency_p999_alarm
        if add_integration_latency_p99_alarm is not None:
            self._values["add_integration_latency_p99_alarm"] = add_integration_latency_p99_alarm
        if add_integration_latency_tm50_alarm is not None:
            self._values["add_integration_latency_tm50_alarm"] = add_integration_latency_tm50_alarm
        if add_integration_latency_tm70_alarm is not None:
            self._values["add_integration_latency_tm70_alarm"] = add_integration_latency_tm70_alarm
        if add_integration_latency_tm90_alarm is not None:
            self._values["add_integration_latency_tm90_alarm"] = add_integration_latency_tm90_alarm
        if add_integration_latency_tm95_alarm is not None:
            self._values["add_integration_latency_tm95_alarm"] = add_integration_latency_tm95_alarm
        if add_integration_latency_tm9999_alarm is not None:
            self._values["add_integration_latency_tm9999_alarm"] = add_integration_latency_tm9999_alarm
        if add_integration_latency_tm999_alarm is not None:
            self._values["add_integration_latency_tm999_alarm"] = add_integration_latency_tm999_alarm
        if add_integration_latency_tm99_alarm is not None:
            self._values["add_integration_latency_tm99_alarm"] = add_integration_latency_tm99_alarm
        if add_latency_average_alarm is not None:
            self._values["add_latency_average_alarm"] = add_latency_average_alarm
        if add_latency_p100_alarm is not None:
            self._values["add_latency_p100_alarm"] = add_latency_p100_alarm
        if add_latency_p50_alarm is not None:
            self._values["add_latency_p50_alarm"] = add_latency_p50_alarm
        if add_latency_p70_alarm is not None:
            self._values["add_latency_p70_alarm"] = add_latency_p70_alarm
        if add_latency_p90_alarm is not None:
            self._values["add_latency_p90_alarm"] = add_latency_p90_alarm
        if add_latency_p95_alarm is not None:
            self._values["add_latency_p95_alarm"] = add_latency_p95_alarm
        if add_latency_p9999_alarm is not None:
            self._values["add_latency_p9999_alarm"] = add_latency_p9999_alarm
        if add_latency_p999_alarm is not None:
            self._values["add_latency_p999_alarm"] = add_latency_p999_alarm
        if add_latency_p99_alarm is not None:
            self._values["add_latency_p99_alarm"] = add_latency_p99_alarm
        if add_latency_tm50_alarm is not None:
            self._values["add_latency_tm50_alarm"] = add_latency_tm50_alarm
        if add_latency_tm70_alarm is not None:
            self._values["add_latency_tm70_alarm"] = add_latency_tm70_alarm
        if add_latency_tm90_alarm is not None:
            self._values["add_latency_tm90_alarm"] = add_latency_tm90_alarm
        if add_latency_tm95_alarm is not None:
            self._values["add_latency_tm95_alarm"] = add_latency_tm95_alarm
        if add_latency_tm9999_alarm is not None:
            self._values["add_latency_tm9999_alarm"] = add_latency_tm9999_alarm
        if add_latency_tm999_alarm is not None:
            self._values["add_latency_tm999_alarm"] = add_latency_tm999_alarm
        if add_latency_tm99_alarm is not None:
            self._values["add_latency_tm99_alarm"] = add_latency_tm99_alarm
        if add_low_tps_alarm is not None:
            self._values["add_low_tps_alarm"] = add_low_tps_alarm
        if latency_types_to_render is not None:
            self._values["latency_types_to_render"] = latency_types_to_render

    @builtins.property
    def api(self) -> aws_cdk.aws_apigatewayv2_alpha.IHttpApi:
        '''
        :stability: experimental
        '''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(aws_cdk.aws_apigatewayv2_alpha.IHttpApi, result)

    @builtins.property
    def api_method(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_method")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_resource(self) -> typing.Optional[builtins.str]:
        '''(experimental) On undefined value is not set in dimensions.

        :stability: experimental
        '''
        result = self._values.get("api_resource")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def api_stage(self) -> typing.Optional[builtins.str]:
        '''
        :default: - $default

        :stability: experimental
        '''
        result = self._values.get("api_stage")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def fill_tps_with_zeroes(self) -> typing.Optional[builtins.bool]:
        '''
        :default: - true

        :stability: experimental
        '''
        result = self._values.get("fill_tps_with_zeroes")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def rate_computation_method(self) -> typing.Optional[RateComputationMethod]:
        '''
        :default: - average

        :stability: experimental
        '''
        result = self._values.get("rate_computation_method")
        return typing.cast(typing.Optional[RateComputationMethod], result)

    @builtins.property
    def alarm_friendly_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Plain name, used in naming alarms.

        This unique among other resources, and respect the AWS CDK restriction posed on alarm names.
        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :default: - derives name from the construct itself

        :stability: experimental
        '''
        result = self._values.get("alarm_friendly_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def human_readable_name(self) -> typing.Optional[builtins.str]:
        '''(experimental) Human-readable name is a freeform string, used as a caption or description.

        There are no limitations on what it can be.

        :default: - use alarmFriendlyName

        :stability: experimental
        '''
        result = self._values.get("human_readable_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def local_alarm_name_prefix_override(self) -> typing.Optional[builtins.str]:
        '''(experimental) If this is defined, the local alarm name prefix used in naming alarms for the construct will be set to this value.

        The length must be 1 - 255 characters and although the validation rules are undocumented, we recommend using ASCII and hyphens.

        :see: AlarmNamingStrategy for more details on alarm name prefixes
        :stability: experimental
        '''
        result = self._values.get("local_alarm_name_prefix_override")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def add_to_alarm_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to alarm dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_alarm_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_detail_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to detailed dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_detail_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def add_to_summary_dashboard(self) -> typing.Optional[builtins.bool]:
        '''(experimental) Flag indicating if the widgets should be added to summary dashboard.

        :default: - true

        :stability: experimental
        '''
        result = self._values.get("add_to_summary_dashboard")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def use_created_alarms(self) -> typing.Optional[IAlarmConsumer]:
        '''(experimental) Calls provided function to process all alarms created.

        :stability: experimental
        '''
        result = self._values.get("use_created_alarms")
        return typing.cast(typing.Optional[IAlarmConsumer], result)

    @builtins.property
    def add4xx_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add4xx_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add4xx_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add5xx_count_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_count_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorCountThreshold]], result)

    @builtins.property
    def add5xx_rate_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add5xx_rate_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, ErrorRateThreshold]], result)

    @builtins.property
    def add_high_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_high_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, HighTpsThreshold]], result)

    @builtins.property
    def add_integration_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_integration_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_integration_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_average_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_average_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p100_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p100_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_p99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_p99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm50_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm50_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm70_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm70_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm90_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm90_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm95_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm95_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm9999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm9999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm999_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm999_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_latency_tm99_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_latency_tm99_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LatencyThreshold]], result)

    @builtins.property
    def add_low_tps_alarm(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]]:
        '''
        :stability: experimental
        '''
        result = self._values.get("add_low_tps_alarm")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, LowTpsThreshold]], result)

    @builtins.property
    def latency_types_to_render(self) -> typing.Optional[typing.List[LatencyType]]:
        '''(experimental) You can specify what latency types you want to be rendered in the dashboards.

        Note: any latency type with an alarm will be also added automatically.
        If the list is undefined, default values will be shown.
        If the list is empty, only the latency types with an alarm will be shown (if any).

        :default: - p50, p90, p99 (

        :see: DefaultLatencyTypesShown)
        :stability: experimental
        '''
        result = self._values.get("latency_types_to_render")
        return typing.cast(typing.Optional[typing.List[LatencyType]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayV2HttpApiMonitoringProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "AddAlarmProps",
    "AddCompositeAlarmProps",
    "AgeAlarmFactory",
    "AlarmActionStrategyProps",
    "AlarmAnnotationStrategyProps",
    "AlarmFactory",
    "AlarmFactoryDefaults",
    "AlarmFactoryProps",
    "AlarmMatrixWidget",
    "AlarmMatrixWidgetProps",
    "AlarmMetadata",
    "AlarmNamingInput",
    "AlarmNamingStrategy",
    "AlarmSummaryMatrixWidget",
    "AlarmSummaryMatrixWidgetPropertiesJson",
    "AlarmSummaryMatrixWidgetProps",
    "AlarmWithAnnotation",
    "AnomalyDetectingAlarmFactory",
    "AnomalyDetectionMathExpression",
    "AnomalyDetectionThreshold",
    "ApiGatewayMetricFactory",
    "ApiGatewayMetricFactoryProps",
    "ApiGatewayMonitoring",
    "ApiGatewayMonitoringOptions",
    "ApiGatewayMonitoringProps",
    "ApiGatewayV2HttpApiMetricFactory",
    "ApiGatewayV2HttpApiMetricFactoryProps",
    "ApiGatewayV2HttpApiMonitoring",
    "ApiGatewayV2HttpApiMonitoringProps",
    "ApiGatewayV2MonitoringOptions",
    "AppSyncMetricFactory",
    "AppSyncMetricFactoryProps",
    "AppSyncMonitoring",
    "AppSyncMonitoringOptions",
    "AppSyncMonitoringProps",
    "ApplicationLoadBalancerMetricFactory",
    "ApplicationLoadBalancerMetricFactoryProps",
    "AutoScalingGroupMetricFactory",
    "AutoScalingGroupMetricFactoryProps",
    "AutoScalingGroupMonitoring",
    "AutoScalingGroupMonitoringOptions",
    "AutoScalingGroupMonitoringProps",
    "AvailabilityThreshold",
    "AwsConsoleUrlFactory",
    "AwsConsoleUrlFactoryProps",
    "AxisPosition",
    "BaseDlqAlarms",
    "BaseEc2ServiceAlarms",
    "BaseFargateServiceAlarms",
    "BaseMonitoringProps",
    "BaseServiceMetricFactory",
    "BaseServiceMetricFactoryProps",
    "BaseSqsQueueAlarms",
    "BillingMetricFactory",
    "BillingMonitoring",
    "BillingMonitoringOptions",
    "BillingMonitoringProps",
    "BitmapDashboard",
    "BitmapWidgetRenderingSupport",
    "CapacityType",
    "CertificateManagerMetricFactory",
    "CertificateManagerMetricFactoryProps",
    "CertificateManagerMonitoring",
    "CertificateManagerMonitoringOptions",
    "CertificateManagerMonitoringProps",
    "CloudFrontDistributionMetricFactory",
    "CloudFrontDistributionMetricFactoryProps",
    "CloudFrontDistributionMonitoring",
    "CloudFrontDistributionMonitoringOptions",
    "CloudFrontDistributionMonitoringProps",
    "CodeBuildProjectMetricFactory",
    "CodeBuildProjectMetricFactoryProps",
    "CodeBuildProjectMonitoring",
    "CodeBuildProjectMonitoringOptions",
    "CodeBuildProjectMonitoringProps",
    "CompositeAlarmOperator",
    "ConnectionAlarmFactory",
    "ConsumedCapacityThreshold",
    "CustomAlarmFactory",
    "CustomAlarmThreshold",
    "CustomEc2ServiceMonitoringProps",
    "CustomFargateServiceMonitoringProps",
    "CustomMetricGroup",
    "CustomMetricGroupWithAnnotations",
    "CustomMetricSearch",
    "CustomMetricWithAlarm",
    "CustomMetricWithAnomalyDetection",
    "CustomMonitoring",
    "CustomMonitoringProps",
    "CustomThreshold",
    "CustomWidget",
    "CustomWidgetProps",
    "DashboardRenderingPreference",
    "DashboardWithBitmapCopy",
    "DaysSinceUpdateThreshold",
    "DaysToExpiryThreshold",
    "DefaultAlarmAnnotationStrategy",
    "DefaultDashboardFactory",
    "DefaultWidgetFactory",
    "DoNotModifyDedupeString",
    "DocumentDbMetricFactory",
    "DocumentDbMetricFactoryProps",
    "DocumentDbMonitoring",
    "DocumentDbMonitoringOptions",
    "DocumentDbMonitoringProps",
    "DoubleAxisGraphWidget",
    "DoubleAxisGraphWidgetProps",
    "DurationThreshold",
    "DynamoAlarmFactory",
    "DynamoTableGlobalSecondaryIndexMetricFactory",
    "DynamoTableGlobalSecondaryIndexMetricFactoryProps",
    "DynamoTableGlobalSecondaryIndexMonitoring",
    "DynamoTableGlobalSecondaryIndexMonitoringProps",
    "DynamoTableMetricFactory",
    "DynamoTableMetricFactoryProps",
    "DynamoTableMonitoring",
    "DynamoTableMonitoringOptions",
    "DynamoTableMonitoringProps",
    "EC2MetricFactory",
    "EC2MetricFactoryProps",
    "EC2Monitoring",
    "EC2MonitoringOptions",
    "EC2MonitoringProps",
    "Ec2ApplicationLoadBalancerMonitoringProps",
    "Ec2NetworkLoadBalancerMonitoringProps",
    "Ec2ServiceMonitoring",
    "Ec2ServiceMonitoringProps",
    "ElastiCacheAlarmFactory",
    "ElastiCacheClusterMetricFactory",
    "ElastiCacheClusterMetricFactoryProps",
    "ElastiCacheClusterMonitoring",
    "ElastiCacheClusterMonitoringOptions",
    "ElastiCacheClusterMonitoringProps",
    "ElastiCacheClusterType",
    "ElasticsearchClusterStatus",
    "ErrorAlarmFactory",
    "ErrorCountThreshold",
    "ErrorRateThreshold",
    "ErrorType",
    "ExtendDedupeString",
    "FargateApplicationLoadBalancerMonitoringProps",
    "FargateNetworkLoadBalancerMonitoringProps",
    "FargateServiceMonitoring",
    "FargateServiceMonitoringProps",
    "FillingAlarmAnnotationStrategy",
    "FullRestartCountThreshold",
    "GlueJobMetricFactory",
    "GlueJobMetricFactoryProps",
    "GlueJobMonitoring",
    "GlueJobMonitoringOptions",
    "GlueJobMonitoringProps",
    "GraphWidgetType",
    "HeaderLevel",
    "HeaderWidget",
    "HealthyTaskCountThreshold",
    "HealthyTaskPercentThreshold",
    "HighConnectionCountThreshold",
    "HighMessagesPublishedThreshold",
    "HighTpsThreshold",
    "IAlarmActionStrategy",
    "IAlarmAnnotationStrategy",
    "IAlarmConsumer",
    "IAlarmDedupeStringProcessor",
    "IDashboardFactory",
    "IDashboardFactoryProps",
    "IDashboardSegment",
    "IEC2MetricFactoryStrategy",
    "ILoadBalancerMetricFactory",
    "IPublisherConsumer",
    "IWidgetFactory",
    "KeyValueTableWidget",
    "KinesisAlarmFactory",
    "KinesisDataAnalyticsAlarmFactory",
    "KinesisDataAnalyticsMetricFactory",
    "KinesisDataAnalyticsMetricFactoryProps",
    "KinesisDataAnalyticsMonitoring",
    "KinesisDataAnalyticsMonitoringOptions",
    "KinesisDataAnalyticsMonitoringProps",
    "KinesisDataStreamMetricFactory",
    "KinesisDataStreamMetricFactoryProps",
    "KinesisDataStreamMonitoring",
    "KinesisDataStreamMonitoringOptions",
    "KinesisDataStreamMonitoringProps",
    "KinesisFirehoseMetricFactory",
    "KinesisFirehoseMetricFactoryProps",
    "KinesisFirehoseMonitoring",
    "KinesisFirehoseMonitoringOptions",
    "KinesisFirehoseMonitoringProps",
    "LambdaFunctionEnhancedMetricFactory",
    "LambdaFunctionMetricFactory",
    "LambdaFunctionMetricFactoryProps",
    "LambdaFunctionMonitoring",
    "LambdaFunctionMonitoringOptions",
    "LambdaFunctionMonitoringProps",
    "LatencyAlarmFactory",
    "LatencyThreshold",
    "LatencyType",
    "LogLevel",
    "LogLevelAlarmFactory",
    "LogLevelCountThreshold",
    "LogMonitoring",
    "LogMonitoringProps",
    "LowConnectionCountThreshold",
    "LowMessagesPublishedThreshold",
    "LowTpsThreshold",
    "MaxAgeThreshold",
    "MaxDowntimeThreshold",
    "MaxIncomingMessagesCountThreshold",
    "MaxItemsCountThreshold",
    "MaxIteratorAgeThreshold",
    "MaxMessageAgeThreshold",
    "MaxMessageCountThreshold",
    "MaxTimeToDrainThreshold",
    "MaxUsedSwapMemoryThreshold",
    "MetricFactory",
    "MetricFactoryDefaults",
    "MetricFactoryProps",
    "MetricStatistic",
    "MinFreeableMemoryThreshold",
    "MinIncomingMessagesCountThreshold",
    "MinMessageCountThreshold",
    "MinProcessedBytesThreshold",
    "MinRunningTaskCountThreshold",
    "MinUsageCountThreshold",
    "Monitoring",
    "MonitoringAspect",
    "MonitoringAspectProps",
    "MonitoringAspectType",
    "MonitoringDashboardsOverrideProps",
    "MonitoringDashboardsProps",
    "MonitoringFacade",
    "MonitoringFacadeProps",
    "MonitoringHeaderWidget",
    "MonitoringHeaderWidgetProps",
    "MonitoringNamingStrategy",
    "MonitoringScope",
    "MultipleAlarmActionStrategy",
    "NameResolutionInput",
    "NetworkLoadBalancerMetricFactory",
    "NetworkLoadBalancerMetricFactoryProps",
    "NetworkLoadBalancerMonitoring",
    "NetworkLoadBalancerMonitoringProps",
    "NoopAlarmActionStrategy",
    "NotificationsFailedThreshold",
    "OpenSearchBackportedMetrics",
    "OpenSearchClusterAlarmFactory",
    "OpenSearchClusterAutomatedSnapshotFailureThreshold",
    "OpenSearchClusterIndexWritesBlockedThreshold",
    "OpenSearchClusterMetricFactory",
    "OpenSearchClusterMetricFactoryProps",
    "OpenSearchClusterMonitoring",
    "OpenSearchClusterMonitoringOptions",
    "OpenSearchClusterMonitoringProps",
    "OpenSearchClusterNodesThreshold",
    "OpenSearchClusterStatus",
    "OpenSearchClusterStatusCustomization",
    "OpenSearchKmsKeyErrorThreshold",
    "OpenSearchKmsKeyInaccessibleThreshold",
    "OpsItemAlarmActionStrategy",
    "QueueAlarmFactory",
    "QueueProcessingEc2ServiceMonitoringProps",
    "QueueProcessingFargateServiceMonitoringProps",
    "RateComputationMethod",
    "RdsClusterMetricFactory",
    "RdsClusterMetricFactoryProps",
    "RdsClusterMonitoring",
    "RdsClusterMonitoringOptions",
    "RdsClusterMonitoringProps",
    "RecordsFailedThreshold",
    "RecordsThrottledThreshold",
    "RedshiftClusterMetricFactory",
    "RedshiftClusterMetricFactoryProps",
    "RedshiftClusterMonitoring",
    "RedshiftClusterMonitoringOptions",
    "RedshiftClusterMonitoringProps",
    "RunningTaskCountThreshold",
    "RunningTaskRateThreshold",
    "S3BucketMetricFactory",
    "S3BucketMetricFactoryProps",
    "S3BucketMonitoring",
    "S3BucketMonitoringOptions",
    "S3BucketMonitoringProps",
    "SecretsManagerMetricsPublisher",
    "SecretsManagerSecretMetricFactory",
    "SecretsManagerSecretMetricFactoryProps",
    "SecretsManagerSecretMonitoring",
    "SecretsManagerSecretMonitoringOptions",
    "SecretsManagerSecretMonitoringProps",
    "SimpleEc2ServiceMonitoringProps",
    "SimpleFargateServiceMonitoringProps",
    "SingleAxisGraphWidget",
    "SingleAxisGraphWidgetProps",
    "SingleWidgetDashboardSegment",
    "SnsAlarmActionStrategy",
    "SnsAlarmActionStrategyProps",
    "SnsTopicMetricFactory",
    "SnsTopicMetricFactoryProps",
    "SnsTopicMonitoring",
    "SnsTopicMonitoringOptions",
    "SnsTopicMonitoringProps",
    "SqsQueueMetricFactory",
    "SqsQueueMetricFactoryProps",
    "SqsQueueMonitoring",
    "SqsQueueMonitoringOptions",
    "SqsQueueMonitoringProps",
    "SqsQueueMonitoringWithDlq",
    "SqsQueueMonitoringWithDlqProps",
    "StepFunctionActivityMetricFactory",
    "StepFunctionActivityMetricFactoryProps",
    "StepFunctionActivityMonitoring",
    "StepFunctionActivityMonitoringProps",
    "StepFunctionLambdaIntegrationMetricFactory",
    "StepFunctionLambdaIntegrationMetricFactoryProps",
    "StepFunctionLambdaIntegrationMonitoring",
    "StepFunctionLambdaIntegrationMonitoringProps",
    "StepFunctionMetricFactory",
    "StepFunctionMetricFactoryProps",
    "StepFunctionMonitoring",
    "StepFunctionMonitoringOptions",
    "StepFunctionMonitoringProps",
    "StepFunctionServiceIntegrationMetricFactory",
    "StepFunctionServiceIntegrationMetricFactoryProps",
    "StepFunctionServiceIntegrationMonitoring",
    "StepFunctionServiceIntegrationMonitoringProps",
    "StorageType",
    "SyntheticsCanaryMetricFactory",
    "SyntheticsCanaryMetricFactoryProps",
    "SyntheticsCanaryMonitoring",
    "SyntheticsCanaryMonitoringOptions",
    "SyntheticsCanaryMonitoringProps",
    "TaskHealthAlarmFactory",
    "ThrottledEventsThreshold",
    "ThroughputAlarmFactory",
    "TopicAlarmFactory",
    "TpsAlarmFactory",
    "UnhealthyTaskCountThreshold",
    "UsageAlarmFactory",
    "UsageCountThreshold",
    "UsageThreshold",
    "UsageType",
    "UserProvidedNames",
    "WafV2MetricFactory",
    "WafV2MetricFactoryProps",
    "WafV2Monitoring",
    "WafV2MonitoringOptions",
    "WafV2MonitoringProps",
    "XaxrMathExpression",
    "XaxrMathExpressionProps",
]

publication.publish()
