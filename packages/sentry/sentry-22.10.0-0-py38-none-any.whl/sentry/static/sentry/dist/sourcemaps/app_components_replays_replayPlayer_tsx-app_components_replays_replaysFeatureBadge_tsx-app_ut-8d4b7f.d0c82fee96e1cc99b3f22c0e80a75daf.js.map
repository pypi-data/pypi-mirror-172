{"version":3,"file":"chunks/app_components_replays_replayPlayer_tsx-app_components_replays_replaysFeatureBadge_tsx-app_ut-8d4b7f.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/replays/player/bufferingOverlay.tsx","webpack:///./app/components/replays/player/fastForwardBadge.tsx","webpack:///./app/components/replays/replayPlayer.tsx","webpack:///./app/components/replays/replaysFeatureBadge.tsx","webpack:///./app/utils/replays/replayReader.tsx","webpack:///./app/utils/replays/hooks/useReplayData.tsx","webpack:///./app/utils/replays/flattenListOfObjects.tsx","webpack:///./app/views/replays/detail/layout/fluidHeight.tsx"],"sourcesContent":["import styled from '@emotion/styled';\n\nimport {IconClock} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  className?: string;\n};\n\nfunction BufferingOverlay({className}: Props) {\n  return (\n    <Overlay className={className}>\n      <Message>\n        <IconClock size=\"sm\" />\n        {t('Buffering...')}\n      </Message>\n    </Overlay>\n  );\n}\n\n/* Position the badge in the corner */\nconst Overlay = styled('div')`\n  user-select: none;\n  display: grid;\n  place-items: center;\n`;\n\n/* Badge layout and style */\nconst Message = styled('div')`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.75)};\n  place-items: center;\n\n  padding: ${space(3)};\n  background: ${p => p.theme.gray300};\n  border-radius: ${p => p.theme.borderRadius};\n  color: ${p => p.theme.white};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default BufferingOverlay;\n","import styled from '@emotion/styled';\n\nimport Tooltip from 'sentry/components/tooltip';\nimport {IconArrow} from 'sentry/icons';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\n\ntype Props = {\n  speed: number;\n  className?: string;\n};\n\nfunction FastForwardBadge({speed, className}: Props) {\n  return (\n    <Badge className={className}>\n      <FastForwardTooltip title={t(`Fast forwarding at ${speed}x`)}>\n        {t('Fast forwarding through inactivity')}\n        <IconArrow size=\"sm\" direction=\"right\" />\n      </FastForwardTooltip>\n    </Badge>\n  );\n}\n\n/* Position the badge in the corner */\nconst Badge = styled('div')`\n  user-select: none;\n  display: grid;\n  align-items: end;\n  justify-items: start;\n`;\n\n/* Badge layout and style */\nconst FastForwardTooltip = styled(Tooltip)`\n  display: grid;\n  grid-template-columns: max-content max-content;\n  gap: ${space(0.5)};\n  align-items: center;\n\n  background: ${p => p.theme.gray300};\n  color: ${p => p.theme.white};\n  padding: ${space(1.5)} ${space(2)};\n  border-top-right-radius: ${p => p.theme.borderRadius};\n  z-index: ${p => p.theme.zIndex.initial};\n`;\n\nexport default FastForwardBadge;\n","import React, {useCallback, useEffect, useRef, useState} from 'react';\nimport styled from '@emotion/styled';\nimport {useResizeObserver} from '@react-aria/utils';\n\nimport {Panel as _Panel} from 'sentry/components/panels';\nimport BufferingOverlay from 'sentry/components/replays/player/bufferingOverlay';\nimport FastForwardBadge from 'sentry/components/replays/player/fastForwardBadge';\nimport {useReplayContext} from 'sentry/components/replays/replayContext';\n\ninterface Props {\n  className?: string;\n}\n\nfunction BasePlayerRoot({className}: Props) {\n  const {\n    initRoot,\n    dimensions: videoDimensions,\n    fastForwardSpeed,\n    isBuffering,\n  } = useReplayContext();\n\n  const windowEl = useRef<HTMLDivElement>(null);\n  const viewEl = useRef<HTMLDivElement>(null);\n\n  const [windowDimensions, setWindowDimensions] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  // Create the `rrweb` instance which creates an iframe inside `viewEl`\n  useEffect(() => initRoot(viewEl.current), [initRoot]);\n\n  // Read the initial width & height where the player will be inserted, this is\n  // so we can shrink the video into the available space.\n  // If the size of the container changes, we can re-calculate the scaling factor\n  const updateWindowDimensions = useCallback(\n    () =>\n      setWindowDimensions({\n        width: windowEl.current?.clientWidth || 0,\n        height: windowEl.current?.clientHeight || 0,\n      }),\n    [setWindowDimensions]\n  );\n  useResizeObserver({ref: windowEl, onResize: updateWindowDimensions});\n  // If your browser doesn't have ResizeObserver then set the size once.\n  useEffect(() => {\n    if (typeof window.ResizeObserver !== 'undefined') {\n      return;\n    }\n    updateWindowDimensions();\n  }, [updateWindowDimensions]);\n\n  // Update the scale of the view whenever dimensions have changed.\n  useEffect(() => {\n    if (viewEl.current) {\n      const scale = Math.min(\n        windowDimensions.width / videoDimensions.width,\n        windowDimensions.height / videoDimensions.height,\n        1\n      );\n      if (scale) {\n        viewEl.current.style['transform-origin'] = 'top left';\n        viewEl.current.style.transform = `scale(${scale})`;\n        viewEl.current.style.width = `${videoDimensions.width * scale}px`;\n        viewEl.current.style.height = `${videoDimensions.height * scale}px`;\n      }\n    }\n  }, [windowDimensions, videoDimensions]);\n\n  return (\n    <SizingWindow ref={windowEl} className=\"sentry-block\">\n      <div ref={viewEl} className={className} />\n      {fastForwardSpeed ? <PositionedFastForward speed={fastForwardSpeed} /> : null}\n      {isBuffering ? <PositionedBuffering /> : null}\n    </SizingWindow>\n  );\n}\n\n// Center the viewEl inside the windowEl.\n// This is useful when the window is inside a container that has large fixed\n// dimensions, like when in fullscreen mode.\n// If the container has a dimensions that can grow/shrink then it is\n// important to also set `overflow: hidden` on the container, so that the\n// SizingWindow can calculate size as things shrink.\nconst SizingWindow = styled('div')`\n  width: 100%;\n  display: flex;\n  flex-grow: 1;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  overflow: hidden;\n\n  background-color: ${p => p.theme.backgroundSecondary};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${p => p.theme.backgroundSecondary} 8px,\n      ${p => p.theme.backgroundSecondary} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${p => p.theme.gray100} 15px,\n      ${p => p.theme.gray100} 16px\n    );\n`;\n\nconst PositionedFastForward = styled(FastForwardBadge)`\n  position: absolute;\n  left: 0;\n  bottom: 0;\n`;\n\nconst PositionedBuffering = styled(BufferingOverlay)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n`;\n\n// Base styles, to make the Replayer instance work\nconst PlayerRoot = styled(BasePlayerRoot)`\n  .replayer-wrapper {\n    user-select: none;\n  }\n  .replayer-wrapper > .replayer-mouse-tail {\n    position: absolute;\n    pointer-events: none;\n  }\n\n  /* Override default user-agent styles */\n  .replayer-wrapper > iframe {\n    border: none;\n    background: white;\n  }\n`;\n\n// Sentry-specific styles for the player.\n// The elements we have to work with are:\n// ```css\n// div.replayer-wrapper {}\n// div.replayer-wrapper > div.replayer-mouse {}\n// div.replayer-wrapper > canvas.replayer-mouse-tail {}\n// div.replayer-wrapper > iframe {}\n// ```\n// The mouse-tail is also configured for color/size in `app/components/replays/replayContext.tsx`\nconst SentryPlayerRoot = styled(PlayerRoot)`\n  .replayer-mouse {\n    position: absolute;\n    width: 32px;\n    height: 32px;\n    transition: left 0.05s linear, top 0.05s linear;\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-image: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTkiIHZpZXdCb3g9IjAgMCAxMiAxOSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgMTZWMEwxMS42IDExLjZINC44TDQuNCAxMS43TDAgMTZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNOS4xIDE2LjdMNS41IDE4LjJMMC43OTk5OTkgNy4xTDQuNSA1LjZMOS4xIDE2LjdaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNNC42NzQ1MSA4LjYxODUxTDIuODMwMzEgOS4zOTI3MUw1LjkyNzExIDE2Ljc2OTVMNy43NzEzMSAxNS45OTUzTDQuNjc0NTEgOC42MTg1MVoiIGZpbGw9ImJsYWNrIi8+CjxwYXRoIGQ9Ik0xIDIuNFYxMy42TDQgMTAuN0w0LjQgMTAuNkg5LjJMMSAyLjRaIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K');\n    border-color: transparent;\n  }\n  .replayer-mouse:after {\n    content: '';\n    display: inline-block;\n    width: 32px;\n    height: 32px;\n    background: ${p => p.theme.purple300};\n    border-radius: 100%;\n    transform: translate(-50%, -50%);\n    opacity: 0.3;\n  }\n  .replayer-mouse.active:after {\n    animation: click 0.2s ease-in-out 1;\n  }\n  .replayer-mouse.touch-device {\n    background-image: none;\n    width: 70px;\n    height: 70px;\n    border-radius: 100%;\n    margin-left: -37px;\n    margin-top: -37px;\n    border: 4px solid rgba(73, 80, 246, 0);\n    transition: left 0s linear, top 0s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device.touch-active {\n    border-color: ${p => p.theme.purple200};\n    transition: left 0.25s linear, top 0.25s linear, border-color 0.2s ease-in-out;\n  }\n  .replayer-mouse.touch-device:after {\n    opacity: 0;\n  }\n  .replayer-mouse.touch-device.active:after {\n    animation: touch-click 0.2s ease-in-out 1;\n  }\n  @keyframes click {\n    0% {\n      opacity: 0.3;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n  @keyframes touch-click {\n    0% {\n      opacity: 0;\n      width: 20px;\n      height: 20px;\n    }\n    50% {\n      opacity: 0.5;\n      width: 10px;\n      height: 10px;\n    }\n  }\n`;\n\nexport default SentryPlayerRoot;\n","import FeatureBadge from 'sentry/components/featureBadge';\n\nfunction ReplaysFeatureBadge(\n  props: Omit<React.ComponentProps<typeof FeatureBadge>, 'type'>\n) {\n  return <FeatureBadge {...props} type=\"alpha\" />;\n}\n\nexport default ReplaysFeatureBadge;\n","import type {Crumb} from 'sentry/types/breadcrumbs';\nimport {\n  breadcrumbFactory,\n  getBreadcrumbsByCategory,\n  isMemorySpan,\n  isNetworkSpan,\n  replayTimestamps,\n  rrwebEventListFactory,\n  spansFactory,\n} from 'sentry/utils/replays/replayDataUtils';\nimport type {\n  MemorySpanType,\n  RecordingEvent,\n  ReplayCrumb,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\ninterface ReplayReaderParams {\n  breadcrumbs: ReplayCrumb[] | undefined;\n  errors: ReplayError[] | undefined;\n\n  /**\n   * The root Replay event, created at the start of the browser session.\n   */\n  replayRecord: ReplayRecord | undefined;\n\n  /**\n   * The captured data from rrweb.\n   * Saved as N attachments that belong to the root Replay event.\n   */\n  rrwebEvents: RecordingEvent[] | undefined;\n\n  spans: ReplaySpan[] | undefined;\n}\n\ntype RequiredNotNull<T> = {\n  [P in keyof T]: NonNullable<T[P]>;\n};\n\nexport default class ReplayReader {\n  static factory({\n    breadcrumbs,\n    replayRecord,\n    errors,\n    rrwebEvents,\n    spans,\n  }: ReplayReaderParams) {\n    if (!breadcrumbs || !replayRecord || !rrwebEvents || !spans || !errors) {\n      return null;\n    }\n\n    return new ReplayReader({breadcrumbs, replayRecord, errors, rrwebEvents, spans});\n  }\n\n  private constructor({\n    breadcrumbs,\n    replayRecord,\n    errors,\n    rrwebEvents,\n    spans,\n  }: RequiredNotNull<ReplayReaderParams>) {\n    // TODO(replays): We should get correct timestamps from the backend instead\n    // of having to fix them up here.\n    const {startTimestampMs, endTimestampMs} = replayTimestamps(\n      replayRecord,\n      rrwebEvents,\n      breadcrumbs,\n      spans\n    );\n    replayRecord.startedAt = new Date(startTimestampMs);\n    replayRecord.finishedAt = new Date(endTimestampMs);\n\n    const sortedSpans = spansFactory(spans);\n    this.networkSpans = sortedSpans.filter(isNetworkSpan);\n    this.memorySpans = sortedSpans.filter(isMemorySpan);\n\n    this.breadcrumbs = breadcrumbFactory(replayRecord, errors, breadcrumbs, sortedSpans);\n    this.consoleCrumbs = getBreadcrumbsByCategory(this.breadcrumbs, ['console', 'issue']);\n\n    this.rrwebEvents = rrwebEventListFactory(replayRecord, rrwebEvents);\n\n    this.replayRecord = replayRecord;\n  }\n\n  private replayRecord: ReplayRecord;\n  private rrwebEvents: RecordingEvent[];\n  private breadcrumbs: Crumb[];\n  private consoleCrumbs: ReturnType<typeof getBreadcrumbsByCategory>;\n  private networkSpans: ReplaySpan[];\n  private memorySpans: MemorySpanType[];\n\n  /**\n   * @returns Duration of Replay (milliseonds)\n   */\n  getDurationMs = () => {\n    return this.replayRecord.duration * 1000;\n  };\n\n  getReplay = () => {\n    return this.replayRecord;\n  };\n\n  getRRWebEvents = () => {\n    return this.rrwebEvents;\n  };\n\n  getRawCrumbs = () => {\n    return this.breadcrumbs;\n  };\n\n  getConsoleCrumbs = () => {\n    return this.consoleCrumbs;\n  };\n\n  getNetworkSpans = () => {\n    return this.networkSpans;\n  };\n\n  getMemorySpans = () => {\n    return this.memorySpans;\n  };\n}\n","import {useCallback, useEffect, useMemo, useState} from 'react';\nimport * as Sentry from '@sentry/react';\n\nimport parseLinkHeader, {ParsedHeader} from 'sentry/utils/parseLinkHeader';\nimport flattenListOfObjects from 'sentry/utils/replays/flattenListOfObjects';\nimport {mapResponseToReplayRecord} from 'sentry/utils/replays/replayDataUtils';\nimport ReplayReader from 'sentry/utils/replays/replayReader';\nimport RequestError from 'sentry/utils/requestError/requestError';\nimport useApi from 'sentry/utils/useApi';\nimport type {\n  RecordingEvent,\n  ReplayCrumb,\n  ReplayError,\n  ReplayRecord,\n  ReplaySpan,\n} from 'sentry/views/replays/types';\n\ntype State = {\n  breadcrumbs: undefined | ReplayCrumb[];\n\n  /**\n   * List of errors that occurred during replay\n   */\n  errors: undefined | ReplayError[];\n\n  /**\n   * If any request returned an error then nothing is being returned\n   */\n  fetchError: undefined | RequestError;\n\n  /**\n   * If a fetch is underway for the requested root reply.\n   * This includes fetched all the sub-resources like attachments and `sentry-replay-event`\n   */\n  fetching: boolean;\n\n  /**\n   * The root replay event\n   */\n  replayRecord: undefined | ReplayRecord;\n\n  /**\n   * The flattened list of rrweb events. These are stored as multiple attachments on the root replay object: the `event` prop.\n   */\n  rrwebEvents: undefined | RecordingEvent[];\n\n  spans: undefined | ReplaySpan[];\n};\n\ntype Options = {\n  /**\n   * The organization slug\n   */\n\n  orgSlug: string;\n  /**\n   * The projectSlug and replayId concatenated together\n   */\n  replaySlug: string;\n};\n\n// Errors if it is an interface\n// See https://github.com/microsoft/TypeScript/issues/15300\ntype ReplayAttachment = {\n  breadcrumbs: ReplayCrumb[];\n  recording: RecordingEvent[];\n  replaySpans: ReplaySpan[];\n};\n\ninterface Result extends Pick<State, 'fetchError' | 'fetching'> {\n  onRetry: () => void;\n  replay: ReplayReader | null;\n  replayRecord: ReplayRecord | undefined;\n}\n\nexport function mapRRWebAttachments(unsortedReplayAttachments): ReplayAttachment {\n  const replayAttachments: ReplayAttachment = {\n    breadcrumbs: [],\n    replaySpans: [],\n    recording: [],\n  };\n\n  unsortedReplayAttachments.forEach(attachment => {\n    if (attachment.data?.tag === 'performanceSpan') {\n      replayAttachments.replaySpans.push(attachment.data.payload);\n    } else if (attachment?.data?.tag === 'breadcrumb') {\n      replayAttachments.breadcrumbs.push(attachment.data.payload);\n    } else {\n      replayAttachments.recording.push(attachment);\n    }\n  });\n\n  return replayAttachments;\n}\n\nconst INITIAL_STATE: State = Object.freeze({\n  breadcrumbs: undefined,\n  errors: undefined,\n  fetchError: undefined,\n  fetching: true,\n  replayRecord: undefined,\n  rrwebEvents: undefined,\n  spans: undefined,\n});\n\n/**\n * A react hook to load core replay data over the network.\n *\n * Core replay data includes:\n * 1. The root replay EventTransaction object\n *    - This includes `startTimestamp` and `tags` data\n * 2. Breadcrumb and Span data from all the related Event objects\n *    - Data is merged for consumption\n * 3. RRWeb payloads for the replayer video stream\n *    - TODO(replay): incrementally load the stream to speedup pageload\n *\n * This function should stay focused on loading data over the network.\n * Front-end processing, filtering and re-mixing of the different data streams\n * must be delegated to the `ReplayReader` class.\n *\n * @param {orgSlug, replaySlug} Where to find the root replay event\n * @returns An object representing a unified result of the network requests. Either a single `ReplayReader` data object or fetch errors.\n */\nfunction useReplayData({replaySlug, orgSlug}: Options): Result {\n  const [projectSlug, replayId] = replaySlug.split(':');\n\n  const api = useApi();\n  const [state, setState] = useState<State>(INITIAL_STATE);\n\n  // Fetch every field of the replay. We're overfetching, not every field is needed\n  const fetchReplay = useCallback(async () => {\n    const response = await api.requestPromise(\n      `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/`\n    );\n    return response.data;\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchAllRRwebEvents = useCallback(async () => {\n    const rootUrl = `/projects/${orgSlug}/${projectSlug}/replays/${replayId}/recording-segments/?download`;\n    let next: ParsedHeader = {\n      href: rootUrl,\n      results: true,\n      cursor: '',\n    };\n\n    const segmentRanges: any = [];\n    // TODO(replay): It would be good to load the first page of results then\n    // start to render the UI while the next N pages continue to get fetched in\n    // the background.\n    while (next.results) {\n      const url = rootUrl + '&cursor=' + next.cursor;\n\n      const [data, _textStatus, resp] = await api.requestPromise(url, {\n        includeAllArgs: true,\n      });\n      segmentRanges.push(data);\n      const links = parseLinkHeader(resp?.getResponseHeader('Link') ?? '');\n      next = links.next;\n    }\n\n    const rrwebEvents = segmentRanges\n      .flatMap(segment => segment)\n      .flatMap(attachments => mapRRWebAttachments(attachments));\n\n    return flattenListOfObjects(rrwebEvents);\n  }, [api, orgSlug, projectSlug, replayId]);\n\n  const fetchErrors = useCallback(\n    async (replayRecord: ReplayRecord) => {\n      if (!replayRecord.errorIds.length) {\n        return [];\n      }\n\n      const response = await api.requestPromise(\n        `/organizations/${orgSlug}/replays-events-meta/`,\n        {\n          query: {\n            start: replayRecord.startedAt.toISOString(),\n            end: replayRecord.finishedAt.toISOString(),\n            query: `id:[${String(replayRecord.errorIds)}]`,\n          },\n        }\n      );\n      return response.data;\n    },\n    [api, orgSlug]\n  );\n\n  const fetchReplayAndErrors = useCallback(async (): Promise<[ReplayRecord, any]> => {\n    const fetchedRecord = await fetchReplay();\n    const mappedRecord = mapResponseToReplayRecord(fetchedRecord);\n    setState(prev => ({\n      ...prev,\n      replayRecord: mappedRecord,\n    }));\n    const fetchedErrors = await fetchErrors(mappedRecord);\n    return [mappedRecord, fetchedErrors];\n  }, [fetchReplay, fetchErrors]);\n\n  const loadEvents = useCallback(async () => {\n    setState(INITIAL_STATE);\n\n    try {\n      const [replayAndErrors, attachments] = await Promise.all([\n        fetchReplayAndErrors(),\n        fetchAllRRwebEvents(),\n      ]);\n      const [replayRecord, errors] = replayAndErrors;\n\n      setState(prev => ({\n        ...prev,\n        breadcrumbs: attachments.breadcrumbs,\n        errors,\n        fetchError: undefined,\n        fetching: false,\n        replayRecord,\n        rrwebEvents: attachments.recording,\n        spans: attachments.replaySpans,\n      }));\n    } catch (error) {\n      Sentry.captureException(error);\n      setState({\n        ...INITIAL_STATE,\n        fetchError: error,\n        fetching: false,\n      });\n    }\n  }, [fetchReplayAndErrors, fetchAllRRwebEvents]);\n\n  useEffect(() => {\n    loadEvents();\n  }, [loadEvents]);\n\n  const replay = useMemo(() => {\n    return ReplayReader.factory({\n      breadcrumbs: state.breadcrumbs,\n      errors: state.errors,\n      replayRecord: state.replayRecord,\n      rrwebEvents: state.rrwebEvents,\n      spans: state.spans,\n    });\n  }, [\n    state.breadcrumbs,\n    state.errors,\n    state.replayRecord,\n    state.rrwebEvents,\n    state.spans,\n  ]);\n\n  return {\n    fetchError: state.fetchError,\n    fetching: state.fetching,\n    onRetry: loadEvents,\n    replay,\n    replayRecord: state.replayRecord,\n  };\n}\n\nexport default useReplayData;\n","/**\n * Given a list of objects (or maps) of `string` -> `any[]`,\n * merge the arrays of each key in the object.\n *\n * e.g. [{a: [1]}, {a: [2]}, {b: [3]}] ==> {a: [1, 2], b: {3}}\n *\n * Any non-array values will throw an exception\n */\nexport default function flattenListOfObjects(\n  objs: Array<Record<string, any[] | undefined>>\n) {\n  return objs.reduce((acc, obj) => {\n    Object.entries(obj).forEach(([key, value]) => {\n      if (!Array.isArray(value)) {\n        // e.g. if value is undefined (otherwise, a non-Array type will get caught by ts)\n        // TS doesn't like our test where object keys are no equivalent, so we\n        // need to allow `undefined` as a valid type in the Record.\n        throw new Error('Invalid value');\n      }\n\n      acc[key] = (acc[key] || []).concat(value);\n    });\n\n    return acc;\n  }, {});\n}\n","import styled from '@emotion/styled';\n\nconst FluidHeight = styled('div')`\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  flex-grow: 1;\n  overflow: hidden;\n`;\n\nexport default FluidHeight;\n"],"names":["BufferingOverlay","className","Overlay","Message","size","t","space","p","theme","gray300","borderRadius","white","zIndex","initial","FastForwardBadge","speed","Badge","FastForwardTooltip","title","direction","Tooltip","BasePlayerRoot","initRoot","dimensions","videoDimensions","fastForwardSpeed","isBuffering","useReplayContext","windowEl","useRef","viewEl","windowDimensions","setWindowDimensions","useState","width","height","useEffect","current","updateWindowDimensions","useCallback","clientWidth","clientHeight","useResizeObserver","ref","onResize","window","ResizeObserver","scale","Math","min","style","transform","SizingWindow","PositionedFastForward","PositionedBuffering","backgroundSecondary","gray100","PlayerRoot","purple300","purple200","ReplaysFeatureBadge","props","type","ReplayReader","breadcrumbs","replayRecord","errors","rrwebEvents","spans","constructor","this","duration","consoleCrumbs","networkSpans","memorySpans","startTimestampMs","endTimestampMs","replayTimestamps","startedAt","Date","finishedAt","sortedSpans","spansFactory","filter","isNetworkSpan","isMemorySpan","breadcrumbFactory","getBreadcrumbsByCategory","rrwebEventListFactory","INITIAL_STATE","Object","freeze","undefined","fetchError","fetching","replaySlug","orgSlug","projectSlug","replayId","split","api","useApi","state","setState","fetchReplay","async","requestPromise","data","fetchAllRRwebEvents","rootUrl","next","href","results","cursor","segmentRanges","url","_textStatus","resp","includeAllArgs","push","parseLinkHeader","getResponseHeader","flatMap","segment","attachments","unsortedReplayAttachments","replayAttachments","replaySpans","recording","forEach","attachment","tag","payload","mapRRWebAttachments","reduce","acc","obj","entries","key","value","Array","isArray","Error","concat","fetchErrors","errorIds","length","query","start","toISOString","end","String","fetchReplayAndErrors","fetchedRecord","mappedRecord","mapResponseToReplayRecord","prev","fetchedErrors","loadEvents","replayAndErrors","Promise","all","error","Sentry","replay","useMemo","factory","onRetry"],"sourceRoot":""}