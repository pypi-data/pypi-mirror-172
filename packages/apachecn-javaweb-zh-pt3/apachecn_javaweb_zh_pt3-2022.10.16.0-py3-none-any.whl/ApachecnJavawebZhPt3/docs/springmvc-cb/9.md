# 九、测试和故障排除

通过下面列出的方法，本章介绍了一组维护、调试和改进应用状态的常见做法:

*   使用 Flyway 自动化数据库迁移
*   用 Mockito 和 Maven Surefire 进行单元测试
*   与 Cargo、放心和 Maven Failsafe 进行集成测试
*   在集成测试中注入 Spring Bean
*   使用 Log4j2 的现代应用日志记录

# 简介

随着我们现在接近这一旅程的终点，我们必须看看如何巩固这项工作。在现实世界中，必须在开发一个特性之前(或者至少同时)编写测试。在软件开发中编写自动化测试传达了对应用状态的巨大信心。这是确保没有任何东西被遗忘的最好方法。拥有一个具有自我测试能力的系统，在现代持续集成工具的帮助下，可以确保特性在任何时候都不会被破坏。

不能相信通过 UI 的手动测试会覆盖开发人员必须考虑的每一个边缘情况。开发人员有责任保护所有漏洞，并覆盖所有可能的路径，这是一项重大责任。

我们的开发人员工作是一项了不起的工作。持续的技术进步为我们每一个人设定了无与伦比的速度——保持竞争、响应市场，有时甚至引领市场。

我们的工作是由长时间的集中精力、搜索信息、设计、重新设计等等组成的。编写测试在循环中带来了健康的稳定性。它允许我们用我们开发的特性更快乐地结束一天，即使是在几周或几个月后。

# 使用 FlyWay 自动化数据库迁移

在交付生命周期中，跨版本和多环境维护数据库可能是一件非常头疼的事情。Flyway 是一种针对模式变化可能导致的熵的自信保护。管理和自动化迁移，Flyway 对软件制造商来说是非常有价值的资产。

## 准备就绪

在本秘籍中，我们回顾飞行路线配置。我们特别回顾了它与 Maven 的集成。这将使每个构建升级(如果必要的话)相应的数据库，使其与预期水平相匹配。

## 怎么做……

1.  从 Eclipse 中的 **Git 视角**来看，检查分支的最新版本`v9.x.x.`
2.  在您的工作区的`/app`目录中，`cloudstreetmarket.properties`文件已经被更新。另外，一个额外的`db/migration`目录显示出来，里面有一个`Migration-1_0__init.sql`文件，以及一个新的`/logs`目录。
3.  请务必将所有这些更改反映到位于您的操作系统用户`home` `directory` : `<home-directory>/app`中的应用目录中。
4.  还要确保您的 **MySQL 服务器**正在运行。
5.  在`zipcloud-parent`项目上运行 **Maven clean** 和 **Maven install** 命令(右击项目**Run as…**|**Maven Clean**，然后**Run as…**|**Maven Install**)。
6.  现在，在`cloudstreetmarket-parent`项目上运行 **Maven clean** 和 **Maven install** 命令。
7.  At the top of the stack trace (at the package Maven phase), you should see the following logs:

    ![How to do it…](img/B4049_09_01.jpg)

8.  在这个阶段，数据库应该已经被重置以匹配结构和数据的标准状态。
9.  If you rerun the build again, you should now see the following logs:

    ![How to do it…](img/B4049_09_02.jpg)

10.  在父`pom.xml`(在`cloudstreetmarket-parent`)中，你可以注意到一个新的插件定义:

    ```java
    <plugin>
      <groupId>com.googlecode.flyway</groupId>
      <artifactId>flyway-maven-plugin</artifactId>
      <version>2.3.1</version>
      <inherited>false</inherited>
      <executions>
          <execution>
          <id>package</id>
          <goals>
          <goal>migrate</goal>
          </goals>
          </execution>
      </executions>
      <configuration>
        <driver>${database.driver}</driver>
        <url>${database.url}</url>
        <serverId>${database.serverId}</serverId>
        <schemas>
          <schema>${database.name}</schema>
          </schemas>
        <locations>
          <location>
            filesystem:${user.home}/app/db/migration
            </location>
          </locations>
          <initOnMigrate>true</initOnMigrate>
            <sqlMigrationPrefix>Migration-</sqlMigrationPrefix>
            <placeholderPrefix>#[</placeholderPrefix>
            <placeholderSuffix>]</placeholderSuffix>
            placeholderReplacement>true</placeholderReplacement>
            <placeholders>
            <db.name>${database.name}</db.name>
            </placeholders>
      </configuration>
      <dependencies>
            <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>5.1.6</version>
            </dependency>
      </dependencies>
      </plugin>
    ```

11.  该定义中使用的几个变量(例如**、**、`${database.driver})`对应于默认的属性，设置在该`pom.xml` :

    ```java
      <database.name>csm</database.name>
      <database.driver>com.mysql.jdbc.Driver</database.driver>
      <database.url>jdbc:mysql://localhost</database.url>
      <database.serverId>csm_db</database.serverId>
    ```

    的顶层
12.  `database.serverId`必须匹配 Maven `settings.xml`文件中的一个新的`Server`条目(在下一点中描述)。
13.  编辑位于`<home-directory>/.m2/settings.xml`的 Maven `settings.xml`文件(您必须已经在[第 1 章](1.html "Chapter 1\. Setup Routine for an Enterprise Spring Application")、*企业 Spring 应用*的设置例程中创建了该文件)。在根节点的某处添加下面的代码块:

    ```java
      <servers>
          <server>  
          <id>csm_db</id>
          <username>csm_tech</username>
          <password>csmDB1$55</password>
          </server>
      </servers>
    ```

14.  在父`pom.xml`(在`cloudstreetmarket-parent` ) 中，添加了一个新的`Profile`，可以选择覆盖(该`pom.xml`的)默认属性:

    ```java
    <profiles>
      <profile>
      <id>flyway-integration</id>
      <properties>
      <database.name>csm_integration</database.name>
      <database.driver>com.mysql.jdbc.Driver</database.driver>
      <database.url>jdbc:mysql://localhost</database.url>
      <database.serverId>csm_db</database.serverId>
      </properties>
      </profile>
    </profiles>
    ```

### Tip

使用`csm_integration`概要文件(`mvn clean install –Pcsm_integration`)运行`Maven Clean Install`将会在这种情况下升级一个`csm_integration`数据库。

## 它是如何工作的...

Flyway 是一个获得 Apache v2(自由软件)许可的数据库版本控制和迁移工具。它是 Boxfuse GmbH 公司的注册商标。

Flyway 不是这一类别中的唯一产品，但由于其简单性和易于配置，在行业中广泛存在。迁移脚本可以用普通的旧 SQL 编写，并且支持许多提供者。从经典的 RDBMS (Oracle、MySQL、SQL Server 等等)到内存 DB (HSQLDB、solidDB 等等)，甚至是基于云的解决方案(AWS Redshift、SQL Azure 等等)。

### 数量有限的命令

Flyway 提供以下六个命令，用于报告和操作目的。

#### 迁移

`Migrate` 命令是我们集成到 Maven 包阶段的目标。它在类路径或文件系统中查找要执行的潜在迁移。可以配置几个`locations`(脚本库)。在 Flyway Maven 插件中，这些`locations`在根`configuration`节点中定义。模式被设置为保留特定的文件名。

#### 干净

`Clean` 命令恢复原始数据库模式。这个命令删除了所有的对象(表、视图、函数等等)。

#### 信息

`Info`命令提供关于给定模式的当前状态和迁移历史的反馈。如果您查看一下本地 MySQL 服务器，在`csm`模式中，您会注意到已经创建了一个名为`schema_version`的元数据表。Flyway 使用下表来比较脚本存储库状态和数据库状态，并填补空白。

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

版本

 | 

描述

 | 

脚本

 | 

安装于

 | 

成功

 |
| --- | --- | --- | --- | --- |
| `0` | `<< Flyway Schema Creation >>` | `'csm'` | `12/11/2015 18:11` | `1` |
| `1` | `drop and create` | `/Migration-1_0__drop_and_create.sql` | `12/11/2015 18:11` | `1` |

`Info`命令基本上将该表作为报告打印出来。

#### 验证

`Validate`命令有助于确保在数据库上执行的迁移实际上对应于存储库中当前存在的脚本。

#### 基线

当我们有一个尚未被 Flyway 管理的现有数据库时，可以使用`Baseline` 命令。创建一个基线版本来标记该数据库的状态，并使其准备好与即将到来的版本共存。该基线之前的版本将被忽略。

#### 修复

`Repair`命令可以清除元数据表的损坏状态。为此，Flyway 会删除失败的迁移条目，并重置存储的校验和以匹配脚本校验和。

### 关于 Flyway Maven 插件

Flyway Maven 插件为 Maven 提供了控制 Flyway 程序的接口。我们的插件配置如下:

```java
<plugin>
    <groupId>com.googlecode.flyway</groupId>
    <artifactId>flyway-maven-plugin</artifactId>
    <version>2.3.1</version>
    <inherited>false</inherited>
    <executions>
      <execution>
        <id>package</id>
        <goals>
          <goal>migrate</goal>
        </goals>
      </execution>
    </executions>
    <configuration>
      <driver>${database.driver}</driver>
    <url>${database.url}</url>
    <serverId>${database.serverId}</serverId>
    <schemas>
       <schema>${database.name}</schema>
    </schemas>
    <locations>
      <location>
          filesystem:${user.home}/app/db/migration
        </location>
        </locations>
    <initOnMigrate>true</initOnMigrate>
      <sqlMigrationPrefix>Migration-</sqlMigrationPrefix>
      <placeholderPrefix>#[</placeholderPrefix>
      <placeholderSuffix>]</placeholderSuffix>
      <placeholderReplacement>true</placeholderReplacement>
      <placeholders>
      <db.name>${database.name}</db.name>
     </placeholders>
  </configuration>
</plugin>
```

和 Maven 插件一样，executions 部分允许将 Maven 阶段绑定到插件的一个或多个目标。对于 Flyway Maven 插件，目标是前面介绍的 Flyway 命令。我们告诉 Maven 什么时候考虑插件以及在这个插件中调用什么。

我们的`configuration` 部分介绍了在迁移过程中检查的一些参数。例如，`locations`指定要递归扫描的迁移存储库(它们可以从`classpath`:或`filesystem:`开始)。`schemas`为整套迁移定义了由 Flyway 管理的模式列表。第一个模式将是迁移中的默认模式。

一个有趣的特性是能够在迁移脚本中使用变量，这样这些脚本就可以用作多种环境的模板。变量名用`placeholders`定义，脚本中变量的识别方式可以用`placeholderPrefix`和`placeholderSuffix`配置。

完整的配置参数列表可在以下位置找到:

[http://flywaydb.org/documentation/maven/migrate.html](http://flywaydb.org/documentation/maven/migrate.html)。

## 还有更多…

### 官方文件

Flyway 得到了其社区的良好记录和积极支持。在[http://flywaydb.org](http://flywaydb.org)在线阅读更多产品信息。

您还可以通过位于 https://github.com/flyway/flyway 的 GitHub 资源库[关注或参与项目。](https://github.com/flyway/flyway)

## 参见

*   **Liquibase**: The main Flyway competitor is probably Liquibase. Liquibase doesn't use plain SQL for its scripts; it has instead its own multirepresentation DSL. For more information, visit:

    [http://www.liquibase.org](http://www.liquibase.org)。

# 使用 Mockito 和 Maven Surefire 进行单元测试

单元测试有助于关注组件的实现。Spring 的传统哲学在应用范围内促进了可重用组件。这些组件的核心实现可以改变状态(暂时对象的状态)或触发与其他组件的交互。

在单元测试中使用 Mocks 专门评估组件的方法相对于其他组件的**行为**。当开发人员习惯于模拟时，会惊奇地发现设计对不同层的使用和逻辑外化的影响有多大。类似地，对象名和方法名被赋予更多的重要性。因为它们总结了其他地方正在发生的事情，模拟节省了下一个必须在代码领域工作的开发人员的精力。

根据定义，开发单元测试是一项企业政策。由于测试覆盖的代码百分比可以很容易地反映产品的成熟度，因此代码覆盖率也成为评估公司产品的标准参考。还必须注意的是，将代码评审作为开发过程的公司会从拉请求中发现有价值的见解。当拉请求通过测试强调行为变化时，潜在变化的影响会更快变得清晰。

## 怎么做……

1.  Rerun a `Maven Install` on the `cloudstreetmarket-parent` project as in the previous recipe. When the build process comes to build the core module, you should see the following logs that suggest the execution of unit tests during the **test** phase (between **compile** and **package**):

    ![How to do it…](img/B4049_09_03.jpg)

2.  Those tests can be found in the `cloudstreetmarket-core` module, specifically in the `src/test/java` source folder:

    ![How to do it…](img/B4049_09_04.jpg)

    单元测试和集成测试都使用 JUnit:

    ```java
        <dependency>
             <groupId>junit</groupId>
             <artifactId>junit</artifactId>
             <version>4.9</version>
        </dependency>
    ```

3.  JUnit is natively supported by Eclipse IDE, and this last one offers handles to **Run** and **Debug** tests from a class or a method outside Maven:

    ![How to do it…](img/B4049_09_05.jpg)

4.  一个非常简单的 JUnit 测试类是`IdentifiableToIdConverterTest` (参见下面的代码)。这个类断言所有注册的实体都可以被`IdentifiableToIdConverter`转换为`Identifiable`实现(记住 hate OAS::

    ```java
    import static org.junit.Assert.*;
    import org.junit.Test;
    import edu.zipcloud.cloudstreetmarket.core.entities.*;

    public class IdentifiableToIdConverterTest {

      private IdentifiableToIdConverter converter;

      @Test
      public void canConvertChartStock(){
        converter = new IdentifiableToIdConverter(ChartStock.class);
        assertTrue(converter.canConvert(ChartStock.class));
        }

      @Test
      public void canConvertAction(){
        converter = new IdentifiableToIdConverter(Action.class);
        assertTrue(converter.canConvert(Action.class));
      }
    }
    ```

5.  More advanced unit tests use the Mockito library. For instance, in the following `YahooQuoteToCurrencyExchangeConverterTest`:

    ```java
    @RunWith(MockitoJUnitRunner.class)
    public class YahooQuoteToCurrencyExchangeConverterTest {
      @InjectMocks
      private YahooQuoteToCurrencyExchangeConverter converter;
      @Mock
      private CurrencyExchangeRepository currencyExchangeRepository;
      @Test
      public void transferCriticalData(){
          when(currencyExchangeRepository.findOne(
          any(String.class))
          )
          .thenReturn(new CurrencyExchange("WHATEVER_ID""));
        CurrencyExchange currencyExchange = converter.convert(buildYahooQuoteInstance());
        assertEquals("WHATEVER_ID"",currencyExchange.getId());
        assertEquals("USDGBP=X"", currencyExchange.getName());
        assertEquals(BigDecimal.valueOf(10), 
          currencyExchange.getBid());
        ...
        assertEquals(BigDecimal.valueOf(17), 
        currencyExchange.getOpen());	
        verify(currencyExchangeRepository, times(1))
          .findOne(any(String.class));
      }
      ...
    }
    ```

    这里，突出显示的`transferCriticalData()`测试获得了一个`YahooQuoteToCurrencyExchangeConverter`实例，它不是用真正的`@Autowired CurrencyExchangeRepository`初始化的，而是用一个**模拟**初始化的。转换器通过一个`YahooQuote` 实例调用它的`convert()`方法。

    ### 注意

    当在`convert()`内部调用其`findOne` ( `String s`)方法时，Mock 被告知返回一个特定的`CurrencyExchange`实例。然后，返回的`currencyExchange`对象被逐个字段地评估，以确保它们符合各自的期望。

6.  Maven 对 Mockito 的依赖关系之后的已经被添加到不同的模块中:

    ```java
        <dependency>
          <groupId>org.mockito</groupId>
          <artifactId>mockito-all</artifactId>
          <version>1.9.5<version>
        </dependency>
    ```

7.  在`CommunityServiceImplTest.`中可以找到 Mockito 在单元测试中更广泛的应用。例如，在下面的例子中，`registerUser_generatePasswordAndEncodeIt` 测试利用了`ArgumentCaptor` :

    ```java
    @Test
    public void registerUser_generatesPasswordAndEncodesIt() {
      when(communityServiceHelper.generatePassword())
        .thenReturn("newPassword");
      when(passwordEncoder.encode("newPassword"))
        .thenReturn("newPasswordEncoded");
      ArgumentCaptor<User>userArgumentCaptor = 
        ArgumentCaptor.forClass(User.class);
      userA.setPassword(null);
      communityServiceImpl.registerUser(userA);
      verify(userRepository, times(1))
        .save(userArgumentCaptor.capture());
      verify(passwordEncoder, times(1))
        .encode("newPassword");
      String capturedGeneratedPassword = 
        userArgumentCaptor.getValue().getPassword();
      assertEquals("newPasswordEncoded", capturedGeneratedPassword);
    }
    ```

## 它是如何工作的...

### @测试注释

必须将`@Test` 注释放在公共 void 方法上，以便 JUnit 将它们视为测试用例。在这些方法之一中引发的异常将被视为测试失败。因此，没有抛出任何异常的执行表示成功。

可以定制`@Test`注释，传递以下两个可选参数。

#### 预期和超时参数

一个`@Test`注释上的**预期**参数指定测试预期抛出一个特定类型的异常以获得成功。当抛出不同类型的异常或者根本没有抛出异常时，JUnit 必须认为执行失败。当一个测试用例在其`@Test`注释中被提供了一个**超时**参数时，当执行持续的时间超过指示的时间时，这个测试将会失败。

### @ run with 注释

正如菜谱中介绍的,`@RunWith`注释允许使用外部测试运行程序(而不是 JUnit 自带的默认`BlockJUnit4ClassRunner`)。顺便说一下，指定默认 JUnit runner 的声明性技术可以是让`@RunWith`像下面这样定位`JUnit4.class`:`@RunWith(JUnit4.class)`。

|  | *一个跑步者运行测试并在运行时通知一个`RunNotifier`重大事件* |  |
|  | -*JUnit.org·贾瓦德克* |

客户`Runner`必须实现来自`org.junit.runner.Runner` 的抽象方法，例如`run(RunNotifier notifier)`和`getDescription()`。它还必须跟进核心 JUnit 功能，例如，驱动测试执行流程。JUnit 有一套由`org.junit.runner.ParentRunner`原生处理的`@BeforeClass`、`@Before`、`@After`、`@AfterClass`等注释。我们接下来将访问这些注释。

### @前@后标注

在包含几个测试用例的测试类中，让测试逻辑尽可能清晰是一个很好的实践。从这个角度来看，变量初始化和上下文重新初始化是人们经常为了可重用性而试图外部化的操作。`@Before`可以在`public void`方法上定义注释，让运行人员在每次测试之前执行这些注释。类似地，`@After`注释再次标记了在**每次测试**之后要执行的`public void`方法(通常是为了清理资源或销毁上下文)。

关于继承的信息，父类的`@Before`方法将在当前类的方法之前运行。类似地，在超类中声明的`@After`方法将在当前类的方法之后运行。

Javadoc 中另一个有趣的点是，所有的`@After`****方法都保证运行，即使**`@Before`或`@Test`注释的方法抛出异常。**

### @BeforeClass 和@AfterClass 注释

`@BeforeClass`和`@AfterClass`注释可以应用于**公共静态 void** 方法。`@BeforeClass`使一个方法在测试生命周期中运行**一次**。该方法将在任何其他`@Test`或`@Before` 注释方法之前运行。

一个带注释的方法`@AfterClass`保证在所有测试之后运行**一次，并且在所有带注释的方法`@BeforeClass`、`@Before,`或`@After`之后运行，即使其中一个方法抛出异常。**

`@BeforeClass`和`@AfterClass`是处理与测试上下文准备(数据库连接管理和前/后业务处理)相关的性能消耗操作的有价值的工具。

关于继承，超类中的`@BeforeClass` 带注释的方法将在当前类的方法之前**执行，超类中的`@AfterClass`带注释的方法将在当前类的**方法之后**执行。**

### 使用 Mockito

Mockito 是一个开源测试框架，支持测试驱动开发和行为驱动开发。它允许创建双对象(模拟对象),并有助于隔离被测系统。

#### MockitoJUnitRunner

我们一直在谈论定制跑步者。`MockitoJUnitRunner`有点特别，它实现了默认`JUnitRunner`周围的装饰模式。

这样的设计使得可以选择使用这个 runner(所有提供的服务也可以用 Mockito 声明性地实现)。

`MockitoJUnitRunner`自动初始化`@Mock`带注释的依赖项(例如，在`@Before`带注释的方法中，这为我们节省了对`MockitoAnnotations.initMocks(this)`的调用)。

`initMocks(java.lang.Object testClass)`

|  | *为给定的测试类初始化用 Mockito 标注标注的对象:`@Mock`* |  |
|  | -- *Javadoc* |

在每个测试方法之后， `MockitoJUnitRunner`还通过调用`Mockito.validateMockitoUsage()`来验证我们实现框架的方式。这种验证肯定会让我们在显式错误输出的帮助下优化库的使用。

#### transferCriticalData 示例

接受测试的系统就是`YahooQuoteToCurrencyExchangeConverter`。`@InjectMocks`注释告诉 Mockito 在每次测试前使用初始化的 Mocks 在目标转换器上执行依赖注入(构造函数注入、属性设置器或字段注入)。

当在被测试的`converter.convert(...)` 方法中实际调用`currencyExchangeRepository.findOne`时，结合`thenReturn(T value)` 的`Mockito.when(T methodCall)` 方法允许定义一个假的`CurrencyExchange`返回对象。

带有`verify(currencyExchangeRepository, times(1)).findOne(any(String.class))` 的`Mockito verify` 方法告诉 Mockito 验证被测试的`convert`方法是如何与 Mock 交互的。在下面的例子中，我们希望`convert`方法只调用存储库一次。

#### 注册用户示例

更多具体来说，在`registerUser_generatesPasswordAndEncodesIt`测试中，我们利用一个`MockitoArgumentCaptor` 来手动地对调用了模拟方法的对象进行更深入的分析。

当我们没有中间层并且结果被重用来调用其他方法时，`MockitoArgumentCaptor`是有用的。

可能需要比表面的(但仍然非常有用的)类型检查更多的自省工具(例如，`any(String.class)`)。在测试方法中，一个`ArgumentCaptor`作为解决方案与额外的局部变量一起使用。

### Tip

请记住，实现方法中的局部变量和过渡状态总是会增加相关测试的复杂性。更短、明确和内聚的方法总是更好的选择。

## 还有更多…

### 关于莫克托

我们建议 Mockito 的 Javadoc 做得非常好，充满了实际的例子

[http://docs . mock ITO . Google code . com/Hg/org/mock ITO/mock ITO . html](http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html)

### JUnit 规则

到目前为止，我们还没有以任何方式介绍 JUnit 规则。JUnit 提供了`@Rule`注释，可以应用于测试类字段来抽象重复出现的特定于业务的准备。它经常被用来准备测试上下文对象(fixtures)。

[http://www.codeaffine.com/2012/09/24/junit-rules](http://www.codeaffine.com/2012/09/24/junit-rules)

[http://junit.org/javadoc/latest/org/junit/Rule.html](http://junit.org/javadoc/latest/org/junit/Rule.html)

## 参见

*   **代码覆盖率，JaCoCo** : JaCoCo 是一个库，用来帮助维护和增加应用中测试覆盖的代码的百分比；在[http://eclemma.org/jacoco](http://eclemma.org/jacoco)有售。
*   Read more about JaCoCo Maven plugin at:

    [http://eclemma.org/jacoco/trunk/doc/maven.html](http://eclemma.org/jacoco/trunk/doc/maven.html)

# 与 Cargo、放心和 Maven failsafe 的集成测试

集成测试和单元测试一样重要。它们从更高的层次验证一个特性，同时涉及更多的组件或层。当环境需要快速发展时，集成测试(IT 测试)就变得更加重要。设计过程经常需要迭代，单元测试有时会严重影响我们重构的能力，而较高级别的测试相对来说受影响较小。

## 准备就绪

这个菜谱展示了如何开发专注于 Spring MVC web 服务的自动化 IT 测试。这样的 IT 测试不是行为测试，因为它们根本不评估用户界面。为了测试行为，甚至需要更高的测试级别，模拟用户通过应用界面的旅程。

我们将配置 Cargo Maven 插件来建立一个测试环境，作为预集成测试 Maven 阶段的一部分。在集成测试阶段，我们将获得 Maven 故障保护插件来执行我们的 IT 测试。这些 IT 测试将利用放心库针对测试环境运行 HTTP 请求，并断言 HTTP 响应。

## 怎么做……

1.  We have designed Integration tests in the `cloudstreetmarket-api` module. These tests are intended to test the API controller methods.

    ![How to do it…](img/B4049_09_06.jpg)

2.  强大的放心库附带了以下 Maven 依赖项:

    ```java
      <dependency>
        <groupId>com.jayway.restassured</groupId>
        <artifactId>rest-assured</artifactId>
        <version>2.7.0</version>
      </dependency>
    ```

3.  使用放心的 IT 测试的一个典型例子是下面的`UserControllerIT.createUserBasicAuth()` :

    ```java
    public class UserControllerIT extends AbstractCommonTestUser{
      private static User userA;
      @Before
      public void before(){
        userA = new User.Builder()
          .withId(generateUserName())
          .withEmail(generateEmail())
          .withCurrency(SupportedCurrency.USD)
          .withPassword(generatePassword())
          .withLanguage(SupportedLanguage.EN)
          .withProfileImg(DEFAULT_IMG_PATH)
          .build();
      }
      @Test
      public void createUserBasicAuth(){
        Response responseCreateUser = given()
          .contentType("application/json;charset=UTF-8")
          .accept("application/json"")
          .body(userA)
          .expect
          .when()
          .post(getHost() + CONTEXT_PATH + "/users");
      String location = 
          responseCreateUser.getHeader("Location");
      assertNotNull(location);
      Response responseGetUser = given()
          .expect().log().ifError()
          .statusCode(HttpStatus.SC_OK)
          .when()
          .get(getHost() + CONTEXT_PATH + location + 
          		JSON_SUFFIX);
        UserDTO userADTO = 
          deserialize(responseGetUser.getBody().asString());
        assertEquals(userA.getId(), userADTO.getId());
        assertEquals(userA.getLanguage().name(), 
        userADTO.getLanguage());
        assertEquals(HIDDEN_FIELD, userADTO.getEmail());
        assertEquals(HIDDEN_FIELD, userADTO.getPassword());
        assertNull(userA.getBalance());
      }
    }
    ```

4.  Because they take longer to execute, we wanted to decouple the IT Tests execution from the main Maven life cycle. We have associated those IT Tests to a Maven profile named `integration`.

    ### 注意

    Maven 概要文件提供了用额外的生命周期绑定来丰富 Maven 构建的可能性。例如，我们的集成概要文件被激活，在通常的命令中将这个概要文件 id 作为`Profile`参数传递:

    `$ mvn clean install -P integration`

5.  对于我们的 API IT 测试，我们已经在`cloudstreetmarket-api pom.xml`文件中找到了特定于概要文件的配置:

    ```java
    <profiles>
      <profile>
      <id>integration</id>
      <build>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-failsafe-plugin</artifactId>
          <version>2.12.4</version>
          <configuration>
          <includes>
            <include>**/*IT.java</include>
          </includes>
          <excludes>
            <exclude>**/*Test.java</exclude>
          </excludes>
       </configuration>
       <executions>
          <execution>
            <id>integration-test</id>
            <goals>
              <goal>integration-test</goal>
            </goals>
          </execution>
          <execution>
            <id>verify</id>
            <goals><goal>verify</goal></goals>
          </execution>
       </executions>
     </plugin>
     <plugin>
      <groupId>org.codehaus.cargo</groupId>
      <artifactId>cargo-maven2-plugin</artifactId>
      <version>1.4.16</version>
          <configuration>
          <wait>false</wait>
          <container>
          <containerId>tomcat8x</containerId>
                <home>${CATALINA_HOME}</home>
          <logLevel>warn</logLevel>
          </container>
          <deployer/>
          <type>existing</type>
          <deployables>
          <deployable>
          <groupId>edu.zc.csm</groupId>
          <artifactId>cloudstreetmarket-api</artifactId>
          <type>war</type>
            <properties>
              <context>api</context>
            </properties>
          </deployable>
          </deployables>
        </configuration>
        <executions>
          <execution>
            <id>start-container</id>
            <phase>pre-integration-test</phase>
            <goals>
             <goal>start</goal>
             <goal>deploy</goal>
          </goals>
        </execution>
        <execution>
          <id>stop-container</id>
          <phase>post-integration-test</phase>
          <goals>
             <goal>undeploy</goal>
             <goal>stop</goal>
          </goals>
             </execution>
          </executions>
        </plugin>
      </plugins>
      </build>
      </profile>
    </profiles>
    ```

6.  在试图在您的机器上运行它们之前，检查您是否有一个指向您的 Tomcat 目录的 **CATALINA_HOME** 环境变量。如果没有，您必须创建它。要设置的变量应该如下(如果您已经遵循了[第 1 章](1.html "Chapter 1\. Setup Routine for an Enterprise Spring Application")、*企业 Spring 应用的设置例程*):
    *   `C:\tomcat8`:在微软视窗系统上
    *   `/home/usr/{system.username}/tomcat8`:在 Linux 上
    *   `/Users/{system.username}/tomcat8`:在 Mac OS X 上
7.  此外，确保 Apache HTTP、Redis 和 MySQL 在您的本地机器上启动并运行(如果您跳过了上一章，请参阅它)。
8.  When ready:
    *   在您的终端中执行以下 Maven 命令(如果您的路径中有 Maven 目录):

        ```java
         mvn clean verify -P integration

        ```

    *   或者在 Eclipse IDE 中从**Run**|**Run configuration…**菜单为这个定制构建创建一个快捷方式。要创建的构建配置如下:

    ![How to do it…](img/B4049_09_07.jpg)

9.  Running this command (or shortcut) should:
    1.  将 **api.war** 部署到本地 Tomcat 服务器
    2.  启动本地 Tomcat
    3.  执行匹配**/*IT.java 模式的测试类

    如果所有测试都通过了，您应该会看到`[INFO] BUILD SUCCESS` 消息。

10.  In between, when the build comes to the API, you should see the following bit of stack trace suggesting the successful execution of our IT tests:

    ![How to do it…](img/B4049_09_08.jpg)

## 它是如何工作的...

我们将在本节中解释为什么我们引入了 Maven 故障保护插件，Cargo 插件配置如何满足我们的需求，我们如何使用放心库，以及这个放心库有多有用。

### Maven fail safe vs Maven Surefire

我们正在使用 Maven failsafe 运行集成测试，使用 Maven Surefire 进行单元测试。这是使用这些插件的标准方式。下表反映了这一点，以及插件对测试类的默认命名模式:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
|  | 

Maven Surefire

 | 

Maven 故障保险

 |
| --- | --- | --- |
| **默认测试包含模式** | 

```java
**/Test*.java
**/*Test.java
**/*TestCase.java

```

 | 

```java
**/IT*.java
**/*IT.java
**/*ITCase.java

```

 |
| **默认输出目录** | 

```java
${basedir}/target/surefire-reports

```

 | 

```java
${basedir}/target/failsafe-reports

```

 |
| **绑定到构建阶段** | 

```java
test

```

 | 

```java
pre-integration-test
integration-test
post-integration-test
verify

```

 |

对于 Maven Failsafe，您可以看到我们的覆盖模式包含/排除是可选的。关于绑定到 Maven 构建阶段的,我们已经选择在`integration-test`和`verify`阶段触发集成测试的执行。

### 编码货物

Cargo 是一个轻量级库，它提供了操作几个受支持容器(Servlet 和 JEE 容器)的标准 API。涵盖的 API 操作的例子有工件的部署、远程部署和容器启动/停止。当通过 Maven、Ant 或 Gradle 使用时，它主要用于为集成测试提供支持，但也可以服务于其他领域。

#### Cargo Maven 插件

我们已经通过 Maven 插件`org.codehaus.cargo:cargo-maven2-plugin` 使用了 Cargo 来自动准备一个集成环境，我们可以对这个集成环境进行集成测试。在集成测试之后，我们希望这个环境能够关闭。

##### 绑定到 Maven 相位

以下执行已被声明为`cargo-maven2-plugin` 配置的一部分:

```java
<executions>
  <execution>
    <id>start-container</id>
    <phase>pre-integration-test</phase>
    <goals>
      <goal>start</goal>
    <goal>deploy</goal>
      </goals>
  </execution>
  <execution>
        <id>stop-container</id>
    <phase>post-integration-test</phase>
      <goals>
      <goal>undeploy</goal>
      <goal>stop</goal>
        </goals>
  </execution>
</executions>
```

让我们看看执行`mvn install`命令时会发生什么。

`install`是默认 Maven 生命周期的一个阶段。正如在[第 1 章](1.html "Chapter 1\. Setup Routine for an Enterprise Spring Application")、*企业 Spring 应用*、*、*的设置例程中所解释的，默认的生命周期从`validate`到`deploy`有 23 个构建阶段。`install`阶段是第 22 个阶段，所以检查了 22 个阶段，看看是否有可能附加到它们的插件目标。

在这里，`pre-integration-test`阶段(出现在默认生命周期的`validate`和`install`之间)将触发位于 maven Cargo 插件的`start`和`deploy`目标下的流程。与`post-integration-test`触发`undeploy`和`stop`目标是相同的逻辑。

在 IT 测试执行之前，我们启动并部署 Tomcat 服务器。这些 IT 测试在`integration-test`阶段由 Maven failsafe 处理。最后，Tomcat 服务器被取消部署并停止。

IT 测试也可以在`verify`阶段执行(如果服务器在默认的 Maven 生命周期之外启动)。

##### 使用现有的 Tomcat 实例

在 Cargo Maven 插件配置中，我们的目标是 Tomcat 的一个现有实例。我们的应用目前依赖于 MySQL、Redis、Apache HTTP 和自定义会话管理。我们已经决定，IT 测试的执行将需要在适当的集成环境中运行。

如果没有所有这些依赖，我们就可以下载 Tomcat 8 实例。

### 放心

放心的是一个获得 Apache v2 许可并由 Jayway 公司支持的开源库。它是用 Groovy 编写的，允许通过其独特的功能性 DSL 发出 HTTP 请求并验证 JSON 或 XML 响应，这极大地简化了 REST 服务的测试。

#### 静态导入

为了放心有效地使用,文档建议添加以下包的静态导入:

*   `com.jayway.restassured.RestAssured.*`
*   `com.jayway.restassured.matcher.RestAssuredMatchers.*`
*   `org.hamcrest.Matchers.*`

#### 给定，当，然后接近

为了理解放心 DSL 的基础，让我们考虑一下我们的一个测试(在`UserControllerIT`中),它提供了放心使用的简要概述:

```java
  @Test
  public void createUserBasicAuthAjax(){
    Response response = given()
    .header("X-Requested-With", "XMLHttpRequest")
    .contentType("application/json;charset=UTF-8")
    .accept("application/json\")
    .body(userA)
    .when()
    .post(getHost() + CONTEXT_PATH + "/users");
    assertNotNull(response.getHeader("Location"));
  }
```

语句的`given`部分是 HTTP 请求规范。放心，一些请求头像`Content-Type`或`Accept`可以用`contentType(…)`和`accept(…)`以直观的方式定义。其他**头**可以用通用的`.header(…)`达到。请求参数和认证也可以以相同的方式定义。

对于`POST`和 `PUT`请求，需要给请求传递一个体。这个`body`可以是普通的 JSON 或 XML，或者直接是 Java 对象(正如我们在这里所做的)。这个`body`作为一个 Java 对象，将由库根据规范(JSON 或 XML)中定义的`content-type`进行转换。

在 HTTP 请求规范之后，`when()`语句提供了关于实际 HTTP 方法和目的地的信息。

在这个阶段，返回的对象允许我们从一个`then()`块中定义期望，或者像我们在这里所做的那样，从可以单独定义约束的地方检索`Response`对象。在我们的测试用例中，`Response`的`Location`头应该被填充。

## 还有更多…

更多信息可在以下货物和放心相关文件中找到:

### 关于货物

有关该产品及其与第三方系统集成的更多信息，请参考 https://codehaus-cargo.github.io/cargo/Home.html 的[。](https://codehaus-cargo.github.io/cargo/Home.html)

### 更多放心例子

对于更多的例子，放心在线维基提供了大量的:

[https://github.com/jayway/rest-assured/wiki/Usage](https://github.com/jayway/rest-assured/wiki/Usage)

# 将 Spring Beans 注入到集成测试中

这个方法是如何将 Spring 托管 beans 注入集成测试类的一个例子。即使对于 IT 测试来说，其首要目标是将后端作为一个黑盒来评估，有时也有必要从中间层获取技术对象。

## 准备就绪

我们将看到如何重用 Spring managed `datasource`的一个实例来注入到我们的测试类中。这个`datasource`将帮助我们构建一个`jdbcTemplate`的实例。从这个`jdbcTemplate`开始，我们将查询数据库并模拟/验证无法通过其他方式测试的流程。

## 怎么做……

1.  We have `@Autowired` a `dataSource` SpringBean in our `UserControllerIT` test. This bean is defined in the test-specific Spring configuration file (`spring-context-api-test.xml`) `resources` directory (`cloudstreetmarket-api`):

    ![How to do it…](img/B4049_09_09.jpg)

    ```java
    <context:property-placeholderlocation="
      file:${user.home}/app/cloudstreetmarket.properties""/>
    <bean id="dataSource" 		
      class="org.apache.commons.dbcp2.BasicDataSource" 	
      destroy-method="close"">
      <property name="driverClassName"">
         <value>com.mysql.jdbc.Driver</value>
      </property>
      <property name="url"">
        <value>${db.connection.url}</value>
      </property>
    <property name="username"">
      <value>${db.user.name}</value>
    </property>
    <property name="password"">
      <value>${db.user.passsword}</value>
    </property>
    <property name="defaultReadOnly">
      <value>false</value>
    </property>
    </bean>
    ```

    从`@Autowired dataSource` bean 的`UserControllerIT`类中创建一个`jdbcTemplate`实例:

    ```java
        @Autowired
        private JdbcTemplate jdbcTemplate;
        @Autowired
        public void setDataSource(DataSource dataSource) {
        	this.jdbcTemplate = new JdbcTemplate(dataSource);
        }
    ```

2.  We use `jdbcTemplate` to insert and delete `Social Connections` directly in the database (see [Chapter 5](5.html "Chapter 5\. Authenticating with Spring MVC"), *Authenticati**ng with Spring MVCA*). This allows us to bypass and simulate a successful user OAuth2 authentication flow (that normally happens through the web browser).

    为了删除社交联系，我们创建了以下私有方法，测试需要时调用该方法:

    ```java
        private void deleteConnection(String spi, String id) {
        	this.jdbcTemplate.update("delete from userconnection where providerUserId = ? and userId = "?", new Object[] {spi, id});
       }
    ```

3.  在`UserControllerIT` 类的最顶端，可以注意到以下两个注释:
    *   `@RunWith(SpringJUnit4ClassRunner.class)`告诉 JUnit 使用支持 Spring `TestContext`框架的自定义扩展 JUnit ( `SpringJUnit4ClassRunner`)运行。
    *   `@ContextConfiguration("classpath:spring-context-api-test.xml")`指定在哪里以及如何加载和配置 Spring 应用上下文:

        ```java
            @RunWith(SpringJUnit4ClassRunner.class)
            @ContextConfiguration("classpath:spring-context-api-test.xml"")
            public class UserControllerIT extends AbstractCommonTestUser{
            private static User userA;
            private static User userB;
            ...
            }
        ```

## 它是如何工作的...

### SpringJUnit4ClassRunner

在其设计中， `SpringJUnit4ClassRunner`是 JUnit 的`BlockJUnit4ClassRunner`的直接子类。`SpringJUnit4ClassRunner`加载`TestContextManager`时初始化。一个`TestContextManager` 管理一个`TestContext` 的生命周期，也可以将测试事件反映到注册的`TestExecutionListeners` (来自`@BeforeClass`、`@AfterClass`、`@Before`和`@After`注释)。

通过加载 Spring 上下文，`SpringJUnit4ClassRunner` Spring 上下文，`SpringJUnit4ClassRunner`使得在测试类中使用 Spring 管理的 beans 成为可能。`SpringJUnit4ClassRunner`还支持一组可以在测试类中使用的注释(来自 JUnit 或 Spring test)。可以信任这些注释的使用，以便随后为上下文定义的对象提供合适的生命周期管理。

这些注释是`@Test` (及其`expected`和`timeout`注释参数)、`@Timed`、`@Ignore`、`@ProfileValueSourceConfiguration`和`@IfProfileValue`。

### @ context configuration 注释

这个类级注释是针对 Spring Test 的。它定义了如何以及在哪里为测试类加载 Spring 上下文。

我们在菜谱中的定义针对一个特定的 Spring XML 配置文件`@ContextConfiguration("classpath:spring-context-api-test.xml").`

然而，由于 Spring 3.1 可以通过编程定义上下文，`@ContextConfiguration`也可以将配置类作为目标，如下所示:

`@ContextConfiguration(classes={AnnotationConfig.class,` `WebSocketConfig.class})`

如下面的代码片段所示，两种声明类型可以组合在同一个注释中:

`@ContextConfiguration(classes={AnnotationConfig.class,` `WebSocketConfig.class}, locations={``classpath:spring-context-api-test.xml``})`

## 还有更多…

我们将在本节中看到更多关于用于测试目的的 Spring JdbcTemplate 的内容。

### JDBC 模板

在第一章“企业 Spring 应用的设置例程”中，我们已经介绍了不同的模块，这些模块使得 Spring 框架成为今天的样子。一组模块是**数据访问和集成**。该组包含 JDBC、ORM、OXM、JMS 和事务模块。

`JdbcTemplate`是 Spring JDBC 核心包的关键级部分。它可靠地允许用简单的实用方法执行数据库操作，并且还提供了对大块样板代码的抽象。这个工具再一次节省了我们的时间，并提供了设计高质量产品的模式。

### 样板逻辑的抽象

让我们以测试类中删除连接的方法为例:

```java
jdbcTemplate.update("delete from userconnection where 
  providerUserId = ? and userId = "?", new Object[] {spi, id});
```

使用`jdbcTemplate`，删除一个数据库元素是一行指令。它在幕后创建一个`PreparedStatement`，根据我们实际传递的参数选择正确的类型，并为我们管理数据库连接，确保无论发生什么都关闭这个连接。

`jdbcTemplate.update`方法被设计成发出一个 SQL 更新操作。它可以用于插入、更新以及删除。

与 Spring 中的常见情况一样，`jdbcTemplate`也将产生的已检查异常(如果有的话)转换成未检查的异常。在这里，潜在的`SQLExceptions`将被包裹在一个`RuntimeException`中。

#### 提取自动生成的 id

`jdbcTemplate.update` 方法还提供了其他参数类型:

```java
jdbcTemplate.update(final PreparedStatementCreator psc, final
  KeyHolder generatedKeyHolder);
```

在插入的情况下，当需要读取和潜在重用生成的 ID(在查询执行之前是未知的)时，可以调用这个方法。

在我们的示例中，如果我们想要在插入新连接时重用生成的连接 id，我们应该按如下方式进行:

```java
KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
  new PreparedStatementCreator() {
    public PreparedStatement createPreparedStatement(Connection 
    connection) throws SQLException {
    PreparedStatement ps = connection.prepareStatement("insert into userconnection (accessToken, ... , secret, userId ) values (?, ?, ... , ?, ?)", new String[] {"id""});
    ps.setString(1, generateGuid());
    ps.setDate(2, new Date(System.currentTimeMillis()));
    ...
    return ps;
    }
  }, keyHolder);
  Long Id = keyHolder.getKey().longValue();
```

但是我们并没有特别要求这样的用例。

# 使用 Log4j2 的现代应用日志

在 Java 生态系统中经历了 20 年的发展之后，种日志记录方式出现了不同的策略、趋势和架构。如今，在使用的第三方依赖中可以找到几个日志框架。我们必须支持它们来调试应用或跟踪运行时事件。

## 准备就绪

这个秘籍为`CloudStreet Market`应用提供了一个面向未来的`Log4j2`实现。它需要在我们的模块中添加几个 Maven 依赖项。作为一个解决方案，它可能看起来相当复杂，但实际上支持的日志框架数量是有限的，并且`Log4j2`迁移背后的逻辑相当简单。

## 怎么做……

1.  The following Maven dependencies have been added to the dependency-management section of the parent-module (`cloudstreetmarket-parent`):

    ```java
        <!-- Logging dependencies -->
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-api</artifactId>
          <version>2.4.1</version>
        </dependency>
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-core</artifactId>
          <version>2.4.1</version>
        </dependency>
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-slf4j-impl</artifactId>
          <version>2.4.1</version>
        </dependency>
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-1.2-api</artifactId>
          <version>2.4.1</version>
        </dependency>
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-jcl</artifactId>
          <version>2.4.1</version>
          </dependency>
        <dependency>
          <groupId>org.apache.logging.log4j</groupId>
          <artifactId>log4j-web</artifactId>
            <scope>runtime</scope>
          <version>2.4.1</version>
        </dependency>
        <dependency>
          <groupId>org.slf4j</groupId>
          artifactId>slf4j-api</artifactId>
          <version>${slf4j.version}</version>
        </dependency>
    ```

    ### Tip

    最后一个依赖管理`org.slf4j`，允许我们确保一个单一版本的`slf4j`将在任何地方使用。

2.  在`api`、`ws`、`core`模块中，添加了以下依赖项:`log4j-api`、`log4j-core`、`log4j-slf4j-impl`、`log4j-1.2-api`、和 `log4j-jcl`。
3.  在 web 模块(`api`、`ws`、`webapp`)中增加了`log4j-web` 。
4.  请注意，添加`slf4j-api`只是为了依赖关系管理。
5.  Start the Tomcat Server with **the extra JVM argument**:

    ```java
    -Dlog4j.configurationFile=<home-directory>\app\log4j2.xml.
    ```

    ### Tip

    用您在机器上实际使用的路径替换`<home-directory>`。

6.  现在用户主目录中的 app 目录包含`log4j2`配置文件:

    ```java
    <?xml version="1.0" encoding="UTF-8"?>
    <Configuration status="OFF" monitorInterval="30">
    <Appenders
      <Console name="Console" target="SYSTEM_OUT">
        <PatternLayout pattern"="%d{HH:mm:ss.SSS} %-5level %logger{36} - %msg%n""/>
      </Console>
      <RollingFile name="FileAppender" fileName="${sys:user.home}/app/logs/cloudstreetmarket.log"
            filePattern="${sys:user.home}/app/logs/${date:yyyy-MM}/cloudstreetmarket-%d{MM-dd-yyyy}-%i.log.gz">
          <PatternLayout>
            <Pattern>%d %p %C{1} %m%n</Pattern>
          </PatternLayout>
          <Policies>
            <TimeBasedTriggeringPolicy />
            <SizeBasedTriggeringPolicy size="250 MB"/>
          </Policies>
      </RollingFile>
    </Appenders>
    <Loggers>
      <Logger name="edu.zipcloud" level="INFO"/>
      <Logger name="org.apache.catalina" level="ERROR"/>
      <Logger name="org.springframework.amqp" level="ERROR"/>
      <Logger name="org.springframework.security" level="ERROR"/>

      <Root level="WARN">
        <AppenderRef ref="Console"/>
      <AppenderRef ref="FileAppender"/>
      </Root>
    </Loggers>
    </Configuration>
    ```

7.  作为一个后备选项，`log4j2.xml`文件也存在于每个模块的类路径(`src/main/resources`)中。
8.  A couple of log instructions have been placed in different classes to trace the user journey.

    在`SignInAdapterImpl`中记录指令:

    ```java
        import org.apache.logging.log4j.LogManager;
    import org.apache.logging.log4j.Logger;

    @Transactional
    public class SignInAdapterImpl implements SignInAdapter{
      private static final Logger logger = 
        LogManager.getLogger(SignInAdapterImpl.class);
      ...
      public String signIn(String userId, Connection<?>connection, NativeWebRequest request) {
      ...
      communityService.signInUser(user);
      logger.info("User {} logs-in with OAUth2 account", user.getId());
      return view;
      }
    }
    ```

    在`UsersController`中记录指令:

    ```java
    @RestController
    @RequestMapping(value=USERS_PATH, produces={"application/xml", "application/json"})
    public class UsersController extends CloudstreetApiWCI{
      private static final Logger logger = LogManager.getLogger(UsersController.class);
      ...
      @RequestMapping(method=POST)
      @ResponseStatus(HttpStatus.CREATED)
      public void create(@Valid @RequestBody User user, 
        @RequestHeader(value="Spi", required=false) String guid, 
      @RequestHeader(value="OAuthProvider", required=false) String provider, HttpServletResponse response) throws IllegalAccessException{
          if(isNotBlank(guid)){
          ...
          communityService.save(user);
          logger.info("User {} registers an OAuth2 account: "{}", user.getId(), guid);
          }
          else{
        user = communityService.createUser(user, ROLE_BASIC);
        ...
        logger.info("User registers a BASIC account"", user.getId());
          }
        ...
      }
      ...
    }
    ```

9.  Start your local Tomcat Server and navigate briefly through the application. As with the following example, you should be able to observe a trace of the customer activity in the aggregated file: `<home-directory>/apps/logs/cloudstreetmarket.log`:

    ![How to do it…](img/B4049_09_10.jpg)

### Tip

使用我们所做的`log4j2.xml`配置，`cloudstreetmarket.log`文件将在达到 250 MB 时自动压缩并分类到目录中。

## 它是如何工作的...

在这一节中，我们主要回顾 Log4j2 是如何与其他日志框架一起工作的。配置的其他部分(这里没有涉及)被认为更直观。

### 其他日志框架中的 Apache Log4j2

Log4j1+作为一个项目正在消亡，因为它不再与 Java 5+兼容。

Log4j 2 是作为 Log4j 代码库的一个分支构建的。从这个角度来看，它与 Logback 项目存在竞争。Logback 最初是 Log4j 的合法延续。

Log4j 2 实际上实现了 Logback 的许多改进，但也修复了 Logback 架构固有的问题。

Logback 提供了巨大的性能改进，尤其是多线程。相比之下，Log4j 2 提供了类似的性能。

#### SLF4j 的案例

SLF4j 本身不是一个日志框架；它是一个抽象层，允许用户在部署时插入任何日志系统。

SLF4j 要求类路径中有一个 SLF4j 绑定。绑定的示例如下:

*   `slf4j-log4j12-xxx.jar` : (log4j 版本 1.2)，
*   `slf4j-jdk14-xxx.jar` : ( `java.util.logging`来自 jdk 1.4)，
*   `slf4j-jcl-xxx.jar`:(雅加达公共日志)
*   `logback-classic-xxx.jar`。

它通常还需要目标日志框架的核心库。

### 迁移到 log4j 2

Log4j2 不为 Log4j1+提供向后兼容性。这听起来可能是个问题，因为应用(比如`CloudStreetMarket`)经常使用嵌入了自己的日志框架的第三方库。例如，Spring core 对 Jakarta Commons 日志记录有一个可传递的依赖性。

为了解决这种情况，log4j 2 提供了适配器，保证内部日志不会丢失，并将被桥接以加入 Log4j 2 日志流。几乎所有可能产生日志的系统都有适配器。

#### Log4j 2 API 和核心

Log4j 2 带有一个 API 和一个实现。两者都是必需的，并且具有以下依赖关系:

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-api</artifactId>
  <version>2.4.1</version>
</dependency>
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-core</artifactId>
  <version>2.4.1</version>
</dependency>
```

#### Log4j 2 适配器

如前所述，一组**适配器**和**桥**可用于为我们的应用提供向后兼容性。

##### Log4j 1.x API 桥

当在特定模块中注意到对 Log4j 1+的传递依赖关系时，应添加以下桥:

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-1.2-api</artifactId>
  <version>2.4.1</version>
</dependency>
```

##### 阿帕奇公共伐木桥

当在特定模块中注意到对 Apache (Jakarta) Commons 日志记录的传递依赖性时，应该添加以下桥:

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-jcl</artifactId>
  <version>2.4.1</version>
</dependency>
```

##### SLF4J 大桥

同样的逻辑适用于 cover slf4j 使用；应添加以下桥:

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-slf4j-impl</artifactId>
  <version>2.4.1</version>
</dependency>
```

##### Java Util 日志适配器

在我们的应用中没有注意到对`java.util.logging` 的可传递依赖关系，但是如果是这样的话，我们会使用下面的桥:

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-jul</artifactId>
  <version>2.4.1</version>
</dependency>
```

##### Web Servlet 支持

Apache Tomcat 容器有自己的一组库，它们也生成日志。在 web 模块上添加以下依赖项是确保容器日志被路由到主 Log4j2 管道的一种方式。

```java
<dependency>
  <groupId>org.apache.logging.log4j</groupId>
  <artifactId>log4j-web</artifactId>
  <version>2.4.1</version>
  <scope>runtime</scope>
</dependency>
```

### 配置文件

这个秘籍的第六步详述了我们的 log4j2 配置。它由不同的可配置的`Appenders`(基本上是输出通道)组成。我们使用控制台和基于文件的`Appender`，但是 Log4j 2 有一个关于`Appenders`的基于插件的架构，如果需要，允许使用外部输出通道(SMTP、打印机、数据库等等)。

## 还有更多…

作为外部信息来源，我们指出了有趣的 Log4j2 自动配置，它由配置文件的级联查找、官方文档和用于直接登录 Redis 的`Appender`组成。

### 自动配置

Log4j2 实现级联查找，以定位 Log4j2 配置文件。从寻找一个提供的`log4j.configurationFile` 系统属性开始，到类路径中的`log4j2-test.xml`和`log4j2.xml`文件，官方文档详细描述了所有遵循瀑布的步骤。该文档可从以下网址获得:

[https://logging . Apache . org/log4j/2 . x/manual/configuration . html](https://logging.apache.org/log4j/2.x/manual/configuration.html)

### 官方文件

官方的文档制作精良，内容完整，可从以下网址获得:

[https://logging.apache.org/log4j/2.x.](https://logging.apache.org/log4j/2.x.)

### 有趣的 Redis Appender 实现

下面的地址介绍了一个 Apache 许可的项目，它提供了一个 Log4j2 **Appender** 来直接登录 Redis:

[https://github . com/pavlobaron/log4j 重试](https://github.com/pavlobaron/log4j2redis)