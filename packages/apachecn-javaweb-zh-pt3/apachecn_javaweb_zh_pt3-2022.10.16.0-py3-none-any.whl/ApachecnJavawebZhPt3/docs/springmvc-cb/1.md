# 一、Spring 企业应用的设置例程

本章涵盖的主题对应于这四个步骤:

*   为 JEE 开发者和 Java SE 8 安装 Eclipse
*   为 Java SE 8、Maven 3 和 Tomcat 8 配置 Eclipse
*   用 Maven 定义项目结构
*   安装 Spring、Spring MVC 和一个 web 结构

# 简介

在我们开始这个初始化开发的例行程序之前，作为介绍，我们要回答几个问题，这些问题会帮助你更好地理解这个例行程序。

请记住，本章的结果也将构成所有后续章节的最低起点。

### 注意

让我们开心地做吧！

在本书中，我们将代表 ZipCloud 公司行事。ZipCloud 的目标是在社交和金融行业打造不同的产品。我们将打造公司的第一个产品:`cloudstreetmarket.com`这将是一个精彩的股票交易平台，具有社交功能。这个项目一定是这个小型 ZipCloud 初创公司的最佳开端！

## 为什么这么套路？

无论你最初的目标是什么，有必要确保设计不会遭受早期的失败。这个程序应该可以帮你抵御这种风险。

超越常规本身的想法是分享一个引导方法来启动你现在需要的项目基础，它将支持你明天的需求。该例程也是将您的产品思想推向易于重构和维护的可持续架构的关键。

为一个企业级架构建立一个新的项目不会扼杀兴奋和创造力！

## 为什么要使用 Eclipse IDE？

这个领域存在竞争，但是 Eclipse 在 Java 社区中很受欢迎，因为它是一个活跃的开源解决方案；因此，任何人都可以不受限制地在线访问它。除了其他用途之外，它还为 web 实现，尤其是 MVC web 实现提供了非常好的支持。

## 为什么要使用 Maven？

**Maven** 是的一个*软件项目管理和理解工具*。这是一个由 Apache 社区和 Apache 软件基金会支持的开源项目。近 10 年来，Maven 带来了巨大的好处。它还形成了 Java 项目的标准结构。凭借其 **项目对象模型** ( **POM** )方法，它为任何人以及任何潜在的第三方软件提供了一种统一的、激进的方式来理解和构建 Java 项目层次结构及其所有依赖关系。

在早期架构中，考虑以下决策至关重要:

*   向潜在的不同开发环境和持续集成工具开放项目定义
*   监控依赖关系，并可能保护它们的访问
*   在项目层次结构中实现统一的目录结构
*   用自测组件构建自测软件

选择 Maven 保证了这些点，并满足了我们的项目需求，使我们的项目可重用、安全且可测试(在自动化下)。

## Spring 框架带来了什么？

十多年来，Spring Framework 及其社区为推动 Java 平台的发展做出了贡献。详细介绍整个框架需要我们写的不仅仅是一本书。然而，基于**控制反转** ( **IOC** )和**依赖注入** ( **DI** )的原则的核心功能，通过对 bean 库的性能访问，允许相当大的可重用性。它重量轻，保证了强大的扩展能力，可能适合所有现代架构。

# 为 JEE 开发者和 Java SE 8 安装 Eclipse

下面的秘籍是关于为 JEE 开发者下载和安装 Eclipse IDE 以及下载和安装 JDK 8 Oracle Hotspot 的。

## 准备就绪

就你的教育或经历而言，第一个方法可能显得多余或不必要。然而，在本书中使用统一的配置会给你带来很多好处。

例如，您肯定会避免未识别的错误(集成或开发)。您还将体验到与截图中相同的界面。还有，因为第三方产品是活的，你不会有遇到意想不到的屏幕或窗口的惊喜。

## 怎么做...

整个第一章总的来说需要一步一步的合作。从下一章开始，我们将使用 GIT，你的积极参与将会减轻。

1.  Download a distribution of the Eclipse IDE for Java EE developers:
    *   在本书中，我们将使用 Eclipse Luna 发行版。我们建议您安装这个版本，以便完全符合我们的指南和截图。从[https://www . eclipse . org/downloads/packages/eclipse-ide-Java-ee-developers/lunasr 1](https://www.eclipse.org/downloads/packages/eclipse-ide-java-ee-developers/lunasr1)下载适用于您选择的操作系统和环境的 Luna 发行版。

    要下载的产品不是编译好的安装程序，而是一个 zip 存档。

    *   If you feel confident enough to use another version (more recent) of the Eclipse IDE for Java EE Developers, all of them can be found at [https://www.eclipse.org/downloads](https://www.eclipse.org/downloads).

        ### Tip

        对于即将进行的安装，在 Windows 上，建议将一些目标位置放在根目录(`C:\`)中。为了避免与权限相关的问题，最好将您的 Windows 用户配置为本地管理员。如果您不能成为该组的一部分，请随意选择您有写权限的目标安装目录。

2.  从以下步骤将下载的归档文件解压缩到一个`eclipse`目录中:
    *   如果你用的是 Windows，在这里解压
    *   如果你是 Linux 的话，在这里解压
    *   如果你在 Mac OS X 上，请在这里提取
3.  Select and download JDK 8:
    *   我们建议您下载甲骨文热点 JDK。Hotspot 是一个高性能的 JVM 实现，最初由 Sun Microsystems 构建。现在归甲骨文公司所有，Hotspot JRE 和 JDK 可以免费下载。
    *   然后通过甲骨文网站的链接[http://www . Oracle . com/tech network/Java/javase/downloads/JDK 8-downloads-2133151 . html](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)选择你的机器对应的产品。

    ### 注意

    为了避免以后的兼容性问题，一定要与您之前为 Eclipse 归档所做的架构选择(32 位或 64 位)保持一致。

4.  Install JDK 8 on the operating system of your choice using the following instructions:

    在 Windows 上，这是由可执行文件启动的受监控安装:

    1.  执行下载的文件，并等待，直到您到达下一个安装步骤
    2.  在安装步骤窗口中，注意目标目录并将其更改为`C:\java\jdk1.8.X_XX` ( `X_XX`在此指最新的当前版本。我们将在本书中使用 jdk1.8.0_25。另外，没有必要安装外部 JRE，所以不要选择公共 JRE 特性。)

    在 Linux/Mac 上，执行以下步骤:

    1.  下载与您的环境相对应的`tar.gz`归档文件
    2.  将当前目录更改为您想要安装 Java 的位置。为了便于说明，让我们就`/usr/java`目录达成一致
    3.  将下载的`tar.gz`档案移动到当前目录
    4.  使用下面的命令行解压归档文件，该命令行以您的归档文件的名称为目标:`tar zxvf jdk-8u25-linux-i586.tar.gz`(该示例针对与 Linux x86 机器相对应的二进制归档文件)

您必须以包含`/bin`、`/db`、`/jre`、`/include`子目录的`/usr/java/jdk1.8.0_25`目录结构结束。

## 它是如何工作的……

在这一节中，我们将提供更多关于我们使用的 Eclipse 版本以及我们如何选择 JVM 这个特定版本的见解。

### 面向 Java EE 开发者的 Eclipse

我们已经在这里为 Java EE 开发人员成功安装了 Eclipse IDE。与面向 Java 开发人员的 Eclipse IDE 相比，还有一些额外的软件包，如 *Java EE 开发工具*、*数据工具平台*和 *JavaScript 开发工具*。该版本因其能够将开发服务器作为 IDE 本身的一部分进行管理、能够定制项目方面以及能够支持 JPA 而受到赞赏。Luna 版本官方兼容 Java SE 8；在编写本报告时，这是一个决定性因素。

### 选择一个 JVM

JVM 实现的选择可以从性能、内存管理、垃圾收集和优化能力等方面进行讨论。

有许多不同的 JVM 实现，包括一些开源解决方案，如 OpenJDK 和 IcedTea (RedHat)。JVM 的选择实际上取决于应用的需求。根据经验和在生产中部署的参考实现，我们选择了 Oracle Hotspot;这个 JVM 实现可以被信任用于广泛的通用目的。如果你有运行 Java UI 应用的，热点也表现得很好。月食就是其中之一。

### Java SE 8

如果您还没有使用过 Scala 或 Clojure，那么是时候参加 Java 的函数式编程培训了！有了 Java SE 8， *Lambda 表达式*大大减少了代码量，提供了改进的*可读性和可维护性*。我们不会实现这个 Java 8 特性，但是因为它可能是最受欢迎的，所以必须强调它，因为它为范式的改变做出了巨大的贡献。如今，熟悉这些模式很重要。

# 为 Java 8、Maven 3 和 Tomcat 8 配置 Eclipse

这个秘籍需要配置技术，以便用 Java、Maven 和 Tomcat 在 Eclipse 上高效地开发。

## 准备就绪

一旦安装了不同的产品，我们需要遵循几个步骤，主要是让 Eclipse 与 Java SE 8、Maven 3 和 Tomcat 8 一起正常工作。在这个菜谱中，我们还将了解如何定制 Eclipse 配置文件(`Eclipse.ini`)，以便充分利用运行 Java 的平台，并确保它能够应对应用的任何显著增长。

## 怎么做...

让我们看看在您的桌面上配置 Eclipse 的以下步骤:

1.  您可以从在桌面上创建一个指向 Eclipse 可执行文件的快捷方式开始:
    *   在 Windows 上，可执行文件是`Eclipse.exe`，位于`eclipse`根目录下
    *   在 Linux/Mac 上，该文件被命名为`Eclipse`，也位于`eclipse`根目录下
2.  Then, we need to customize the `eclipse.ini` file:

    在 Eclipse 目录中，在之前解压 Eclipse 归档文件的地方，可以找到`eclipse.ini`文件。*它是一个文本文件，包含一些命令行选项，用于控制 Eclipse 启动*。

    *   Eclipse 社区建议在这里指定 JVM 的路径。因此，根据您的系统，在文件顶部添加以下两行:

    对于 Windows，添加以下内容:

    ```java
    -vm 
    C:\java\jdk1.8.0_25\jre\bin\server\jvm.dll

    ```

    对于 Linux/Mac，添加以下内容:

    ```java
    -vm 
    /usr/java/jdk1.8.0_25/jre/lib/{your.architecture}/server/libjvm.so

    ```

    以下是您可以考虑的可选设置:

    *   If your development machine has at least 2 GB of RAM, you can enter the following options to make Eclipse run faster than the default settings. *This section is optional because Eclipse's default settings are already optimized to suit most users' environment*:

        ```java
        -vmargs
        -Xms128m
        -Xmx512m
        -Xverify:none
        -Dosgi.requiredJavaVersion=1.6
        -XX:MaxGCPauseMillis=10
        -XX:MaxHeapFreeRatio=70
        -XX:+UseConcMarkSweepGC
        -XX:+CMSIncrementalMode
        -XX:+CMSIncrementalPacing

        ```

        如果您的机器的 RAM 少于 2 GB，您仍然可以输入这组选项，而不用覆盖默认的`–Xms`和`–Xmx`参数。

        ### Tip

        `-vmargs`下的所有选项都是启动时将传递给 JVM 的参数。重要的是不要把 Eclipse 选项(文件的顶部)和 VM 参数(底部)搞混了。

3.  After this we will go through the following steps to start Eclipse and set the workspace:

    启动步骤 *2* 中描述的可执行文件。

    *   对于我们的项目，指定路径:`<home-directory>/workspace`

    这个路径对于每个操作系统都是不同的:

    *   这是 Windows 上的路径
    *   这是在 Linux 上
    *   这是在苹果操作系统上
    *   点击 **OK** ，让 Eclipse 程序启动

    ### 注意

    工作区是您管理 Java 项目的地方。它可以特定于一个应用，但不是必须的。

4.  Then, we need to check the JRE definitions:

    这里，需要在 Eclipse 中验证几个设置:

    1.  打开**窗口**下的**偏好**菜单(在 Mac OS X 上**偏好**菜单在 **Eclipse** 菜单下)。
    2.  在左侧的导航面板中，打开 Java 层级，点击 **Java** 下的 **Installed JREs** 。
    3.  在中央屏幕上，删除您可能已经拥有的任何现有 JRE。
    4.  单击 **Add…** 按钮添加一个标准 JVM。
    5.  输入`C:\java\jdk1.8.0_25`(或`/usr/java/...`)作为 **JRE home** 。
    6.  并输入`jdk1.8.0_25`作为 **JRE 名称**。

    ### 注意

    我们告诉 Eclipse 使用 JDK 8 的 Java 运行时环境。

    完成这些步骤后，您应该得到以下配置:

    ![How to do it...](img/B04049_01_01.jpg)

5.  现在，我们将检查编译器符合性级别:
    1.  在导航面板中，点击 **Java** 下**编译器**上的。
    2.  检查下拉列表中的**编译器兼容级别**是否设置为 **1.8** 。
6.  在这之后，我们需要检查 Maven 的配置:
    1.  仍然在**偏好设置**菜单的导航面板中，打开 Maven 层级并导航至 **Maven** | **安装**。
    2.  我们将在这里指定我们计划使用哪个 Maven 安装。出于本书的目的，嵌入式 Maven 将是完美的。
    3.  回到导航面板，进入 **Maven** | **用户设置**。
    4.  Set the local repository to `<home-directory>/.m2/repository`.

        ### 注意

        在这个本地存储库中，将驻留我们所需工件的本地缓存版本。这将使我们的环境不必在每次构建时都下载它们。

    5.  对于**用户设置**字段，在`.m2`目录:`<home-directory>/.m2/settings.xml`下创建一个`settings.xml`文件。
    6.  Edit the `settings.xml` file and add the following block:

        (也可以从`chapter_1/source_code/.m2`目录复制/粘贴):

        ```java
        <settings  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd">
          <profiles>
            <profile>
              <id>compiler</id>
                <properties>
                  <JAVA_HOME>C:\java\jdk1.8.0_25</JAVA_HOME>
                </properties>
            </profile>
          </profiles>
          <activeProfiles>
          <activeProfile>compiler</activeProfile>
          </activeProfiles>
        </settings>
        ```

        ### Tip

        如果您是 Windows 机器上的*而不是* ，将该文件中的`JAVA_HOME`更改为您的 JDK 安装目录(`/usr/java/jdk1.8.0_25`)。

    7.  Go back to the navigation panel and click on **Maven**. Follow the configuration given in this screenshot:

        ![How to do it...](img/B04049_01_02.jpg)

    8.  点击 **OK** 保存这些配置更改。
7.  Now we will install Tomcat 8 in the Eclipse IDE. For this, go through these steps:
    1.  从 Tomcat 网站:[http://tomcat.apache.org/download-80.cgi](http://tomcat.apache.org/download-80.cgi)下载 Tomcat8 最新核心版本的 ZIP 存档。
    2.  Extract the downloaded archive to the following directory:
        *   在窗口，解压`C:\tomcat8`处的档案
        *   在 Linux 上，解压`/home/usr/{system.username}/tomcat8`处的归档文件
        *   在 Mac OS X 上，解压位于`/Users/{system.username}/tomcat8`的档案

        ### 注意

        根据您的系统，您必须能够从层次结构:`C:\tomcat8\bin, /home/usr/{system.username}/tomcat8/bin or /Users/{system.username}/tomcat8/bin`访问 bin 目录。

    3.  在 Eclipse 中，选择**窗口**下的**首选项**菜单，在左侧的导航面板中，打开**服务器**层级，然后选择**运行时环境**。
    4.  在中央窗口，点击**添加…** 按钮。
    5.  在下一步中(**新服务器**环境窗口)，导航到**Apache**|**Apache Tomcat v 8.0**。
    6.  另外，选中这个选项:**创建一个新的本地服务器**。
    7.  点击**下一个**按钮。
    8.  在窗口中填写详细信息，如下图所示:

    ![How to do it...](img/B04049_01_03.jpg)

    ### 注意

    如果你在 Linux(或 Mac OS X)上，用你的 Tomcat 安装目录替换`C:\tomcat8`。

## 它是如何工作的...

在这一部分，我们将回顾这个秘籍带给我们的不同元素和概念。

### eclipse . ini 文件

正如我们已经看到的,`eclipse.ini`文件控制 Eclipse 的启动。正是这个额外的组件使得 Eclipse 平台非常易于配置。您可以在他们的文档中找到可以使用的命令行参数列表

[http://help . eclipse . org/luna/topic/org . eclipse . platform . doc . ISV/reference/misc/runtime-options . html](http://help.eclipse.org/luna/topic/org.eclipse.platform.doc.isv/reference/misc/runtime-options.html)

确认本文档中提到的以下警告非常重要:

*   All lines after `-vmargs` are passed as arguments to the JVM; all arguments and options for Eclipse must be specified before `-vmargs` (just like when you use arguments on the command line)

    ### 注意

    这解释了为什么我们在文件的顶部插入了`–vm`选项。

*   在命令行上使用`-vmargs`会替换`.ini`文件中的所有`-vmargs`设置，除非在`.ini`文件或命令行中指定了`--launcher.appendVmargs`

### 设置–VM 选项

设置`-vm`选项允许我们确定 Eclipse 作为程序运行的 JVM 实现。您可能已经注意到，我们将 JVM 定位为一个库(`*.dll / *.so`)。它在启动时具有更好的性能，并且还将程序进程识别为 Eclipse 可执行文件，而不仅仅是 Java 可执行文件。

如果您想知道在没有设置`–vm`选项时 Eclipse 使用哪个 JVM，请注意 Eclipse *不会*查询`JAVA_HOME`环境变量。(Eclipse wiki)。

相反，Eclipse 会执行解析 path 环境变量的 Java 命令。

### 定制 JVM 参数

建议的 JVM 参数列表来自 Piotr Gabryanczyk 关于 Java 内存管理模型的工作。最初，对于 JetBRAINS IntelliJ 设置，这个配置对于 Eclipse 环境也很有用。它有助于以下任务:

*   防止垃圾收集器暂停应用超过 10 毫秒(`-XX:MaxGCPauseMillis=10`)
*   将垃圾收集器的启动级别降低到所占内存的 30%(`-XX:MaxHeapFreeRatio=70`)
*   强制垃圾收集器作为并行线程运行，降低其对应用的干扰(`-XX:+UseConcMarkSweepGC`)
*   为垃圾收集器选择增量调步模式，这将在 GC 作业中生成中断，以便应用可以明确地停止冻结(`–XX:+CMSIncrementalPacing`)

在程序的整个生命周期中，实例化的对象都存储在堆内存中。建议的参数定义了 128 mb 的 JVM 启动堆空间(`-Xms`)和 512 mb 的最大堆空间(`–Xmx`)。堆分为两个子空间，如下所示:

*   **年轻一代**:新的对象存放在这个区域。对于领先的 Hotspot 或 open JDK JVM，年轻的内存空间被一分为二:
    *   `Eden`:新对象存储在该细分区域。生命周期短的对象将从这里被释放。
    *   `Survivor`: This is a buffer between the young and old generation. The survivor space is smaller than the Eden and it is also divided in two (the `FROM` and `TO` areas). You can adjust the ratio between `Eden` and `Survivor` objects with `-XX:SurvivorRatio` (here, `-XX: SurvivorRatio=10` means `YOUNG = 12`, `EDEN = 10`, `FROM = 1` and `TO =1`).

        ### Tip

        可用`-XX:NewSize`调整年轻区域的最小尺寸。最大尺寸可以用`-XX:MaxNewSize`调节。

*   **Old generation**: When objects in `Eden` or `Survivor` spaces are still referenced after enough garbage collections, they are moved here. It is possible to set the `Young` area size as a ratio of the `Old` area size with `-XX:NewRatio`. (That is, `-XX:NewRatio=2` means `HEAP = 3, YOUNG = 1` and `OLD =2`).

    ### Tip

    新一代空间`-XX:MaxNewSize`的最大大小必须始终小于堆空间(`-Xmx/2`)的一半，因为垃圾收集器可能会将所有的`Young`空间移动到`Old`空间。

对于 Hotspot 或 OpenJDK，永久生成空间用于存储与类定义相关的信息(结构、字段、方法等等)。).当加载的结构变得太大时，您可能已经遇到了一个`PermGen space OutOfMemoryError`异常。在这种情况下，解决方案是增加`-XX:MaxPermSize`参数。*有了 JDK8* 就不再需要了。

为此，**永久生成** ( **永久生成**)空间已经被一个元数据空间所取代，这个元数据空间不是堆的一部分，而是本机内存的一部分。此空间的默认最大大小是无限的。不过我们还是可以用`-XX:MetaspaceSize`或者`-XX:MaxMetaspaceSize`来限制。

### 更改 JDK 合规级别

降级一个依从级别允许我们运行一个比 JDK 本地识别的 Java 编译器更低的版本。它影响 Eclipse 构建、错误和警告，也影响 JavaDocs。显然不可能设置比编译器本机版本更高的编译版本。

### 配置 Maven

在 Eclipse 内部，Maven 配置的大部分来自插件`m2eclipse`(也称为 Eclipse 的 Maven 集成)。这个插件默认包含在 Eclipse Luna 中。这样就不需要手动下载了。在我们完成 Maven 配置之后，m2eclipse 对于从 IDE 上下文中触发 Maven 操作以及提供创建 Java Maven 项目的帮助也非常有帮助。在下一节中，您将了解更多关于 m2eclipse 的内容。

然后我们安装了一个基本的`settings.xml`文件。这个文件用于配置 Maven，而不直接绑定到任何项目。`settings.xml`最常见的用途可能是配置文件定义和访问存储库管理器的凭证存储。

有了 Maven 概要文件，您就有可能为特定的环境运行构建，并匹配特定的配置(变量值、依赖集等等)。).Maven 概要文件可以相互累积。它们可以通过命令行激活，可以在 Maven 设置中以声明方式激活，也可以从环境配置中激活，例如文件系统中存在或缺失的文件、使用的 JDK 等等。

### Tip

在我们的`settings.xml`文件中，我们用自己的`JAVA_HOME`属性定义了一个编译器配置文件。默认情况下，编译器配置文件被激活，并在`<activeProfiles>`部分进行声明式定义。Maven 将在查找系统变量之前查阅`settings.xml`文件。

### 仓库管理员

存储库管理器是一个第三方应用，它管理开发的应用可能需要的所有必需的二进制文件和依赖项。作为开发环境和公共存储库之间的缓冲代理，存储库管理器提供对关键参数的控制，如构建时间、依赖项的可用性、可见性和访问限制等。

著名的解决方案有*阿帕奇 Archiva* 、 *Artifactory* 、 *Sonatype Nexus* 。在我们的应用的上下文中，我们不会使用存储库管理器。

### 月蚀里面的 Tomcat 8

面向 JEE 开发者的 Eclipse 允许 Tomcat 与开发环境中的其他应用服务器集成。这是通过提供的 **web 工具平台** ( **WTP** )插件实现的，这些插件可以管理 Web 工件、它们的编译以及它们在 Web 服务器中的部署。

在`servers`选项卡(之前可见)中，双击创建的 Tomcat v8.0 服务器，打开一个配置窗口，并允许设置通常在`server.xml` Tomcat 文件中定义的参数，该文件位于`tomcat8\conf`目录中。

默认情况下，WTP 抽象这个配置，不影响正版`server.xml`文件。这种行为可以通过激活**服务器配置**窗口中的**发布模块上下文来分离 XML 文件**选项来改变。

## 还有更多...

*   在 http://wiki.eclipse.org/Eclipse/Installation 的[找到更多关于 Eclipse 安装的](http://wiki.eclipse.org/Eclipse/Installation)
*   在 http://wiki.eclipse.org/Eclipse.ini[了解更多关于`Eclipse.ini`文件的信息](http://wiki.eclipse.org/Eclipse.ini)
*   在[https://maven.apache.org/plugins/maven-eclipse-plugin/](https://maven.apache.org/plugins/maven-eclipse-plugin/)了解更多关于 m2eclipse 插件的信息
*   要了解如何使用一个存储库管理器，请参考[http://maven.apache.org/repository-management.html](http://maven.apache.org/repository-management.html)
*   关于 ide 垃圾收集优化的 Piotr Gabryanczyk 文章可以在[http://piotrga . WordPress . com/2006/12/12/intellij-and-garbage-collection](http://piotrga.wordpress.com/2006/12/12/intellij-and-garbage-collection)找到
*   你可以在[http://pubs . VMware . com/v fabric 52/topic/com . VMware . v fabric . em4j . 1.2/em4j/conf-heap-management . html](http://pubs.vmware.com/vfabric52/topic/com.vmware.vfabric.em4j.1.2/em4j/conf-heap-management.html)和[https://blog . code centric . de/en/2012/08/useful-JVM-flags-part-5-young-generation-garbage-collection](https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection)了解更多关于内存优化的一般信息

# 使用 Maven 定义项目结构

在这个菜谱中，我们将集中于使用 Maven 定义我们的应用所需的项目结构。

## 准备就绪

我们将首先创建两个 Eclipse 项目:一个用于应用，另一个用于组件，ZipCloud 作为一家公司可以在以后与其他项目共享这些组件。看一下下图，它展示了我们将要构建的项目组件:

![Getting ready](img/B04049_01_04.jpg)

应用项目 **cloudstreetmarket-parent** 将有三个模块。其中两个会打包成 web 档案( **war** ):主 web 应用和 REST API。其中一个将被打包成一个 **jar** 依赖项(cloudstreetmarket-core)。

公司特定项目**zipcloud-母**将只有一个子模块— **zipcloud-core** ，被打包成 **jar** 。

## 怎么做...

以下步骤将帮助我们创建一个 Maven 父项目:

1.  从 Eclipse 中，导航到**文件** | **新** | **其他**。
2.  A **New** wizard opens up wherein you can select the type of project within a hierarchy. Then, open the **Maven** category, select **Maven Project**, and click on **Next**.

    “新建 Maven 项目”向导打开，如下面的屏幕截图所示:

    ![How to do it...](img/B04049_01_05.jpg)

3.  确保选中**创建一个简单项目**选项。点击**下一个**。
4.  Fill up the next wizard as follows:
    *   `edu.zipcloud.cloudstreetmarket` 为**组 Id**
    *   `cloudstreetmarket-parent`为**神器 Id**
    *   `0.0.1-SNAPSHOT`为**版本**
    *   `pom`为**包装**
    *   `CloudStreetMarket Parent`作**名**
    *   然后，点击**完成**按钮

    父项目必须出现在仪表板左侧的包资源管理器中。

    ![How to do it...](img/B04049_01_06.jpg)

    我们现在必须告诉 m2eclipse 您计划在这个项目中使用哪个 Java 编译器版本，以便它自动将正确的 JRE 系统库添加到我们将要创建的子模块中。这是通过`pom.xml`文件完成的。

5.  编辑`pom.xml`文件以指定 Java 编译器版本:
    *   双击 **pom.xml** 文件。默认显示**m2 eclipse****Overview**页签。您必须单击最后一个选项卡 **pom.xml** ，才能访问完整的 xml 定义。
    *   In this definition, add the following block at the end but still as part of the **<project>** node. (*You can also copy/paste this piece of code from the cloudstreetmarket-parent's* `pom.xml` *of the* `chapter_1` *source code):*

        ```java
        <build>
          <plugins>
            <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-compiler-plugin</artifactId>
              <version>3.1</version>
              <configuration>
                  <source>1.8</source>
                  <target>1.8</target>
                  <verbose>true</verbose>
                  <fork>true</fork>
                  <executable>${JAVA_HOME}/bin/javac</executable>
                  <compilerVersion>1.8</compilerVersion>
              </configuration>
            </plugin>
            <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-surefire-plugin</artifactId>
              <version>2.4.2</version>
              <configuration>
                <jvm>${JAVA_HOME}/bin/java</jvm>
                <forkMode>once</forkMode>
               </configuration>
            </plugin>
          </plugins>
        </build>
        ```

        ### 注意

        你可能也注意到了 **maven-surefire-plugin** 声明。我们将很快对其进行审查；它允许我们在构建期间运行单元测试。

6.  Now, we will create submodules:

    作为父项目的子模块，我们已经看到，我们需要一个 web 模块来处理和呈现站点的屏幕，一个 web 模块用于 REST API，另一个模块将用于打包所有业务逻辑(服务、数据访问等等)。)具体到第一个产品`cloudstreetmarket.com`:

    1.  从 Webapp 主模块:在 Eclipse 中，导航到**文件** | **新** | **其他**。一个**新的**向导打开，通过它您可以选择层次结构中的项目类型。打开 **Maven** 类别，选择 **Maven 模块**，点击**下一个**。
    2.  The New Maven Module wizard opens up after this; fill it up as follows:

        选中创建简单项目。

        输入`cloudstreetmarket-webapp`作为**模块名**。

        输入`cloudstreetmarket-parent`作为**父项目**。

        ![How to do it...](img/B04049_01_07.jpg)

    3.  Click on the **Next** button after which the next step shows up. Enter the following entries in that new window:

        输入`edu.zipcloud.cloudstreetmarket`作为**组 Id** 。

        输入`0.0.1-SNAPSHOT`作为**版本**。

        选择**战争**作为**包装**。

        输入`CloudStreetMarket Webapp`作为**名**。

        然后点击**完成**按钮。

7.  Now we will go ahead to create and REST API module:

    我们将使用不同的参数重复前面的操作。

    1.  从 Eclipse 中，导航到**文件|新** | **其他**。去那里的时候弹出选择向导。之后，打开 **Maven** 类别，选择 **Maven 模块**，点击**下一个**:
    2.  In the **New Maven Module** wizard, enter the following entries:

        勾选**创建一个简单项目**选项。

        输入`cloudstreetmarket-api`作为**模块名**。

        输入`cloudstreetmarket-parent`作为**父项目**。

    3.  Click on the **Next** button to proceed to the next step. Enter the following entries in that window:

        输入`edu.zipcloud.cloudstreetmarket`作为**组 Id** 。

        输入`0.0.1-SNAPSHOT`作为**版本**。

        选择**战争**作为**包装**。

        输入`CloudStreetMarket API`作为**名**。

        然后点击完成按钮。

8.  Now, we will create the core module:

    为此，导航到**文件** | **新建** | **其他**。当您这样做时，会弹出选择向导。打开 **Maven** 类别，选择 **Maven 模块**，点击**下一个**。

    1.  In the **New Maven Module** wizard, enter the following entries:

        勾选**创建一个简单项目**选项。

        输入`cloudstreetmarket-core`作为**模块名**。

        输入`cloudstreetmarket-parent`作为**父项目**。

    2.  Click on the **Next** button to go to the next step. Fill in the fields with the following:

        输入`edu.zipcloud.cloudstreetmarket`作为**组 Id** 。

        输入`0.0.1-SNAPSHOT`作为**版本**。

        这次选择**罐**作为**包装**。

        输入`CloudStreetMarket Core`作为**名**。

        然后点击完成按钮。

    如果您激活了 Java 透视图(在右上角),您应该会看到创建的整体结构与这里的截图相匹配:

    ![How to do it...](img/B04049_01_08.jpg)

9.  Now, we will create a company-specific project and its module(s):

    让我们假设许多不同类别的依赖项(核心、消息传递、报告等等)将成为公司-商业项目的一部分。

    1.  我们需要一个父项目，所以从 Eclipse 导航到**文件** | **新** | **其他**。弹出选择向导。打开 Maven 类别，选择 Maven 项目，然后点击 Next。
    2.  在新建 Maven 项目向导的第一步中，对于我们之前创建的父项目，只有勾选了**创建简单项目**和**使用默认工作区位置**选项。
    3.  Click on the **Next** button and fill in the next wizard as follows:

        输入`edu.zipcloud`作为**组 Id** 。

        输入`zipcloud-parent`作为**工件 Id** 。

        输入`0.0.1-SNAPSHOT`作为**版本**。

        选择 **pom** 作为**包装**。

        输入`ZipCloud Factory Business Parent`作为**名**。

    同样，在创建的`pom.xml`文件中，将下面的块添加到`<project>`节点中，以正确创建底层模块并启用自动测试执行。(*你也可以从 chapter_1 源代码*的 zipcloud-parent 的 pom.xml 文件中复制/粘贴这段代码):

    ```java
    <build>
      <plugins>
        <plugin>
        <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>3.1</version>
          <configuration>
            <source>1.8</source>
            <target>1.8</target>
              <verbose>true</verbose>
              <fork>true</fork>
            <executable>${JAVA_HOME}/bin/javac</executable>
          <compilerVersion>1.8</compilerVersion>
          </configuration>
        </plugin>
        <plugin>
        <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-surefire-plugin</artifactId>
            <version>2.4.2</version>
            <configuration>
            <jvm>${JAVA_HOME}/bin/java</jvm>
            <forkMode>once</forkMode>
          </configuration>
        </plugin>
      </plugins>
    </build>
    ```

    现在，我们将创建一个公司-业务核心模块，这将是我们刚刚创建的父项目的子模块。

    为此，导航到**文件** | **新建** | **其他**。弹出选择向导。打开 **Maven** 类别，选择 **Maven 模块**，点击**下一个**。

    1.  In the **New Maven Module** wizard, enter the following details:

        勾选**创建一个简单项目**选项。

        输入`zipcloud-core`作为**模块名**。

        输入`zipcloud-parent`作为**父项目**。

    2.  Click on the **Next** button and go to the next step. Here, enter the following details:

        输入`edu.zipcloud`作为**组 Id** 。

        输入`0.0.1-SNAPSHOT`作为**版本**。

        选择**罐**作为**包装**。

        选择`ZipCloud Factory Core Business`作为**名**。

10.  Now, build the two projects:

    如果结构正确，下面的 Maven 命令可以成功运行:

    ```java
    mvn clean install

    ```

    ### Tip

    如果 Maven 安装在开发机器上，这个命令可以在终端中启动。

    在我们的研究案例中，我们现在将使用 m2eclipse 修改的 **Run As** 菜单启动它:右键单击 zipcloud-parent 项目，然后单击 **Run As** | **Maven Clean** 。

    ### 注意

    在 Maven 控制台中，您现在应该会在底部看到这条漂亮的线:

    [信息]建立成功

    现在，重复安装构建阶段的操作。现在，您应该会在控制台中看到以下输出:

    ```java
    [INFO] ZipCloud Parent .......................SUCCESS [  0.313 s]
    [INFO] ZipCloud Core .........................SUCCESS [  1.100 s]
    [INFO] ----------------------------------------------------------
    [INFO] BUILD SUCCESS
    [INFO] ----------------------------------------------------------

    ```

    好了，现在你应该也能构建`cloudstreetmarket-parent`了。

    为此，右键单击 **cloudstreetmarket -parent** 项目，然后单击 **Run As** | **Maven Clean** 。在这一步之后，Maven 控制台应该打印出以下内容:

    ```java
    [INFO] BUILD SUCCESS

    ```

    同样，右键单击**cloudstreetmarket**-父项目，并单击**运行为** | **Maven 安装**。Maven 控制台现在应该打印出以下内容:

    ```java
    [INFO] CloudStreetMarket Parent ..............SUCCESS [  0.313 s]
    [INFO] CloudStreetMarket Webapp ..............SUCCESS [  6.129 s]
    [INFO] CloudStreetMarket Core ................SUCCESS [  0.922 s]
    [INFO] CloudStreetMarket API .................SUCCESS [  7.163 s]
    [INFO] ----------------------------------------------------------
    [INFO] BUILD SUCCESS
    [INFO] ----------------------------------------------------------

    ```

    向上滚动一点应该会显示以下轨迹:

    ```java
    -------------------------------------------------------
     T E S T S
    -------------------------------------------------------
    There are no tests to run.
    Results :
    Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

    ```

    ### 注意

    Maven 在我们手动添加的 maven-surefire-plugin 的帮助下，解析所有在`src/test/java`目录中遇到的类。同样，该路径可以定制。

    在检测到的测试类中，Maven 还将运行用 JUnit `@Test`注释标注的方法。项目中需要一个 JUnit 依赖项。

## 它是如何工作的...

在本节中，我们将介绍一些关于 Maven 的概念，以便您能够更好地理解它的标准。

### 新的 Maven 项目，新的 Maven 模块

我们刚刚浏览的项目创建屏幕也来自 m2eclipse 插件。这些屏幕用于用预配置的`pom.xml`文件和标准目录结构初始化 Java 项目。

m2eclipse 插件还提供了一组运行 Maven 构建阶段的快捷方式和一些方便的选项卡(已经看到),用于管理项目依赖性和可视化`pom.xml`配置。

### 标准项目层次结构

在创建的项目中导航，您应该能够注意到一个由以下目录组成的递归层次结构:`src/main/java`、`src/main/resource`、`src/test/java`和`src/test/resource`。这个结构是 Maven 驱动我们通过的默认结构。这款车型如今已经成为标配。但是，我们仍然可以覆盖它(在`pom.xml`文件中)并创建我们自己的层次结构。

如果您还记得添加到父项目的`pom.xml`文件中的 **maven-compiler-plugin** 定义，我们使用了以下四行代码:

```java
<verbose>true</verbose>
<fork>true</fork>
<executable>${JAVA_HOME}/bin/javac</executable>
<compilerVersion>1.8</compilerVersion>
```

这些行允许 Maven 为编译器使用外部 JDK。最好能够控制 Maven 使用哪个编译器，尤其是在管理不同的环境时。

此外，以下两行看起来可能像过度配置:

```java
<source>1.8</source>
<target>1.8</target>
```

从严格的 Maven 角度来看，当用指定的编译器版本定义外部 JDK 时，这些行是可选的。最初，通过这两行代码，我们可以控制希望默认代码在哪个 Java 版本中编译。当维护较旧的系统时，现有的代码仍然可以在以前版本的 Java 中编译。

实际上，m2eclipse 特别期待这两行代码，以便将`JRE System Library [JavaSE-1.8]`添加到`jar`和`war`模块的构建路径中。现在，有了这些代码行，Eclipse 以与 Maven 相同的方式编译这些项目:在 Java SE 8 中。

### Tip

如果这种依赖仍然以不同版本的 Java 出现，你可能需要右击模块，然后导航到 **Maven** | **更新项目**。

### IDE 中的项目结构

关于 Eclipse 项目层次结构中的父项目；您是否注意到创建的子模块似乎作为独立项目和父模块的直接子模块被复制了？这是因为 Eclipse 在 Luna 中还不能处理项目的层次结构。因此，这些模块显示为独立的项目。这可能有点令人困惑，因为源代码似乎位于父项目旁边。实际情况并非如此，这只是它们的呈现方式，因此我们可以将所有工具正常绑定到项目级别。

### 注意

目前，JetBRAINS IntelliJ IDEA 已经支持项目的可视化层次结构。

最后，如果您打开一个父项目的`pom.xml`文件，您应该看到用创建的子模块填充的`<modules>`节点。这也是由 m2eclipse 自动完成的。我们建议您关注这个特性，因为 m2eclipse 并不总是根据您改变项目层次的方式来更新这些`<modules>`节点。

### Maven 的构建生命周期

Maven 中的构建生命周期是一个特定的序列(和一组)预定义的操作，称为阶段。Maven 中有三个现有的生命周期:默认、清理和站点。

让我们来看看所有的阶段，包括默认的和干净的生命周期(可能是开发人员最常用的生命周期)。

#### 清洁的生命周期

美芬**清洁**阶段起着核心作用。它从 Maven 的角度重置项目构建。通常是删除 Maven 在构建过程中创建的目标目录。下面是关于**清洁**生命周期中各个阶段的一些细节。这些细节来自 Maven 文档:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

阶段

 | 

描述

 |
| --- | --- |
| `pre-clean` | 此执行实际项目清理之前所需的流程 |
| `clean` | 这个删除了之前构建生成的所有文件 |
| `post-clean` | 此执行完成项目清理所需的过程 |

#### 默认生命周期

在默认的生命周期中，您可以找到最有趣的构建阶段，处理源代码生成、编译、资源处理、测试、集成测试和产品部署。以下是默认生命周期中包含的一些阶段的详细信息:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

阶段

 | 

描述

 |
| --- | --- |
| `validate` | 此验证项目是否正确以及所有必要信息是否可用。 |
| `initialize` | 这个初始化构建状态，例如，设置属性或创建目录。 |
| `generate-sources` | 这个生成源代码用于编译。 |
| `process-sources` | 这个处理源代码，例如，过滤任何值。 |
| `generate-resources` | 这个生成包含在包中的资源。 |
| `process-resources` | 这个将资源复制并处理到目标目录中，准备打包。 |
| `compile` | 这个编译项目的源代码。 |
| `process-classes` | 这个 post 处理编译生成的文件，例如，在 Java 类上执行字节码增强。 |
| `generate-test-sources` | 这个生成任何要包含在编译中的测试源代码。 |
| `process-test-sources` | 这个处理测试源代码，例如，过滤任何值。 |
| `generate-test-resources` | 这个为测试创建资源。 |
| `process-test-resources` | 这个将资源复制并处理到测试目标目录中。 |
| `test-compile` | 这个将测试源代码编译到测试目标目录中。 |
| `process-test-classes` | 这篇文章处理测试编译生成的文件，例如，在 Java 类上执行字节码增强。对于 Maven 2.0.5 及以上版本。 |
| `test` | 这个使用合适的单元测试框架运行测试。这些测试不需要打包或部署代码。 |
| `prepare-package` | 此在实际包装前执行准备包装所需的操作。这通常会导致包的解包、处理版本。(Maven 2.1 及以上) |
| `package` | 这个获取编译后的代码，并将其打包成可分发的格式，比如 JAR。 |
| `pre-integration-test` | 此在执行集成测试之前执行所需的动作。这可能涉及到诸如设置所需环境之类的事情。 |
| `integration-test` | 这个处理并在必要时将包部署到可以运行集成测试的环境中。 |
| `post-integration-test` | 这个执行集成测试执行后所需的动作。这可能包括清理环境。 |
| `verify` | 该运行检查以验证包是有效的并且满足质量标准。 |
| `install` | 这个将包安装到本地存储库中，作为本地其他项目的依赖项。 |
| `deploy` | 这个将最终的包复制到远程存储库中，以便与其他开发人员和项目共享(在集成或发布环境中完成)。 |

#### 插件目标

有了插件的概念，Maven 获得了更广阔的空间。Maven 原生提供内置插件，但外部插件可以像其他依赖项一样引入(由 groupIds 和 artefactIds 标识)。

每个构建阶段可以附加零个、一个或多个插件目标。目标代表了以某种方式负责构建或处理项目的具体任务。默认情况下，一些阶段通过本地插件绑定了目标。

#### 内置生命周期绑定

既然我们已经看到了所展示的两个生命周期中每个阶段的目的，我们必须说，对于默认的生命周期，根据我们所选择的模块封装类型，只有这些阶段中的一些可能被激活用于目标执行。

让我们看看我们在不同包装类型的默认生命周期中跳过的阶段:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
|  | 

默认生命周期

 |
| --- | --- |
| 

包装类型

 | 

jar/war/ejb/ejb3/rar

 | 

耳朵

 | 

maven 插件

 | 

砰的一声

 |
| --- | --- | --- | --- | --- |
| 激活阶段 |  | 生成资源 | 生成资源 |  |
| 流程-资源 | 流程-资源 | 流程-资源 |  |
| 编制 |  | 编制 |  |
| 流程-测试-资源 |  | 流程-测试-资源 |  |
| 测试编译 |  | 测试编译 |  |
| 试验 |  | 试验 |  |
| 包裹 | 包裹 | 包裹 | 包裹 |
| 安装 | 安装 | 安装 | 安装 |
| 部署 | 部署 | 部署 | 部署 |

### Tip

在[第 9 章](9.html "Chapter 9\. Testing and Troubleshooting")、*测试和故障排除*中，我们将把外部插件目标实际绑定到已确定的构建阶段。

总之，在 jar 打包模块上调用:mvn clean install 将导致执行以下阶段:清理、处理资源、编译、处理测试资源、测试编译、测试、打包和安装。

#### 关于 Maven 命令

当 Maven 被告知执行一个或多个针对特定项目的`pom.xml`文件的阶段时，它将为其每个模块执行所请求的阶段。

然后，对于每个请求的阶段，Maven 将执行以下操作:

*   确定阶段属于哪个生命周期
*   寻找当前模块的包装，并确定正确的生命周期绑定
*   执行已标识生命周期绑定层次结构中的所有阶段，这些阶段位于层次结构中所请求的阶段之前

### 注意

术语“执行所有阶段”指的是执行所有潜在的检测到的和附加的插件目标(无论是否是本机插件)。

综上所述，在`jar`封装模块上调用`mvn clean install`将执行的以下阶段:`clean`、`process-resources`、`compile`、`process-test-resources`、`test-compile`、`test`、`package`、`install`。

## 还有更多...

您可能想知道为什么我们在应用中创建了这些项目和模块。

### 我们如何选择 jar 模块的名称？

关于 Maven 结构，不可部署模块的最佳名称通常强调一个功能目的，一个由业务创建的特定概念，或者由产品驱动(cloudstreetmarket-chat、cloudstreetmarket-reporting、cloudstreetmarket-user-management，等等)。).这种策略使得依赖管理更加容易，因为我们可以推断一个新模块是否需要另一个模块。在这个阶段，从宏观的角度考虑控制器、服务和 DAO 层并没有什么意义，这可能会导致设计干扰或循环依赖。根据需要，这些技术子组件(服务、DAO 等)将作为 Java 包而不是 JAR 打包的依赖项出现在每个功能模块中。

### 我们如何选择可部署模块的名称？

为可部署模块(`war`)选择一个名称与为 JAR 打包模块选择一个名称略有不同。可部署的归档必须被认为是可伸缩的，并且可能是负载平衡的。假设以应用为目标的检索 HTML 内容的请求可以与返回 REST 内容的请求区分开来是合理的。

基于这个假设，在我们的例子中，我们希望将`war`一分为二。这样做可能会产生这样的问题:如何在两个 webapps 之间维护 *web 会话*。我们稍后将回答这一点。

### 我们为什么要创建核心模块？

首先，我们创建了核心模块，因为可以肯定的是，在`cloudstreetmarket`应用和公司共享的项目中，我们将拥有 POJOs、异常、常量、枚举和一些服务，这些服务将被几乎所有的模块或应用横向使用。如果一个概念特定于一个已创建的功能模块，那么它一定不是核心模块的一部分。

然后，可能更好的是*开始大粒度的*到*稍后再细化*，而不是考虑可能被不同地实现或者甚至根本没有被实现的模块。在我们的情况下，我们是一个初创公司，说我们要实现的 5 到 10 个功能可以构成这个应用的核心业务并不傻。

## 参见...

*   我们还建议您安装**代码风格格式化器**。从**保存事件**触发，有了这些格式化程序，我们有能力用统一的预定义自动地重新设计我们的代码。在一个团队中有这样的格式化器是非常受欢迎的，因为它保证了在用版本控制工具比较两个文件时的相同呈现。

# 安装 Spring、Spring MVC 和一个 web 结构

在这个菜谱中，我们将使用继承向我们的`pom.xml`文件添加第三方依赖项。我们将加载`Spring application contexts`并创建我们应用的第一个控制器。最后，我们将在 Tomcat 中部署并启动 web 应用。

## 准备就绪

既然我们已经准备好了 Eclipse 并正确配置了 Maven，那么有趣的事情就可以开始了。我们需要在我们的`pom.xml`文件中指定所有必要的 Spring 依赖项，并且我们需要设置 Spring 以便它为每个模块加载和检索它的上下文。

我们还需要组织并有选择地公开 web 资源，比如 JSP、JavaScript 文件、CSS 文件等等。如果您已经完成了这个配置，我们应该会看到一个由 Tomcat 服务器提供的静态欢迎页面，启动时没有异常！

## 怎么做...

我们的第一组变更与父项目相关:

1.  我们将为这些父项目定义依赖项和构建选项。让我们按照以下步骤来做:
    1.  Open the cloudstreetmarket-parent `pom.xml` from the `chapter_1` source code directory and select the **pom.xml** tab (underneath the main window).

        将`<properties>`、`<dependencyManagement>`和`<build>`块复制并粘贴到 cloudstreetmarket-parent 的 **pom.xml** 文件中。

        现在，对 zipcloud-parent 重复操作。

    2.  从 **chapter_1** 源代码中打开 zipcloud-parent 的`pom.xml`文件，点击 **pom.xml** 选项卡。
    3.  复制并粘贴到你的 zipcloud-parent 的 **pom.xml** 中的`<properties>`和`<dependencyManagement>`块。你应该已经复制了第三个秘籍*中的`<build>`部分。*
2.  现在，我们将为 web 模块定义依赖关系和构建选项:
    1.  从 **chapter_1** 源代码中打开 cloudstreetmarket-api 的`pom.xml`，选择 **pom.xml** 标签页。
    2.  将`<build>`和`<dependencies>`块复制并粘贴到你的 cloudstreetmarket-api 的`pom.xml`中。
    3.  现在，对 cloustreetmarket-webapp 重复该操作。
    4.  从 **chapter_1** 源代码目录中打开 cloudstreetmarket-webapp 的`pom.xml`，点击 **pom.xml** 选项卡。
    5.  将`<build>`和`<dependencies>`块复制并粘贴到你的 cloudstreetmarket-webapp 的 **pom.xml** 文件中。
3.  之后，我们定义 jar 模块的依赖关系:
    1.  从 **chapter_1** 源代码中打开 cloudstreetmarket-core 的`pom.xml`，点击 **pom.xml** 标签。
    2.  将整个`<dependencies>`块复制并粘贴到你的 cloudstreetmarket-core 的 **pom.xml** 中。
4.  Then, we place the web resources:
    1.  From the **chapter_1** source code, copy and paste the entire **src/main/webapp/*** directory into your **cloudstreetmarket-webapp** project. You need to end up with the same **webapp** directory structure as the **chapter_1** source code:

        ![How to do it...](img/B04049_01_09.jpg)

    2.  现在，对 **cloudstreetmarket-api** 执行相同的操作。从 **chapter_1** source 中复制并粘贴整个 **src/main/webapp/*** 分支到你的 **cloudstreetmarket-api** 项目中。您需要以与 **chapter_1** 源代码相同的 webapp 节点和子节点结束:

    ![How to do it...](img/B04049_01_10.jpg)

5.  Now, we target a runtime for the web modules:
    1.  在 Eclipse 中，右键单击 **cloudmarket-api** 项目。
    2.  选择**属性**菜单。
    3.  在导航面板上，选择**目标运行时间**。
    4.  在中央窗口中，选中**服务器 Apache Tomcat v8.0** 选项。
    5.  点击 **OK** ，在 **cloudstreetmarket-webapp** 上重复第五个操作。

    ### 注意

    在此之后，index.jsp 文件中的一些月食警告肯定消失了。

    如果项目中仍然有警告，您的 Eclipse Maven 配置可能与本地存储库不同步。

6.  This step should clean your existing project warnings (if any):

    在这种情况下，请执行以下步骤:

    1.  Select all the projects in the project hierarchy, except the servers, as follows:

        ![How to do it...](img/B04049_01_11.jpg)

    2.  右击选择中的某处，点击 **Maven** 下的**更新项目**。此阶段的**警告**窗口应该消失！
7.  Let's deploy the `wars` and start Tomcat:

    在 Eclipse 中添加**服务器**视图。为此，请执行以下操作:

    1.  导航到**窗口** | **显示视图** | **其他**。
    2.  打开**服务器**目录，选择服务器。您应该会看到仪表板上创建了以下选项卡:

    ![How to do it...](img/B04049_01_12.jpg)

8.  要部署 web 档案，请执行以下操作:
    1.  在我们刚刚创建的视图中，右键单击本地主机服务器上的 **Tomcat v8.0 服务器，并选择**添加和删除…** 。**
    2.  在下一步，即**添加和删除**窗口，选择两个可用的档案并点击**添加**，然后点击**完成**。
9.  要在 Tomcat 中启动应用，我们需要完成以下步骤:
    1.  在的**服务器**视图中，右键点击本地主机服务器上的 **Tomcat v8.0 服务器，点击**开始**。**
    2.  在**控制台的**视图中，您应该看到下面的内容:

        ```java
        INFO: Starting ProtocolHandler ["http-nio-8080"]
        Oct 20, 2014 11:43:44 AM org.apache.coyote.AbstractProtocol start
        INFO: Starting ProtocolHandler ["ajp-nio-8009"]
        Oct 20, 2014 11:43:44 AM org.apache.catalina.startup.Cata.. start
        INFO: Server startup in 6898 ms

        ```

### 注意

如果您向上滚动这些日志，您应该不会有任何例外！

最后，如果您尝试使用浏览器访问`http://localhost:8080/portal/index.html`，您应该会收到以下 HTML 内容:

![How to do it...](img/B04049_01_13.jpg)

### 注意

对 HTML 页面的静态访问仍然是本章的一个适度的视觉成就。纵观这本书，你会发现我们并没有降低环境的重要性，以及 Spring MVC 在其中发挥作用的上下文。

## 它是如何工作的...

通过这个方法，我们已经在网络资源和与 Spring、Spring MVC 和网络环境相关的 Maven 依赖项之间移动。现在，我们将介绍 Maven 依赖性和插件管理的执行方式。然后我们将讨论 Spring web 应用上下文，最后讨论 web 资源的组织和打包。

### 继承 Maven 的依赖关系

关于父项目和子模块之间依赖关系的继承有两种策略。它们都是从父项目实现的。一方面，我们可以选择直接从`<dependencies>`节点定义这些依赖，以这种方式塑造一个基本的继承。另一方面，要设置托管继承，我们可以将`<dependencies>`节点定义为`<dependencyManagement>`的子节点。我们来看看两者的区别。

#### 基本继承

有了基本继承，父模块的`pom.xml`文件中指定的所有依赖项都会自动继承到具有相同属性(范围、版本、打包类型等等)的子模块中，除非您覆盖它们(用相同的对`groupId` / `artifactId`重新定义这些依赖项)。

一方面，它提供了在我们想要的模块中使用我们想要的依赖版本的选项。另一方面，我们可能会在子模块中得到一个非常复杂的依赖关系模式和巨大的`pom.xml`文件。此外，管理与外部可传递依赖关系的版本冲突可能是一件痛苦的事情。

### Tip

可传递依赖是具有所需依赖的必需依赖。从 Maven 2.0 开始，传递依赖项已经被自动导入。

此继承类型中没有外部依赖的标准。

#### 托管继承

使用`< dependencyManagement>`机制，在父模块`pom.xml`中定义的依赖关系不会在子模块中自动继承。但是，依赖关系属性(范围、版本、打包类型等)是从父依赖关系的定义中提取的，因此，这些属性的重新定义是可选的。

这个过程驱使我们走向一个集中的依赖关系定义，其中所有的子模块使用相同版本的依赖关系，除非特定的依赖关系需要一个定制的依赖关系。

### 包括第三方依赖

在复制过来的依赖项中，您可能已经注意到一些 Spring 模块、一些测试、web、日志和实用程序依赖项。

这个想法是从一个基本的 web 开发工具箱开始，它通过所有的 Spring 模块得到了增强。当我们面临特殊情况时，我们将访问实际包含的大多数依赖项。

#### Spring 框架依赖模型

正如从 [spring.io](http://spring.io) 网站上截取的下图中的所示，目前，spring 框架由 20 个模块组成，这些模块被分组到不同的区域:

![The Spring Framework dependency model](img/B04049_01_14.jpg)

这些模块已经作为托管依赖项包含在父 POM 中。这将允许我们稍后快速挑选出需要的，缩小我们`wars`的选择范围。

#### Spring MVC 依赖

Spring MVC 模块自包含在`spring-webmvc` jar 中。web 应用中的 Spring MVC 是一个基本元素，因为它处理传入的客户端请求，并平稳地监控来自控制器的业务操作。最后，它提供了许多工具和接口，能够以客户期望的格式准备响应。

所有这些工作流都伴随着 spring-webmvc jar 输出 HTML 内容或 web 服务。

Spring MVC 完全集成在 Spring 框架中，并且它的所有组件都是 Spring 架构选择的标准。

#### 使用 Maven 属性

在每个父`pom.xml`文件中，我们定义了一个`<properties>`块作为`<project>`部分的一部分。这些属性是绑定到项目的用户定义的属性，但是我们也可以在 **Maven Profile** 选项中定义这样的属性。像变量一样，属性在 POM 中被引用，它们的名字用 **${…}** 括起来。

关于使用句点作为单词分隔符来定义属性名称，有一个标准。不仅仅是一个标准，它还是访问用户定义的变量和构成 Maven 模型的对象的属性的统一符号。Maven 模型是 Maven 的公共接口，从项目层面开始。

POM **XML 模式定义** ( **xsd** )就是从这个 Maven 模型中生成的。这听起来很抽象，但最终，Maven 模型只是一组带有 getters 和 setter 的 POJOs。从下面的 URL 看一下 Maven 模型的 JavaDoc，以识别 pom.xml 文件特有的概念(构建、依赖、插件等等)。):

[http://maven . Apache . org/ref/3 . 0 . 3/maven-model/API docs/index . html](http://maven.apache.org/ref/3.0.3/maven-model/apidocs/index.html)

总的来说，我们可以检索 POM 中定义的节点值，并使用以 getters 为目标的基于句点的表达式语言来导航 Maven 模型层次结构。

例如，`${project.name}`引用当前的`project.getName()`、`${project.parent.groupId}`、当前的`project.getParent().getGroupId()`等等。

定义匹配 Maven 模型现有路径的用户属性是覆盖其值的一种方式。这就是我们为`project.build.sourceEncoding`所做的。

Maven 还提供了到达在`settings.xml`文件中定义的属性的可能性，比如`${settings.localRepository}`；而且还有环境变量如`${env.JAVA_HOME}`；以及 Java 系统属性，如`${java.class.path}`、`${java.version}`、`${user.home}`或`${user.name}`。

### 网络资源

如果你还记得，我们从`chapter_1`源代码中复制/粘贴了整个`src/main/webapp`目录。`webapp`目录名是一个 Maven 标准。Eclipse 中的`webapp`文件夹不需要被标记为构建路径的源文件夹，因为这会为静态文件创建一个复杂而无用的包层次结构。优选地，它以普通目录树的形式出现。

必须将`webapp`目录视为应用的文档根，并定位于 WAR 的根级别。`webapp`下的公共静态 web 资源，如 HTML 文件、Javascript、CSS、图片文件，可以放在我们选择的子目录和结构中。然而，正如在 *Servlet 3.0 规范*中所描述的那样，`WEB-INF`目录是应用层次结构中的一个特殊目录。它的所有内容永远不能从应用外部访问；它的内容可以从在`ServletContext`上调用`getResource`或`getResourceAsStream`的 servlet 代码中访问。规范还告诉我们,`WEB-INF`目录的内容由以下内容组成:

*   `/WEB-INF/web.xml`部署描述符。
*   servlet 和实用程序类的目录。该目录中的类必须对应用类加载器可用。
*   Java 归档文件的`/WEB-INF/lib/*.jar`区域。这些文件包含打包在 JAR 文件中的 servlets、beans、静态资源和 JSP，以及对 web 应用有用的其他实用程序类。web 应用类加载器必须能够从这些归档文件中加载类。

在`WEB-INF`文件夹中创建一个`jsp`目录是一个很好的实践，这样`jsp`文件在没有通过明确定义的控制器的情况下就不能被直接定位。

JSP 应用确实存在，根据定义，它们不会遵循这种做法。这些类型的应用可能适合某些需求，但是它们也没有特别促进 MVC 模式的使用，也没有很好地分离关注点。

要在 web 应用中使用 JSP，必须在`web.xml`中启用该特性，并将`org.apache.jasper.servlet.JspServlet`类型的 servlet 定义映射到 JSP 文件位置。

#### 目标运行时环境

我们在`index.jsp`文件中遇到了警告。我们通过在项目中添加一个目标运行时来解决这些问题。我们还看到 Tomcat 以 JAR 库的形式附带了 Eclipse 编译器 Java 版。为了执行 JSP 编译，`tomcat8\lib`目录必须包含以下 JAR 库:`jsp-api`、`servlet-api`和`el-api`，等等。在 Eclipse 中为项目指定目标运行时模拟并预测了应用将从外部 Tomcat 容器(用这些库设置)运行的情况。这也解释了为什么`jsp-api`和`el-api`依赖关系是用*提供的*范围在父 POM 中定义的。

#### Spring web 应用上下文

在`web.xml`文件中，我们定义了一种特殊类型的 Servlet，Spring MVC `DispatcherServlet`，我们将其命名为`spring`。这个 servlet 涵盖了最广泛的`/*` URL 模式。我们将在下一章重温`DispatcherServlet`。

一个`DispatcherServlet`有自己的发现算法来构建`WebApplicationContext`。提供了一个可选的`contextConfigLocation`初始化参数，指向一个`dispatcher-context.xml`文件。该参数覆盖在`DispatcherServlet`发现逻辑中定义的`WebApplicationContext`的默认预期文件名和路径(`/WEB-INF/{servletName}-servlet.xml`)。

当`load-on-startup`属性设置为`1`时，一旦 servlet 容器准备就绪，一个新的`WebApplicationContext`就会被加载，并且只为启动的 servlet 确定范围。现在，*我们不再等待第一个客户端请求来加载 WebApplicationContext* 。

Spring `WebApplicationContext`文件通常定义或覆盖 Spring MVC 提供给 web 应用的配置和 bean。

仍然在`web.xml`文件中，设置了一个`org.sfw.web.context.ContextLoaderListener`监听器。这个侦听器的目的是启动和关闭另一个 Spring `ApplicationContext`，它将是容器生命周期中的根 Spring。

要轻松加载多个 spring 上下文文件，这里的技巧是在资源路径中使用类路径符号(相对的)和星号(`*`)字符:

```java
<context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>classpath*:/META-INF/spring/*-config.xml</param-value>
</context-param>
```

这样做允许我们*加载在类路径中遇到的所有匹配标准符号和位置*的上下文文件。这种方法因其强加的一致性而受到赞赏，也因其以底层 jar 中的上下文文件为目标的方式而受到赞赏。

所有匹配的上下文文件的集合创建了一个范围更广的`ApplicationContext`根，`WebApplicationContext`继承了它。我们在根上下文中定义的 beans 对`WebApplicationContext`上下文变得可见。如果需要，我们可以覆盖它们。然而，`DispatcherServlet`上下文的 beans 对于根上下文是不可见的。

#### 插件

Maven 首先是一个插件的执行框架。Maven 运行的每个任务都对应一个插件。一个插件有一个或多个分别与生命周期阶段相关联的目标。像依赖项一样，插件也由一个`groupId`、`artifactId`和一个版本来标识。当 Maven 遇到一个不在本地存储库中的插件时，它会下载它。此外，默认情况下，特定版本的 Maven 的目标是许多与生命周期阶段相匹配的插件。这些插件在固定版本上是冻结的，因此在一个定义的行为上是冻结的——你需要覆盖它们的定义来获得一个更新的版本或者改变它们的默认行为。

##### Maven 编译器插件

maven 编译器插件是一个 Maven 核心插件。核心插件如此命名是因为它们的目标是在 Maven 核心阶段(清理、编译、测试等等)触发的。).非核心插件与打包、报告、实用程序等相关。重新定义 maven-compiler-plugin 来控制使用哪个版本的编译器或者触发一些外部工具的动作(实际上是 m2eclipse 项目管理工具)是一个很好的实践。

顾名思义，maven 编译器插件编译 Java 源代码。为此，它使用了`javax.tools.JavaCompiler`类并有两个目标:`compiler:compile`(作为编译阶段的一部分被触发来编译`java/main`源类)和`compiler:testCompile`(作为测试-编译阶段的一部分被触发来编译`java/test`源类)。

##### Maven surefire 插件

maven-surefire-plugin 也是一个只有一个目标的 maven 核心插件:`surefire:test`。这作为默认生命周期(测试阶段)的一部分被调用，以运行应用中定义的单元测试。默认情况下，它在`${basedir}/target/surefire-reports`位置下生成报告`(*.txt`或`*.xml`。

##### Maven enforcer 插件

maven-enforcer-plugin 对于将环境条件定义为项目的*关键*非常有用。它有两个目标:`enforcer:enforce`(默认情况下，绑定到验证阶段，每个模块执行一次每个定义的规则)和`enforcer:display-info`(显示规则执行的检测信息)。

最有趣的标准规则可能是`DependencyConvergence`:它为我们分析了所有使用过的依赖关系(直接的和可传递的)。在版本出现分歧的情况下，它会突出显示并停止构建。当我们面临这种冲突时，在以下两者之间做出选择是非常容易的:

*   从类路径中排除最低版本
*   不升级依赖关系

我们也很快谈到了与 maven-enforcer-plugin 相关的`<pluginManagement>`部分。在这种情况下，这是因为 m2eclipse 不支持这个插件。因此，为了避免在 Eclipse 中出现警告，有必要添加这个部分，以便 m2eclipse 跳过 enforce 目标。

##### Maven 战争插件

使用 maven-war-plugin，我们重新定义了我们的 web POMs。我们再次覆盖了这个用来打包 web 模块的插件的默认行为。如果您有一个非 Maven 标准的项目结构，这肯定是必要的。

我们可能希望以一种不同的方式打包我们的网络资源，而不是像在我们的 IDE 中那样组织。出于某种原因，我们可能需要从 war 打包中排除一些资源，或者我们甚至希望为构建的 war 命名，以便它可以被与应用 URL`(/api`、`/app`等中的特定上下文路径匹配的 servlet 容器使用。这个插件的目的是过滤，移动网络资源，管理生成的 war。

### Tip

默认情况下，web 资源被复制到 WAR 根目录。要覆盖默认目标目录，请指定目标路径`*`。

## 还有更多...

这是对自然需要更深兴趣的概念的一个相当广泛的概述:

*   About the way Maven manages its dependencies, we would suggest you to go through the Maven documentation on this topic at:

    [http://maven . Apache . org/guides/introduction/introduction-to-dependency-mechanism . html](http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html)

*   Sonatype 电子书很好地讲述了 Maven 属性。您可以在以下位置找到本电子书:[https://books . sonatype . com/mvnref-book/reference/resource-filtering-Sect-properties . html # resource-filtering-Sect-settings-properties](https://books.sonatype.com/mvnref-book/reference/resource-filtering-sect-properties.html#resource-filtering-sect-settings-properties)
*   The Maven model API documentation can again be found at:

    [http://maven . Apache . org/ref/3 . 0 . 3/maven-model/API docs/index . html](http://maven.apache.org/ref/3.0.3/maven-model/apidocs/index.html)

*   关于我们之前提到的 servlet 3.0 规范，可以在[http://download . Oracle . com/OTN-pub/JCP/servlet-3.0-fr-eval-oth-JSpec/servlet-3 _ 0-final-spec . pdf](http://download.oracle.com/otn-pub/jcp/servlet-3.0-fr-eval-oth-JSpec/servlet-3_0-final-spec.pdf)找到关于`web.xml`文件定义和关于 WebArchive 结构的更多信息
*   最后，关于 Maven 插件的更多信息；我们强烈建议您参观 http://maven.apache.org/plugins 的 Maven 列表

## 参见

*   Pivotal 的 [spring.io](http://spring.io) 网站，尤其是 spring 框架概述页面，也可以刷新，或者介绍一些关键概念。关注地址:[http://docs . spring . io/spring-framework/docs/current/spring-framework-reference/html/overview . html](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/overview.html)

### Maven checkstyle 插件

另一个有趣的插件是 maven-checkstyle-plugin。当团队成长时，我们有时需要保证维护某些开发实践，或者我们可能需要维护特定的安全相关的编码实践。像 maven-enforcer-plugin 一样，maven-checkstyle-plugin 使我们的构建对这种类型的违反更加自信。

再次在 Maven 文档中找到关于这个插件的更多信息:[http://maven.apache.org/plugins/maven-checkstyle-plugin](http://maven.apache.org/plugins/maven-checkstyle-plugin)。