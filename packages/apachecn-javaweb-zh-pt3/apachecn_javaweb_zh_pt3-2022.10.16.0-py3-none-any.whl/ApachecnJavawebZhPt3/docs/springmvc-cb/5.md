# 五、将 Spring MVC 用于认证

本章包括以下秘籍:

*   配置 Apache HTTP 来代理您的 Tomcat
*   调整用户和角色以适应 Spring 安全性
*   基于基本方案的认证
*   在 REST 环境中存储凭证
*   使用第三方 OAuth2 方案进行身份验证
*   在服务和控制器上授权

# 简介

在开发`CloudStreetMarket`应用的这一章中，我们将介绍在 Spring 环境中进行身份验证的两种方式。

我们认为，仅仅提供安全注释来限制控制器和服务不足以提供 Spring 认证的全貌。显然，如果没有一些关键概念，比如`Authentication`对象的角色、Spring 安全过滤链、`SecurityInterceptor`工作流等等，就不可能对 Spring MVC 使用的安全工具有信心。由于配置 OAuth 是必要的，我们还将向您展示如何在您的机器上设置一个 Apache HTTP 代理和一个主机别名，以便在本地模拟`cloudstreetmarket.com`域。

# 配置 Apache HTTP 来代理您的 Tomcat

我们将使用本地别名`cloudstreetmarket.com`(在端口`80`上)而不是以前的`localhost:8080`来访问应用。在开发第三方集成时，实现配置有时是一个强制性的步骤。在我们的例子中，第三方将是雅虎！和它的 OAuth2 认证服务器。

## 准备就绪

主要是配置的问题。我们将安装一个 Apache HTTP 服务器，并坚持使用 Apache Tomcat How-To。这将促使我们更新我们的 Tomcat 连接器，并在 Apache 配置文件中创建一个虚拟主机。

您将发现这种配置如何能够提供极大的灵活性，并通过一种先进的可扩展架构为客户提供简单的 web 内容。

## 怎么做...

1.  On MS Windows, download and install Apache HTTP Server.
    *   最简单的方法可能是直接从官方发行商那里下载二进制文件。从以下网址之一选择并下载适当的最新 Zip 存档文件:
    *   创建一个目录`C:\apache24`并将下载的档案文件解压到这个位置。

    [http://www.apachelounge.com/download](http://www.apachelounge.com/download)

    [http://www.apachehaus.com/cgi-bin/download.plx](http://www.apachehaus.com/cgi-bin/download.plx)

    ### 注意

    你应该可以通过这个表单到达 bin 目录:`C:\apache24\bin`。

2.  在 Linux / Mac OS 上，下载并安装 Apache HTTP Server。
    1.  Download the latest sources (compressed in a `tar.gz` archive) from the apache website:

        [http://httpd.apache.org/download.cgi#apache24](http://httpd.apache.org/download.cgi#apache24)

    2.  From the downloaded archive, extract the sources:

        ```java
        $ tar –xvzf httpd-NN.tar.gz
        $ cd httpd-NN

        ```

        ### 注意

        `NN`命令是 Apache HTTP 的当前版本。

    3.  自动配置树状结构:

        ```java
        $ ./configure

        ```

    4.  编译包:

        ```java
        $ make

        ```

    5.  安装树状结构:

        ```java
        $ make install

        ```

3.  在 MS Windows 上，在 hosts 文件中添加一个新别名。
    1.  Edit with Notepad the file that can be found at the following path:

        ```java
        %SystemRoot%\system32\drivers\etc\hosts
        ```

        ### 注意

        这个文件没有扩展名，当你想保存文件时，记事本不会报错。

    2.  在文件末尾添加以下条目:

        ```java
        127.0.0.1 cloudstreetmarket.com
        ```

    3.  保存修改。
4.  在 Linux/Mac OS 上，在 hosts 文件中添加一个新的别名。
    1.  编辑可在以下路径找到的文件:`/etc/hosts`
    2.  在文件末尾添加以下条目:

        ```java
        127.0.0.1 cloudstreetmarket.com
        ```

    3.  保存修改。
5.  For all Operation Systems, edit the `httpd.conf` Apache configuration file.
    1.  这个文件可以在`C:\apache24\conf`(在 Windows 上)或`/usr/local/apache2/conf`(在 Linux 或 Mac 上)找到。
    2.  取消以下两行的注释:

        ```java
        LoadModule proxy_module modules/mod_proxy.so
        LoadModule proxy_http_module modules/mod_proxy_http.so

        ```

    3.  在文件的最底部添加以下块:

        ```java
        <VirtualHost cloudstreetmarket.com:80>
          ProxyPass        /portal http://localhost:8080/portal
          ProxyPassReverse /portal http://localhost:8080/portal
          ProxyPass        /api  http://localhost:8080/api
          ProxyPassReverse /api  http://localhost:8080/api
          RedirectMatch ^/$ /portal/index
        </VirtualHost>
        ```

    ### 注意

    在`chapter_5/source_code/app/apache`目录中可以找到一个修改过的`httpd.conf`文件的示例(适用于 Apache HTTP 2.4.18)。

6.  Edit the `server.xml` Tomcat configuration file.
    1.  这个文件可以在`C:\tomcat8\conf`(在 Windows 上)或`/home/usr/{system.username}/tomcat8/conf`(在 Linux 或 Mac 上)找到。
    2.  找到`<Connector port"="8080"" protocol"="HTTP/1.1""... >`定义，编辑如下:

        ```java
            <Connector port"="8080"" protocol"="HTTP/1.1""
            connectionTimeout"="20000" redirectPort"="8443"" 
            proxyName"="cloudstreetmarket.com"" proxyPort"="80""/>
        ```

    ### 注意

    在`chapter_5/source_code/app/tomcat`目录中可以找到一个修改过的`server.xml`文件的示例(适用于 Apache Tomcat 8.0.30)。

7.  在 MS Windows 上，启动 Apache HTTP 服务器。
    1.  打开命令提示符窗口。
        *   输入以下命令:

            ```java
            $ cd C:/apache24/bin
            ```

    2.  安装 Apache 服务:

        ```java
        $ httpd.exe –k install

        ```

        *   启动服务器:

            ```java
            $ httpd.exe –k start
            ```

8.  On Linux/Mac OS, start the Apache HTTP server:
    *   启动服务器:

        ```java
        $ sudo apachectl start
        ```

    现在启动 Tomcat 服务器并打开您最喜欢的 web 浏览器。转到`http://cloudstreetmarket.com`，您将获得以下登录页面:

    ![How to do it...](img/B4049_05_01.jpg)

## 它是如何工作的...

我们在这里制作的 Apache HTTP 配置在某种程度上是当今的标准。它在网络上提供无限级别的定制。它还允许我们启动可伸缩性。

### DNS 配置或主机别名

让我们重温一下网络浏览器是如何工作的。当我们在 web 浏览器中定位一个 URL 时，从它的 IP 访问最终的服务器，在一个特定的端口上建立一个 TCP 连接。浏览器需要为指定的名称解析此 IP。

为此，它查询一连串的域名服务器(在互联网上，这个链条往往从用户的**互联网** **服务提供商** ( **ISP** )开始)。每个 DNS 基本上都是这样工作的:

*   它试图自己解析 IP，在数据库或缓存中查找
*   如果不成功，它会询问另一个 DNS 并等待响应，以缓存结果并将其发送回调用者

管理一个特定域的 DNS 被称为**授权开始** ( **SOA** )。此类 DNS 通常由注册服务商提供，我们通常使用他们的服务来配置域区域的记录(以及我们的服务器 IP)。

围绕 web，每个 DNS 都试图解析最终的 SOA。DNS 服务器的顶层被称为**根名称** **服务器**。其中有数百个绑定到一个特定的**顶级域名** ( **TLD** 如。com、`.net`、`.org` …)。

当浏览器获得 IP 时，它会尝试在指定的端口(默认为 80)上建立 TCP 连接。远程服务器接受连接，并通过网络发送 HTTP 请求。

### 生产中——编辑 DNS 记录

一旦我们进入生产阶段，我们就需要通过域名提供商在线为 DNS 记录配置真实域名。有不同类型的记录可以编辑。每一个都服务于特定的目的或资源类型:主机、规范名称、邮件交换器、名称服务器等等。具体指导通常可以在域名提供商网站上找到。

### 主机的别名

在联系任何类型的 DNS 之前，操作系统可能能够自己解析 IP。为此，主机文件是一个纯文本文件`registry`。向该注册表添加别名定义了任何最终服务器的代理。这样做是开发环境的一种常见技术，但并不局限于此。

每行代表一个 IP 地址，后跟一个或多个主机名。每个字段由空格或制表符分隔。可以在一行的最开始用一个`#`字符指定注释。空行被忽略，IP 可以在 *IPv4* 或 *IPv6* 中定义。

此文件仅用于主机别名，我们在此阶段不处理端口！

#### OAuth 开发的别名定义

在这一章中，我们将使用 OAuth2 协议进行认证。在 OAuth 中，有一个**认证** **服务器(AS)** 和一个**服务提供者** ( **SP** )。在我们的例子中，认证服务器将是第三方系统(Yahoo！)和服务提供商将是我们的应用(`cloudstreetmarket.com`)。

OAuth2 身份验证和授权发生在第三方。一旦完成这些步骤，身份验证服务器就使用作为参数传递或作为变量存储的回调 URL 将 HTTP 请求重定向到服务提供者。

第三方有时会屏蔽指向`localhost:8080`的回调 URL。在本地测试和开发 OAuth2 对话仍然是必要的。

为主机名(在 hosts 文件中)和 HTTP 服务器中的虚拟主机配置一个代理来管理端口、URL 重写和重定向，对于本地环境和生产基础设施来说都是一个很好的解决方案。

### Apache HTTP 配置

Apache HTTP 服务器使用 TCP/IP 协议，并提供 HTTP 的实现。TCP/IP 允许计算机通过网络相互通信。

网络(局域网或广域网)上使用 TCP/IP 的每台计算机都有一个 IP 地址。当请求到达一个接口(例如以太网连接)时，会尝试使用目标端口号将其映射到机器上的服务(DNS、SMTP、HTTP 等)。Apache 通常使用 80 端口监听。这是 Apache HTTP 负责一个站点的情况。

#### 虚拟主机

这个特性允许我们从一个 Apache 实例中运行和维护多个网站。我们通常将一个专用站点的 Apache 指令集合在一个`<VirtualHost...>` 部分中。每个组由一个**站点 ID** 标识。

不同的站点可以定义如下:

1.  按名称:

    ```java
    NameVirtualHost 192.168.0.1
    <VirtualHost portal.cloudstreetmarket.com>…</VirtualHost>
    <VirtualHost api.cloudstreetmarket.com>…</VirtualHost>
    ```

2.  通过 IP(您仍然需要在块中定义一个`ServerName`):

    ```java
    <VirtualHost 192.168.0.1>…</VirtualHost>
    <VirtualHost 192.168.0.2>…</VirtualHost>
    ```

3.  按港口:

    ```java
    Listen 80
    Listen 8080
    <VirtualHost 192.168.0.1:80>…</VirtualHost>
    <VirtualHost 192.168.0.2:8080>…</VirtualHost>
    ```

我们当前一台机器和一台 Tomcat 服务器的配置并不是展示虚拟主机所有好处的理想场景。但是，我们已经用其配置划分了一个站点。这是实现可伸缩性和负载平衡的第一步。

#### mod _ proxy 模块

这个 Apache 模块为 Apache HTTP 服务器提供代理/网关功能。这是一个核心特性，因为它可以将 Apache 实例转变成一个独特的接口，能够管理一组复杂的应用，这些应用在网络上的多台机器之间保持平衡。

它让 Apache 超越了最初的目的:通过 HTTP 在文件系统上公开一个目录。具体取决于五个子模块:`mod_proxy_http`、`mod_proxy_ftp`、`mod_proxy_ajp`、`mod_proxy_balancer`、`mod_proxy_connect`。当需要时，它们中的每一个都需要主`mod_proxy`依赖。代理可以定义为正向(`ProxyPass`)和/或反向(`ProxyPassReverse`)。它们通常用于为防火墙后的服务器提供互联网接入。

可以用 `ProxyPassMatch`替换`ProxyPass` ，以提供正则表达式匹配功能。

#### proxy pass 反向

反向代理处理响应和重定向，就像它们自己是网络服务器一样。为了被激活，它们通常被绑定到一个`ProxyPass`定义，如我们这里的用例:

```java
ProxyPass         /api  http://localhost:8080/api
ProxyPassReverse  /api  http://localhost:8080/api
```

##### 工人

代理管理底层服务器的配置，以及它们之间的通信参数，对象称为**工作器**(将它们视为一组参数)。当用于反向代理时，这些工作器使用`ProxyPass`或`ProxyPassMatch`进行配置:

```java
ProxyPass /api http://localhost:8080/api connectiontimeout=5 timeout=30
```

worker-parameters 的一些示例有:`connectiontimeout`(以秒为单位)、`keepalive`(开/关)、`loadfactor`(从 1 到 100)、`route`(在负载平衡器内部使用时绑定到`sessionid`)、`ping`(它向 ajp13 连接发送 CPING 请求以确保 Tomcat 不忙)、`min/max`(到底层服务器的连接池条目数)、`ttl`(到底层服务器的连接的到期时间)。

#### mod _ alias 模块

这个模块提供 URL 别名和客户端请求重定向。我们已经使用这个模块将对`cloudstreetmarket.com`的请求重定向(默认)到门户网站应用的索引页面(`cloudstreetmarket.com/portal/index`)。

注意，同样地，`ProxyPassMatch`提高了`ProxyPass`，`RedirectMatch`提高了`Redirect`的正则表达式匹配能力。

### Tomcat 连接器

一个**连接器** 代表一个进程单元:监听特定端口接收请求，将这些请求转发给特定引擎，接收引擎生成的动态内容，最后将生成的内容发送回端口。几个连接器可以在一个`Service`组件中定义，共享一个*引擎*。可以为一个 Tomcat 实例(`Server`)定义一个或多个*服务*。Tomcat 中有两种类型的连接器。

#### HTTP 连接器

这个连接器在 Tomcat 的 8080 端口上默认设置为。它支持 HTTP1/1 协议，并允许 Catalina 作为独立的 web 服务器工作。HTTP 连接器可以在代理后面使用。Tomcat 支持`mod_proxy`作为负载平衡器。这是我们的预期配置。当在代理后面实现时，可以设置属性`proxyName`和`proxyPort`，以便 servlets 将指定的值绑定到请求属性 `request.getServerPort()`和`request.getServerName()`。

“这种连接器具有最低的延迟和最佳的整体性能。”

Tomcat 文档还陈述了以下关于 HTTP 代理的内容:

*“需要注意的是，HTTP 代理的性能通常低于 AJP 的性能。”*

但是，配置 AJP 集群会在体系结构上增加一层。对于无状态架构来说，这种额外层的必要性是有争议的。

#### AJP 连接器

AJP 连接器的行为类似于 HTTP 连接器，只是它们支持 AJP 协议而不是 HTTP。 **Apache JServ 协议** ( **AJP** )是 HTTP 连接器的优化二进制版本。

它允许 Apache HTTP 在不同的 Tomcats 之间有效地平衡请求。它还允许 Apache HTTP 服务于 web 应用的静态内容，而 Tomcat 专注于动态内容。

在 Apache HTTP 端，这个连接器需要`mod_proxy_ajp`。我们的配置可能是:

```java
ProxyPass / ajp://localhost:8009/api
ProxyPassReverse / http://cloudstreetmarket.com/api/
```

## 还有更多…

在本节中，我们将提供一些链接，以便更深入地了解这些主题:

*   DNS and the distributed system:

    [http://computer.howstuffworks.com/dns.htm](http://computer.howstuffworks.com/dns.htm)

    [https://en.wikipedia.org/wiki/Root_name_server](https://en.wikipedia.org/wiki/Root_name_server)

*   How the domain name system works:

    [http://wiki.bravenet.com/How_the_domain_name_system_works](http://wiki.bravenet.com/How_the_domain_name_system_works)

*   Apache HTTP:

    [http://httpd.apache.org/docs/trunk/getting-started.html](http://httpd.apache.org/docs/trunk/getting-started.html)

*   The modules we have used:

    [http://httpd.apache.org/docs/2.2/mod/mod_alias.html](http://httpd.apache.org/docs/2.2/mod/mod_alias.html)

    [http://httpd.apache.org/docs/2.2/en/mod/mod_proxy.html](http://httpd.apache.org/docs/2.2/en/mod/mod_proxy.html)

*   Tomcat connectors:

    [http://tomcat.apache.org/tomcat-8.0-doc/connectors.html](http://tomcat.apache.org/tomcat-8.0-doc/connectors.html)

    [http://wiki.apache.org/tomcat/FAQ/Connectors](http://wiki.apache.org/tomcat/FAQ/Connectors)

    [https://www.mulesoft.com/tcat/tomcat-connectors](https://www.mulesoft.com/tcat/tomcat-connectors)

*   In proxy mode:

    [http://Tomcat . Apache . org/Tomcat-8.0-doc/Proxy-how to . html # Apache _ 2.0 _ Proxy _ Support](http://tomcat.apache.org/tomcat-8.0-doc/proxy-howto.html#Apache_2.0_Proxy_Support)

## 参见

*   When using an AJP connector, the ProxyPassReverse definition is slightly different from an HTTP connector:

    [http://www.apachetutor.org/admin/reverseproxies](http://www.apachetutor.org/admin/reverseproxies)

    [http://www.humboldt.co.uk/the-mystery-of-proxypassreverse](http://www.humboldt.co.uk/the-mystery-of-proxypassreverse)

*   If you wish to implement an AJP Cluster, go through the following URL:

    [http://www . richardnichols . net/2010/08/5 分钟-指南-聚类-apache-tomcat/](http://www.richardnichols.net/2010/08/5-minute-guide-clustering-apache-tomcat/)

### Apache HTTP 的替代方案

Apache HTTP 的使用在非常高的流量上是有争议的，特别是因为默认配置会导致程序为每个连接创建一个新的进程。

如果我们只寻找一个代理和负载均衡器，我们也应该考虑 HAProxy。HAProxy 是一个高可用性负载平衡器和代理服务器。它是一个免费的开源(GPL v2)产品，在 GitHub、StackOverflow、Reddit、Twitter 和其他网站([http://haproxy.org](http://haproxy.org))中使用。

Nginx 可能(也是目前)是 Apache HTTP 最常用的替代方案。专注于高并发性和低内存使用，它的许可是一个 2 条款 BSD 许可([http://nginx.org](http://nginx.org))。

# 使用户和角色适应 Spring Security

我们认为将这一部分分开很有意思，因为用户和角色通常是应用和 Spring 安全之间的分界线。

## 准备就绪

在这个菜谱中，我们将安装 Spring 安全依赖项并更新`User`实体。我们还将创建一个基于我们创建的自定义`Role`枚举的`Authority`实体。最后，我们更新`init.sql`脚本来添加一组现有用户。

## 怎么做...

1.  From the **Git Perspective** in Eclipse, checkout the latest version of the branch `v5.x.x`. Then, run a `maven clean install` command on the `cloudstreetmarket-parent` module (right-click on the module, go to **Run as…** | **Maven Clean**, and then navigate to **Run as…** | **Maven Install**). Execute a `Maven Update Project` to synchronize Eclipse with the maven configuration (right-click on the module and then navigate to **Maven** | **Update Project…)**.

    ### 注意

    您将注意到代码前端和后端的一些变化。

2.  Spring Security 附带了以下依赖项，添加在`cloudstreetmarket-parent`、`cloudstreetmarket-core`和`cloudstreetmarket-api` ::

    ```java
    <!-- Spring Security -->
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-web</artifactId>
      <version>4.0.0.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-config</artifactId>
      <version>4.0.0.RELEASE</version>
    </dependency>
    ```

    中
3.  The `User` entity has been updated. It now reflects the `users` table (instead of the previous `user` table). It also implements the `UserDetails` interface:

    ```java
    @Entity
    @Table(name="users")
    public class User implements UserDetails{
    private static final long serialVersionUID = 1990856213905768044L;

    @Id
    @Column(name = "user_name", nullable = false)
    private String username;

    @Column(name = "full_name")
    private String fullName;

    private String email;
    private String password;
    private boolean enabled = true;
    private String profileImg;

    @Column(name="not_expired")
    private boolean accountNonExpired;

    @Column(name="not_locked")
    private boolean accountNonLocked;

    @Enumerated(EnumType.STRING)
    private SupportedCurrency currency;

    @OneToMany(mappedBy= "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @OrderBy("id desc")
    private Set<Action> actions = new LinkedHashSet<Action>();

    @OneToMany(mappedBy="user", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    private Set<Authority> authorities = new LinkedHashSet<Authority>();

    @OneToMany(cascade=CascadeType.ALL, fetch = FetchType.LAZY)
    private Set<SocialUser> socialUsers = new LinkedHashSet<SocialUser>();

    //getters and setters as per the UserDetails interface
    ...
    }
    ```

    这个`User`实体与`SocialUser`有关系。`SocialUser`在 OAuth2 认证中发挥作用，我们将在后面开发这一部分。

4.  已经创建了一个权限实体，并且映射了一个`authorities`表。这个实体还实现了`GrantedAuthority`接口。该类如下:

    ```java
    @Entity
    @Table(name"="authorities"", uniqueConstraints={@UniqueConstraint(columnNames = "{"username""","authority""})})
    public class Authority implements GrantedAuthority{
      private static final long serialVersionUID = 1990856213905768044L;
      public Authority() {}
      public Authority(User user, Role authority) {
        this.user = user;
        this.authority = authority;
      }
      @Id
      @GeneratedValue
      private Long  id;
      @OneToOne(fetch = FetchType.LAZY)
      @JoinColumn(name = ""username"", nullable=false)
      private User user;
      @Column(nullable = false)
      @Enumerated(EnumType.STRING)
      private Role authority;
      //getters and setters as per the GrantedAuthority 
      //interface
      ...
    }
    ```

5.  为了提高代码的可读性，我们在`cloudstreetmarket-core` 模块中为不同的角色

    ```java
    public enum Role {
      ROLE_ANONYMOUS,
      ROLE_BASIC,
      ROLE_OAUTH2,
      ROLE_ADMIN,
      ROLE_SYSTEM,
      IS_AUTHENTICATED_REMEMBERED; //Transitory role
    }
    ```

    创建了一个`Role`枚举
6.  此外，我们对`init.sql`文件做了一些修改。已对与用户相关的现有预初始化脚本进行了调整，以适应新模式:

    ```java
    insert into users(username, fullname, email, password, profileImg, enabled, not_expired, not_locked) values ('userC', '', 'fake12@fake.com', '123456', '', true, true, true);
    insert into authorities(username, authority) values ('userC', 'ROLE_'BASIC');
    ```

7.  启动应用。(不应观察到任何异常)。
8.  Click on the **login** button (on the right-hand side of the main menu). You will see the following popup that allows entering a username and a password to log in:

    ![How to do it...](img/B4049_05_02.jpg)

9.  You also have the option to create a new user. In the previous popup, click on the **Create new account** link that can be found at the bottom right. This will load the following pop-up content:

    ![How to do it...](img/B4049_05_03.jpg)

10.  Let's create a new user with the following values:

    ```java
    username: <marcus>
    email: <marcus@chapter5.com>
    password: <123456>
    preferred currency: <USD>
    ```

    ### 注意

    对于配置文件图片，您必须在您的文件系统上创建与`cloudstreetmarket-api/src/main/resources/application.properties`中的属性`pictures.user.path`对应的目录结构。

    然后，点击用户图标，上传个人资料图片。

    ![How to do it...](img/B4049_05_04.jpg)

    最后，点击**注册**按钮，弹出窗口应该会消失。

11.  Now, call the following URI: `http://cloudstreetmarket.com/api/users/marcus`. The application should fetch the following persisted data for the Marcus user:

    ![How to do it...](img/B4049_05_05.jpg)

## 它是如何工作的...

这个阶段的秘籍预先配置了我们的实体，因此它们符合 Spring 安全性。这一部分提到了一些关于 Spring 安全性的概念，并在接下来的章节中进一步阐述。

### Spring Security 简介

Spring Security 是围绕三个核心组件构建的:`SecurityContextHolder`对象、`SecurityContext`对象和`Authentication`对象。

`SecurityContextHolder`对象允许我们为一个 JVM 定义和携带一个`SecurityContextHolderStrategy`实现(主要是存储和检索一个`SecurityContext`)。

### 注意

`SecurityContextHolder`有以下`static`字段:

```java
private static SecurityContextHolderStrategy strategy;
```

默认情况下，在大多数设计中，所选策略使用`Threadlocals` ( `ThreadLocalSecurityContextHolderStrategy`)。

### 线程本地上下文容器

一个 Tomcat 实例管理一个 Spring MVC servlet(像任何其他 servlet 一样),当多个 HTTP 请求进来时，它有多个线程。代码如下:

```java
final class ThreadLocalSecurityContextHolderStrategy implements
    SecurityContextHolderStrategy {
  private static final ThreadLocal<SecurityContext> contextHolder = new ThreadLocal<SecurityContext>();
  ...
}
```

在 Spring MVC 上，分配给一个请求的每个线程都可以访问为一个用户(或其他可识别的事物)携带一个`Authentication`对象的`SecurityContext`的副本。

一旦`SecurityContext`的副本不再被引用，它就会被垃圾回收。

### 引人注目的 Spring 安全接口

Spring Security 中有一堆引人注目的接口。我们将特别参观`Authentication`、`UserDetails`、`UserDetailsManager`和`GrantedAuthority`。

### 认证界面

Spring 的`Authentication` 对象可以从`SecurityContext`中检索出来。这个对象通常由 Spring Security 管理，但是应用仍然经常需要访问它来处理业务。

以下是`Authentication` 对象的接口:

```java
public interface Authentication extends Principal, Serializable {
  Collection<? extends GrantedAuthority> getAuthorities();
  Object getCredentials();
  Object getDetails();
  Object getPrincipal();
  boolean isAuthenticated();
  void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
}
```

它提供了对`Principal`(代表已识别的用户、实体、公司或客户)、其凭证、其权限以及一些可能需要的额外细节的访问。现在让我们看看如何从`SecurityContextHolder`中检索用户:

```java
Object principal = SecurityContextHolder.getContext()
  .getAuthentication()
  .getPrincipal();
if (principal instanceof UserDetails) {
    String username = ((UserDetails) principal).getUsername();
} else {
  String username = principal.toString();
}
```

`Principal` 类可以铸入 Spring `UserDetails`类型，由核心框架公开。该接口在几个扩展模块中用作标准桥( *Spring Social* 、 *Connect* 、 *Spring Security SAML* 、 *Spring Security LDAP* 等等)。).

### 用户详细信息界面

`UserDetails` 实现以可扩展和特定于应用的方式表示主体。

你必须知道的单方法`UserDetailsService`接口，该接口为核心框架内的账户检索提供了关键方法 `loadUserByUsername`:

```java
public interface UserDetailsService {
  UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

Spring Security 为这个接口提供了两种实现:`CachingUserDetailsService`和`JdbcDaoImpl`，不管我们是想从内存中的`UserDetailsService`还是基于 JDBC 的`UserDetailsService` 实现中受益。更全面地说，通常重要的是用户和角色在哪里以及如何被持久化，这样 Spring Security 就可以自己访问这些数据并处理认证。

#### 认证提供者

Spring Security 访问用户和角色数据的方式是通过选择或引用具有安全名称空间的 Spring Security 配置文件中的身份验证提供者来配置的。

下面是使用本机`UserDetailsService` 实现时的两个配置示例:

```java
<security:authentication-manager alias="authenticationManager">
  <security:authentication-provider>
    <security:jdbc-user-service data-source-ref="dataSource" />
  </security:authentication-provider>
</security:authentication-manager>
```

第一个例子指定了一个基于 JDBC 的`UserDetailsService`。下一个例子指定了一个内存中的`UserDetailsService.`

```java
<security:authentication-manager alias="authenticationManager">
  <security:authentication-provider>
    <security:user-service id="inMemoryUserDetailService"/>
  </security:authentication-provider>
</security:authentication-manager>
```

在我们的例子中，我们已经注册了我们自己的`UserDetailsService`实现(`communityServiceImpl)`,如下所示:

```java
<security:authentication-manager alias="authenticationManager">
  <security:authentication-provider user-service-ref='communityServiceImpl'>
    <security:password-encoder ref="passwordEncoder"/>
  </security:authentication-provider>
</security:authentication-manager>
```

我们认为通过 JPA 抽象继续访问数据库层更合适。

##### user details manager 界面

Spring 安全提供了一个`UserDetails` 实现`org.sfw.security.core.userdetails.User`，可以直接使用，也可以扩展使用。用户类别定义如下:

```java
public class User implements UserDetails, CredentialsContainer {
  private String password;
  private final String username;
  private final Set<GrantedAuthority> authorities;
  private final boolean accountNonExpired;
  private final boolean accountNonLocked;
  private final boolean credentialsNonExpired;
  private final boolean enabled;
  ...
}
```

### 注意

管理用户(创建、更新等)可以是 Spring Security 的共同责任。不过，它通常主要由应用来执行。

Spring Security 还为管理用户提供了一个`UserDetailsManager`接口，引导我们走向`UserDetails`的结构:

```java
public interface UserDetailsManager extends UserDetailsService {
  void createUser(UserDetails user);
  void updateUser(UserDetails user);
  void deleteUser(String username);
  void changePassword(String oldPassword, String newPassword);
  boolean userExists(String username);
}
```

Spring Security 有两个本机实现，分别用于非持久性(`InMemoryUserDetailsManager`)和基于 JDBC(`JdbcUserDetailsManager`)的用户管理。

当决定不使用内置的身份验证提供者时，实现给出的接口是一个很好的实践，特别是对于保证 Spring Security 未来版本的向后兼容性的。

#### 授予权限界面

在 Spring 安全性中，`GrantedAuthorities`反映了授予`Principal`的应用范围的权限。Spring Security 引导我们走向基于角色的认证。这种身份验证强制创建能够执行操作的用户组。

### 注意

除非某个功能有很强的商业意义，否则最好选择`ROLE_ADMIN`或`ROLE_GUEST`而不是`ROLE_DASHBOARD`或`ROLE_PAYMENT` …

角色可以从`getAuthorities()`的`Authentication`对象中提取出来，作为`GrantedAuthority`实现的数组。

`GrantedAuthority`界面非常简单:

```java
public interface GrantedAuthority extends Serializable {
  String getAuthority();
}
```

`GrantedAuthority`实现是包装器，携带角色的文本表示。这些文本表示可能与安全对象的配置属性相匹配(我们将在服务和控制器的*授权中详述这个概念)。*

嵌入在从`getAuthority()` getter 访问的`GrantedAuthority`中的`Role`对于 Spring 安全性来说比包装器本身更重要。

我们已经创建了自己的实现:与`User`有关联的实体`Authority`。该框架还提供了`SimpleGrantedAuthority`的实现。

在最后一个菜谱中，我们将讨论 Spring 安全授权过程。我们将看到 Spring Security 提供了一个`AccessDecisionManager`接口和几个`AccessDecisionManager`实现。这些实现都是基于投票并使用和`AccessDecisionVoter`实现的。这些实现中最常用的是`RoleVoter`类。

### 注意

当配置属性(权威的文本表示)以预定义的前缀开始时，`RoleVoter` 实现投票赞成用户授权。默认情况下，该前缀设置为`ROLE_`。

## 还有更多…

Spring 安全认证和授权过程将在服务和控制器上的授权方法中深入讨论。本节将介绍 Spring Security 参考文档中的更多细节。

### 春季安全参考

Spring SecuritySecurity reference 是理论和实践信息的惊人来源。

#### 技术概述

技术概述是对 Spring 安全框架的一个很好的介绍:

[http://docs . spring . io/spring-security/site/docs/3.0 . x/reference/technical-overview . html](http://docs.spring.io/spring-security/site/docs/3.0.x/reference/technical-overview.html)

#### 示例应用

Spring Security 参考提供了许多关于不同认证类型的 Spring Security 示例( *LDAP* 、 *OPENID* 、 *JAAS* 等等)。).其他基于角色的示例也可以在以下位置找到:

[http://docs . spring . io/spring-security/site/docs/3 . 1 . 5 . release/reference/sample-apps . html](http://docs.spring.io/spring-security/site/docs/3.1.5.RELEASE/reference/sample-apps.html)

#### 核心服务

如需了解更多关于内置`UserDetailsService`实现(内存或 JDBC)的信息，请访问:

[http://docs . spring . io/spring-security/site/docs/3 . 1 . 5 . release/reference/core-services . html](http://docs.spring.io/spring-security/site/docs/3.1.5.RELEASE/reference/core-services.html)

# 基于基本方案的认证

对于像我们这样的无状态应用来说，通过基本方案进行身份验证是一种流行的解决方案。凭据随 HTTP 请求一起发送。

## 准备就绪

在这个菜谱中，我们完成了 Spring 安全配置。我们让它支持应用所需的基本身份验证方案。

我们稍微定制了生成的响应头，因此它们不会触发浏览器显示本机基本身份验证表单(这对我们的用户来说不是最佳体验)。

## 怎么做...

1.  为了使用 Spring 安全名称空间，我们将下面的过滤器添加到`cloudstreetmarket-api web.xml` :

    ```java
    <filter>
      <filter-name>springSecurityFilterChain</filter-name>
      <filter-class> org.sfw.web.filter.DelegatingFilterProxy
      </filter-	class>
    </filter>
    <filter-mapping>
      <filter-name>springSecurityFilterChain</filter-name>
      <url-pattern>/*</url-pattern>
    </filter-mapping>
    ```

2.  在`cloudstreetmarket-api`模块中专门为 Spring 安全性创建了一个 Spring 配置文件。该文件包含以下 bean 定义:

    ```java
    <bean id="authenticationEntryPoint" class="edu.zc.csm.api.authentication.CustomBasicAuthenticationEntryPoint">
      <property name="realmName" value="cloudstreetmarket.com" />
    </bean> 
    <security:http create-session="stateless" authentication-manager-ref="authenticationManager" entry-point-ref="authenticationEntryPoint">
        <security:custom-filter ref="basicAuthenticationFilter" after="BASIC_AUTH_FILTER" />
       <security:csrf disabled="true"/>
    </security:http>

    <bean id="basicAuthenticationFilter" class="org.sfw.security.web.authentication.www.BasicAuthenticationFilter">
      <constructor-arg name="authenticationManager" ref="authenticationManager" />
      <constructor-arg name="authenticationEntryPoint" ref="authenticationEntryPoint" />
    </bean>
    <security:authentication-manager alias="authenticationManager">
        <security:authentication-provider user-service-ref='communityServiceImpl'>
          <security:password-encoder ref="passwordEncoder"/>
      </security:authentication-provider>
    </security:authentication-manager>

    <security:global-method-security secured-annotations="enabled" pre-post-annotations="enabled" authentication-manager-ref="authenticationManager"/>
    ```

3.  这个新的配置指的是`CustomBasicAuthenticationEntryPoint`级。本课有以下内容:

    ```java
    public class CustomBasicAuthenticationEntryPoint extends BasicAuthenticationEntryPoint {
      @Override
      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setHeader("WWW-Authenticate", "CSM_Basic realm=\ + getRealmName() + \");
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage()
        );
      }
    }
    ```

4.  A new `@ExceptionHandler` has been added to catch authentication Exceptions:

    ```java
    @ExceptionHandler({BadCredentialsException.class, AuthenticationException.class, AccessDeniedException.class})
    protected ResponseEntity<Object> handleBadCredentials(final RuntimeException ex, final WebRequest request) {
      return handleExceptionInternal(ex, "The attempted  operation has been denied!", new HttpHeaders(),   FORBIDDEN, request);
    }
    ...
    ```

    ### 注意

    差不多就是这样！我们已经使我们的后端支持一个基本的认证。然而，我们还没有限制我们的服务(作为安全对象)。我们现在就去做。

5.  出于示例目的，请务必更新`cloudstreetmarket-core`中的 `IMarketService` 界面。给`Type`添加`@Secured("ROLE_BASIC")`注释如下:

    ```java
    @Secured ("ROLE_BASIC")
    public interface IMarketService {
      Page<IndexOverviewDTO> getLastDayIndicesOverview( MarketCode market, Pageable pageable);
      Page<IndexOverviewDTO> getLastDayIndicesOverview( Pageable pageable);
      HistoProductDTO getHistoIndex(String code, MarketCode market, Date fromDate, Date toDate, QuotesInterval interval);
    }
    ```

6.  现在重新启动 Tomcat 服务器(这样做将会删除您之前创建的用户)。
7.  In your favorite web browser, open the developer-tab and observe the AJAX queries when you refresh the home page. You should notice that two AJAX queries have returned a `403` status code (`FORBIDDEN`).

    ![How to do it...](img/B4049_05_06.jpg)

    这些查询也返回了 JSON 响应:

    ```java
    {"error":"Access is denied","message":"The attempted operation has been denied!","status":403","date":"2015-05-05 18:01:14.917"}
    ```

8.  现在，使用登录功能/弹出窗口，使用之前创建的具有`BASIC`角色的用户之一登录:

    ```java
    Username: <userC> 
    Password: <123456>
    ```

9.  Refresh the page and observe the same two AJAX queries. Amongst the request headers, you can see that our frontend has sent a special **Authorization** header:

    ![How to do it...](img/B4049_05_07.jpg)

10.  这个授权头携带值:`Basic dXNlckM6MTIzNDU2`。编码后的`dXNlckM6MTIzNDU2`是`userC:123456`的 base64 编码值。
11.  Let's have a look at the response to these queries:

    ![How to do it...](img/B4049_05_08.jpg)

    现在状态是`200 (OK)`，您应该也收到了正确的 JSON 结果:

    ![How to do it...](img/B4049_05_09.jpg)

12.  服务器在对值:**CSM _ Basic realm " = " cloudstreetmarket . com "**的响应中发回了一个`WWW-Authenticate`头
13.  最后，务必恢复您在`IMarketService`(第 5 步)中所做的更改。

## 它是如何工作的...

我们将探索 Spring Security 基本认证背后的概念:

### Spring 安全命名空间

和往常一样， Spring 配置名称空间带来了特定的语法，适合模块的需求和用途。它减轻了整个 Spring 配置，可读性更好。名称空间通常带有默认配置或自动配置工具。

spring 安全名称空间附带了 spring-security-config 依赖项，可以在 Spring 配置文件中定义如下:

```java
<beans  xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation"="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-4.0.0.xsd">
    ...
</beans>
```

名称空间包含三个顶级组件:`<http>`(关于 web 和 HTTP 安全性)、`<authentication-manager>,`和`<global-method-security>`(服务或控制器限制)。

然后，其他概念被那些顶级组件作为属性或子元素引用:`<authentication-provider>`、`<access-decision-manager>`(为 web 和安全方法提供访问决策)，以及`<user-service>`(作为`UserDetailsService`实现)。

#### <http>组件

名称空间的`<http>`组件提供了一个我们在这里没有使用的`auto-config`属性。`<http auto-config"="true">`定义可能是以下定义的快捷方式:

```java
  <http>
    <form-login />
    <http-basic />
    <logout />
  </http>
```

这对我们的 REST API 来说是不值得的，因为我们没有计划为表单登录实现服务器端生成的视图。此外，`<logout>`组件对我们来说也没有用，因为我们的 API 不管理会话。

最后，`<http-basic>`元素为配置创建底层的`BasicAuthenticationFilter`和`BasicAuthenticationEntryPoint`。

我们使用了自己的`BasicAuthenticationFilter`来定制`WWW-Authenticate`响应的头值，从`Basic base64token`到`CSM_Basic base64token`。这是因为 AJAX HTTP 响应(来自我们的 API)包含一个带有以 **Basic** 关键字开始的值的`WWW-Authenticate`头，自动触发 web 浏览器打开一个本地基本表单弹出窗口。这不是我们想要建立的用户体验类型。

#### Spring 安全过滤链

在菜谱的第一步中，我们在`web.xml`中声明了一个名为`springSecurityFilterChain`的过滤器:

```java
  <filter>
    <filter-name>springSecurityFilterChain</filter-name>
  <filter-class>org.sfw.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
  <filter-name>springSecurityFilterChain</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

这里，`springSecurityFilterChain`也是一个 Spring bean，由 Spring Security 名称空间(特别是`http`组件)在内部创建。`DelegatingFilterProxy`是一个 Spring 基础设施，它在应用上下文中寻找特定的 bean 并调用它。目标 bean 必须实现`Filter`接口。

整个 Spring 安全机制就是这样通过最后一个 bean 连接起来的。

`<http>`元素的配置在定义滤波器链的构成中起着核心作用。它定义的元素直接创建相关的过滤器。

|  | 一些核心过滤器总是在一个过滤器链中创建，而其他过滤器将根据存在的属性和子元素添加到栈中 |  |
|  | - *春天的安全* |

区分依赖于配置的过滤器和不能移除的核心过滤器非常重要。作为核心过滤器，我们可以数出`SecurityContextPersistenceFilter`、`ExceptionTranslationFilter,`和`FilterSecurityInterceptor`。这三个过滤器被本地绑定到`<http>`元素，可以在下一个表中找到。

该表来自 Spring Security reference 文档，它包含了所有的核心过滤器(随框架提供),可以使用特定的元素或属性激活这些过滤器。这里按照它们在链中的位置顺序列出。

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

别名

 | 

过滤器类别

 | 

命名空间元素或属性

 |
| --- | --- | --- |
| `CHANNEL_FILTER` | 频道处理过滤器 | http/intercept-URL @ requires-channel |
| `SECURITY_CONTEXT_FILTER` | securitycontextpersistence filter | 超文本传送协议（Hyper Text Transport Protocol 的缩写） |
| `CONCURRENT_SESSION_FILTER` | ConcurrentSessionFilter | 会话管理/并发控制 |
| `HEADERS_FILTER` | HeaderWriterFilter | http/标题 |
| `CSRF_FILTER` | CsrfFilter | http/csrf |
| `LOGOUT_FILTER` | logout 过滤器 | http/注销 |
| `X509_FILTER` | x509authentaicationfilter | http/x509 |
| `PRE_AUTH_FILTER` | AbstractPreAuthenticatedProcessingFilter 子类 | 不适用的 |
| `CAS_FILTER` | casauthentaicationfilter | 不适用的 |
| `FORM_LOGIN_FILTER` | usernamepasswordtauthenticationfilter | http/form-登录 |
| `BASIC_AUTH_FILTER` | 基本认证过滤器 | http/http-基本 |
| `SERVLET_API_SUPPORT_FILTER` | SecurityContextHolderAwareRequestFilter | http/@servlet-api-provision |
| `JAAS_API_SUPPORT_FILTER` | JaasApiIntegrationFilter | http/@jaas-api-provision |
| `REMEMBER_ME_FILTER` | remembermeauthentaicationfilter | http/记住我 |
| `ANONYMOUS_FILTER` | anonymousauthentaicationfilter | http/匿名 |
| `SESSION_MANAGEMENT_FILTER` | SessionManagementFilter | 会话管理 |
| `EXCEPTION_TRANSLATION_FILTER` | ExceptionTranslationFilter | 超文本传送协议（Hyper Text Transport Protocol 的缩写） |
| `FILTER_SECURITY_INTERCEPTOR` | FilterSecurityInterceptor | 超文本传送协议（Hyper Text Transport Protocol 的缩写） |
| `SWITCH_USER_FILTER` | 开关用户过滤器 | 不适用的 |

请记住，自定义过滤器可以相对定位，或者可以使用 `custom-filter`元素替换这些过滤器中的任何一个:

```java
<security:custom-filter ref="myFilter" after="BASIC_AUTH_FILTER"/>
```

##### 我们的< http >配置

我们已经为名称空间的组件定义了如下配置:

```java
<security:http create-session="stateless" entry-point-ref="authenticationEntryPoint" authentication-manager- ref="authenticationManager">
  <security:custom-filter ref="basicAuthenticationFilter" after="BASIC_AUTH_FILTER" />
  <security:csrf disabled="true"/>
</security:http>
<bean id="basicAuthenticationFilter" class="org.sfw.security.web.authentication.www.BasicAuthenticationFilter">
  <constructor-arg name="authenticationManager" ref="authenticationManager" />
  <constructor-arg name="authenticationEntryPoint" ref="authenticationEntryPoint" />
</bean>
<bean id="authenticationEntryPoint" class="edu.zc.csm.api. authentication.CustomBasicAuthenticationEntryPoint">
  <property name="realmName" value="${realm.name}" />
</bean>
```

这里，我们告诉 Spring 不要创建会话，并使用`create-session=="stateless"`忽略到来的会话。我们这样做是为了追求无状态和可扩展的微服务设计。

出于同样的原因，我们也暂时禁用了**跨站请求伪造** ( **csrf** )支持。从版本 3.2 开始，框架默认启用此功能。

有必要定义一个`entry-point-ref`，因为我们没有实现任何由名称空间(`http-basic`或`login-form`)预先配置的认证策略。

我们已经定义了一个自定义过滤器`BasicAuthenticationFilter`，在核心`BASIC_AUTH_FILTER`的理论位置之后执行。

我们现在来看看这三个引用是由哪些角色扮演的:`authenticationEntryPoint`、`authenticationManager`和`basicAuthenticationFilter`。

### 认证管理器接口

首先，是一个单一方法接口:

```java
public interface AuthenticationManager {
  Authentication authenticate(Authentication authentication) throws AuthenticationException;
}
```

Spring Security 提供了一个实现:`ProviderManager`。这个实现允许我们插入几个`AuthenticationProviders`。`ProviderManager`按顺序尝试所有的`AuthenticationProviders`，调用它们的`authenticate`方法。代码如下:

```java
public interface AuthenticationProvider {
  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;
  boolean supports(Class<?> authentication);
}
```

当`ProviderManager`找到一个非空的`Authentication`对象时，它停止迭代。或者，当抛出一个`AuthenticationException`时，它使`Authentication`失败。

通过使用名称空间，可以使用`ref`元素定位特定的`AuthenticationProviders`，如下所示:

```java
<security:authentication-manager >
  <security:authentication-provider ref='myAuthenticationProvider'/>
</security:authentication-manager>
```

现在，这是我们的配置:

```java
<security:authentication-manager alias"="authenticationManager"">
  <security:authentication-provider user-service-ref='communityServiceImpl'>
    <security:password-encoder ref="passwordEncoder"/>
  </security:authentication-provider>
</security:authentication-manager>
```

我们的配置中没有`ref`元素。默认情况下，名称空间将实例化一个`DaoAuthenticationProvider`。它还将注入我们的`UserDetailsService`实现:`communityServiceImpl`，因为我们已经用`user-service-ref`指定了它。

当`UsernamePasswordAuthenticationToken`中提交的密码与`UserDetailsService`加载的密码不匹配时`DaoAuthenticationProvider`抛出`AuthenticationException`(利用`loadUserByUsername`方法)。

在我们的项目中还存在一些其他的`AuthenticationProviders`，例如`RememberMeAuthenticationProvider``LdapAuthenticationProvider``CasAuthenticationProvider`或`JaasAuthenticationProvider`。

### 基本认证

正如我们已经说过的，使用基本模式对于 REST 应用来说是一项伟大的技术。但是，在使用它时，使用加密通信协议(HTTPS)至关重要，因为密码是以明文形式发送的。

正如在*如何做*部分所演示的，原理非常简单。HTTP 请求和平常一样，只是多了一个头`Authentication`。这个头的值由关键字`Basic`组成，后跟一个空格，再后跟一个以 base 64 编码的字符串。

我们可以在网上找到一些免费的服务来快速编码/解码 64 进制字符串。要用 base 64 编码的字符串必须采用以下形式:`<username>:<password>`。

#### 基础认证过滤器

为了实现我们的基本认证，我们在过滤器链中添加了`BasicAuthenticationFilter`。这个`BasicAuthenticationFilter` ( `org.sfw.security.web.authentication.www.BasicAuthenticationFilter`)需要一个`authenticationManager`和一个可选的`authenticationEntryPoint`。

`authenticationEntryPoint`的可选配置将滤波器驱动至下述两种不同行为。

两者都以相同的方式启动:过滤器从其在链中的位置被触发。它在请求中寻找认证头，并委托给`authenticationManager`，然后由`UserDetailsService`实现将其与数据库中的用户凭证进行比较。

##### 带认证输入点

这是我们的配置，其行为方式如下:

*   当认证成功时，过滤器链停止，并返回一个`Authentication`对象。
*   当认证失败时，在过滤器链的中断中调用`authenticationEntryPoint`方法。我们的认证入口点设置一个定制的`WWW-Authenticate`响应头和一个`401`状态码(`FORBIDDEN`)。

这种类型的配置提供了预认证，其中检查 HTTP 请求中的`Authentication Header`以查看业务服务是否需要授权(安全对象)。

这种配置允许快速反馈，web 浏览器提示潜在的本地基本表单。我们已经在我们的应用中选择了这种配置。

##### 没有认证输入点

如果没有 authenticationEntryPoint，筛选器的行为如下:

*   当认证成功时，过滤器链停止，并返回一个`Authentication`对象。
*   当认证失败时，过滤器链继续。在此之后，如果链中的另一个身份验证成功，用户将得到相应的身份验证。但是，如果该链中没有其他身份验证成功，那么用户将通过匿名角色进行身份验证，这可能适合也可能不适合服务访问级别。

## 还有更多…

### 春天里的安全参考

这一节的灵感主要来自 Spring r 安全参考，这也是一个很好的资源:

[http://docs . spring . io/spring-security/site/docs/current/reference/html single](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle)

附录提供了 Spring 安全名称空间的完整指南:

[http://docs . spring . io/spring-security/site/docs/current/reference/html/appendix-namespace . html](http://docs.spring.io/spring-security/site/docs/current/reference/html/appendix-namespace.html)

### 勿忘我 cookie/功能

我们将传递给了`RememberMeAuthenticationFilter`，它为服务器提供了不同的方式来记住会话间主体的身份。Spring Security reference 提供了关于这个主题的大量信息。

# 使用第三方 OAuth2 方案进行认证

这个菜谱使用了 Spring social 项目，以便从客户端的角度使用 OAuth2 协议。

## 准备就绪

这里我们不会创建一个 OAuth2 **认证服务器** ( **为**)。我们将建立与第三方认证服务器(Yahoo！)在我们的应用上进行验证。我们的应用将充当一个 **服务提供者** ( **SP** )。

我们将使用 Spring social，它的第一个角色是透明地管理社交连接，并提供一个门面来调用提供者 API(Yahoo！财务)使用 Java 对象。

## 怎么做...

1.  Spring social 增加了两个 Maven 依赖:

    ```java
        <!– Spring Social Core –>
        <dependency>
          <groupId>org.springframework.social</groupId>
          <artifactId>spring-social-core</artifactId>
          <version>1.1.0.RELEASE</version>
        </dependency>
        <!– Spring Social Web (login/signup controllers) –>
        <dependency>
          <groupId>org.springframework.social</groupId>
          <artifactId>spring-social-web</artifactId>
          <version>1.1.0.RELEASE</version>
        </dependency>
    ```

2.  如果我们想要处理到 Twitter 或脸书的 OAuth2 连接，我们还必须添加以下依赖项:

    ```java
      <!– Spring Social Twitter –>
        <dependency>
          <groupId>org.springframework.social</groupId>
          <artifactId>spring-social-twitter</artifactId>
          <version>1.1.0.RELEASE</version>
        </dependency>
        <!– Spring Social Facebook –>
          <dependency>
          <groupId>org.springframework.social</groupId>
          <artifactId>spring-social-facebook</artifactId>
          <version>1.1.0.RELEASE</version>
        </dependency>
    ```

3.  After the BASIC authentication section, the Spring Security configuration file hasn't changed much. A few interceptors can be noticed in the `http` bean:

    ```java
    <security:http create-session="stateless" entry-point-ref="authenticationEntryPoint" authentication-manager-ref="authenticationManager">
      <security:custom-filter ref="basicAuthenticationFilter" after="BASIC_AUTH_FILTER" />
      <security:csrf disabled="true"/>
      <security:intercept-url pattern="/signup" access="permitAll"/>
      ...
      <security:intercept-url pattern="/**" access="permitAll"/>
    </security:http>
    ```

    随着`SocialUserConnectionRepositoryImpl`后面的，我们创建了自己的`org.sfw.social.connect.ConnectionRepository`实现，它是一个`Spring Social` c `ore`接口，带有管理社交用户连接的方法。代码如下:

    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    @SuppressWarnings("unchecked")
    public class SocialUserConnectionRepositoryImpl implements ConnectionRepository {
    @Autowired
    private SocialUserRepository socialUserRepository;
    private final String userId;
    private final ConnectionFactoryLocator connectionFactoryLocator;
    private final TextEncryptor textEncryptor;
    public SocialUserConnectionRepositoryImpl(String userId, SocialUserRepository socialUserRepository, ConnectionFactoryLocator connectionFactoryLocator, TextEncryptor textEncryptor){
        this.socialUserRepository = socialUserRepository;
        this.userId = userId;
        this.connectionFactoryLocator = connectionFactoryLocator;
        this.textEncryptor = textEncryptor;
    }
     ...
    public void addConnection(Connection<?> connection) {
    try {
       ConnectionData data = connection.createData();
      int rank = socialUserRepository.getRank(userId, data.getProviderId()) ;
      socialUserRepository.create(userId, data.getProviderId(), data.getProviderUserId(), rank, data.getDisplayName(), data.getProfileUrl(), data.getImageUrl(), encrypt(data.getAccessToken()), encrypt(data.getSecret()), encrypt(data.getRefreshToken()), data.getExpireTime()    );
        } catch (DuplicateKeyException e) {
      throw new   DuplicateConnectionException(connection.getKey());
    }
    }
    ...
    public void removeConnections(String providerId) {
      socialUserRepository.delete(userId,providerId);
    }
      ...
    }
    ```

    ### 注意

    实际上，这个定制的实现扩展并改编了来自 https://github.com/mschipperheyn/spring-social-jpa 的作品，这些作品是在 GNU GPL 许可下发布的。

4.  正如您所见，`SocialUserConnectionRepositoryImpl`使用了一个定制的 Spring 数据 JPA `SocialUserRepository`接口，其定义如下:

    ```java
    public interface SocialUserRepository {
      List<SocialUser> findUsersConnectedTo(String providerId);
      ...
      List<String> findUserIdsByProviderIdAndProviderUserIds( String providerId, Set<String> providerUserIds);
    ...
      List<SocialUser> getPrimary(String userId, String providerId);
      ...
      SocialUser findFirstByUserIdAndProviderId(String userId, String providerId);
    }
    ```

5.  这个 Spring 数据 JPA 存储库支持我们已经创建的一个`SocialUser`实体(社会联系)。这个实体是`UserConnection` SQL 表的直接模型，如果我们使用这个实现而不是我们自己的，那么`JdbcUsersConnectionRepository`会期望找到这个实体。`SocialUser`定义是下面的代码:

    ```java
    @Entity
    @Table(name="userconnection", uniqueConstraints = {@UniqueConstraint(columnNames = { ""userId", "providerId", "providerUserId" }), 
    @UniqueConstraint(columnNames = { "userId", "providerId", "rank" })})
    public class SocialUser {
      @Id
      @GeneratedValue
      private Integer id;

      @Column(name = "userId")
      private String userId;

      @Column(nullable = false)
      private String providerId;
      private String providerUserId;

      @Column(nullable = false)
      private int rank;
      private String displayName;
      private String profileUrl;
      private String imageUrl;

      @Lob
      @Column(nullable = false)
      private String accessToken;
      private String secret;
      private String refreshToken;
      private Long expireTime;
      private Date createDate = new Date();
      //+ getters / setters
      ...
    } 
    ```

6.  `SocialUserConnectionRepositoryImpl`在更高层的服务层:`SocialUserServiceImpl`中实例化，这是 Spring `UsersConnectionRepository`接口的一个实现。该实现创建如下:

    ```java
    @Transactional(readOnly = true)
    public class SocialUserServiceImpl implements SocialUserService {
       @Autowired
       private SocialUserRepository socialUserRepository;
      @Autowired
       private ConnectionFactoryLocator connectionFactoryLocator;
      @Autowired
      private UserRepository userRepository;
      private TextEncryptor textEncryptor = Encryptors.noOpText();
    public List<String> findUserIdsWithConnection(Connection<?> connection) {
       ConnectionKey key = connection.getKey();
      return socialUserRepository. findUserIdsByProviderIdAndProviderUserId(key.getProviderId(), key.getProviderUserId());
    }
    public Set<String> findUserIdsConnectedTo(String providerId, Set<String> providerUserIds) {
        return Sets.newHashSet(socialUserRepository.findUserIdsByProviderIdAndProviderUserIds(providerId, providerUserIds));
    }
    public ConnectionRepository createConnectionRepository(String userId) {
      if (userId == null) {
        throw new IllegalArgumentException"("userId cannot be null"");
      }
      return new SocialUserConnectionRepositoryImpl(
          userId,
          socialUserRepository,
          connectionFactoryLocator,
          textEncryptor);
    }
     	...
    }
    ```

7.  这个更高的级别`SocialUserServiceImpl`在`cloudstreetmarket-api` Spring 配置文件(`dispatcher-context.xml`)中注册为一个工厂 bean，该工厂 bean 能够在请求范围下产生`SocialUserConnectionRepositoryImpl`(针对特定的社交用户配置文件)。代码如下:

    ```java
    <bean id="usersConnectionRepository" class="edu.zc.csm.core.services.SocialUserServiceImpl"/>
    <bean id="connectionRepository" factory-method="createConnectionRepository" factory-bean="usersConnectionRepository" scope"="request">
      <constructor-arg value="#{request.userPrincipal.name}"/>
      <aop:scoped-proxy proxy-target-class"="false"" />
    </bean>
    ```

8.  在这个`dispatcher-context.xml`文件中定义了另外三个 beans】
9.  在 OAuth2 认证之后, `SignInAdapterImpl`在我们的应用中登录一个用户。从应用业务的角度来看，它执行我们希望它在这一步执行的操作。代码如下:

    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    @PropertySource("classpath:application.properties")
    public class SignInAdapterImpl implements SignInAdapter{
      @Autowired
      private UserRepository userRepository;
      @Autowired
      private CommunityService communityService;
      @Autowired
      private SocialUserRepository socialUserRepository;
      @Value("${oauth.success.view}")
      private String successView;
      public String signIn(String userId, Connection<?> connection, NativeWebRequest request) {
          User user = userRepository.findOne(userId);
          String view = null;
          if(user == null){
            //temporary user for Spring Security
            //won't be persisted
            user = new User(userId, communityService.generatePassword(), null, true, true, true, true, communityService.createAuthorities(newRole[]{Role.ROLE_BASIC, Role.ROLE_OAUTH2}));
        }
        else{
            //We have a successful previous oAuth 	//authentication
            //The user is already registered
            //Only the guid is sent back
            List<SocialUser> socialUsers = 
            socialUserRepository. findByProviderUserIdOrUserId(userId, userId);
            if(CollectionUtils.isNotEmpty(socialUsers)){
              //For now we only deal with Yahoo!
              view = successView.concat(
                "?spi=" + socialUsers.get(0) .getProviderUserId());
        }
        }
        communityService.signInUser(user);
        return view;
      }
    }
    ```

10.  The `connectionFactoryLocator` can also refer to more than one connection factories. In our case, we have only one: `YahooOAuth2ConnectionFactory`. These classes are the entry points of social providers APIs (written for Java). We can normally find them on the web (from official sources or not) for the OAuth protocol we target (OAuth1, OAuth1.0a, and OAuth2).

    ### 注意

    目前几乎没有适用于雅虎的 OAuth2 适配器。我们不得不自己动手。这就是为什么这些类可以作为源代码而不是 jar 依赖项获得(在 Zipcloud 项目中)。

11.  当涉及到控制器声明时，`dispatcher-context.xml`配置一个`ProviderSignInController`，它在`Spring Social Core`中被完全抽象。然而，为了在我们的应用中注册一个 OAuth2 用户(用户第一次访问站点)，我们创建了一个定制的`SignUpController` :

    ```java
    @Controller
    @RequestMapping"("/signup"")
    @PropertySource"("classpath:application.properties"")
    public class SignUpController extends CloudstreetApiWCI{
      @Autowired
      private CommunityService communityService;
      @Autowired
      private SignInAdapter signInAdapter;
      @Autowired
      private ConnectionRepository connectionRepository;
      @Value("${oauth.signup.success.view}")
      private String successView;
      @RequestMapping(method = RequestMethod.GET)
      public String getForm(NativeWebRequest request, @ModelAttribute User user) {
        String view = successView;
        // check if this is a new user signing in via //Spring Social
        Connection<?> connection = ProviderSignInUtils.getConnection(request);
          if (connection != null) {
            // populate new User from social connection //user profile
            UserProfile userProfile = connection.fetchUserProfile();
            user.setUsername(userProfile.getUsername());
            // finish social signup/login
            ProviderSignInUtils. handlePostSignUp(user.getUsername(), request);
            // sign the user in and send them to the user //home page
            signInAdapter.signIn(user.getUsername(), connection, request);
          view += ?spi=+ user.getUsername();
        }
        return view;
      }
    }
    ```

12.  现在是时候试试了。要继续，我们建议您创建一个雅虎！账户。我们实际上不是由雅虎赞助的！这只是为了我们伟大的 Zipcloud 公司以金融服务为导向的战略。不仅仅是为了玛丽莎·梅耶尔的蓝眼睛！([https://login.yahoo.com](https://login.yahoo.com))。
13.  启动您的 Tomcat 服务器并点击登录按钮(在主菜单的最右边)。然后点击**登录雅虎！**按钮
14.  You should be redirected to the Yahoo! servers in order for you to authenticate on their side (if you are not logged-in already):

    ![How to do it...](img/B4049_05_10.jpg)

15.  Once logged-in, agree that Cloudstreet Market will be able to access your profile and your contacts. We won't make use of contacts; however, we have the Java adaptors to access them. If it's too scary, just create an empty new Yahoo! account:

    ![How to do it...](img/B4049_05_11.jpg)

16.  点击**同意**按钮上的。
17.  雅虎！现在应该重定向到本地`cloudstreetmarket.com`服务器，特别是带有授权码作为 URL 参数的`/api/signin/yahoo`处理程序。
18.  The application detects when in the `Cloudstreet Market` database there isn't any `User` registered for the `SocialUser`. This triggers the following popup and it should come back to the user until the account actually gets created:

    ![How to do it...](img/B4049_05_12.jpg)

19.  Fill the form with the following data:

    ```java
    username: <marcus>
    email: <marcus@chapter5.com>
    password: <123456>
    preferred currency: <USD>
    ```

    此外，点击用户图标以上传个人资料图片(如果您愿意)。这样做的时候，确保属性`cloudstreetmarket-api/src/main/resources/application.properties`中的属性`pictures.user.path`指向文件系统上创建的路径。

20.  一旦这一步完成，新的公共活动**马库斯注册了一个新账户**应该会出现在欢迎页面上。
21.  Also, bound to each REST response from the API, the extra-headers **Authenticated** and **WWW-Authenticate** must be present. This is proof that we are authenticated with OAuth2 capability in the application.

    ![How to do it...](img/B4049_05_13.jpg)

## 它是如何工作的...

我们在这个菜谱中执行应用中的社交整合。OAuth2 认证涉及服务提供商(cloudstreetmarket.com)和身份提供商(雅虎！).

这只有在用户拥有(或准备拥有)双方的账户时才会发生。它是当今非常流行的认证协议。因为大多数互联网用户在一个主要的社交 SaaS 提供商(脸书、Twitter、LinkedIn、Yahoo！等等)，这种技术极大地减少了花费在 web 服务提供商身上的注册时间和登录时间。

### 从应用的角度来看

当登录雅虎！按钮，向我们的一个 API 处理程序`/api/signin/yahoo`发出一个 HTTP POST 请求。这个句柄对应于`ProviderSignInController`，由`Spring Social`抽象。

*   该处理程序将用户重定向到 Yahoo！在服务器上，他可以进行身份验证，并授权应用使用他的社交身份并访问他的一些 Yahoo！数据。
*   雅虎！向应用发送一个授权码，作为重定向到它执行的回调 URL 的参数。
*   应用使用授权代码作为参数来处理回调。这个回调以抽象的`ProviderSignInController`中不同的方法处理程序为目标。该处理程序完成调用 Yahoo！以便与**刷新令牌**和**访问令牌**交换授权码。该操作在`Spring Social`后台透明完成。
*   同一处理器在数据库中查找该用户的现有持久社交联系:
    *   如果找到一个连接，用户将在`Spring Security`中通过验证，并通过 Yahoo！user-ID 作为请求参数(名为`spi`的参数)。
    *   如果没有找到连接，用户将被重定向到`SignupController`，在这里他的连接将被创建和持久化。然后，他在 Spring Security 中通过身份验证，并使用 Yahoo！用户 ID 作为请求参数(名为`spi`)。
*   当门户主页被加载时，Yahoo！检测到用户 ID 请求参数，并将该标识符存储在 HTML5 `sessionStorage`中(我们已经完成了这一切)。
*   从现在开始，在用户向 API 发出的每个 AJAX 请求中，`spi`标识符将作为请求头传递，直到用户实际注销或关闭浏览器。

### 来自雅虎！观点

雅虎！API 提供了两种使用 OAuth2 进行身份验证的方式。这导致了两种不同的流:适用于服务器端(web)应用的显式 OAuth2 流和特别有利于前端 web 客户端的隐式 OAuth2 流。这里我们将重点关注实现的显式流。

#### OAuth2 显式授权流

这是我们的应用和 Yahoo！之间的通信协议的概要图。。这或多或少是一个标准的 OAuth2 对话:

![OAuth2 explicit grant flow](img/B4049_05_19.jpg)

标有`*`符号的参数在通信中是可选的。这个流程在 OAuth2 Yahoo！指南:

[https://developer.yahoo.com/oauth2/guide/flows_authcode](https://developer.yahoo.com/oauth2/guide/flows_authcode)

#### 刷新令牌和访问令牌

必须了解这两种标记之间的差异。访问令牌用于识别用户(Yahoo！用户)在 Yahoo！API。例如，下面是一个 GET 请求，可以执行该请求来检索 Yahoo！由 Yahoo！ID abcdef123:

```java
GET https://social.yahooapis.com/v1/user/abcdef123/profile
Authorization: Bearer aXJUKynsTUXLVY 
```

为了给这个调用提供标识，**访问令牌**必须作为带有`Bearer`关键字的`Authorization`请求头的值传入。一般来说，访问令牌的寿命非常有限(对于 Yahoo！，是一个小时)。

刷新令牌用于请求新的访问令牌。刷新令牌具有更长的寿命(对于 Yahoo！，它们实际上永远不会过期，但可以被撤销)。

### Spring social——角色和主要功能

Spring social 的角色是与**软件即服务** ( **SaaS** )提供商如脸书、推特或雅虎建立联系。Spring social 还负责代表用户调用应用(Cloudstreet Market)服务器端的 API。

这两项任务都是在 spring-social-core 依赖关系中分别使用 Connect 框架和 OAuth 客户端支持来完成的。

简而言之，春天社交是:

*   A `Connect Framework`处理核心授权和与服务提供商的连接流程
*   在 web 应用环境中处理服务提供者、消费者和用户之间的 OAuth 交换的`Connect Controller`
*   允许用户在我们的应用中进行身份验证，使用他们的 Saas 提供商帐户登录

### 社会联系的持久性

Spring social core 提供了能够使用 JDBC(特别是使用`JdbcUsersConnectionRepository`)在数据库中保持社会联系的类。该模块甚至为模式定义嵌入了 SQL 脚本:

```java
create table UserConnection (userId varchar(255) not null,
    providerId varchar(255) not null,
    providerUserId varchar(255),
    rank int not null,
    displayName varchar(255),
    profileUrl varchar(512),
    imageUrl varchar(512),
    accessToken varchar(255) not null,
    secret varchar(255),
    refreshToken varchar(255),
    expireTime bigint,
    primary key (userId, providerId, providerUserId));
create unique index UserConnectionRank on UserConnection(userId, providerId, rank);
```

当一个应用(比如我们的)使用 JPA 时，可以创建一个实体在持久性上下文中表示这个表。为此，我们在秘籍的第六步中创建了`SocialUser`实体。

在该表实体中，您可以看到以下字段:

*   `userId`:该字段匹配用户注册时`User`的`@Id`(用户名)。如果用户尚未注册，`userId`是 GUID (Yahoo！用户 ID，在 web 端也称为`spi`
*   `providerId`:该字段是提供商的小写名称:雅虎、脸书或推特。
*   `providerUserId`:该字段是 GUID，在提供商系统中的唯一标识符(Yahoo！用户 ID 或 **spi** 。).
*   `accessToken, secret, refreshToken, and expireTime`:这些是连接的 OAuth2 令牌(凭证)及其相关信息。

框架附带了两个接口:

*   `ConnectionRepository`:管理一个用户连接的持久性。对于标识的用户，实现是请求范围的。
*   `UsersConnectionRepository`:这提供了对所有用户的连接的全局存储的访问。

如果您还记得，我们创建了自己的`UsersConnectionRepository`实现(`SocialUserServiceImpl`)。在`dispatcher-servlet.xml`文件中注册，这个实现作为一个工厂产生请求范围`connectionRepository`实现(`SocialUserConnectionRepositoryImpl`):

```java
<bean id="connectionRepository" factory-method="createConnectionRepository" factory-bean="usersConnectionRepository" scop="request">
  <constructor-arg value="#{request.userPrincipal.name}" />
  <aop:scoped-proxy proxy-target-class="false" />
</bean>
<bean id="usersConnectionRepository" class="edu.zc.csm.core.services.SocialUserServiceImpl"/>
```

这两个定制实现都使用我们创建的 Spring 数据 JPA `SocialUserRepository`来查找、更新、持久化和移除连接。

在`UsersConnectionRepository` 接口的`SocialUserServiceImpl`实现中，一个`ConnectionFactoryLocator`属性为`autowired`，一个`TextEncryptor`属性用默认的`NoOpTextEncryptor`实例初始化。

### 注意

默认的`TextEncryptor`实例可以替换为数据库中维护的社交用户数据的适当加密。看一看 spring-security-crypto 模块:

[http://docs . spring . io/spring-security/site/docs/3.1 . x/reference/crypto . html](http://docs.spring.io/spring-security/site/docs/3.1.x/reference/crypto.html)

### 供应商特定的配置

特定于提供商的配置(脸书、推特、雅虎！)从`connectionFactoryLocator` bean 的定义开始。

#### 一个入口点–connectionFactoryLocator

我们在`dispatcher-servlet.xml`中定义的 `connectionFactoryLocator` bean 在 Spring Social 中起着核心作用。其注册如下:

```java
<bean id="connectionFactoryLocator" class="org.sfw.social.connect.support.ConnectionFactoryRegistry">
  <property name="connectionFactories">
    <list>
    <bean class"="org.sfw.social.yahoo.connect. YahooOAuth2ConnectionFactory"">
        <constructor-arg value="${yahoo.client.token}" />
        <constructor-arg value="${yahoo.client.secret}" />
        <constructor-arg value="${yahoo.signin.url}" />
      </bean>
    </list>
  </property>
</bean>
```

有了这个 bean，Spring social 实现了一个`ServiceLocator`模式，允许我们轻松地插入/拔出新的社交连接器。最重要的是，它允许系统在运行时解析特定于提供者的连接器(a `connectionFactory`)。

我们的`connectionFactoryLocator`为指定的类型是`ConnectionFactoryRegistry`，它是`ConnectionFactoryLocator`接口提供的一个实现:

```java
public interface ConnectionFactoryLocator {
    ConnectionFactory<?> getConnectionFactory(String providerId);
    <A> ConnectionFactory<A> getConnectionFactory(Class<A> apiType);
    Set<String> registeredProviderIds();
}
```

我们有一个在`ProviderSignInController.signin`方法中查找`connectionFactory`的例子:

```java
ConnectionFactory<?> connectionFactory = connectionFactoryLocator.getConnectionFactory(providerId);
```

这里，`providerId`参数是一个简单的字符串(在我们的例子中是 yahoo)。

#### 特定于提供者的连接工厂

`ConnectionFactory`如`YahooOAuth2ConnectionFactory`在`ConnectionFactoryRegistry`用 OAuth2 消费者密钥和消费者秘密注册，它们在提供者端识别(授权)我们的应用。

我们已经开发了`YahooOAuth2ConnectionFactory`类，但是你应该能够从官方的`Spring Social`子项目(`spring-social-facebook`、`spring-social-twitter`等等)或者开源项目中找到你的`ProviderSpecificConnectionFactory` 。

#### 使用提供商帐户登录

为了执行 OAuth2 认证步骤，Spring social 提供了一个抽象的 Spring MVC 控制器:`ProviderSignInController`。

该控制器执行 OAuth 流并建立与提供者的连接。它试图找到以前建立的连接，并使用连接的帐户来验证应用中的用户。

如果没有先前的连接匹配，则流被发送到与特定请求映射`/signup`匹配的已创建的`SignUpController`。此时，用户不会自动注册为 CloudStreetMarket `User`。当一个 API 调用显示为 OAuth2 authenticated 而没有绑定本地用户时，我们强制用户通过`Must-Register`响应头手动创建他的帐户。这个`Must-Register`响应头触发客户端上的**立即创建账户**弹出窗口(参见`home_community_activity.js`中的`loadMore`功能)。

在这个注册过程中，连接(`SocialUser`实体)与创建的`User`实体同步(参见`CommunityController.createUser`方法)。

`ProviderSignInController`与`SignInAdapter`实现(我们也必须构建)紧密合作，后者实际上使用 Spring Security 验证用户进入 CloudStreetMarket 的身份。通过调用`communityService.signInUser(user)`来触发认证。

下面是创建`Authentication`对象并将其存储到`SecurityContext`中的方法的细节:

```java
@Override
public Authentication signInUser(User user) {
  Authentication authentication = new UsernamePasswordAuthenticationToken(user, user.getPassword(), user.getAuthorities());
  SecurityContextHolder.getContext().setAuthentication(authentication);
  return authentication;
}
```

我们为`ProviderSigninController`注册并初始化一个 Spring bean，配置如下:

```java
<bean class"="org.sfw.social.connect.web.ProviderSignInController"">
  <constructor-arg ref="connectionFactoryLocator"/>
  <constructor-arg ref="usersConnectionRepository"/>
  <constructor-arg ref="signInAdapter"/>
  <property name="signUpUrl"" value"="/signup"/>
  <property name="postSignInUrl" value="${frontend.home.page.url}"/>
</bean>
```

如您所见，我们已经指定了`signUpUrl`请求映射，以便在数据库中没有找到以前的连接时重定向到我们的自定义`SignupController`。

或者，指定的`postSignInUrl`允许用户在`ProviderSignInController`解析一个现有的连接以便重用时被重定向到门户的主页。

## 还有更多…

再来看看 Spring social 的其他功能。

### 执行认证的 API 调用

在这个秘籍中，我们重点介绍了 OAuth2 客户端认证过程。在下一章，我们将看到如何使用 Spring social 来执行对 Yahoo！代表用户的 API。我们将看到如何使用现有的库来达到这个目的，以及它们是如何工作的。在我们的例子中，我们必须开发到 Yahoo！金融 API。

### 春季社交控制器

Spring social web 提供了另一个抽象的控制器，它允许社交用户直接与他们的社交关系交互，以连接、断开和获取他们的连接状态。`ConnectController`也可以用来建立一个交互式监控屏幕，用于管理一个站点可能处理的所有提供者的连接。查看了解更多详情:

[http://docs . spring . io/spring-social/docs/current/reference/html single/# connecting](http://docs.spring.io/spring-social/docs/current/reference/htmlsingle/#connecting)

## 参见

### 社会认证过滤器

这是一个要添加到 Spring Security 中的过滤器，这样就可以从 Spring Security 过滤器链中执行社会认证(而不是像我们那样从外部执行)。

[http://docs . spring . io/spring-social/docs/current/reference/html single/# enabling-provider-sign-in-with-code-socialauthenticationfilter-code](http://docs.spring.io/spring-social/docs/current/reference/htmlsingle/#enabling-provider-sign-in-with-code-socialauthenticationfilter-code)

### 春季社交联系人列表

您将从项目的主页上找到一个已实现的 Saas 供应商连接器的列表:【http://projects.spring.io/spring-social

### 实现 OAuth2 认证服务器

您可以使用 Spring Security OAuth 项目:

[http://projects.spring.io/spring-security-oauth](http://projects.spring.io/spring-security-oauth)

### 和谐发展博客

关于春季社交的文章启发了这个秘籍。欢迎访问本博客:

[http://harmonic development . Tumblr . com/post/13613051804/adding-spring-social-to-a-spring-MVC-and-spring](http://harmonicdevelopment.tumblr.com/post/13613051804/adding-spring-social-to-a-spring-mvc-and-spring)

# 在 REST 环境中存储凭证

这个菜谱展示了一个在 RESTful 应用中存储凭证的解决方案。

## 准备就绪

该解决方案是临时客户端存储和永久服务器端存储之间的折衷。

在客户端，我们使用 HTML5 会话存储来临时存储用 base 64 编码的用户名和密码。在服务器端，只为密码存储散列。这些散列是用`passwordEncoder`创建的。这个`passwordEncoder`在 Spring Security 中注册，自动连接，并在`UserDetailsService` 实现中使用。

## 怎么做...

### 客户端(AngularJS)

1.  我们已经利用了 HTML5 的属性。主要的变化是建立了一个`httpAuth`工厂。在`http_authorized.js`文件中，这个工厂是`$http`的包装器，透明地处理客户端存储和认证头。该工厂的代码如下:

    ```java
    cloudStreetMarketApp.factory("httpAuth", function ($http) {
      return {
        clearSession: function () {
          var authBasicItem = sessionStorage.getItem('basicHeaderCSM');
          var oAuthSpiItem = sessionStorage.getItem('oAuthSpiCSM');
        if(authBasicItem || oAuthSpiItem){
          sessionStorage.removeItem('basicHeaderCSM');
          sessionStorage.removeItem('oAuthSpiCSM');
          sessionStorage.removeItem('authenticatedCSM');
          $http.defaults.headers.common.Authorization = undefined;
          $http.defaults.headers.common.Spi = undefined;
          $http.defaults.headers.common.OAuthProvider = undefined;
      }
      },
      refresh: function(){
        var authBasicItem = sessionStorage.getItem('basicHeaderCSM');
        var oAuthSpiItem = sessionStorage.getItem('oAuthSpiCSM');
        if(authBasicItem){
          $http.defaults.headers.common.Authorization = 
          $.parseJSON(authBasicItem).Authorization;
          }
          if(oAuthSpiItem){
            $http.defaults.headers.common.Spi = oAuthSpiItem;
            $http.defaults.headers.common.OAuthProvider = "yahoo";
        }
        },
        setCredentials: function (login, password) {
        //Encodes in base 64
        var encodedData = window.btoa(login+":"+password);
        var basicAuthToken = 'Basic '+encodedData;
        var header = {Authorization: basicAuthToken};
        sessionStorage.setItem('basicHeaderCSM', JSON.stringify(header));
        $http.defaults.headers.common.Authorization = basicAuthToken;
      },
      setSession: function(attributeName, attributeValue) {
        sessionStorage.setItem(attributeName, attributeValue);
      },
      getSession: function (attributeName) {
        return sessionStorage.getItem(attributeName);
      },
      post: function (url, body) {
        this.refresh();
      return $http.post(url, body);
      },
      post: function (url, body, headers, data) {
        this.refresh();
        return $http.post(url, body, headers, data);
      },
      get: function (url) {
        this.refresh();
        return $http.get(url);
      },
      isUserAuthenticated: function () {
        var authBasicItem = sessionStorage.getItem('authenticatedCSM');
      if(authBasicItem){
        return true;
        }
      return false;
      }
    }});
    ```

2.  这个工厂在任何地方(或者几乎是在前面的地方)都被调用，透明地传递和处理 AJAX 请求所需的凭证或标识头。
3.  我们避免了直接处理来自不同控制器的属性，以避免与这个存储解决方案紧密耦合。
4.  `account_management.js`文件将不同的控制器(`LoginByUsernameAndPasswordController`、`createNewAccountController`和`OAuth2Controller`)重新分组，这些控制器将凭证和提供者 id 存储在`sessionStorage`到`httpAuth`中。
5.  几个工厂也被修改，通过`httpAuth`工厂拉和推数据。例如，`indiceTableFactory`(来自`home_financial_table.js`)请求凭证透明处理的市场指数:

    ```java
    cloudStreetMarketApp.factory("indicesTableFactory", function (httpAuth) {
        return {
            get: function (market) {
            return httpAuth.get("/api/indices/" + market + ".json?ps=6");
            }
        }
    });
    ```

### 服务器端

1.  我们已经在`security-config.xml`(在`cloudstreetmarket-core`模块中)声明了一个`passwordEncoder`bean:

    ```java
    <bean id="passwordEncoder" 
      class="org.sfw.security.crypto.bcrypt.BCryptPasswordEnco  der"/>
    ```

2.  在`security-config.xml`中，对密码编码器的引用如下，在我们的`authenticationProvider` to 中。

    ```java
    <security:authentication-manager alias"="authenticationManager">
      <security:authentication-provider user-service-ref='communityServiceImpl'>
        <security:password-encoder ref="passwordEncoder"/>
      </security:authentication-provider>
    </security:authentication-manager>
    ```

3.  在`CommunityServiceImpl`(我们的`UserDetailsService`实现)中， `passwordEncoder` bean 是自动绑定的。账户注册时，密码在这里用`passwordEncoder`散列。然后，当用户尝试登录时，将存储的哈希与用户提交的密码进行比较。`CommunityServiceImpl`代码如下:

    ```java
    @Service(value="communityServiceImpl")
    @Transactional(propagation = Propagation.REQUIRED)
    public class CommunityServiceImpl implements CommunityService {
      @Autowired
      private ActionRepository actionRepository;	
      ...
      @Autowired
      private PasswordEncoder passwordEncoder;
      ...
      @Override
      public User createUser(User user, Role role) {
        if(findByUserName(user.getUsername()) != null){
          throw new ConstraintViolationException("The provided user name already exists!", null, null);
         }
        user.addAuthority(new Authority(user, role));
        user.addAction(new AccountActivity(user, UserActivityType.REGISTER, new Date()));
        user.setPassword(passwordEncoder. encode(user.getPassword()));
        return userRepository.save(user);
      }
      @Override
      public User identifyUser(User user) {
        Preconditions.checkArgument(user.getPassword() != null, "The provided password cannot be null!");
       Preconditions.checkArgument( StringUtils.isNotBlank(user.getPassword()), "The provided password cannot be empty!");
        User retreivedUser = userRepository.findByUsername(user.getUsername());
        if(!passwordEncoder.matches(user.getPassword(), retreivedUser.getPassword())){
          throw new BadCredentialsException"("No match has been found with the provided credentials!");
        }
      return retreivedUser;
      }
      ...
    }
    ```

4.  我们的 `ConnectionFactory`实现`SocialUserConnectionRepositoryImpl`在`SocialUserServiceImpl`中用 Spring `TextEncryptor`实例化。这提供了为 OAuth2 加密存储的连接数据的可能性(最重要的是，访问令牌和刷新令牌)。目前，这些数据没有用我们的代码加密。

## 它是如何工作的...

在这一章中，我们试图维护 RESTful API 的无状态性，因为它提供了一些好处(可伸缩性、易于部署、容错等等)。

### 微服务认证

保持无状态符合微服务的一个关键概念:我们模块的自给自足。我们不会为了可伸缩性而使用粘性会话。当状态被维护时，它仅由客户端在有限的时间内保存用户的标识符和/或他的凭证。

微服务的另一个关键概念是有限和确定责任的概念(水平可伸缩性)。我们的设计支持这一原则，即使应用的大小不需要域分割。我们完全可以想象按照领域(社区、指数和股票、监控等等)来划分我们的 API。位于核心模块中的 Spring Security 将毫无问题地嵌入到每个 API war 中。

让我们把重点放在如何在客户端维护状态上。我们为用户提供了两种登录方式:使用基本方案或使用 OAuth2。

*   用户可以注册自己的帐户进行基本身份验证，然后决定使用 OAuth2 登录(为此，他必须将其社交帐户绑定到现有帐户)。
*   或者，用户可以用 OAuth2 注册他的帐户，然后用一个基本表单登录。他的 OAuth2 凭证自然会绑定到他的身份验证。

### 使用基本认证

当用户注册账户时，他定义了用户名和密码。这些凭证使用`httpAuth`工厂和`setCredentials`方法存储。

在`account_management.js`文件中，尤其是在`createNewAccountController`(通过`create_account_modal.html`模态调用)中，可以在`createAccount`方法的成功处理程序中找到`setCredentials`调用:

```java
httpAuth.setCredentials($scope.form.username, $scope.form.password);
```

现在，这种方法使用 HTML5 `sessionStorage`作为存储设备:

```java
setCredentials: function (login, password) {
  var encodedData = window.btoa(login"+":"+password);
  var basicAuthToken = 'Basic '+encodedData;
  var header = {Authorization: basicAuthToken};
  sessionStorage.setItem('basicHeaderCSM', JSON.stringify(header));
  $http.defaults.headers.common.Authorization = basicAuthToken;
}
```

`window.btoa(...)`函数对提供的字符串进行 64 进制编码。`$httpProvider.defaults.headers`配置对象也被添加了一个新的头，这个头可能会被下一个 AJAX 请求使用。

当用户使用基本表单登录时(参见`account_management.js`，尤其是从`auth_modal.html`模式调用的`LoginByUsernameAndPasswordController`，用户名和密码使用相同的方法存储:

```java
httpAuth.setCredentials($scope.form.username, $scope.form.password);
```

现在有了`httpAuth`抽象层 angular `$http`服务，我们确保在每个使用`$http`的 API 调用中都设置了**授权**头。

![Using the BASIC authentication](img/B4049_05_22.jpg)

#### 使用 OAuth2

从`auth_modal.html`发起，使用 OAuth2 登录创建一个 POST HTTP 请求给 API 处理程序`/api/signin/yahoo`(这个处理程序位于抽象的`ProviderSignInController`)。

登录请求被重定向到 Yahoo！认证屏幕。整页都是雅虎的！直到完工。当 API 最终将请求重定向到门户的主页时，会添加一个`spi`请求参数:`http://cloudstreetmarket.com/portal/index?spi=F2YY6VNSXIU7CTAUB2A6U6KD7E`

这个`spi`参数就是 Yahoo！用户 ID (GUID)。被`DefaultController` ( `cloudstreetmarket-webapp`)捕捉并注入模型；

```java
@RequestMapping(value="/*", method={RequestMethod.GET,RequestMethod.HEAD})
public String fallback(Model model, @RequestParam(value="spi", required=false) String spi) {
  if(StringUtils.isNotBlank(spi)){
    model.addAttribute("spi", spi);
  }
  return "index";
}
```

`index.jsp`文件直接在顶部菜单的 DOM 中呈现值:

```java
<div id="spi" class="hide">${spi}</div>
```

当`menuController`(绑定到顶部菜单)自身初始化时，该值被读取并存储在`sessionStorage`:

```java
$scope.init = function () {
  if($('#spi').text()){
    httpAuth.setSession('oAuthSpiCSM', $('#spi').text());
  }
}
```

在我们的`httpAuth`工厂(`http_authorized.js`)中，每次调用 API 之前被调用的`refresh()`方法检查这个值是否存在，并添加两个额外的头:`Spi`和 GUID 值以及 **OAuthProvider** (在我们的例子中是 yahoo)。代码如下:

```java
refresh: function(){
  var authBasicItem = sessionStorage.getItem('basicHeaderCSM');
  var oAuthSpiItem = sessionStorage.getItem('oAuthSpiCSM');
  if(authBasicItem){
    $http.defaults.headers.common.Authorization = $.parseJSON(authBasicItem).Authorization;
  }
  if(oAuthSpiItem){
    $http.defaults.headers.common.Spi = oAuthSpiItem;
    $http.defaults.headers.common.OAuthProvider = "yahoo";
  }
}
```

这里的截图显示了我们的一个 AJAX 请求的两个标题:

![Using OAuth2](img/B4049_05_21.jpg)

### HTML5 会话存储

我们在客户端使用 SessionStorage 作为用户凭证和社会标识符(GUIDs)的存储解决方案。

在 HTML5 中，网页能够使用 web 存储技术在浏览器中本地存储数据。存储的 Web 存储中的数据可以从页面脚本中访问，并且值可以相对较大(高达 5MB ),而不会影响客户端性能。

Web 存储是基于源的(协议、主机名和端口号的组合)。来自一个源的所有页面可以存储和访问相同的数据。有两种类型的对象可用于本地存储数据:

*   `window.localStorage`:存储没有截止日期的数据。
*   `window.sessionStorage`:存储一个会话的数据(标签关闭时数据丢失)。

这两个对象可以直接从 window 对象中访问，它们都带有自解释的方法:

```java
setItem(key,value);
getItem(key);
removeItem(key);
clear();
```

正如[http://www.w3schools.com/](http://www.w3schools.com/)指出的那样，现在几乎所有的浏览器都支持本地存储(根据你的市场，在 94%到 98%之间)。下表显示了完全支持它的第一个版本:

![HTML5 SessionStorage](img/B4049_05_23.jpg)

我们应该为不合规的 web 浏览器实现一个带有 cookies 的后备选项，或者至少在浏览器似乎过时时提供一条警告消息。

### SSL/TLS

使用基本身份验证时，必须设置加密的通信协议。我们已经看到，凭证用户名:密码和雅虎！GUID 作为请求头发送。尽管这些凭证是用 base 64 编码的，但这并不能提供足够的保护。

### BCryptPasswordEncoder

在服务器端，我们不以纯文本形式存储`User`密码。我们只存储它们的编码描述(散列)。因此，哈希函数应该是不可逆的。

|  | *“哈希函数是可以用来将任意大小的数字数据映射到固定大小的数字数据的任何函数”。* |  |
|  | ——*维基百科* |

让我们看看下面的映射:

![BCryptPasswordEncoder](img/B4049_05_24.jpg)

此图显示了从 0 到 15 映射`names` `to` `integers`的散列函数。

我们使用了一个在持久化和更新`Users`时手动调用的`PasswordEncoder`实现。另外`PasswordEncoder`是 Spring 安全核心的一个接口:

```java
public interface PasswordEncoder {
  String encode(CharSequence rawPassword);
  boolean matches(CharSequence rawPassword, String encodedPassword);
}
```

Spring Security 提供了三种实现:`StandardPasswordEncoder`、`NoOpPasswordEncoder`和`BCryptPasswordEncoder`。

我们在新项目中使用了推荐的`BCryptPasswordEncoder`。`BCryptPasswordEncoder`没有实现 MD5 或 SHA 散列算法，而是使用一种更强的散列算法，随机生成`salt`。

这允许为同一个密码存储不同的哈希值。下面是一个关于`123456`值的不同`BCrypt`散列的例子:

```java
$2a$10$Qz5slUkuV7RXfaH/otDY9udROisOwf6XXAOLt4PHWnYgOhG59teC6
$2a$10$GYCkBzp2NlpGS/qjp5f6NOWHeF56ENAlHNuSssSJpE1MMYJevHBWO
$2a$10$5uKS72xK2ArGDgb2CwjYnOzQcOmB7CPxK6fz2MGcDBM9vJ4rUql36
```

## 还有更多…

### 用 AngularJS 设置 HTTP 头

由于我们已经设置了标题，请查看以下页面，了解有关 AngularJS 标题管理的更多信息:

[https://docs.angularjs.org/api/ng/service/$http](https://docs.angularjs.org/api/ng/service/$http)

### 浏览器支持本地存储

了解每个 b 浏览器版本的总体支持:

[http://caniuse.com/#search=localstorage](http://caniuse.com/#search=localstorage)

### 关于 SSL 和 TLS

我们已经在生产服务器上安装了一个 SSL 证书。为了购买并获得 SSL 证书，我们必须提供我们的 web 服务器类型(Apache 2)和从 keytool 程序(嵌入在 JDK 中)生成的**证书签名请求** ( **CSR** )。

*   [http://ars technica . com/information-technology/2012/11/securing-your-web-server-with-SSL ts/](http://arstechnica.com/information-technology/2012/11/securing-your-web-server-with-ssltls/)
*   [http://en.wikipedia.org/wiki/Certificate_signing_request](http://en.wikipedia.org/wiki/Certificate_signing_request)
*   [https://www . name cheap . com/support/knowledge base/article . aspx/9422/0/Tomcat-using-keytool](https://www.namecheap.com/support/knowledgebase/article.aspx/9422/0/tomcat-using-keytool)

# 在服务和控制器上授权

在这个秘籍中，我们根据授予用户的权限来限制对服务和控制器的访问。

## 准备就绪

我们将在特定的 URL 路径和方法调用上安装拦截器，这将触发预定义的授权工作流:`AbstractSecurityInterceptor`工作流。

为了测试这些服务的限制，我们还稍微定制了 Swagger UI，以便在基本身份验证上使用它。

## 怎么做...

1.  我们为这个新版本更新了我们的`CustomBasicAuthenticationEntryPoint`类，它允许当从 Swagger UI 发出调用时提示浏览器本机基本表单:

    ```java
    public class CustomBasicAuthenticationEntryPoint extends BasicAuthenticationEntryPoint {
      @Override
      public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        String referer = (String) request.getHeader("referer");
        if(referer != null && referer.contains(SWAGGER_UI_PATH)){
          super.commence(request, response, authException);
          return;
        }
        response.setHeader("WWW-Authenticate", "CSM_Basic realm=\" + getRealmName() + \");
        response.sendError( HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage());
      }
    }
    ```

2.  我们创建了一个 `MonitoringController`(一个`RestController`)提供了出于管理目的管理用户的可能性。
3.  `GET`方法直接返回`User`对象(而不是`UserDTO`，它提供关于用户的所有数据。另外，一个`delete`方法出现在这个位置。`MonitoringController`代码如下:

    ```java
    @RestController
    @RequestMapping(value="/monitoring", 	produces={"application/xml", "application/json"})
    @PreAuthorize("hasRole('ADMIN')")
    public class MonitoringController extends CloudstreetApiWCI{
      @Autowired
      private CommunityService communityService;
      @Autowired
      private SocialUserService socialUserService;
      @RequestMapping(value="/users/{username}", method=GET)
      @ResponseStatus(HttpStatus.OK)
      @ApiOperation(value = "Details one account", notes = )
      public User getUserDetails(@PathVariable String username){
        return communityService.findOne(username);
      }
      @RequestMapping(value="/users/{username}", method=DELETE)
      @ResponseStatus(HttpStatus.OK)
      @ApiOperation(value = "Delete user account", notes =)
      public void deleteUser(@PathVariable String username){
        communityService.delete(username);
      }
      @RequestMapping(value="/users", method=GET)
      @ResponseStatus(HttpStatus.OK)
      @ApiOperation(value = "List user accounts", notes =)
      public Page<User> getUsers(@ApiIgnore @PageableDefault(size=10, page=0) Pageable pageable){
        return communityService.findAll(pageable);
      }
    }
    ```

4.  在 `communityService`实现中，使用了两种方法(`findAll`、`delete`)被保护:

    ```java
      @Override
      @Secured({"ROLE_ADMIN", "ROLE_SYSTEM"})
      public void delete(String userName) {
        userRepository.delete(userName);
      }
      @Override
      @Secured("ROLE_ADMIN")
      public Page<User> findAll(Pageable pageable) {
        return userRepository.findAll(pageable);
      }
    ```

5.  提醒一下，我们已经在`security-config.xml` :

    ```java
    <security:global-method-security secured-annotations"="enabled"" pre-post-annotations"="enabled"" authentication-manager-ref"="authenticationManager""/>
    ```

    中设置了一个全局方法-安全
6.  Let's try it now. Restart your Tomcat and open a new window in your favorite browser. Open **Swagger UI** (`http://cloudstreetmarket.com/api/index.html`) as shown here:

    ![How to do it...](img/B4049_05_14.jpg)

7.  打开 **监控**选项卡。尝试调用**GET/monitoring/users**T5】方法来列出用户帐户。
8.  Your web browser should prompt a BASIC authentication form as follows:

    ![How to do it...](img/B4049_05_15.jpg)

9.  如果您取消此表格，您应该会收到一个 **401(未授权)**响应代码。
10.  出于测试目的，`communityController`中有一个`delete`方法不受任何注释保护。另外，记住没有为`communityController`路径:

    ```java
    @RequestMapping(value"="/{username"}", method=DELETE)
    @ResponseStatus(HttpStatus.OK
    @ApiOperation(value = "Delete a user account", notes =)
    public void deleteUser(@PathVariable String username){
      communityService.delete(username);
    }
    ```

    定义特定的 URL 拦截器
11.  Without sign in, try to call this handler from Swagger UI. As shown in the following screenshot, try to delete the user named **other10**.

    ![How to do it...](img/B4049_05_17.jpg)

12.  您应该会收到一个 **403(禁止)**响应状态，因为底层服务方法是安全的！
13.  You will see that you haven't been prompted a BASIC login form. Also, take a look at the response headers. You shouldn't see any **WWW-Authenticate** header, which could have triggered this popup.

    ### Tip

    如果用户没有通过身份验证，并且所请求的 HTTP 资源似乎是安全的，则调用`AuthenticationEntryPoint`。仅仅保护服务是不足以让 Spring Security 将控制器方法处理程序视为安全的。

14.  Try to `GET` the users again in the **monitoring** tab. You should see again the BASIC authentication form. Fill it with the following details:

    ```java
    <User Name> admin
    <Password> admin 
    ```

    您现在应该会收到以下带有 **200 状态代码**的响应:

    ![How to do it...](img/B4049_05_18.jpg)

15.  当我们请求 JSON 响应时，Swagger UI 不能美化主体，但是一切都在那里。

### 注意

注意响应代码:**WWW-Authenticate:CSM _ Basic realm " = " cloudstreetmarket . com "**。

## 它是如何工作的...

我们将看到 Spring 安全授权过程是如何工作的，以及如何配置它。

### 春天安全机关

一个 `AuthenticationManager`实现将`GrantedAuthorities`存储到`SecurityContext`中的一个`Authentication`对象中。这些`GrantedAuthorities`由`AccessDecisionManager`读取，试图将它们与访问要求相匹配。

`AccessDecisionManager`实现可以是本地的，也可以是外部的，这解释了为什么基础设施强制将权限呈现为字符串。

如果一个`getAuthority()`方法不能将`GrantedAuthority`表示为一个字符串，那么它应该返回`null`，向`AuthenticationManager`表明它必须支持这种类型的`Authority`。

这种机制将不同的`getAuthority()`实现约束到有限的职责中。

### 配置属性

我们在介绍`GrantedAuthority`对象时提到了配置属性(*通过基本方案*秘籍进行认证)。

配置属性在`SecurityInterceptor`和`AccessDecisionManager`实现中扮演着关键角色，因为`SecurityInterceptor` 委托给了`AccessDecisionManager`。配置属性实现一种方法的`ConfigAttribute`接口:

```java
public interface ConfigAttribute extends Serializable {
  String getAttribute();
}
```

### 注意

配置属性被指定为安全方法上的注释或安全 URL(拦截 URL)上的访问属性。

我们已经在我们的`security-config.xml`文件中定义了下面的指令，作为告诉 Spring Security 期望 web 请求上的配置属性`ROLE_BASIC`匹配`/basic.html`模式的一种方式:

```java
<security:intercept-url pattern="/basic.html" access="hasRole('BASIC')"/>
```

使用默认的`AccessDecisionManager`实现，任何拥有匹配`GrantedAuthority`的用户都将被授予访问权限。

对于基于投票者的`AccessDecisionManager`实现，以前缀`ROLE_`开头的配置属性将被视为一个角色，应该由`RoleVoter`进行检查。我们将在接下来的章节中看到更多关于`AccessDecisionManager`的内容。

SecurityInterceptor 保护安全对象是需要安全检查的对象或动作。框架处理两种类型的安全对象:

*   由**filtersecurityintector**检查的`ServletRequest`或`ServletResponse.`等 Web 资源:一个几乎位于过滤器链末端的核心过滤器。
*   方法调用，它是`org.aopalliance.intercept.MethodInvocation`的实现。这些由**方法安全拦截器**检查。

安全拦截器(方法或 HTTP 请求)在每个安全对象调用实际到达资源之前异步(基于事件)拦截它们。Spring Security 在处理这些调用时总是应用简单的模式。这种模式来自于对`AbstractSecurityInterceptor`子类的使用。

`AbstractSecurityInterceptor`检查采用一致的工作流程来保护物品:

*   查找与相关联的**配置属性**。安全物体。
*   向`AccessDecisionManager`接口提交安全对象、当前认证对象和配置属性，以进行授权决策。
*   可选地改变发生调用的`Authentication`对象。
*   允许安全对象调用继续进行(假设访问被授权)。
*   一旦调用返回，调用`AfterInvocationManager`接口(如果已配置)。如果调用引发了一个异常，那么`AfterInvocationManager`将不会被调用。

该工作流程可以用下图进行总结:

![Configuration attributes](img/B4049_05_20.jpg)

这张图的原图来自 Spring Security reference。这很有趣，因为它强调了在检查安全对象时`SecurityInterceptor`可以使用的不同元素。

### 注意

主要思想是委托给一个`AccessDecisionManager`接口，然后可选地委托给一个`AfterInvocationManager`接口，使用从`SecurityMetadaSource`拉取的属性，并最终使用`AuthenticationManager`能力进行认证。

在极少数情况下，当`SecurityContext Authentication` 对象可能需要改变时，可以选择将`RunAsManager`依赖项添加到`SecurityInterceptor`(工作流的*步骤 3* )。该接口定义如下:

```java
public interface RunAsManager {
  Authentication buildRunAs(Authentication authentication, Object object, Collection<ConfigAttribute> attributes);
  boolean supports(ConfigAttribute attribute);
  boolean supports(Class<?> clazz);
}
```

如果没有为`RunAsManager`设置依赖关系，`SecurityInterceptor`将运行一个`NullRunAsManager`实现。可选地，可以配置一个`AfterInvocationManager`接口，用于改变调用返回的`statusToken`对象(工作流的*步骤 5* )。

### 预调用处理

`AccessDecisionManager`决定是否必须允许访问。

#### AccessDecisionManager

`AccessDecisionManager`接口由`SecurityInterceptor`(在其工作流的*步骤 2* 中)调用，负责做出最终的访问控制决策。

该接口由以下三种方法组成:

```java
public interface AccessDecisionManager {
  void decide(Authentication authentication, Object object, 				Collection<ConfigAttribute> configAttributes) throws AccessDeniedException, InsufficientAuthenticationException;
  boolean supports(ConfigAttribute attribute);
  boolean supports(Class<?> clazz);
}
```

如您所见，方法名称非常明确:

*   `decide`方法为所提供的参数解析访问控制决策。`Authentication`对象表示调用方法的调用者，该对象是要检查的安全对象，`configAttributes`是与安全对象相关联的配置属性。此外，当访问被拒绝时，它抛出一个`AccessDeniedException`。
*   在检查的早期调用`supports(ConfigAttribute attribute)`方法，以确定`AccessDecisionManager`是否可以处理特定的`ConfigAttribute`。
*   在调用之前调用`supports(Class<?> clazz)`方法，以确保配置的`AccessDecisionManager`支持将要呈现的安全对象的类型。

### Tip

当使用名称空间配置时，Spring Security 根据在 intercept-url 和 protect-pointcut 声明中指定的访问属性(如果使用注释来保护方法，则在注释中指定)，自动注册默认的`AccessDecisionManager`实例来评估方法调用和 web 访问。

在下列情况下可以指定特定的或自定义的`AccessDecisionManager`:

*   在 **http** 名称空间上处理 web 资源时:

    ```java
      <security:http ... access-decision-manager-ref"="xxx"">
      </security:http>
    ```

*   在处理方法调用时在**全局方法安全**命名空间上:

    ```java
      <security:global-method-security access-decision-manager-ref""=""... />
    ```

Spring Security 包括三个基于投票的`AccessDecisionManager`实现(`AffirmativeBased`、`ConsensusBased`和`UnanimousBased`)。选民有资格`AccessDecisionVoter`实现。该接口定义如下:

```java
public interface AccessDecisionVoter<S> {
  boolean supports(ConfigAttribute attribute);
  boolean supports(Class<?> clazz);
  int vote(Authentication authentication, S object,
  Collection<ConfigAttribute> attributes);
}
```

一些`AccessDecisionVoter`实现伴随框架而来(`AuthenticatedVoter`、`Jsr250Voter`、`PreInvocationAuthorizationAdviceVoter`、`WebExpressionVoter`、`RoleVoter`等等)。在检查过程中，合格的`AccessDecisionVoters`将被投票表决授权决定。选民资格取决于选民在`AccessDecisionManager.decisionVoters`属性中的登记。这也取决于选民的支持方式。

根据对投票的评估，`AccessDecisionManager`决定是否应该抛出一个`AccessDeniedException`。每个`AccessDecisionVoter`根据不同的标准评估安全对象。

|  | Spring Security 提供的最常用的 AccessDecisionVoter 是简单的 RoleVoter，它将配置属性视为简单的角色名，并在用户被分配了该角色时投票授予访问权限。" |  |
|  | - *春季安全参考* |

### 调用处理后

春安只有一个`AfterInvocationManager`实现:`AfterInvocationProviderManager`。这个类将所有符合条件的`AfterInvocationProvider`实现对齐，让它们有机会改变`SecurityInterceptor`结果。

与 `AccessDecisionManager`界面类似，`AfterInvocationProvider`界面看起来是这样的:

```java
public interface AfterInvocationProvider {
  Object decide(Authentication authentication, Object object, Collection<ConfigAttribute> attributes, Object returnedObject) throws AccessDeniedException;
  boolean supports(ConfigAttribute attribute);
  boolean supports(Class<?> clazz);
}
```

### 基于表达式的访问控制

从 Spring Security 3 开始，现在可以使用 Spring **表达式语言** ( **EL** )来定义 Web 安全性和方法安全性。

|  | *"表达式使用根对象作为评估上下文的一部分进行评估。Spring Security 使用 web 和方法安全的特定类作为根对象，以便提供内置表达式和对值(如当前主体)的访问。* |  |
|  | - *春季安全参考* |

表达式根对象的基类是`SecurityExpressionRoot`。这个抽象类提供了对以下方法和属性的访问，这些方法和属性代表了常见的内置表达式:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表示

 | 

描述

 |
| --- | --- |
| `hasRole([role])` | 如果当前主体具有指定的角色，则返回`true`。默认情况下，如果提供的角色不以`ROLE_`开头，它将被添加。这可以通过修改`defaultRolePrefix onDefaultWebSecurityExpressionHandler`来定制。 |
| `hasAnyRole([role1,role2])` | 如果当前主体具有任何提供的角色(以逗号分隔的字符串列表形式给出)，则返回`true`。默认情况下，如果提供的角色不以`ROLE_`开头，它将被添加。这可以通过修改`DefaultWebSecurityExpressionHandler`上的`defaultRolePrefix`来定制。 |
| `hasAuthority([authority])` | 如果当前主体具有指定的权限，则返回`true`。 |
| `hasAnyAuthority([authority1,authority2])` | 如果当前主体具有任何提供的角色(以逗号分隔的字符串列表形式给出)，则返回`true`。 |
| `principal` | 允许直接访问代表当前用户的主体对象。 |
| `authentication` | 允许直接访问从`SecurityContext`获得的当前`Authentication`对象。 |
| `permitAll` | 总是评估为`true.` |
| `denyAll` | 总是评估为`false.` |
| `isAnonymous()` | 如果当前主体是匿名用户，则返回`true`。 |
| `isRememberMe()` | 如果当前主体是“记住我”用户，则返回`true`。 |
| `isAuthenticated()` | 如果用户不是匿名的，则返回`true`。 |
| `isFullyAuthenticated()` | 如果用户不是匿名用户或“记住我”用户，则返回 `true`。 |
| `hasPermission(Object target, Object permission)` | 如果用户有权访问给定权限的目标，则返回`true`。例如，`hasPermission(domainObject, 'read').` |
| `hasPermission(Object targetId, String targetType, Object permission)` | 如果用户有权访问给定权限的目标，则返回`true`。比如`hasPermission(1,'com.example.domain.Message', 'read')`。 |

#### 网络安全表达式

使用 Spring 安全名称空间，`<http>`块有一个默认为 true 的`use-expression`属性。该属性使得`intercept-url`元素中的访问属性需要表达式作为值。

对于 Web 安全，表达式根对象的基类是`WebSecurityExpressionRoot`，它继承了 `SecurityExpressionRoot` 的方法，并提供了一个额外的方法:`hasIpAddress(…)`。

此外，`WebSecurityExpressionRoot`在评估上下文中公开了在名称`request`下可访问的`HttpServletRequest`对象。

如果表达式正在被使用，一个`WebExpressionVoter`将被添加到`AccessDecisionManager`中。

#### 方法安全表达式

在 Spring Security 3.0 中引入了用于方法安全性的表达式。四种安全注释支持使用表达式:`@PreAuthorize`、`@PostAuthorize`、`@PreFilter`和`@PostFilter`。

##### 使用@PreAuthorize 和@PostAuthorize 进行访问控制

这些注释的使用必须在全局安全 bean 中被激活:

```java
<security:global-method-security pre-post-annotations"="enabled"">
```

`@PreAuthorize` 通常用于允许或禁止方法调用。

我们在`MonitoringController`类上实现了这个注释:

```java
@PreAuthorize("hasRole('ADMIN')")
public class MonitoringController extends CloudstreetApiWCI{
  ...
}
```

指定的表达式`hasRole('ADMIN')`意味着只允许角色`ROLE_ADMIN`内的用户访问控制器。

### Tip

你可以注意到`ROLE` _ 的自动前缀避免了单词重复。这个很好的特性可以用在表达式中，包括 web 安全性(intercept-url: access 属性)和方法安全性。

让我们也考虑一下 Spring 安全参考文档中的这个例子:

```java
@PreAuthorize("hasPermission(#contact, 'admin')")
public void deletePermission(Contact contact, Sid recipient, Permission permission);
```

这里，一个方法参数被传递到表达式中，以决定当前用户是否拥有给定联系人的`admin`权限。

`@PostAuthorize`不太常用，但是可以在方法被调用后执行访问控制检查。要访问表达式中的`AccessDecisionManager`返回值，请使用内置名称`returnObject`。

##### 使用@PreFilter 和@PostFilter 过滤集合

现在可以依靠 Spring Security 来过滤可能从方法调用返回的集合(使用表达式)。

考虑参考文档中的这个示例:

```java
@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
public List<Contact> getAll();
```

Spring Security 遍历返回的集合，并删除任何提供的表达式为 false 的元素。name filter 对象是指集合中的当前对象。您还可以在方法调用之前使用`@PreFilter`进行过滤，尽管这是一个不太常见的要求。

实际上，为了在表达式中使用`hasPermission()`的，需要在应用上下文中显式配置一个`PermissionEvaluator` 。以下代码是一个示例:

```java
<security:global-method-security...>
  <security:expression-handler ref="expressionHandler"/>
</security:global-method-security>
<bean id="expressionHandler" class="org.sfw.security.access.expression.method.DefaultMethod SecurityExpressionHandler">
  <property name="permissionEvaluator" ref="myPermissionEvaluator"/>
</bean>
```

其中`myPermissionEvaluator`是一个`PermissionEvaluator`实现:

```java
public interface PermissionEvaluator extends AopInfrastructureBean {
  boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission);
  boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission);
}
```

### JSR-250 和遗产法安全

JSR-250 是一个于 2006 年发布的 Java 规范请求。它指定了一组注释来处理常见的语义模式。在这些注释中，有些与安全性有关:

<colgroup><col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

注释名称

 | 

描述

 |
| --- | --- |
| `RolesAllowed` | 指定允许访问应用中的方法的安全角色 |
| `PermitAll` | 指定允许所有安全角色访问带注释的方法或带注释的类中的所有方法 |
| `DenyAll` | 指定不允许任何安全角色调用指定的方法 |
| `DeclareRoles` | 用于指定应用的安全角色 |

Spring Security 支持这些注释，但是这种支持必须被激活:

```java
<security:global-method-security jsr250-annotations"="enabled""…/>
```

如果启用的话，Spring Security 还支持它的传统注释:

```java
<security:global-method-security secured-annotations"="enabled""…/>
```

## 还有更多…

### 域对象安全(ACL)

一些更复杂的应用可能需要做出授权决定，这取决于方法调用的实际域对象:

[http://docs . spring . io/spring-security/site/docs/current/reference/html single/# domain-ACLs](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#domain-acls)

### 春埃尔

你可能需要找到更多关于 Spring EL 的信息:

[http://docs . spring . io/spring/docs/current/spring-framework-reference/html/expressions . html](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html)

### 春天的安全参考

Spring 和安全参考以及 Spring JavaDoc 是这个菜谱的主要信息来源。我们希望您喜欢我们的信息选择、分析和观点。

[http://docs . spring . io/spring-security/site/docs/current/API docs/](http://docs.spring.io/spring-security/site/docs/current/apidocs/)

[http://docs . spring . io/spring-security/site/docs/current/reference/html single](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle)

## 参见

*   Hierarchical Roles and role nesting appear to be recurring requirements:

    [http://docs . spring . io/spring-security/site/docs/current/reference/html single/# authz-hierarchical-roles](http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authz-hierarchical-roles)