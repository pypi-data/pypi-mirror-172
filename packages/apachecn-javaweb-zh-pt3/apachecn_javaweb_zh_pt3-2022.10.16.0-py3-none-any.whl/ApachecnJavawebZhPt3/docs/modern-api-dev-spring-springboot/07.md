# 七、设计用户界面

在前一章中，您使用 Spring Security 实现了身份验证和授权，这也包括了所有示例电子商务 app **应用编程接口**(**API**)。在本章中，您将使用 React 库开发一个示例电子商务应用的前端。然后，这个**用户界面** ( **UI** )应用将使用前一章中开发的 API、 [*、第 6 章*](06.html#_idTextAnchor134) 、*安全(授权和认证)*。这个 UI 应用将是一个**单页应用** ( **SPA** )，由交互组件组成，如**登录**、**产品列表**、**产品详情**、**购物车**和**订单列表**。本章将总结端到端的开发和在线购物应用不同层之间的通信。在本章结束时，你将学习到 SPAs，使用 React 开发 UI 组件，以及使用浏览器内置的`Fetch` API 使用**表述性状态转移**(**REST**)API。

本章将涵盖以下主题:

*   学习反应基础
*   探索 React 组件和其他功能
*   设计电子商务应用组件
*   使用 Fetch 使用 API
*   实现身份验证

# 技术要求

开发和执行代码需要以下先决条件:

*   您应该熟悉 JavaScript—数据类型、变量、函数、循环和数组方法，如`map()`、`Promises`和`async`等等。
*   Node.js 14.x 带**节点包管理器** **(npm)** 6.x(还有可选的`yarn`，可以用`npm install yarn -g`安装)。
*   **Visual Studio 代码** ( **VS 代码**)——一个免费的源代码编辑器。
*   当你使用`create-react-app`时，反应 17 个将被包括的库。

让我们开始吧！

请访问以下链接查看代码:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 07/ecomm-ui](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter07/ecomm-ui)

# 学习反应基础知识

React 是一个声明性库，用于构建交互式动态 ui，包括独立的小组件。有时，它也被称为框架，因为它能够与其他 JavaScript 框架(如 AngularJS)相媲美。然而，React 是一个与其他受支持的 React 库(如 React Router、React Redux 等)一起工作的库。您通常使用它来开发 spa，但是它也可以用于开发全栈应用。

React 的被用于构建应用的视图层，按照**模型-视图-控制器** ( **MVC** )架构。您可以构建具有自己状态的可重用 UI 组件。你可以使用普通 JavaScript 和**超文本标记语言** ( **HTML** )或者 **JavaScript 语法扩展** ( **JSX** )进行模板化。在这一章中，我们将使用 JSX。它使用一个**虚拟文档对象模型** ( **VDOM** )进行动态变化和交互。

让我们使用`create-react-app`实用程序创建一个新的 React 应用。它搭建并提供了您将用来开发示例电子商务应用前端的基本应用结构。

## 创建 React 应用

您可以从头开始配置和构建 React UI 应用。然而，React 提供了一个`create-react-app`实用程序，用于引导和构建一个基本的运行示例应用。您可以进一步使用它来构建一个完整的 UI 应用。

其语法如下所示:

```java
npx create-react-app <app name>
```

**npm 包执行程序** ( **NPX** )是一个工具，它允许你使用**命令行界面** ( **CLI** )工具和 npm 注册表中可用的其他可执行文件。默认情况下，npm 5.2.0 提供了它，否则您可以使用`npm i npx`来安装它。因此，它直接执行`create-react-app` React 包。

使用 npm 代替纱线

默认情况下，`create-react-app`使用`yarn`包作为包管理器。但是，如果您愿意，也可以通过以下命令使用 npm:

`npx create-react-app ecomm-ui --use-npm`

现在，让我们用这个命令创建一个`ecomm-ui`应用:

```java
$ npx create-react-app ecomm-ui
Creating a new React app in C:\modern-api-with-spring-and-sprint-boot\Chapter07\ecomm-ui.
Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...
yarn add v1.22.5
[1/4] Resolving packages...
[2/4] Fetching packages...
[3/4] Linking dependencies...
[4/4] Building fresh packages...
success Saved lockfile.
success Saved 297 new dependencies.
info Direct dependencies
├─ cra-template@1.1.1
├─ react-dom@17.0.1
├─ react-scripts@4.0.1
└─ react@17.0.1
info All dependencies 
├─ @babel/compat-data@7.12.7
├─ @babel/core@7.12.10
├─ <Output truncated for brevity>
├─ yargs-parser@18.1.3
└─ yocto-queue@0.1.0
Done in 644.56s.
```

在安装了所有必需的依赖包之后，它继续安装模板依赖项，如下所示:

```java
Installing template dependencies using yarnpkg...
yarn add v1.22.5
[1/4] Resolving packages...
[2/4] Fetching packages...
[3/4] Linking dependencies...
[4/4] Building fresh packages...
success Saved lockfile.
success Saved 15 new dependencies.
info Direct dependencies
├─ @testing-library/jest-dom@5.11.9
├─ @testing-library/react@11.2.3
├─ @testing-library/user-event@12.6.0
└─ web-vitals@0.2.4
info All dependencies
├─ @testing-library/dom@7.29.4
├─ @testing-library/jest-dom@5.11.9
├─ <Output truncated for brevity>
├─ strip-indent@3.0.0
└─ web-vitals@0.2.4
Done in 109.90s.
```

它还可能要求您添加一些测试依赖项——您可以使用以下命令来安装它们:

```java
yarnpkg add @testing-library/jest-dom@^5.11.4 @testing-library/react@^11.1.0 @testing-library/user-event@^12.1.10 web-vitals@^0.2.4
```

安装成功后，您可以转到`app`目录，通过运行以下代码启动使用`create-react-app`安装的应用:

```java
$ cd ecomm-ui
$ code .
```

`code .`命令在 VS 代码中打开`ecomm-ui` app 项目。然后，您可以使用以下命令启动开发服务器:

```java
$ yarn start
```

一旦服务器成功启动，它将在您的默认浏览器上用`localhost:3000`打开一个新的选项卡，如下面的屏幕截图所示:

![Figure 7.1 – Default UI app created by the create-react-app utility ](img/Figure_7.1_B16561-CV111.jpg)

图 7.1–由 create-react-app 实用程序创建的默认 UI 应用

我们的 bootstrapped React UI 已经启动并运行，但是现在您需要理解由`create-react-app`生成的基本概念和文件，然后才能在其上构建电子商务 UI 应用。

## 探索基本结构和文件

一个搭建的 React 应用在根项目目录中包含以下目录和文件:

```java
ecomm-ui
├── README.md
├── node_modules
├── package.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── logo192.png
│   ├── logo512.png
│   ├── manifest.json
│   └── robots.txt
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    ├── reportWebVitals.js
    └── setupTests.js
```

让我们来了解一下主要部分，如下:

*   `node_modules`:你不要在这里做任何改动。基于节点的应用在这里保存所有相关包的本地副本。
*   `public`:这个目录包含了一个应用在这里的所有静态资产，包括`index.html`、图片、favicon 图标、`robots.txt`。
*   `src`:这个目录包含了所有的动态代码，包括 React 代码和**层叠样式表** ( **CSS** )(包括**合成牛逼样式表** ( **Sass** )， **Leaner 样式表** ( **少**， so on)。它还包含测试代码。
*   `package.json`:这个 **JavaScript 对象符号** ( **JSON** )文件包含了所有的元数据、命令(在`scripts`里面)、依赖包(在`dependencies`和`dev-dependencies`里面)。

您可以从`src`目录中删除`serviceWorker.js`文件(如果生成的话)、`logo.svg`文件和测试文件，因为我们在本章中不会用到它们。

让我们在下一小节中了解一下`package.json`文件。

## 了解 package.json 文件

您还可以查看包含`dependencies`和`dev-dependencies`字段下所有依赖项的`package.json`文件。它本质上类似于`build.gradle`文件。

主要的 React 库是`react`和`react-dom`，在`dependencies`字段中提到；这些分别用于 React 和虚拟 DOM。

`package.json`还包含一个`script`字段，其中包含您可以在该应用上执行的所有命令。我们使用了`yarn start`命令在开发模式下启动应用。类似地，您可以使用`yarn`和`npm`执行其他命令，如下面的代码块所示:

```java
"scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
},
```

`react-scripts`是由`create-react-app`实用程序安装的 CLI 软件包。它包含许多依赖项，这里列出了几个主要的依赖项:

*   **web pack**([https://webpack.js.org/](https://webpack.js.org/)):这个是一个模块捆绑器捆绑 JavaScript、CSS、图片、HTML 等等。CSS 和图像可能需要额外的加载器作为依赖。例如，它将挑选所有的 JavaScript 文件，并将它们捆绑到一个 JavaScript 文件中，尽管您可以通过使用`webpack.config.js`配置定制它捆绑它们的方式。
*   **Jest**([https://jestjs.io/](https://jestjs.io/)):Jest 是一个由脸书维护的 JavaScript 测试框架。
*   ESLint(【https://eslint.org/】T2):ESLint 是一个 linter，允许你保持代码质量。它非常类似于 Java 世界中的 Checkstyle。
*   Babel([https://babeljs.io/](https://babeljs.io/)):Babel 是一个 JavaScript transcompiler 工具，将 JavaScript 代码转换成向后兼容的 JavaScript 代码。最新的 JavaScript 草案版本是 **ECMAScript 2020** ，也被称为 **ES10** 。最新的 JavaScript 稳定版是**ECMAScript 2018**(**ES9**)。Babel 允许您从使用最新版本编写的 JavaScript 代码中生成优化的向后兼容代码。

你可以在`package.json`的`dependencies`栏的下找到`react-scripts`。让我们来理解这些命令，如下所示:

*   `start`:该命令允许您在节点环境中启动开发服务器。它还提供了热重新加载特性，这意味着对 React 代码的任何更改都将反映在应用中，而不需要重启。因此，如果有任何林挺或代码问题，这将相应地显示在控制台(终端窗口)和 web 浏览器中。
*   `build`:该命令打包 React 应用代码，用于生产部署。它将一个 CSS 文件中的 JavaScript 文件捆绑到另一个 CSS 文件中，并缩小和优化代码文件。然后，您可以使用这个包在任何 web 服务器上进行部署。
*   `test`:该命令使用测试运行器(Jest 工具)执行测试。它执行所有扩展名为`.test.js`或`.spec.js`的测试文件。
*   `eject` : React 自带默认构建配置，比如`webpack`、`Babel`等等。构建配置实现了优化构建应用的最佳实践。此命令帮助您弹出隐藏的配置，之后您可以重写和自定义构建配置。然而，你应该非常小心地做这件事，因为这是一个单向的活动，你不能逆转它。

在下一小节中，让我们了解 React 是如何工作的。

## 了解 React 的工作原理

网页只不过是一个 HTML 文档。HTML 文档包含 DOM，一种 HTML 元素的树状结构。对 DOM 的任何更改都会反映在浏览器中 HTML 文档的呈现中。在实际的 DOM 中进行更改——具体到第 *n* 级——在遍历和呈现 DOM 方面是一项繁重的操作，因为每次更改都是在整个 DOM 上进行的，这是一项耗时且消耗内存的操作。

React 使用一个 **VDOM** 来使这些操作变得轻量级。VDOM 是实际 DOM 的内存副本。React 使用`react-dom`包维护 VDOM。因此，当初始化 React 应用时，首先将根 HTML 元素 ID 传递给`ReactDOM`对象的`render`函数。React 在第一次渲染后将 VDOM 写到这个根元素下。

在第一次渲染之后，根据对 React 组件及其状态的更改，只有必要的更改才会写入实际的 DOM。React components 的`render` 函数以 JSX 语法返回标记。然后，React 将其转换为 HTML 标记，并将生成的 VDOM 与实际的 HTML DOM 进行比较，只对实际的 DOM 进行必要的更改。这个过程一直持续到组件被改变。让我们探索第一次渲染是如何发生的。

### React 应用的引导

`public`目录下的`index.html`文件包含主 HTML 文件。它是一个应用框架，包含站点`title`、`meta`元素、`body`元素和 ID 为`root`的`body`下的`div`元素。您将这个根元素传递给`index.js`目录中`ReactDOM`的`render`函数。**这是 React app 的入口点**。让我们来看看它的代码，如下:

```java
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
ReactDOM.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/index.js

这里，React 使用来自`react-dom`包的`ReactDOM`对象来呈现页面。`render()`函数包含两个参数:`element`和`container`。它还可以有第三个(可选的)回调参数。

您正在将一个用 React 的严格模式组件包装的`<App />`标签组件作为一个`element`参数传递给`index.html`的`<body>`元素内的一个`<div id= "root">`作为一个`container`参数传递给`render`函数。

App 组件可以是单个组件，也可以是带有单层或多层子组件的父组件。单个组件不会包含任何其他反应组件；它只会包含 JSX，仅此而已。但是，父组件可能包含一个或多个子组件，而这些子组件可能包含一个或多个子组件，依此类推。例如，`App`组件可能有页眉、页脚和内容组件。一个`content`组件可能有一个`cart`组件，然后`cart`组件内部可能有项目。

`<React.StrictMode>`组件是一个特殊的 React 组件，它在开发模式下被渲染两次，以检查 React 组件中的最佳实践、不推荐使用的方法和潜在风险，并在控制台日志中打印警告和建议。它对生产构建没有影响，因为它只在开发模式下工作。

`render`函数将`app`组件的 JSX 转换为 HTML，并将其添加到`<div id="root"> tag`中，然后它将 VDOM 与真实的 DOM 进行比较，并在真实的 DOM 中进行必要的更改。这就是 React 组件在浏览器上呈现的方式。

您现在了解了 React 组件在这里是关键。让我们在下一部分深入探讨它们。

# 探索 React 组件和其他功能

每个页面都是使用 React 组件构建的，例如，亚马逊的**产品列表页面可以大致分为页眉、页脚、内容、产品列表、过滤和排序选项以及产品卡组件。您可以通过两种方式在 React 中创建组件:使用 JavaScript 类或使用函数。**

让我们在 React 中创建一个带有函数和类的示例 header 组件。

你可以写一个普通的 JavaScript 函数，也可以写 **ECMAScript 6** ( **ES6** )箭头函数。我们将主要使用箭头函数。在下面的代码片段中，使用 JavaScript arrow 函数检查`Header`组件:

```java
export const Header = (props) => {
  return (
    <div>
      <h1>{props.title}</h1>
    <div>
  )
}
```

让我们使用一个 JavaScript 类创建和相同的`Header`组件，如下所示:

```java
export default class Header extends React.Component {
  render() {
    return (
      <div>
        <h1>{this.props.title}</h1>
      <div>
    )
  }
}
```

让我们逐点理解这两个函数，如下所示:

*   两者都返回看起来类似于 HTML 的 JSX，它实际上是在转换后呈现的。
*   两者都分别导出函数和类，以便它们可以被其他组件导入。
*   两者都有道具——一个作为参数，另一个绑定了一个`this`范围，它是`React.Component`的一部分。道具代表属性和它们的值——例如，这里使用了一个`title`属性。当它被渲染时，它被替换为`title`属性的值。
*   该类需要一个`render()`函数，而该函数只需要一个`return`语句。

让我们看看如何使用`Header`组件。您可以像在 JSX 代码中使用任何其他 HTML 标记一样使用这个`Header`组件，如下所示:

```java
<Header title="Sample Ecommerce App" />
```

当这个`Header`组件被渲染时，它将显示包装在`<H1>`元素中的标题。

接下来让我们探索一下 JSX。这是使用 props 的方法:在使用组件时，将一个属性(比如 title)添加到它的值中。在组件内部，您可以通过直接使用`props`或在功能组件中使用`{ title }`析构形式以及在类组件中使用`this.props`来访问这些属性。

## 探索 JSX

反应组件将返回 JSX。您可以编写 HTML 代码来设计组件，因为除了 HTML 属性之外，JSX 与 HTML 非常相似。因此，您需要确保更新属性，例如将`class`更新为`className`、`for`更新为`htmlFor`、`fill-rule`更新为`fillRule`等等。使用`React.StrictMode`组件的好处是，如果您使用 HTML 属性或者有拼写错误，您会得到一个警告和使用正确的 JSX 属性名称的建议。

您还可以将任何 JavaScript 表达式放入 JSX 或元素的属性中，通过使用花括号(`{}`)中的表达式使组件动态化。

让我们看一些样本代码来理解 JSX 和表达式。下面的 JSX 代码片段摘自`CartItem`组件。检查突出显示的表达式代码；剩下的代码是 JSX，非常类似于 HTML:

```java
<div className="w-32">
   <img className="h-24" src={item?.imageUrl} alt="" /> 
</div>
<div className="flex flex-col justify-between ml-4 flex-
        grow">
   <Link to={"/products/" + item.id} className="font-bold 
        text-sm text-indigo-500 hover:text-indigo-700"> 
      {item?.name} 
   </Link>
   <span className="text-xs">Author: {author}</span> 
   <button className="font-semibold hover:text-red-500 
       text-indigo-500 text-xs text-left" onClick={() => 
 removeItem(item.id)}> 
      Remove
   </button>
</div>
```

前面的代码片段表示一个购物车条目，它显示了产品图片、产品名称、作者和**删除**按钮。产品名称也是链接到产品详细信息页面的链接。您可以使用 JSX(读取 HTML)进行设计，如图所示。还请注意，`class`属性名被更改为`className`，因为它是一个 JSX。`Link`是`react-router-dom`图书馆的一部分。

您已经完成了购物车物品的设计部分。现在，您需要一种机制来填充这些值，并在其中添加事件处理。这就是 JSX 表达帮助你的地方。

您使用了`item`—一个表示购物车商品的对象，以及`author`—一个包含作者姓名的变量。两者都是 React 组件状态的一部分。您将在下一小节中了解更多关于状态的信息，但是现在您可以把它们看作是在`CartItem`组件中定义的变量。一旦编写了 JSX(读取 HTML)，动态值(来自变量)和交互(针对事件)就可以使用花括号(`{}`)中的表达式来定义。

接下来让我们来理解每个表达式，如下所示:

*   `src={item?.imageUrl}`:你得到物品(产品)图像**统一资源定位符** ( **URL** )作为 API 响应的一部分。您只需将它赋给`img`标签的`src`属性。请注意，点运算符(`.`)允许您访问对象的属性。如果您尝试读取任何 null 或未定义对象的属性，代码可能会引发错误。您可以通过使用`?.`操作符来避免这种情况。那么，只有当一个对象(在这里是`item`)不为空或未定义时，属性(在这里是`imageUrl`)才会被读取。
*   `to={"/products/" + item.id}`:在这里，通过使用对象项目的`id`属性来形成到属性的链接。
*   `{item?.name}`:这里使用`item`对象的`name`属性显示产品名称。
*   `Author: {author}`:使用`author`变量显示作者值。
*   `onClick={() => removeItem(item.id)}`:这是你将一个用户自定义函数与一个事件关联起来的方式。这里，`removeItem()`将通过单击按钮传递项目对象的`id`属性来调用。如果您没有传递任何参数或使用多个语句，那么您可以直接传递函数名，而不是使用 arrow 函数—例如，`onClick={removeItem}`。

接下来，我们将深入了解 React 组件的状态。让我们看看这是如何工作的。

## 探索组件的状态

组件是动态的，包含一个状态。状态表示组件在给定时间点保存的数据和元数据。有两个级别的状态:全局(应用级别)状态和局部(组件级别)状态。

早期(React 版之前)，状态仅在使用类定义的组件中受支持。现在，React 支持函数组件和类组件中的状态。React 使用诸如`useState()`、`useContext()`等钩子支持功能组件中的状态。

React 在 16.8 版本中引入了钩子(一组函数)，它为功能组件引入了许多早期不支持的功能，例如状态和类似于`componentDidMount`的事件(类中的一个生命周期方法，指示组件已被挂载)，现在可以执行某些操作，例如使用 API 加载数据，等等。

接下来让我们来理解 React 挂钩。

### 钩住

钩子是 React 版本 16.8 以后提供的特殊的 React 函数。每个挂钩代表一个可以在功能组件中使用的特殊特性。让我们来逐一了解一下最流行最常见的挂钩，如下:

*   `useState`: `useState` allows you to define and maintain the state. Let's see how you can use this hook. First, you import the `useState` hook at the top of the component code file, as follows:

    ```java
    import {useState} from "react"; 
    ```

    接下来，在组件的箭头函数代码中，定义`return`语句之前的状态，如下所示:

    ```java
    const [total, setTotal] = useState(0);
    ```

    在声明状态时，需要在数组中定义状态和状态设置函数。这里，`total`状态是用它的`setter`函数定义的。您可以使用任何类型的状态，如对象、数组、字符串或数字。`total`状态属于`number`类型，因此用`0`进行初始化。`setTotal`是一个 setter 函数。`setter`函数允许您更新状态(此处为`total`)，例如，您可以通过调用`setTotal(100)`来更新总状态，然后`total`状态将从`0`变为`100`。

    React 跟踪状态的`setter`函数，每当它被调用时，React 更新组件的状态并重新呈现组件。`setter`函数的命名约定是在州名前面加上`set`，并使州名的第一个字母大写。因此，我们使用了`setTotal`作为`total`州的名称。在大多数组件中，您将使用`useState`进行本地状态管理。

*   `useEffect`:当你在渲染一个组件后想要做什么的时候，你使用一个`useEffect()`钩子。每次渲染后都会调用这个函数。当您想要从 API 加载初始数据或添加事件侦听器时，也可以使用它。然而，如果应该进行一次 API 调用，那么您可以在调用时传递空数组(`[]`)依赖。当为单个调用传递一个空数组时，您会在`ecomm-ui`代码中发现多个`useEffect`实例。
*   React 建议在组件内部使用多个`useEffect`函数来分离关注点。此外，确保它返回一个用于清理的箭头函数。例如，当您为任何组件添加事件侦听器时，它应该返回一个删除事件侦听器的箭头函数。
*   你可以将道具从一个组件传递到另一个组件。有时候，你不得不使用道具钻到第 *n* 级。React 还提供了定义这些属性的另一种方法，这样它们就可以在树中的任何组件中使用，而无需使用属性钻取。你可以将它用于跨组件通用的道具，比如`theme`或`isUserLoggedIn`。
*   React provides a `createContext()` function to create a context. It returns a provider and consumer to provide access to its values and changes respectively (see the next code block). However, `useContext` can easily make use of the context by removing usage of the consumer. The following code snippet depicts `useContext` usage:

    ```java
    import {createContext} from "react";
    import ReactDOM from "react-dom";
    const LoggedInContext = createContext();
    const App = () => {
       return (
          <LoggedInContext.Provider isUserLoggedIn=true>
             <ProductList/>
          <LoggedInContext.Provider/>
       );
    }
    const ProductList = () => {
       return (
     <LoggedInContext.Consumer> { (isUserLoggedIn) => 
     <div>Is user logged-in: {isUserLoggedIn}</div>
     } <LoggedInContext.Consumer>
       );
    }
    ReactDOM.render(<App/>, 
        document.getElementById("root"));
    ```

    您可以用`useContext`简化之前代码片段中`ProductList`组件的`return`块(检查高亮显示的代码)，如下所示:

    ```java
    import {createContext, useContext} from "react";
    import ReactDOM from "react-dom";
    const LoggedInContext = createContext();
    const App = () => {
       return (
          <LoggedInContext.Provider isUserLoggedIn=true>
             <ProductList/>
          <LoggedInContext.Provider/>
       );
    }
    const ProductList = () => {
     const isUserLoggedIn = useContext(LoggedInContext); 
     return (
     <div>Is user logged-in: {isUserLoggedIn}</div>
     );
    }
    ReactDOM.render(<App/>, document.getElementById("root"));
    ```

    这就是如何使用`createContext`和`useContext`钩子。

*   `useReducer`: This is an advanced version of the `useState` hook that not only allows you to use a component's state but also provides better controls to manage its state by taking the `reducer` function as a first argument. It takes the initial state as a second argument. Check out its syntax, as seen in the following code block:

    ```java
    const [state, dispatch] = useReducer(reducer, initialState);
    ```

    `reducer`函数是一个特殊的函数，它以状态和动作作为参数，返回一个新的状态。当我们在本章后面构建`CartContext`组件时，我们将对此进行更深入的探讨。

现在您已经学习了 React 的基本概念，让我们使用`TailwindCSS`为`ecomm-ui`应用添加一些样式。

## 使用顺风设计组件

Tailwind CSS 是一个实用的 CSS 框架，它可以帮助你设计一个反应灵敏的 UI。它支持主题化、动画、预定义的填充和边距、伸缩、网格等等。您可以使用`yarn`安装 Tailwind 及其对等包，如下面的代码片段所示(从项目根目录执行):

```java
$ yarn add -D tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9
```

`create-react-app`在撰写本章时还不支持 PostCSS 8，所以你需要暂时安装带有 PostCSS 7 兼容性构建的 Tailwind CSS v2.0，如前面的代码片段所示。但是，一旦`create-react-app`开始支持它(版本 8+)，就可以将其更改为适当的 PostCSS 版本。

配置顺风构建需要 **Create React App 配置覆盖** ( **CRACO** )包。

### 安装和配置 CRACO

你还需要安装到安装 CRACO 来配置顺风构建，因为`create-react-app`不允许你在本地覆盖 PostCSS 配置。CRACO 允许您覆盖由`create-react-app`创建的配置。让我们通过从项目根目录执行以下命令来安装它:

```java
$ yarn add -D @craco/craco
```

安装成功后，您可以更新`package.json`文件中的`scripts`，将除`eject`之外的所有脚本的`react-scripts`替换为`craco`，如下所示:

```java
  {
    ...
    ...
    "scripts": {
     "start": "craco start",
     "build": "craco build",
     "test": "craco test",
     "eject": "react-scripts eject"
    },
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/package.json

接下来，在项目的根目录下创建一个名为`craco.config.js`的文件，并添加`tailwindcss`和`autoprefixer`作为`postcss`插件，如下所示:

```java
module.exports = {
  style: {
    postcss: {
      plugins: [
        require('tailwindcss'),
        require('autoprefixer'),
      ],
    },
  },
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/craco.config.js

现在，您可以创建一个顺风配置文件。

### 创建顺风配置文件

您可以使用以下命令创建并初始化`tailwind.config.js`文件:

```java
npx tailwindcss init
```

这将用最少的配置在项目的根目录下创建一个默认的`tailwind.config.js`文件，如下面的代码片段所示:

```java
module.exports = {
  purge: [],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/tailwind.config.js

现在，我们可以添加配置来清除生产中未使用的样式。

# 删除生产中未使用的样式的配置

您希望在生产环境中保持较小的样式表大小，因为这可以提高应用的性能。您可以通过在`tailwind.config.js`文件中添加以下清除块来清除不必要的样式。然后，Tailwind 可以在构建生产版本时对未使用的样式进行树抖动。对于生产构建，您可以将环境变量`PURGE_CSS`设置为`production`。下面的片段展示了这段代码:

```java
  module.exports = {
    purge: {
 enabled: process.env.PURGE_CSS === "production" ? true 
 : false,
 content: ["./src/**/*.{js,jsx,ts,tsx}", 
 "./public/index.html"],
 },
    darkMode: false, // or 'media' or 'class'
    theme: {
      extend: {},
    },
    variants: {
      extend: {},
    },
    plugins: [],
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/tailwind.config.js

接下来，我们将添加顺风反应。

## 反应中包括顺风

打开`create-react-app`默认为您生成的`src/index.css`文件，导入顺风的基础、组件和工具样式，替换原来的文件内容，如下:

```java
@import "tailwindcss/base";
@import "tailwindcss/components";
@import "tailwindcss/utilities";
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/index.css

当您执行构建时，这些语句根据顺风配置导入构建生成的样式。

最后，通过运行以下代码，确保将 CSS 文件导入到`src/index.js`文件中:

```java
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './index.css';
  import App from './App';
  import reportWebVitals from './reportWebVitals';
  ReactDOM.render(
    <React.StrictMode>
      <App />
    </React.StrictMode>,
    document.getElementById('root')
  );
  ...
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/index.js

搞定了。接下来，你可以执行`yarn run start`来使用`ecomm-ui`应用中的 Tailwind CSS。

### 添加基本组件

首先，删除由`create-react-app`创建的以下文件:

*   `App.css`
*   `logo.svg`

不要忘记也从`/src/App.js`中删除这些文件引用。

然后，在`/src`下创建一个新的`components`目录。您将在该目录下创建所有的新组件，如图*图 7.2* 所示。让我们创建三个新组件，如下所示:

*   `Header`:显示在顶部，包含 app 名称、**登录** / **注销**按钮等标题项。
*   `Container`:包含主要内容，如产品列表。
*   `Footer`:显示在底部，包含版权信息等页脚项。
*   基本结构可以在下面的截图中看到:

![Figure 7.2 – Basic structure of app containing Header, Footer, and Container components ](img/Figure_7.2_B16561-CV111.jpg)

图 7.2–包含页眉、页脚和容器组件的应用的基本结构

*   让我们添加这些容器。首先，我们将创建一个`Header`组件，如下面的代码片段所示:

```java
const Header = () => {
  return (
    <div>
      <header className="p-2 border-b-2 border-gray-300 bg-
          gray-200">
        <h1 className="text-lg font-bold">Ecommerce 
            App</h1>
      </header>
    </div>
  );
};
export default Header;
```

类似地，您可以创建一个`Footer`组件，如下面的代码片段所示:

```java
const Footer = () => {
  return (
    <div>
      <footer className="text-center p-2 border-t-2 bg-
        gray-200 border-gray-300 text-sm">
        No &copy; by Ecommerce App.{" "}
        <a href="https://github.com/PacktPublishing/Modern-
            API-Development-with-Spring-and-Spring-Boot">
          Modern API development with Spring and Spring Boot
        </a>
      </footer>
    </div>
  );
};
export default Footer;
```

类似地，您可以创建一个`Container`组件，如以下代码片段所示:

```java
const Container = () => {
  return (
    <div className="flex-grow flex-shrink-0 p-4">
      <p>Hello, text/element would appear in container</p>
    </div>
  );
};
export default Container;
```

最后，您可以修改`the /src/App.js`文件，如下面的代码片段所示:

```java
import Header from "./components/Header";
import Footer from "./components/Footer";
import Container from "./components/Container";
function App() {
  return (
    <div className="flex flex-col min-h-screen h-full">
      <Header />
      <Container />
      <Footer />
    </div>
  );
}
export default App;
```

这就是你如何创建和使用新组件的方法。这些组件都是以最简单的形式保存的，这样更容易理解。但是，您可以在 GitHub 上找到这些组件的优化和改进版本，如下所示:

*   **Header 组件源**:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/components/Header . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Header.js)
*   **页脚组件源**:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/components/Footer . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Footer.js)
*   `Container`组件(在中间包含实际内容)将被来自`react-router-dom`的组件`switch`所替换，该组件将根据给定的路径显示组件，比如购物车、订单和登录。

现在，您可以开始实际的`ecomm-ui`开发了。

# 设计电子商务应用组件

设计不仅仅是用户体验的关键部分，对前端开发者来说也很重要。基于这种设计，您可以创建可重用和可维护的组件。然而，一个示例电子商务应用是一个简单的应用，不需要太多的关注。您将在该应用中创建以下组件:

*   **产品列表组件**:一个显示所有产品的组件，同时也是一个主页。列表中的每个产品都将显示为一张卡片，上面有产品名称、价格和两个按钮— **立即购买**和**添加到包中**。下面的屏幕截图显示了**产品列表**页面，该页面显示了产品信息以及产品图片:

![Figure 7.3 – Product listing page (home page) ](img/Figure_7.3_B16561.jpg)

图 7.3–产品列表页面(主页)

*   **产品细节组件**:这是一个组件，显示被点击产品的细节。它显示产品图片、产品名称、产品描述、标签以及**立即购买**和**添加到袋子**按钮，如下所示:

![Figure 7.4 – Product detail page ](img/Figure_7.4_B16561.jpg)

图 7.4–产品详细信息页面

*   **登录组件**:登录组件允许用户使用用户名和密码登录应用，如下图所示。当登录尝试失败时，它会显示一条错误消息。点击**取消**返回到**产品列表**页面。**产品列表**页面显示了客户可以购买的产品列表:

![Figure 7.5 – Login page ](img/Figure_7.5_B16561.jpg)

图 7.5–登录页面

*   **购物车组件**:购物车组件列出了已经添加到购物车中的所有商品。每个项目显示产品图像、名称、描述、价格、数量和总数。它还提供了一个减少和增加数量的按钮，以及一个从购物车中删除商品的按钮。

**产品名称**是将用户带回到**产品详情**页面的链接。**继续购物**按钮将用户带到**产品列表**页面。**结帐**按钮执行结帐。成功结帐后，生成一个订单，用户被重定向到**订单**页面，如下所示:

![Figure 7.6 – Cart page ](img/Figure_7.6_B16561.jpg)

图 7.6–购物车页面

**订单组件**:**订单**页面以表格形式显示用户下的所有订单。**订单**表显示每个订单的订单日期、订购项目、订单状态和订单金额。

订单日期将以用户的当地时间显示，但在服务器上，订单日期将采用全球协调时间(T2)格式。订单项目将显示在订单列表中，其数量和单价在括号中，如下面的屏幕截图所示:

![Figure 7.7 – Order page ](img/Figure_7.7_B16561.jpg)

图 7.7–订单页面

让我们开始编码这些组件。首先，您将编写**产品列表**页面，该页面使用 REST API 从后端服务器获取产品。

# 使用 Fetch 使用 API

让我们创建第一个组件——也就是`Product Listing Page`。在`src/components`目录下创建一个名为`ProductList.js`的新文件。这是**产品列表**页面的父组件。

该组件从后端服务器获取产品，并将它们传递给子组件`Products`(它在`components` 目录下创建一个新的`Products.js`文件)。

产品包含提取的产品列表迭代的逻辑。每次迭代都会呈现每个产品的卡片 UI。`ProductCard`是另一个组件，因此您将在`src/components`下创建另一个文件`ProductCard.js`。您可以在产品中编写产品卡逻辑，但是为了挑出责任，最好创建一个新的组件。

`ProductCard`组件有一个**立即购买**按钮和一个**添加到包**链接。这些链接应该只有在用户登录的情况下才起作用，否则它应该将用户重定向到登录页面。

现在你已经对`Product Listing Page`组件的树形结构有了一个概念。现在，我们的第一个任务是拥有一个 API 客户端，它获取我们可以在这些组件中呈现的产品。

## 编写产品 API 客户端

您将使用`Fetch`浏览器库作为 REST API 客户端。也可以用第三方库比如`axios`。然而，这意味着您需要包含另一个依赖项。当您可以使用内置的浏览器 API 完成同样的工作时，为什么还要包含额外的依赖呢？

您将创建一个配置文件供所有 API 客户端使用。我们把它命名为`Config.js`，这样你就可以在`src/api`目录下创建了。

`Config`是一个 JavaScript 类，包含 URL 等常量和`DefaultHeaders()`、`tokenExpired()`等常用方法。在下面的代码片段中查看它的代码:

```java
class Config {
  SCHEME = process.env.SCHEME ? process.env.SCHEME :       "http";
  HOST = process.env.HOST ? process.env.HOST : "localhost";
  PORT = process.env.PORT ? process.env.PORT : "8080";
  LOGIN_URL = `${this.SCHEME}://${this.HOST}:${this.PORT}    /api/v1/auth/token`;
  PRODUCT_URL = `${this.SCHEME}://${this.HOST}:${    this.PORT}/api/v1/products`;
  // other constants removed for brevity
  defaultHeaders() {
    return { "Content-Type": "application/json",
             Accept: "application/json",
    };
  }
  headersWithAuthorization() {
    return {...this.defaultHeaders(),
      Authorization: localStorage.getItem(
          this.ACCESS_TOKEN),
    };
  }
// continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/Config.js

在这里，您可以看到我们已经创建了使用环境变量形成的常量。`defaultHeaders()`函数返回所有 API 调用中使用的公共头，`headersWithAuthorization()`返回带有`Authorization`头的公共头。`headersWithAuthorization()`使用对象销毁来检索默认标题。`Authorization`头是从本地存储中获取的，它是在用户成功登录时设置的，一旦用户注销，它就会被删除。

它还有一个`tokenExpired()`功能，简单地检查存储在本地存储器中的令牌的到期时间。这个到期时间是从访问令牌(J **儿子 Web 令牌**，或者 **JWT** )中提取的。如果到期时间超过当前时间，它将返回`true`。在下面的代码片段中查看该函数的代码:

```java
// Config.js continue
  tokenExpired() {
   const expDate = Number(localStorage.getItem(
        this.EXPIRATION));
   if (expDate > Date.now()) {
     return false;
   }
   return true;
  }
  storeAccessToken(token) {
   localStorage.setItem(this.ACCESS_TOKEN, `Bearer 
       ${token}`);
   localStorage.setItem(this.EXPIRATION, 
       this.getExpiration(token));
  }
  getExpiration(token) {
   let encodedPayload = token ? token.split(".")[1] : null;
   if (encodedPayload) {
     encodedPayload = 
              encodedPayload.replace(/-/g, 
                  "+").replace(/_/g, "/");
     const payload = JSON.parse(window.atob(
                                encodedPayload));
     return payload?.exp ? payload?.exp * 1000 : 0;
   }
   return 0;
 }
}
```

`Config`类还包含一个`storeAccessToken()`函数，它只是在本地存储中存储访问令牌和到期时间。它使用一个`getExpiration()`函数从访问令牌中提取到期时间。这个函数首先从令牌字符串中提取有效载荷，然后解码有效载荷并将其转换为 JSON。最后，如果一个有效负载是一个有效的对象，它返回到期时间，否则它返回`0`。

现在，让我们在`ProductClient.js`文件中使用这个`Config`类，如下面的代码块所示:

```java
import Config from "./Config";
class ProductClient {
  constructor() { this.config = new Config(); }
  async fetchList() {
    return fetch(this.config.PRODUCT_URL, {
      method: "GET",
      mode: "cors",
      headers: {
        ...this.config.defaultHeaders(),
      },
    })
    .then((response) => Promise.all([response, 
                        response.json()]))
    .then(([response, json]) => {
      if (!response.ok) {
        return { success: false, error: json };
      }
      return { success: true, data: json };
    })
    .catch((e) => { return this.handleError(e); });
  }
// continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/ProductClient.js

`ProductClient`是一个类，在其构造函数中实例化了一个`config`实例。这个类包含两个获取产品的异步函数:`fetchList()`和`fetch()`。前者获取所有产品，后者基于 ID 获取单个产品。`fetchList()`利用`fetch`浏览器功能获取产品列表。您传递 URL 作为第一个参数输入，并请求一个包含 HTTP 方法、模式和头的初始化对象作为第二个参数。浏览器调用返回一个您用来处理请求的承诺。首先，将承诺分解到`response`和`response JSON`，然后检查`response.ok`是否为`true`。对于 200 到 299 范围内的状态，`response.ok`返回`true`。响应成功后，`fetchList()`方法返回一个对象，其`data`和`success`字段为`true`。响应不成功时，返回`success`为`false`，并在`data`字段显示错误响应。

类似地，您可以编写一个函数来按 ID 检索产品。除了 URL 之外，一切都是一样的，正如您在下面的代码块中看到的:

```java
  // ProductClient.js continue…
  async fetch(prodId) {
    return fetch(this.config.PRODUCT_URL + "/" + prodId, {
      method: "GET",
      mode: "cors",
      headers: {
        ...this.config.defaultHeaders(),
      },
    })
      .then((response) => Promise.all([response, 
                                      response.json()]))
      .then(([response, json]) => {
        if (!response.ok) {
          return { success: false, error: json };
        }
        return { success: true, data: json };
      })
      .catch((e) => { this.handleError(e); });
  }
  handleError(error) {
    const err = new Map([
      [TypeError, "There was a problem fetching the 
          response."],
      [SyntaxError, "There was a problem parsing the 
          response."],
      [Error, error.message],
    ]).get(error.constructor);
    console.log(err);
    return err;
  }
}
export default ProductClient;
```

`handleError()`函数检查错误类型(使用`error.constructor`)，并基于此返回适当的错误消息。

请注意，其他 API 客户端如`CartClient`、`CustomerClient`和`OrderClient`都是以类似的方式开发的。该代码可在以下位置获得:

*   `CartClient`:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/API/cart client . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/CartClient.js)
*   `CustomerClient`:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/API/customer client . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/CustomerClient.js)
*   `OrderClient`:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/API/order client . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/OrderClient.js)

现在，我们可以用`ProductClient`取货了。让我们对`ProductList`组件及其子组件进行编码。

## 编码产品列表页面

`ProductList`是一个简单的组件，它使用`ProductClient`在第一次渲染后加载产品。你知道为了这个目的，应该使用`useEffect`钩子。让我们对它进行编码，如下所示:

```java
import { useEffect, useState } from "react";
import CartClient from "../api/CartClient";
import ProductClient from "../api/ProductClient";
import { updateCart, useCartContext } from 
    "../hooks/CartContext";
import Products from "./Products";
const ProductList = ({ auth }) => {
  const [productList, setProductList] = useState();
  const [noRecMsg, setNoRecMsg] = useState("Loading...");
  const { dispatch } = useCartContext();
  useEffect(() => {
    async function fetchProducts() {
      const res = await new ProductClient().fetchList();
      if (res && res.success) {
        setProductList(res.data);
      } else {
        setNoRecMsg(res);
      }
    }
    async function fetchCart(auth) {
      const res = await new CartClient(auth).fetch();
      if (res && res.success) {
        console.log(res.data);
        dispatch(updateCart(res.data.items));
        if (res.data?.items && res.data.items?.length < 1) {
          setNoRecMsg("Cart is empty.");
        }
      } else {
        setNoRecMsg(res && typeof res === "string" ? res : 
                                     res?.error?.message);
      }
    }
    if (auth?.token) fetchCart(auth);
    fetchProducts();
  }, []);
  // Continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/ProductList.js

`ProductList`组件使用`auth`作为道具。它包含身份验证信息，如令牌。`ProductList`组件作为主`App`组件，`auth`由它传递给`ProductList`组件。

请注意，您传递了一个空数组(`[]`)作为依赖项，以确保 API 只被调用一次。您使用一个`useState`钩子通过 setter 方法存储产品列表(`productList`)和消息状态(`noRecMsg`—无记录)。

### 在产品列表中获取购物车的原因

`ProductList`组件及其子组件可供未认证用户使用。一旦用户点击**立即购买**按钮或**添加到袋子**链接，它会要求用户登录。登录后，用户可以向购物车添加商品。用户很可能已经在购物车中有了一些商品。因此，当您向购物车添加商品时，应该增加现有产品的数量，如果购物车中不存在单击的商品，则应该将其添加到购物车中。

`Cart`是一个完全独立的成分；这意味着您无法访问`cart`，除非您从`App`组件到`Cart`和`ProductCard`组件进行推车道具钻孔，或者有一个用于推车的`useContext`挂钩。我们构建了一个自定义存储来维护购物车状态，非常类似于 **Redux** (一个在 React app 中维护状态的库)。我们将在本章的后面了解更多关于这个库的内容。`Dispatch`是一个将从后端服务器接收的购物车商品更新到购物车上下文的操作。

接下来，创建一个 JSX 模板，并将获取的`productList`组件传递给子组件`Products`，以便进一步渲染，如下面的代码片段所示:

```java
  // ProductList.js continue…
  return (
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-
        8">
      {productList ? (
        <div className="flex flex-wrap -mx-1 lg:-mx-4">
          <Products auth={auth} productList={productList ?  
                      productList : []} />
        </div>
      ) : (
        <div className="text-lg font-
            semibold">{noRecMsg}</div>
      )}
    </div>
  );
};
export default ProductList;
```

这里，也将`auth`对象作为道具传递给`Products`。

让我们来看看`Products`代码，如下:

```java
import ProductCard from "./ProductCard";
const Products = ({ auth, productList }) => {
  return (
    <>
      {productList.map((item) => (
        <ProductCard key={item.id} product={item} 
            auth={auth} />
      ))}
    </>
  );
};
export default Products;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Products.js

它简单地由完成迭代由`ProductList`组件传递的产品列表的工作，并将带有`product`道具的每一项连同`auth`对象一起传递给`ProductCard`组件。

您可以在这里观察到两个 React 概念的用法，如下所示:

*   它使用了一个`<></>`片段，这是一个空标签。理想情况下，当一个组件返回多个顶级标签时使用这种方法，因为 React 在每个组件中只需要一个顶级标签。然后，您可以用片段包装这些标签。从`react`包中导入`React`后，你也可以用`<React.Fragment>`来代替空标签。
*   另一种用法是用于`ProductCard`组件中的`key`道具。当您基于集合生成组件时，React 需要`key`道具来惟一地标识它们。这将允许 React 识别哪个项目被更改、删除或添加。我们在这里使用了项目 ID。如果您的集合中没有 ID，也可以使用索引，如下面的代码示例所示:

    ```java
    {productList.map((item, index) => (
       <ProductCard key={index} product={item} auth={auth} />
    ))}
    ```

现在，我们来看看`ProductList`组件的最后一个子组件:`ProductCard`。`ProductCard`组件只是将`Product`值传递给 JSX 模板表达式进行渲染。

我们已经添加了一些额外的代码来添加与**添加到包**和**立即购买**点击事件相关的功能。

### 配置路由

你正在创建一个水疗中心。在这里，默认情况下路由不可用。路由是向单个页面提供路由的机制，这意味着对于每个新页面，浏览器 URL 都会反映这种变化，并允许您将该页面加入书签。它还维护 URL 历史记录。您将使用`react-router-dom`包进行路由管理。您需要添加`react-router-dom`包来使用路由，如下面的代码片段所示。确保从项目根目录执行它:

```java
$ yarn add react-router-dom
```

您将在`App`组件中配置路由，因为它是`ecomm-ui`应用的根组件。在`ProductList`组件中，您将使用`react-router-dom`包中的`Link`组件和`useHistory()`挂钩。让我们来理解它们，如下:

*   `Link`:这类似于一个`<a>` HTML 锚标签。它使用一个`to`属性来链接 URL，而不是一个`href`属性。route library 维护链接，因此当点击`Link`时，它知道当带有`to`属性的链接被传入时要呈现哪个组件。
*   `useHistory()`:这允许在组件内部导航并访问路由器的状态。您将使用它的`push("/path ")`函数来导航，如`ProductList`组件的`checkLogin()`函数所示。

让我们继续开发下一个基于产品的组件:`ProductCard`。

### 开发 ProductCard 组件

首先，你导入所需的包。然后，声明状态(使用`useCartContext`和`useState`)和变量。请注意下面的代码片段，它有`auth`和`product`作为道具:

```java
import { useState } from "react";
import { Link, useHistory } from "react-router-dom";
import CartClient from "../api/CartClient";
import { updateCart, useCartContext } from "../hooks/CartContext";
const ProductCard = ({ auth, product }) => {
  const history = new useHistory();
  const cartClient = new CartClient(auth);
  const { cartItems, dispatch } = useCartContext();
  const [msg, setMsg] = new useState("");
  // continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/ProductCard.js

首先，编写将产品添加到购物车的`add()`异步函数。它首先检查用户是否登录。如果没有，它会将用户重定向到登录页面。`checkLogin()`使用`useHistory`钩子的`push`方法进行重定向。`auth`的`token`属性用于标识用户是否登录。

一旦它识别出用户已经登录，它就调用`callAddItemApi`函数将产品添加到购物车中。`callAddItemApi`函数首先发现产品是否存在于购物车中。如果存在，它就找出这个量，然后加 1。然后，`callAddItemApi`函数使用`CartClient`调用 REST API 来添加新商品或更新现有购物车商品的数量。

最后，`add`函数调用`dispatch`来更新购物车上下文中`cartItems`的状态。

以下代码片段包含相同的逻辑:

```java
  // ProductCard.js continue…
  const add = async () => {
    const isLoggedIn = checkLogin();
    if (isLoggedIn && product?.id) {
      const res = await callAddItemApi();
      if (res && res.success) {
        if (res.data?.length > 0) {
          setMsg("Product added to bag.");
          dispatch(updateCart(res.data));
        }
      } else {
        setMsg(res && typeof res === "string" ? res : 
                                       res.error.message);
      }
    }
  };
  const checkLogin = () => {
    if (!auth.token) {
      history.push("/login");
      return false;
    }
    return true;
  };
  const callAddItemApi = async () => {
    const qty = findQty(product.id);
    return cartClient.addOrUpdate({
      id: product.id, quantity: qty + 1, unitPrice: 
          product.price
    });
  };
  const findQty = (id) => {
    const idx = cartItems.findIndex((i) => i.id === id);
    if (~idx) { return cartItems[idx].quantity; }
    return 0;
  };
  // continue…
```

点击**添加到袋子**链接的调用`add`功能。类似地，当用户点击**立即购买**按钮时，将调用下面代码片段中所示的`buy`函数:

```java
  // ProductCard.js continue…
  const buy = async () => {
    const isLoggedIn = checkLogin();
    if (isLoggedIn && product?.id) {
      const res = await callAddItemApi();
      if (res && res.success) {
        history.push("/cart");
      } else {
        setMsg(res && typeof res === "string" ? res : 
                                       res.error.message);
      }
    }
  };
  // continue…
```

这非常类似于`add`函数。然而，当来自`callAddItemApi`的响应成功时，它使用一个`useHistory`钩子实例将用户重定向到购物车页面。

让我们来看一个 JSX 模板。在下面的代码片段中，为了更好的可读性，`className`属性值被去掉了:

```java
  // ProductCard.js continue…
  return (
    <div id={product.id} className="…">
      <figure className="…">
        <img src={product.imageUrl} alt={product.name}/>
        <div className="…">
          <form className="…">
            <div className="…">
              <h1 className="…">
                <Link to={`/products/${product.id}`}>
                {product.name}</Link>
              </h1>
              <div className="…">{"$"}{
                  product.price.toFixed(2)}
              </div>
              <div className="…">In stock</div>
            </div>
            <div className="…">
              <div className="…">
                <button className="…" type="button" 
                    onClick={buy}
                >Buy now</button>
                <button className="…" type="button" 
                   onClick={add}
                >Add to bag</button>
              </div>
            </div>
            <p className="…">Free shipping on all local 
                orders.</p>
          </form>
        </div>
      </figure>
    </div>
  );
};
export default ProductCard;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/ProductCard.js

`onClick`事件已经分别绑定到**立即购买**按钮和**添加到袋子**链接的`buy`和`add`。此外，产品名称是使用`Link`创建的链接。`Link`的`to`属性包含指向`ProductDetail`组件的路径。该路径还包含`path`参数 ID。您可以使用此参数对其执行某些操作。同样，您也可以像在浏览器 URL 中那样传递查询参数。

当用户在产品名称上点击时，用户被重定向到`ProductDetail`组件(`ProductDetail.js`)。接下来我们来开发这个。

### 开发产品详细信息组件

`ProductDetail`组件是类似于`ProductCard`组件的，除了它通过使用来自路径的 ID 从后端加载产品细节。

让我们看看这是如何做到的。下面的代码片段只显示了与`Fetch`产品相关的代码。其余的代码与`ProductCard`组件相同。但是，您可以参考 GitHub 资源库中的完整代码:

```java
import { Link, useParams, useHistory } from "react-router-dom";
import ProductClient from "../api/ProductClient";
// Other imports removed for brevity
const ProductDetail = ({ auth }) => {
  const { id } = useParams();
  // Other declaration removed for brevity
  // Other functions removed for brevity
  useEffect(() => {
    async function getProduct(id) {
      const client = new ProductClient();
      const res = await client.fetch(id);
      if (res && res.success) {
        setProduct(res.data);
      }
    }
    // rest of code removed from brevity
    getProduct(id);
  }, [id]);
  return ( /* JSX Template */  );
};
export default ProductDetail;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/ProductDetail.js

您已经使用来自`react-router-dom`包的`useParams()`来检索从`ProductCard`组件传递的产品 ID。这个`id`属性随后被用于使用`ProductClient`组件从后端服务器获取产品。在成功的响应后，使用`setProduct`状态功能在状态产品中设置检索的产品详细信息。

我们已经完成了基于产品的组件的开发，例如`ProductList`、`Products`、`ProductCard`和`ProductDetail`。我们现在将把重点放在认证功能上，这样我们以后就可以处理`cart`和`orders`组件，它们需要一个经过认证的用户。

# 实现认证

在您进入`Login`组件开发之前，您将希望弄清楚如何管理从成功登录响应中接收到的令牌，以及如何确保如果访问令牌已经过期，那么在进行任何需要身份验证的调用之前应该触发刷新令牌请求。

浏览器允许您在 cookies、会话存储和本地存储中存储令牌或任何其他信息。从服务器端来看，我们没有选择 cookie 或有状态通信，因此我们只剩下剩下的两个选项。会话存储更适用于更安全的应用，因为它特定于同一个选项卡，只要您单击**刷新**按钮或关闭选项卡，它就会被清除。我们希望管理不同选项卡之间的登录持久性和页面刷新，因此我们将选择浏览器的本地存储。

除此之外，您还可以将它们存储在状态中，就像管理购物车状态一样。但是，这与会话存储非常相似。让我们暂时保留这个选项。

## 创建自定义的 useToken 挂钩

你有现在使用不同的反应钩。让我们向前移动一步，然后**创建一个自定义挂钩**。首先，在`src`目录下新建一个`hooks`目录，并在其中创建一个`useToken.js`文件。

然后，向其中添加以下代码:

```java
import { useState } from "react";
export default function useToken() {
  const getToken = () => {
   const tokenResponse = localStorage.getItem(       "tokenResponse");
   const userInfo = tokenResponse ? 
                         JSON.parse(tokenResponse) : "";
    return userInfo;
  };
  const [token, setToken] = useState(getToken());
  const saveToken = (tokenResponse) => {
    localStorage.setItem("tokenResponse",         JSON.stringify(tokenResponse));
    setToken(tokenResponse);
  };
  return { setToken: saveToken, token };
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/hooks/useToken.js

这里，您使用了一个`useState`钩子来维护令牌状态。通过调用`useState`的构造函数中的`getToken`函数，在声明令牌状态的同时初始化令牌状态。现在，您需要提供一种机制，每当操作发生变化(比如登录或注销)时，该机制应该更新初始令牌状态。为此，您可以创建一个新功能`saveToken`。

`getToken`和`saveToken`函数分别使用`localStorage`来检索和更新令牌。最后，返回`token`状态和`saveToken`函数(以`setToken`的形式)供其使用。

接下来，创建另一个 REST API 客户端进行身份验证。让我们在`src/api`目录下添加另一个客户端`Auth.js`([https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/API/auth . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/api/Auth.js))。

这个`Auth.js`客户端与其他 API 客户端非常相似。它有三个函数，通过使用后端服务器 REST APIs 来执行登录、注销和刷新访问令牌操作，概述如下:

*   登录操作通过使用由`App`组件传递的状态参数在本地存储的`responseToken`键中设置访问令牌、刷新令牌、用户 ID 和用户名。像往常一样，`App`组件使用`useToken`定制钩子。登录操作还设置访问令牌的到期时间。
*   刷新访问令牌操作更新访问令牌及其到期时间。
*   注销操作会删除令牌并将到期时间设置为零。
*   您已经完成了实现登录功能的先决条件工作，现在可以继续创建`Login`组件了。

## 编写登录组件

让在`src/components`目录下创建一个新的`Login.js`文件，然后运行下面的代码:

```java
import { useHistory } from "react-router-dom";
import { useState } from "react";
import PropTypes from "prop-types";
Login.propTypes = {
 auth: PropTypes.object.isRequired,
};
const Login = ({ uri, auth }) => {
  const [username, setUserName] = useState();
  const [password, setPassword] = useState();
  const [errMsg, setErrMsg] = useState();
  const history = useHistory();
  const cancel = () => {
    const l = history.length;
    l > 2 ? history.goBack() : history.push("/");
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    const res = await auth.loginUser({username, password});
    if (res && res.success) {
      setErrMsg(null);
      history.push(uri ? uri : "/");
    } else {
      setErrMsg(
        res && typeof res === "string" ? res : "Invalid  
                                       Username/Password");
    }
  };
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Login.js

在你开始理解代码之前，知道`PropTypes`提供了一种检查被传递道具类型的方法是很有用的。这里，我们已经确定了`auth`道具是一个对象，并且是一个必需的道具。如果失败，您可能会在控制台中看到消息。通常，您在文件的末尾添加这个 props 检查(在源代码中，它在底部)，但是这里为了更好的可读性，它被添加在顶部。

这个组件包含两个道具:`auth`和`uri`。`auth` prop 表示身份验证客户端，`uri`是一个字符串，在用户成功登录后，它将用户发送回相应的页面。

它有两个功能:`handleSubmit`和`cancel`。`cancel`功能只是将用户送回上一页或主页。`handleSubmit`函数使用认证客户端，并使用用户名和密码调用登录 API。

让我们来看看它的 JSX 模板，如下:

```java
  return (
    <div className="…"><div className="…">
      <div className="…" role="dialog" aria-modal="true">
      <div className="…"><div className="…">
      <div className="…"><div className="…">
      <h2 className="…">Sign in to your account</h2>
      <form className="…" onSubmit={handleSubmit}>
      <div className="…"><div>
      <span className="…" style={{ dispay: errMsg ? "block" : 
                                "none" }} >{errMsg}</span>
      <label htmlFor="username" className="…">Username 
      </label>
      <input id="username" name="username" type="username" 
       autoComplete="username" placeholder="Username" 
           required 
       className="…" onChange={(e) => 
           setUserName(e.target.value)}/>
      </div><div>
      <label htmlFor="password" className="…">Password 
      </label>
      <input id="password" name="password" type="password"   
       autoComplete="password" placeholder="Password" required 
       className="…" onChange={(e) => setPassword(e.target.         value)}/>
      </div></div><div className="…"><div>
      <button type="submit" className="…">
       <span className="…">
       <svg className="…" xmlns=http://www.w3.org/2000/svg
        viewBox="0 0 20 20" fill="currentColor" aria-
        hidden="true"><path fillRule="evenodd" d="M5 9V7a5 5 0         0110 
        0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0         012-
        2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd"/>
       </svg>
       </span><span className="…">Sign in</span>
      </button>
      </div><div className="…">
      <button type="button" onClick={cancel} 
      >Cancel</button>
      </div></div>
      </form>
      </div></div></div></div></div></div></div>
  );};
export default Login;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Login.js

当表单提交时(当用户点击按钮中的**符号时)调用`handleSubmit`函数。当用户点击**取消**按钮时，调用`cancel`功能。另一个值得注意的点与设置用户名和密码状态有关。这些分别设置在`onChange`事件上。`e.target.value`参数表示相应输入字段中的输入值。`e`实例代表事件，而`target`代表相应事件的目标输入字段。**

现在，您知道了完整的流程:用户登录，应用在本地存储中设置所需的令牌和信息。API 客户端使用这些信息来调用经过身份验证的 API。注销操作是`Header`组件([https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 07/ecomm-ui/src/components/header . js](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Header.js))的一部分，它调用`Auth`客户端的注销函数，该函数调用 remove refresh token 后端服务器的 REST API ，并从本地存储中删除认证信息。

在身份验证实现之后，在开始编写`Cart`组件:cart 上下文之前，您需要再编写一段代码。让我们现在做那件事。

## 编写定制购物车上下文

您可以使用 Redux 库来集中和维护应用的全局状态。但是，您可以编写一个类似 Redux 的定制钩子来维护购物车的状态。这使用了 React 库中的`createContext`、`useReducer`和`useContext`钩子。

你已经知道`createContext`返回了`Provider`和`Consumer`。因此，当您使用`createContext`创建一个`CartContext`时，它会提供`CartContext.Provider`。你不会使用`Consumer`，因为你将使用`useContext`钩。

接下来，您需要一个 cart state ( `cartItems`)，您将它传递给`CartContext.Provider`中的值，这样它将在使用`CartContext`的组件中可用。现在，我们只需要一个`reducer`函数。一个`reducer`函数接受两个参数:`state`和`action`。基于所提供的动作，它更新(改变)状态并返回更新后的状态。

现在，让我们进入代码，看看结果如何。看看下面的片段:

```java
import React,{ createContext, useReducer, useContext } from "react";
export const CartContext = createContext();
function useCartContext() {
  return useContext(CartContext);
}
export const UPDATE_CART = "UPDATE_CART";
export const ADD_ITEM = "ADD_ITEM";
export const REMOVE_ITEM = "REMOVE_ITEM";
export function updateCart(items) {
  return { type: UPDATE_CART, items };
}
export function addItem(item) {
  return { type: ADD_ITEM, item };
}
export function removeItem(index) {
  return { type: REMOVE_ITEM, index };
}
export function cartReducer(state, action) {
  switch (action.type) {
    case UPDATE_CART:
      return [...action?.items];
    case ADD_ITEM:
      return [...state, action.item];
    case REMOVE_ITEM:
      const list = [...state];
      list.splice(action.index, 1);
      return list;
    default:
      return state;
  }
}
const CartContextProvider = (props) => {
  const [cartItems, dispatch] = useReducer(cartReducer, 
 []);
  const cartData = { cartItems, dispatch };
  return <CartContext.Provider value={cartData} {...props} 
 />;
};
export { CartContextProvider, useCartContext };
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/hooks/CartContext.js

首先，我们让创建了一个带有`createContext`钩子的`CartContext`。然后，我们声明了一个函数，它使用了一个`useContext`钩子并返回在`CartContext.Provider`标签中声明的`value`字段的值。

接下来，您需要一个使用动作和状态的`reducer`函数。因此，我们首先定义动作类型，比如`UPDATE_CART`，然后编写函数返回一个包含动作类型和参数值的动作对象，比如`updateCart`。最后，您可以编写一个`reducer`函数，它将`state`和`action`作为参数，并根据传递的动作类型，改变状态并返回更新后的状态。

接下来，定义一个返回`CartContext.Provider`组件的`CartContextProvider`函数。这里，您在`useReducer`钩子中使用了`reducer`函数，在它的第二个参数中，您传递了一个空数组作为初始状态。`useReducer`挂钩返回到`state`和`dispatch`功能。`dispatch`函数将`action`对象作为参数。可以使用返回`action`对象的函数，比如`updateCart`和`addItem`。您将`state` ( `cartItems`)和`dispatcher`函数(`dispatch`)包装在`cartData`对象中，并将其传递给`CartContext.Provider`组件中的`value`属性。最后，它导出了`CartContextProvider`和`useCartContext`函数。

您将使用作为`App`组件中的组件包装器。这使得`CartContextProvider`内的所有组件都可以使用`cartData` ( `cartItems`和`dispatch`)，可以使用`useCartContext`访问和使用。

现在，最后，您可以在下一小节中编写`Cart`组件。

## 编写购物车组件

`Cart`组件是一个父组件，因为它可以包含多个条目(`CartItem`组件)。让我们在`src/components`目录下创建一个新的`cart.js`文件，并向其中添加以下代码:

```java
import { useEffect, useState } from "react";
import { Link, useHistory } from "react-router-dom";
import CartClient from "../api/CartClient";
import CustomerClient from "../api/CustomerClient";
import OrderClient from "../api/OrderClient";
import { removeItem, updateCart, useCartContext }
 from "../hooks/CartContext";
import CartItem from "./CartItem";
const Cart = ({ auth }) => {
  const [grandTotal, setGrandTotal] = useState(0)
  const [noRecMsg, setNoRecMsg] = useState("Loading...");
  const history = useHistory();
  const cartClient = new CartClient(auth);
  const orderClient = new OrderClient(auth);
  const customerClient = new CustomerClient(auth);
  const { cartItems, dispatch } = useCartContext();
  // Continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Cart.js

您在这里使用`useCartContext`并导入返回`action`对象的`updateCart`之类的函数(由`dispatch`函数使用)。除了`CartClient`之外，这里还使用`OrderClient`和`CustomerClient`进行结账操作。

让我们添加函数来计算给定产品 ID 的总计(`calTotal`)和增加数量(`increaseQty`)，如下所示:

```java
  // Cart.js Continue…
  const calTotal = (items) => {
    let total = 0;
    items?.forEach((i) => (total = total + i?.unitPrice * 
                                             i?.quantity));
    return total.toFixed(2);
  };
  const increaseQty = async (id) => {
    const idx = cartItems.findIndex((i) => i.id === id);
    if (~idx) {
      cartItems[idx].quantity = cartItems[idx].quantity + 1;
      const res = await cartClient.addOrUpdate(          cartItems[idx]);
      if (res && res.success) {
        refreshCart(res.data);
        if (res.data?.length < 1) { setNoRecMsg("Cart is             empty."); }
      } else {
        setNoRecMsg(res && typeof res === "string" ? res :                                             res.error.message);
      }
    }
  }; // Continue…
```

`increaseQty`函数首先发现给定的 ID 是否存在于购物车商品中。如果存在，那么将产品的数量增加`1`。最后，它调用 REST API 来更新购物车商品，并通过调用`refreshCart`函数使用响应来更新购物车。

让我们添加一个`decreaseQty`函数，它与`increaseQty`相似，但数量减少了一。此外，`deleteItem`函数将从购物车中删除商品。代码如下面的代码片段所示:

```java
  // Cart.js Continue…
  const decreaseQty = async (id) => {
    const idx = cartItems.findIndex((i) => i.id === id);
    if (~idx && cartItems[idx].quantity <= 1) {
      return deleteItem(id);
    } else if (cartItems[idx]?.quantity > 1) {
      cartItems[idx].quantity = cartItems[idx].quantity – 
          1;
      const res = await cartClient.addOrUpdate(
          cartItems[idx]);
      if (res && res.success) {
        refreshCart(res.data);
        if (res.data?.length < 1) { setNoRecMsg("Cart is 
                                                empty.");}
        return;
      } else { setNoRecMsg(res && typeof res === "string" ?
                                res : res?.error?.message); }
    }
  };
  const deleteItem = async (id) => {
    const idx = cartItems.findIndex((i) => i.id === id);
    if (~idx) {
      const res = await cartClient.remove(
          cartItems[idx].id);
      if (res && res.success) {
       dispatch(removeItem(idx));
       if (res.data?.length < 1) { setNoRecMsg("Item is 
           removed.");}
      } else { setNoRecMsg(res && typeof res === "string" ? 
           res
            : "There is an error performing the remove."); }
    }
  }; // Continue…
```

与`increaseQty`相比，`decreaseQty`函数多做了一步——如果现有数量为`1`,它会通过调用`deleteItem`来删除该项目。功能。

`deleteItem`函数首先根据给定的 ID 找到产品。如果它存在，那么它调用 REST API 从购物车中删除产品，并通过使用由`removeItem`函数返回的`action`对象调用`dispatch`函数来更新购物车商品状态。

让定义`refreshCart`和`useEffect`函数，如下面的代码片段中的所示:

```java
  // Cart.js Continue…
  const refreshCart = (items) => {
    setGrandTotal(calTotal(items));
    dispatch(updateCart(items));
  };
  useEffect(() => {
    async function fetch() {
      const res = await cartClient.fetch();
      if (res && res.success) {
        refreshCart(res.data.items);
        if (res.data?.items && res.data.items?.length < 1) {
          setNoRecMsg("Cart is empty.");
        }
      } else {
        setNoRecMsg(res && typeof res === "string" ? res                               : res.error.message);
      }
    }
    fetch();
  }, []);// Continue…
```

`refreshCart`函数更新总数并调度`updateCart`动作。`useEffect`从后端服务器加载购物车商品，并调用`refreshCart`来更新`cartItems`全局状态。

让我们添加`Cart`组件的最后一个函数来执行结帐操作，如下面的代码片段所示:

```java
  // Cart.js Continue…
  const checkout = async () => {
    const res = await customerClient.fetch();
    if (res && res.success) {
      const payload = {
        address: { id: res.data.addressId },
        card: { id: res.data.cardId },
      };
      const orderRes = await orderClient.add(payload);
      if (orderRes && orderRes.success) {
        history.push("/orders");
      } else {
        setNoRecMsg(orderRes && typeof orderRes === 
            "string"
            ? orderRes: "Couldn't process checkout."
        );
      }
    } else {
      setNoRecMsg( res && typeof res === "string" ? res                                 : "error retreiving customer");
    }
  };
```

`checkout`函数首先获取客户信息，并形成一个有效载荷用于下订单。在成功的`POST`订单 API 响应中，用户被重定向到`Orders`组件。

最后，让我们添加一个 JSX 模板，它是从`codepen`用户`abdelrhman`为`Cart`组件使用的，如下面的代码块所示(为了简洁起见，`Code`和`className`的值已经被去掉):

```java
  // Cart.js Continue…
  return (
    <div className="…">
      <!-- code stripped for brevity  -->
          <div className="…">
            <h1 className="…">Shopping Cart</h1>
            <h2 className="…">{cartItems?.length} 
            Items</h2>
          </div>
          <div className="…">
            <h3 className="…">Product Details</h3>
            <h3 className="…">Quantity</h3>
            <h3 className="…">Price</h3>
            <h3 className="…">Total</h3>
          </div>
          {cartItems && cartItems.length > 0 ? (
            cartItems?.map((i) => (
             <CartItem item={i} key={i.id} 
 removeItem={deleteItem} 
              increaseQty={
 increaseQty}decreaseQty={decreaseQty}/>
        <!-- code stripped for brevity  -->
          <div className="…">
            <div className="…">
              <span>Total cost</span>
              <span>${grandTotal}</span>
            </div>
            <button className="…" onClick={checkout}
              disabled={grandTotal == 0 ? true : false} >
              Checkout
            </button>
        <!-- code stripped for brevity  -->
    </div>
  );
};
export default Cart;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Cart.js

在这里，您可以看到单击 **Checkout** 按钮，它调用`checkout`函数来下用户订单。购物车商品使用您接下来创建的`CartItem`组件来呈现。你通过`removeItem`、`increaseQty`和`decreaseQty`函数作为道具。

让我们通过创建一个新文件(`src/components/CartItem.js`)并添加以下代码来编写组件`CartItem`:

```java
import { useEffect, useState } from "react";
import { Link } from "react-router-dom";
const CartItem = ({ item, increaseQty, decreaseQty, removeItem }) => { const des = item ? item.description?.split(".") : [];
  const author = des && des.length > 0       ? des[des.length - 1] : "";
  const [total, setTotal] = useState();
  const calTotal = (item) => {
    setTotal((item?.unitPrice *               item?.quantity)?.toFixed(2));
  };
  const updateQty = (qty) => {
    if (qty === -1) { decreaseQty(item?.id); }
    else if (qty === 1) { increaseQty(item?.id); }
    else { return false; }
    calTotal(item);
  };
  useEffect(() => {
    calTotal(item);
  }, []);
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/CartItem.js

这里，您维护总量的状态，即数量和单价的乘积(`calTotal`函数)和`updateQty`辅助函数，以执行增加/减少数量的操作。`useEffect`钩子也调用`calTotal`来更新**购物车**页面上的总数。

让我们为`CartItem`组件添加 JSX 模板的最后一部分，如下一个代码块所示(为了简洁起见，`className`值已被去除):

```java
  return (
    <div className="…">
      <div className="…">
        <div className="…">
          <img className="…" src={item?.imageUrl} alt="" />
        </div>
        <div className="…">
          <Link to={"/products/" + item.id} className="…">
            {item?.name}
          </Link>
          <span className="…">Author: {author}</span>
          <button className="…" onClick={() => 
 removeItem(item.id)}>
            Remove
          </button>
        </div>
      </div>
      <div className="…">
        <span className="…" onClick={() => updateQty(-1)}>
          <svg className="…" viewBox="0 0 448 512">
            <path d="M416 208H32c-17.67 0-32 14.33-32 32v32c0             17.67              14.33 32 32 32h384c17.67 0 32-14.33             32-32v-32c0-17.67-            14.33-32-32-32z" /></svg>
        </span>
        <input type="text" readOnly value={item?.quantity} />
        <span className="…" onClick={() => updateQty(1)}>
          <svg className="…" viewBox="0 0 448 512">
            <path d="M416 208H272V64c0-17.67-14.33-32-32-32h-            32c-            17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32             32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33             32 32             32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-            14.33             32-32v-32c0-17.67-14.33-32-32-32z" /></svg>
        </span>
      </div>
      <span className="…">{item?.unitPrice?.toFixed(2)}</span>
      <span className="…">${total}</span>
    </div>
  );
};
export default CartItem;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/CartItem.js

在表达式中使用了`state`项来生成值。对于各自的 JSX 元素，`removeItem`和`updateQty`函数被绑定到`onClick`事件。

现在，您可以在下一小节中编写应用的最后一个组件(页面):组件`Order`。

## 编写订单组件

`Order`组件包含从后端服务器获取的订单细节。它以表格形式显示日期、状态、金额和项目。它用`useEffect`钩子在第一次渲染时加载订单细节，然后在 JSX 表达式中使用`orders`状态来显示它。

让我们在`src/components`目录中创建一个新文件`Orders.js`，并向其中添加以下代码:

```java
import { useEffect, useState } from "react";
import OrderClient from "../api/OrderClient";
const Orders = ({ auth }) => {
  const [orders, setOrders] = useState([]);
  const formatDate = (dt) => {
    return dt && new Date(dt).toLocaleString();
  };
  useEffect(() => {
    async function fetchOrders() {
      const client = new OrderClient(auth);
      const res = await client.fetch();
      if (res && res.success) {
        setOrders(res.data);
      }
    }
    fetchOrders();
  }, []);
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Orders.js

接下来，添加下面的 JSX 模板。这里，为了简洁起见，代码和`className`都被去掉了:

```java
  return (
    <div className="…">
      <!-- code stripped for brevity  -->
              <table className="…">
                <thead className="…">
                  <tr>
                    <th scope="col" className="…">Order 
                    Date</th>
                    <th scope="col" className="…">Order 
                    Items</th>
                    <th scope="col" 
                    className="…">Status</th>
                    <th scope="col" className="…">Order 
                    Amount</th>
                  </tr>
                </thead>
                <tbody className="…">{orders && 
 orders.length < 1 ?
 ( <tr className="px-6 py-4 whitespace-
                   nowrap">
                     Found zero order</tr>
                  ) : (
                    orders?.map((order) => (
                  <tr>
                    <td className="…">
                      <div className="…">{formatDate(
 order?.date)}
                      </div>
                      <div className="…">Local Time</div>
                    </td>
                    <td className="…">
                       <!-- code stripped for brevity  -->
                            {order?.items.map((o, idx) => (
                              <div>
                                <span className="…">
                                  {idx + 1}.
                                </span>{" "}{o.name}{" "}
                                <span className="…">
                                  ({o?.quantity +" x $" +
                                  o?.unitPrice?.toFixed(2)}
                                  )
                                </span><br/>
                              </div>
                            ))}
                           </div>
                        </div>
                    </div>
                  </td>
                  <td className="…"><span className="…">{
 order?.status}</span>
                  </td>
                  <td className="…">${
 order?.total?.toFixed(2)}</td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
        <!-- code stripped for brevity  -->
      </div>
    </div>
  );
};
export default Orders;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/components/Orders.js

它只是显示从`orders`状态获取的信息。

现在，我们可以用`yarn start`命令更新根组件来完成流程并测试应用。

## 编写根(App)组件

`App`组件是 React 应用的根组件。它包含路由信息和带有所有父组件的应用布局，如产品列表和订单组件。

用以下代码更新项目`src`目录中的`App.js`文件:

```java
import { BrowserRouter as Router, Route, Switch } from "react-router-dom";
import Header from "./components/Header";
import Footer from "./components/Footer";
import ProductList from "./components/ProductList";
import Login from "./components/Login";
import useToken from "./hooks/useToken";
import Cart from "./components/Cart";
import ProductDetail from "./components/ProductDetail";
import NotFound from "./components/NotFound";
import Auth from "./api/Auth";
import { CartContextProvider } from "./hooks/CartContext";
import Orders from "./components/Orders";
function App() {
  const { token, setToken } = useToken();
  const auth = new Auth(token, setToken);
  const loginComponent = (props) => (
    <Login {...props} uri="/login" auth={auth} />
  );
  const productListComponent= (props)=> <ProductList auth={auth}/>;
  // continue…
```

这包含了`App`组件所需的所有导入。然后，使用`useToken()`钩子和`Auth`认证 REST API 客户端进行认证。你创建返回`loginComponent`和`productListComponent`的函数。

它的 JSX 模板与我们现在使用的不同。它使用`react-router-dom`包中的`BrowserRouter`(`Router`)`Route`和`Switch`组件。您在`BrowserRouter`组件中定义了所有的`Route`组件。这里，我们也使用了`Switch`组件，因为我们想独占地呈现组件。如果没有路径匹配，它还允许您呈现`NotFound`组件(典型的`404 – not found`页面)。`Route`组件允许您定义要呈现的路径和组件。您已经使用了 arrow 函数作为一个`render`属性值，因为我们也可以使用表达式。以下代码片段包含这里解释的逻辑:

```java
  // App.js continue…
  return (
   <div className="flex flex-col min-h-screen h-full ">
    <Router>
     <Header userInfo={token} auth={auth} />
      <div className="flex-grow flex-shrink-0 p-4">
       <CartContextProvider>
         <Switch>
           <Route path="/" exact render={() =>
                                     productListComponent()} />
           <Route path="/login" render={(props) => token ? 
             productListComponent() : loginComponent(props)} />
           <Route path="/cart" render={(props) => token ? 
             <Cart auth={auth} /> : loginComponent(props)} />
           <Route path="/orders" render={(props) => token ? 
             <Orders auth={auth} /> : loginComponent(props)} />
           <Route path="/products/:id" render={() => 
             <ProductDetail auth={auth} />} />
           <Route path="*" exact component={NotFound} />
         </Switch>
       </CartContextProvider>
      </div>
     <Footer />
    </Router>
   </div>
  );
}
export default App;
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter07/ecomm-ui/src/App.js

所有组件都被包裹在`CartContextProvider`内，以允许`cartItems`和`dispatch`可以在所有组件中使用`useCartContext`定制挂钩。

## 运行应用

您可以使用第六章*安全(授权和认证)*中的代码启动后端服务器。然后，您可以通过从项目根目录执行一个`yarn start`命令来启动`ecomm-ui`应用。您可以使用`scott/tiger`登录并执行所有操作。

# 总结

在本章中，您已经学习了 React 的基本概念，并使用它们创建了不同类型的组件。您还学习了如何使用浏览器内置的`Fetch` API 来消费 REST APIs。您在 React 中获得了以下技能:开发基于组件的 UI、实现路由、使用 REST APIs、用钩子实现功能组件、编写定制钩子、用 React 上下文 API 和`useReducer`钩子构建全局状态存储。您在本章中获得的概念和技能为现代前端开发奠定了坚实的基础，并为您获得 360 度应用开发的视角提供了优势。

在下一章，你将学习如何为基于 REST 的 web 服务编写测试。

# 问题

1.  `props`和`state`有什么区别？
2.  什么是事件，如何在 React 组件中绑定事件？
3.  什么是高阶分量？

# 延伸阅读

*   *Mastering React Test Driven Development:*

    [https://www . packtpub . com/product/mastering-react-test-driven-development/9781789133417](https://www.packtpub.com/product/mastering-react-test-driven-development/9781789133417)

*   React documentation:

    [https://reactjs.org/docs/](https://reactjs.org/docs/)

*   React Router guide:

    [https://reactrouter.com/web/guides/quick-start](https://reactrouter.com/web/guides/quick-start)