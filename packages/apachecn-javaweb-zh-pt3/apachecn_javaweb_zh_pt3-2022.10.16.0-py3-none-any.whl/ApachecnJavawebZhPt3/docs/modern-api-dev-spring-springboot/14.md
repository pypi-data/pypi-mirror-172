# 十四、GraphQL API 开发和测试

在本章中，你将学习基于 GraphQL 的 API 开发及其测试。在本章中，您将为一个示例应用实现基于 GraphQL 的 API。GraphQL 服务器实现将基于**设计优先**的方法进行开发，您在 [*第 3 章*](03.html#_idTextAnchor064) 、 *API 规范和实现*中定义 OpenAPI 规范的方式，以及在 [*第 11 章*](11.html#_idTextAnchor230) 、*基于 gRPC 的 API 开发和测试*中设计模式的方式。

本章将涵盖以下主题:

*   工作流程和工具
*   实现 GraphQL 服务器
*   记录 API
*   测试自动化

完成本章后，您将学会如何实际实现前一章中学习的 GraphQL 概念，以及使用 Java 和 Spring 实现 GraphQL 服务器及其测试。

# 技术要求

为了开发和测试本章中介绍的基于 GraphQL 的服务代码，您需要以下内容:

*   任何 Java IDE，如 NetBeans、IntelliJ 或 Eclipse
*   **Java 开发工具包** ( **JDK** ) 15
*   一个互联网连接，用于克隆代码和下载依赖项和 Gradle(版本 7+)

那么，让我们开始吧！

请访问以下链接查看代码文件:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter14)

# graph QL 的工作流程和工具

作为 GraphQL 中基于数据图的思维方式，数据是使用由对象图组成的 API 来公开的。这些对象使用关系进行连接。GraphQL 只公开一个 API 端点。客户端查询这个使用*单数据图*的端点。最重要的是，通过遵循 GraphQL 的 **OneGraph 原则**，数据图可以解析来自单个源或多个源的数据。这些来源可以是数据库、遗留系统或使用 REST/gRPC/SOAP 公开数据的服务。

GraphQL 服务器可以通过以下两种方式实现:

*   **独立的 GraphQL 服务**:独立的 GraphQL 服务包含一个单独的数据图。它可以是从单个或多个来源(没有 GraphQL API)获取数据的单片应用或微服务架构。
*   **Federated GraphQL services** :查询单个数据图以获取全面的数据非常容易。然而，企业应用是使用多种服务构建的，因此除非构建一个整体系统，否则不可能有单一的数据图。如果您没有构建一个单一的系统，那么您将拥有多个特定于服务的数据图。

这就是使用联邦 GraphQL 服务的地方。联合 GraphQL 服务包含一个使用网关公开的*单一分布式图*。客户端将调用网关，网关是系统的入口点。数据图将分布在多个服务中，每个服务可以独立地维护自己的开发和发布周期。话虽如此，联邦 GraphQL 服务仍将遵循 OneGraph 原则。因此，客户端将查询单个端点来获取图的任何部分。

让我们假设一个示例电子商务应用是使用 GraphQL 联邦服务开发的。它将包含产品、订单、运输、库存、客户和其他服务，这些服务将使用 GraphQL API 公开特定于领域的数据图。

让我们绘制一个 GraphQL 联合电子商务服务的高层图，如下所示:

![Figure 14.1 – Federated GraphQL services ](img/Figure_14.1_B16561-CV111.jpg)

图 14.1–联合 GraphQL 服务

假设 GraphQL 客户端通过调用**网关**端点来查询订购最多、库存最少的产品的列表。该查询可能包含来自**订单**、**产品**和**库存**的字段。每个服务只负责解析数据图的相应部分。**订单**将解析订单相关数据，**产品**将解析产品相关数据，**库存**将解析库存相关数据，依此类推。**网关**然后合并图形数据并将其发送回客户端。

`graphql-java`库([https://www.graphql-java.com/](https://www.graphql-java.com/))提供了 GraphQL 规范的 Java 实现。它的源代码可以在 https://github.com/graphql-java/graphql-java 的[获得。](https://github.com/graphql-java/graphql-java)

有很多针对 GraphQL 的 Spring Boot Starter 项目，例如在[https://github . com/graph QL-Java-kickstart/graph QL-spring-boot](https://github.com/graphql-java-kickstart/graphql-spring-boot)。不过我们准备用网飞的**域名图服务** ( **DGS** )框架([https://netflix.github.io/dgs/](https://netflix.github.io/dgs/))。网飞的 DGS 不仅提供了 GraphQL Spring Boot 入门版，还提供了开发生产就绪的 GraphQL 服务所需的全套工具和库。它建立在 Spring Boot 之上，使用了`graphql-java`库。

网飞在 2021 年 2 月将 DGS 框架用于生产后，对其进行了开源。它不断得到社区的增强和支持。网飞基于他们的产品使用相同的开源代码，这为代码的质量和未来的维护提供了保证。

它提供以下功能:

*   提供了一个 Spring Boot 启动器，并与 Spring Security 集成
*   Gradle 插件，用于从 GraphQL 模式生成代码
*   支持接口和联合类型，并提供自定义标量类型
*   使用 WebSocket 和服务器发送的事件支持 GraphQL 订阅
*   错误处理
*   可插拔仪器
*   通过与 GraphQL Federation 的轻松集成实现 GraphQL 联邦服务
*   文件上传
*   图形 java 客户端
*   GraphQL 测试框架

将来可能会提供完整的 WebFlux 支持。在写这一章的时候发布候选版本是可用的。

让我们在下一节中使用网飞的 DGS 框架编写一个 GraphQL 服务器。

# graph QL 服务器的实现

在本章中，您将开发一个独立的 GraphQL 服务器。您在开发独立 GraphQL 服务器时获得的知识可以用来实现联邦 GraphQL 服务。

让我们在下一小节中首先创建 Gradle 项目。

## 创建 gRPC 服务器项目

要么你可以使用来自一个克隆的 Git 存储库的`Chapter 14`代码([https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot))，要么你可以使用*Spring Initializr*([https://start.spring.io/](https://start.spring.io/))为服务器和客户端从头开始创建一个新的 Spring 项目，选项如下(你将单独创建 gRPC `api`库项目):

*   **项目**:梯度项目
*   **语言** : Java
*   **Spring Boot** : `2.4.4`(首选版本为 2.4+；如果不可用，您可以稍后在`build.gradle`文件中手动修改它)
*   **Project Metadata**:

    **组** : `com.packt.modern.api`

    **神器** : `chapter14`

    **姓名** : `chapter14`

    **描述** : `Chapter 14 code of book Modern API Development with Spring and Spring Boot`

    **包名** : `com.packt.modern.api`

*   **包装** : `JAR`
*   **Java** : `11`(如下面的代码块所示，稍后可以在`build.gradle`文件中将其更改为另一个版本如 15/16/17):

    ```java
    // update following build.gradle file
    sourceCompatibility = JavaVersion.VERSION_15
    // or for Java 16
    // sourceCompatibility = JavaVersion.VERSION_16
    // or for Java 17
    // sourceCompatibility = JavaVersion.VERSION_17
    ```

*   **属地** : `org.springframework.boot:spring-boot-starter-web`

然后，您可以点击**生成**按钮并下载项目。下载的项目将用于创建 GraphQL 服务器。

接下来，让我们将 GraphQL DGS 依赖项添加到新创建的项目中。

## 添加 GraphQL DGS 依赖项

一旦 Gradle 项目可用，您可以修改`build.gradle`文件以包含 GDS 依赖项和插件，如以下代码所示:

```java
plugins {
  id 'org.springframework.boot' version '2.4.4'
  id 'io.spring.dependency-management' version 
    '1.0.11.RELEASE'
  id 'java'
  id 'com.netflix.dgs.codegen' version '4.6.4'
}
// other part removed from brevity
def dgsVersion = '3.12.1'
dependencies {
  implementation platform("com.netflix.graphql.dgs:
 graphql-dgs-platform-dependencies:${dgsVersion}")
  implementation 'com.netflix.graphql.dgs:graphql-dgs-
 spring-boot-starter'
  implementation 'com.netflix.graphql.dgs:graphql-dgs-
 extended-scalars'
  implementation 'org.springframework.boot:spring-boot-
      starter-web'
  testImplementation 'org.springframework.boot:spring-boot-
      starter-test'
 implementation 'com.github.javafaker:javafaker:1.0.2'
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/build.gradle

这里添加了 DGS Codegen 插件，它将从 GraphQL 模式文件生成代码。接下来，添加了以下三个依赖项:

*   `graphql-dgs- platform-dependencies`:DGS**物料清单** ( **BOM** )的 DGS 平台依赖
*   `graphql-dgs-spring-boot-starter`:支持 DGS Spring 的 DGS Spring Boot Starter 库
*   用于定制标量类型的 DGS 扩展标量库

请注意，这里使用了`javafaker`库来生成域种子数据。

接下来，让我们在`build.gradle`文件中配置 DGS Codegen 插件，如下一个代码块所示:

```java
generateJava {
    packageName = "com.packt.modern.api.generated"
    generateClient = true
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/build.gradle

您已经使用`generateJava`任务配置了 DGS Codegen 的以下两个属性，该任务使用了`com.netflix.graphql.dgs.codegen.gradle.GenerateJavaTask`类:

*   `packageName`:生成的 Java 类的 Java 包名
*   `generateClient`:是否要生成客户端

默认情况下，DGS Codegen 插件从`src/main/resources/schema`文件夹中选择 GraphQL 模式文件。但是，您可以使用接受数组的`schemaPaths`属性来修改它。如果您想更改默认的模式位置，您可以在`generateTask`的前面的代码中添加该属性以及`packageName`和`generateClient`，如下所示:

```java
schemaPaths = ["${projectDir}/src/main/resources/schema"]
```

在第三章 、 *API 规范和实现*中*将 OpenAPI 规范转换为 Spring 代码*一节的*步骤 4* 中，您还可以配置类型映射，就像您为`org.hidetake.swagger.generator` Gradle 插件所做的那样。要添加自定义类型映射，您可以将`typeMapping`属性添加到插件任务，如下所示:

```java
typeMapping = ["GraphQLType": "mypackage.JavaType"]
```

此属性接受数组；您可以在此添加一个或多个类型映射。你可以参考[https://netflix.github.io/dgs/generating-code-from-schema/](https://netflix.github.io/dgs/generating-code-from-schema/)的插件文档了解更多信息。

接下来让我们添加 GraphQL 模式。

## 添加 GraphQL 模式

网飞的 DGS 支持代码优先和设计优先的方法。然而，你将在本章中使用设计优先的方法，就像我们在整本书中所做的那样。因此，首先您将使用 GraphQL 模式语言设计模式，然后使用生成的代码实现 GraphQL APIs。

我们将保持域对象最小化，以降低业务逻辑的复杂性，并将重点放在 GraphQL 服务器实现上。因此，您将只有两个域对象—`Product`和`Tag`。GraphQL 模式允许使用其端点执行以下操作，如以下模式文件所示:

```java
type Query {
  products(filter: ProductCriteria): [Product]!
  product(id: ID!): Product
}
type Mutation {
  addTag(productId: ID!, tags: [TagInput!]!): Product
  addQuantity(productId: ID!, quantity: Int!): Product
}
type Subscription {
  quantityChanged(productId: ID!): Product
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/resources/schema/schema.graphqls

您需要在`src/main/resources/schema`位置添加`schema.graphqls` GraphQL 模式文件。可以有多个模式文件来创建模块模式。

这里，已经公开了以下根类型:

*   **查询**:`product`和`products`查询根据 ID 获取产品，以及符合给定条件的产品集合。
*   **突变**:`addTag`突变会给与给定 ID 匹配的产品添加一个标签。另一个突变`addQuantity`，会增加产品数量。`addQuantity`突变也将被用作触发订阅发布的事件。
*   **订阅**:`quantityChanged`订阅将发布数量已经更新的产品。事件数量变化将通过`addQuantity`突变来捕获。

让我们添加在这些根类型中使用的对象类型和输入类型,如下一个代码块所示:

```java
type Product {
  id: String
  name: String
  description: String
  imageUrl: String
  price: BigDecimal
  count: Int
  tags: [Tag]
}
type Tag {
  id: String
  name: String
}
input ProductCriteria {
  tags: [TagInput] = []
  name: String = ""
  page: Int = 1
  size: Int = 10
}
input TagInput {
  name: String
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/resources/schema/schema.graphqls

这些是简单的对象和输入类型。`ProductCriteria`输入类型的所有字段都是可选的。

你已经也使用了一个`BigDecimal`自定义标量类型。因此，我们需要首先在模式中声明它。您可以通过在模式文件的末尾添加`BigDecimal`来实现，如下所示:

```java
scalar BigDecimal
```

接下来，您还需要在代码生成器插件中将它映射到`java.math.BigDecimal`。让我们将它添加到如下所示的`build.gradle`文件中(检查突出显示的行):

```java
generateJava {
  generateClient = true
  packageName = "com.packt.modern.api.generated"
  typeMapping = ["BigDecimal": "java.math.BigDecimal"]
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/build.gradle

完成这些更改后，您的项目就可以生成 GraphQL 对象和客户机了。您可以从项目根目录运行以下命令来构建项目:

```java
gradlew clean build
```

这个命令将在`build/generated`目录中生成 Java 类。

在您开始实现 GraphQL 根类型之前，让我们在下一小节中讨论定制标量类型。

## 添加自定义标量类型

您将使用`BigDecimal`来获取货币值。这是一个自定义标量类型，因此您需要将这个自定义标量添加到代码中，以便 DGS 框架可以选择它进行序列化和反序列化。(除了在 Gradle 代码生成器插件中添加映射之外，还必须完成此操作。)

创建一个名为`BigDecimalScaler.java`的新 Java 文件，并向其中添加以下代码:

```java
@DgsScalar(name = "BigDecimal")
public class BigDecimalScalar extends 
    GraphqlBigDecimalCoercing {
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/scalar/BigDecimalScalar.java

这里，`class`用`@DgsScalar`注释标记，它将这个类注册为 DGS 框架的自定义标量。理想情况下，您应该实现`graphql.schema.Coercing`接口(是`graphql-java`库的一部分)。此接口允许您实现自定义标量类型的序列化和解析。

然而，由于`BigDecimal`默认实现(`GraphqlBigDecimalCoercing`)已经存在于`graphql-java`中，我们将简单地扩展它。

DGS 框架还提供了自定义标量，如`DateTime`。这些自定义标量也可以添加到 DGS 框架中。`DateTime`自定义标量实现可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 14/src/main/Java/com/packt/Modern/API/scalar/datetime scalar . Java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/scalar/DateTimeScalar.java)获得，可以作为添加其他 DGS 自定义标量类型的参考。

接下来，让我们开始实现 GraphQL 根类型。首先，您将实现 GraphQL 查询。

## 实现 GraphQL 查询

这两个查询都很简单。您传递一个产品 ID 来查找由该 ID 标识的产品——这就是对您的`product`查询。接下来，将可选的产品标准传递给，根据给定的标准查找产品，否则根据产品标准字段的默认值返回产品。

在休息时，你已经做到了。您创建一个控制器，将调用传递给服务，服务调用存储库从数据库获取数据。你将使用相同的设计。然而，您将使用`ConcurrentHashMap`代替数据库来简化代码。这也可以用在你的自动化测试中。

让我们为此创建一个存储库类，如下一个代码块所示:

```java
public interface Repository {
  Product getProduct(String id);
  List<Product> getProducts();
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/repository/Repository.java

这些是获取产品和产品集合的简单签名。

让我们使用`ConcurrentHashMap`实现这个接口，如下一个代码块所示:

```java
@org.springframework.stereotype.Repository
public class InMemRepository implements Repository {
  private final Logger LOG = LoggerFactory.getLogger(
                             getClass());
  private static final Map<String, Product> 
    productEntities = new ConcurrentHashMap<>();
  private static final Map<String, Tag> tagEntities = 
    new ConcurrentHashMap<>();
  // rest of the code is truncated
```

在这里，您已经创建了`ConcurrentHashMap`的两个实例来存储产品和标签。让我们使用构造函数将种子数据添加到这些地图中:

```java
 public InMemRepository() {
  Faker faker = new Faker();
  IntStream.range(0, faker.number().numberBetween(20, 50))
   .forEach(number -> {
     String tag = faker.book().genre();
     tagEntities.putIfAbsent(tag, 
        Tag.newBuilder().id(UUID.randomUUID().toString())
        .name(tag).build());
  });
  IntStream.range(0, faker.number().numberBetween(4, 20))
   .forEach(number -> {
     String id = String.format("a1s2d3f4-%d", number);
     String title = faker.book().title();
     List<Tag> tags = tagEntities.entrySet().stream()
       .filter(t -> t.getKey().startsWith(
         faker.book().genre().substring(0, 1)))
       .map(Entry::getValue).collect(toList());
     if (tags.isEmpty()) {               
       tags.add(tagEntities.entrySet().stream()
         .findAny().get().getValue());
     }
     Product product = Product.newBuilder().id(id).name(
           title)          
       .description(faker.lorem().sentence())
       .count(faker.number().numberBetween(10, 100))
       .price(BigDecimal.valueOf(faker.number()
             .randomDigitNotZero()))
       .imageUrl(String.formatimg/%s.jpeg", 
          title.replace(" ", "")))
       .tags(tags).build();
      productEntities.put(id, product);
  });
 }
```

这段代码首先生成标签，然后生成产品，并将它们存储在各自的地图中。这样做只是为了开发目的。您应该在生产应用中使用数据库。

现在，`getProduct`和`getProducts`方法很简单，如下一个代码块所示:

```java
@Override
public Product getProduct(String id) {
  if (Strings.isBlank(id)) {
    throw new RuntimeException("Invalid Product ID.");
  }
  Product product = productEntities.get(id);
  if (Objects.isNull(product)) {
    throw new RuntimeException("Product not found.");
  }
  return product;
}
@Override
public List<Product> getProducts() {
  return productEntities.entrySet().stream().map(e -> 
                       e.getValue()).collect(toList());
}
```

`getProduct`方法执行基本验证并返回产品。`getProducts`方法只是返回从地图转换而来的产品集合。

现在，您可以添加服务及其实现。让我们添加服务接口，如下一个块所示:

```java
public interface ProductService {
  Product getProduct(String id);
  List<Product> getProducts(ProductCriteria criteria);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/services/ProductService.java

这些接口简单地调用存储库来获取数据。让我们添加如下一个代码块所示的实现:

```java
@Service
public class ProductServiceImpl implements ProductService {
  private final Repository repository;
  public ProductServiceImpl(Repository repository) {
    this.repository = repository;
  }
  @Override
  public Product getProduct(String id) {
    return repository.getProduct(id);
  }
  // continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/services/ProductServiceImpl.java

这里，使用构造函数注入来注入存储库。

让我们添加`getProducts()`方法，它也根据给定的过滤标准执行过滤，如下一个代码块所示:

```java
@Override
public List<Product> getProducts(ProductCriteria criteria) {
  List<Predicate<Product>> predicates = new ArrayList<>(2);
  if (!Objects.isNull(criteria)) {
    if (Strings.isNotBlank(criteria.getName())) {
      Predicate<Product> namePredicate = p -> 
          p.getName().contains(criteria.getName());
      predicates.add(namePredicate);
    }
    if (!Objects.isNull(criteria.getTags()) && 
        !criteria.getTags().isEmpty()) {
      List<String> tags = criteria.getTags().stream().map(
          ti -> ti.getName()).collect(toList());
      Predicate<Product> tagsPredicate = p ->
         p.getTags().stream().filter(t -> 
                   tags.contains(t.getName())).count() > 0;
      predicates.add(tagsPredicate);
    }
  }
  if (predicates.isEmpty()) {
    return repository.getProducts();
  }
  return repository.getProducts().stream()
        .filter(p -> predicates.stream().allMatch(
                   pre -> pre.test(p))).collect(toList());
}
```

该方法首先检查是否给定了标准。如果没有给出标准，那么它调用存储库并返回所有产品。

如果给定了标准，那么它将创建谓词列表。然后，这些谓词用于过滤出匹配的产品，并返回给调用函数。

现在是 GraphQL 查询实现的最关键部分:编写数据提取器。首先，接下来让我们为`product`查询编写数据获取器。

### 为产品编写数据提取器

数据获取器是一个关键的 DSG 组件，用于服务获取数据的 GraphQL 请求，DSG 在内部解析每个字段。你用特殊的`@DgsComponent` DGS 注解来标记它们。这些是 DGS 框架扫描并用于服务请求的 Spring 组件类型。

让我们在`datafetchers`包中创建一个名为`ProductDatafetcher.java`的新文件，用于表示 DGS 数据提取器组件。它将有一个数据提取器方法来服务于`product`查询。您可以向其中添加以下代码:

```java
DgsComponent
public class ProductDatafetcher {
 private final ProductService productService;
 public ProductDatafetcher(ProductService productService) {
 this.productService = productService;
 }
 @DgsData(
 parentType = DgsConstants.QUERY_TYPE, 
 field = QUERY.Product
 )
 public Product getProduct(@InputArgument("id") String id) {
 if (Strings.isBlank(id)) {
 new RuntimeException("Invalid Product ID.");
 }
 return productService.getProduct(id);
 }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java

这里，您使用构造函数创建一个产品服务 bean 注入。这个服务 bean 帮助您根据给定的产品 ID 找到产品。

另外两个重要的 DGS 框架注释已经在`getProduct`方法中使用。让我们了解一下它的作用:

*   `@DgsData`: This is a data fetcher annotation that marks the method as the data fetcher. The `parentType` property represents the type, and the `field` property represents the type's (`parentType`) field. Therefore, you can say that method would fetch the field of the given type.

    您已经将`"Query"`设置为`parentType`。将`field`属性设置为`"product"`查询。因此，这个方法作为 GraphQL 查询`product`调用的入口点。使用`DgsConstants`常量类设置`@DsgData`注释属性。

    `DgsConstants`是由 DGS Gradle 插件生成的，它包含了模式的所有常量部分。

*   `@InputArgument`:这个注释允许您捕获 GraphQL 请求传递的参数。这里，`id`参数的值被捕获并分配给`id`字符串变量。

您可以在*测试自动化*部分找到与这个数据获取方法相关的测试用例。

类似地，您可以为`products`查询编写数据获取器方法。让我们在下一小节中对其进行编码。

### 为产品集合编写数据提取器

让我们在`datafetchers`包中创建一个名为`ProductsDatafetcher.java`的新文件，用于表示一个 DGS 数据提取器组件。它将有一个数据提取器方法来服务于`products`查询。你可以给它添加下面的代码:

```java
@DgsComponent
public class ProductsDatafetcher {
  private final Logger LOG = LoggerFactory.getLogger(
      getClass());
  private ProductService service;
  public ProductsDatafetcher(ProductService service) {
    this.service = service;
  }
  @DgsData(
      parentType = DgsConstants.QUERY_TYPE,
      field = QUERY.Products
  )
  public List<Product> getProducts(
              @InputArgument("filter") ProductCriteria 
                  criteria) {
    return service.getProducts(criteria);
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java

这个`getProducts()`方法看起来与倒数第二个代码块中为`getProduct()`返回的数据提取器方法没有什么不同。在这里，`@DsgData`的`parentType`和`field`属性表明这个方法将被用于为`"products"`查询获取产品集合(最后是额外的`s`)。

您已经完成了 GraphQL 查询实现。您现在可以测试您的更改。您需要在运行测试之前构建应用。让我们使用以下命令构建应用:

```java
$ gradlew clean build
```

构建成功完成后，您可以运行以下命令来运行应用:

```java
$ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar
```

如果您没有对端口设置进行任何更改，应用应该在默认端口`8080`上运行。

现在，您可以打开一个浏览器窗口，并使用以下 URL 打开 graphisql:`http://localhost:8080/graphiql`(DGS 框架的一部分)。如果需要，相应地更改主机/端口。

您可以使用以下查询来提取产品集合:

```java
{
  products(filter: {name: "His Dark Materials", tags: [{name: 
                   "Fantasy"}, {name: "Legend"}]}
  ) {
    id
    name
    price
    description
    tags {
      id
      name
    }
  }
}
```

这会很有用的。但是，如果您必须单独获取标签，该怎么办呢？您可能在可能从单独的数据库或服务或从两个单独的表中获取的对象中有关系(比如有账单信息的订单)。在这种情况下，您可能希望使用数据提取器方法添加字段解析器。

让我们在下一小节中使用数据提取器方法添加一个字段解析器。

### 使用数据提取器方法编写字段解析器

到目前为止，您还没有一个单独的数据获取器来获取标签。你获取产品，它也为你获取标签，因为我们使用一个并发映射将两个数据存储在一起。因此，首先您需要编写一个新的数据获取器方法来获取给定产品的标签。

让我们将`tags()`方法添加到`ProductsDatafetcher`类来获取标签，如下一个代码块所示:

```java
 @DgsData(
     parentType = PRODUCT.TYPE_NAME,
     field = PRODUCT.Tags
 )
 public List<Tags>  tags(String productId) {
   return tagService.fetch(productId);
 }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java

这里，`tags()`方法为`@DsgData`属性提供了一组不同的值。`parentType`属性不像早期的数据提取器方法那样设置为根类型(设置为`Query`)。相反，它被设置为一个对象类型—`"Product"`。`field`属性被设置为`"tags"`。

这个方法将被调用来获取每个产品的标签，因为它是`Product`对象的`tags`字段的字段解析器。因此，如果你有 20 个产品，这个方法将被调用 20 次，以获取这 20 个产品的标签。这是一个 *N+1* 的问题，我们在上一章( [*第十三章*](13.html#_idTextAnchor263) ， *GraphQL 基础*)中有所了解。

在 *N+1* 问题中，额外的数据库调用用于获取关系数据。因此，给定一个产品集合，它可能会访问数据库来分别获取每个产品的标签。

您知道您必须使用数据加载器来避免 *N+1* 问题。数据加载器在单个查询中提取相应的标签之前，会缓存产品的所有 id。

接下来，让我们学习如何实现一个数据加载器来修复这种情况下的 *N+1* 问题。

### 编写一个数据加载器来解决 N+1 问题

你将利用`DataFetchingEnvironment`类作为数据获取方法中的参数。它由数据获取器方法中的`graphql-java`库注入，以提供执行上下文。这个执行上下文包含关于解析器的信息，例如对象及其字段。您还可以在特殊的用例中使用它们，比如加载数据加载器类。

让我们修改前面代码块中提到的`ProductsDatafetcher`类中的`tags()`方法，以获取标签，而不会出现 *N+1* 的问题，如下一个代码块所示:

```java
 @DgsData(
     parentType = PRODUCT.TYPE_NAME,
     field = PRODUCT.Tags
 )
 public CompletableFuture<List<Tags>>  
            tags(DgsDataFetchingEnvironment env) {
   DataLoader<String, List<Tags>> tagsDataLoader = 
          env.getDataLoader(
 TagsDataloaderWithContext.class);
   Product product = env.getSource();
   return tagsDataLoader.load(product.getId());
 }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductsDatafetcher.java

这里，修改的`tags()`数据提取器方法使用数据加载器执行提取方法，并返回包装在`CompletableFuture`内的标签集合。即使产品的数量大于 1，它也只被调用一次。

什么是 CompletableFuture？

`CompletableFuture`是一个 Java 并发类，表示异步计算的结果，被显式标记为完成。它可以异步链接多个相关任务，当当前任务的结果可用时，将触发下一个任务。

你在用`DsgDataFetchingEnvironment`做论据。它实现了`DataFetchingEnvironment`接口，并提供了通过类和名称加载数据加载器类的方法。这里，您使用数据加载器类来加载数据加载器。

`DsgDataFetchingEnvironment`的`getSource()`方法从`@DsgData`的`parentType`属性中返回值。因此，`getSource()`返回`Product`。

这个修改过的数据获取器方法将获取给定产品列表的标签。产品列表？您只是传递了一个产品 ID。这是正确的，数据加载器类实现了`MappedBatchLoader`，它使用批处理来执行操作。

数据加载器类使用数据加载器*批量*获取给定产品的标签(通过 ID)。神奇之处在于返回`CompletableFuture`。因此，尽管您将单个产品 ID 作为参数传递，但数据加载器会成批处理它。接下来让我们实现这个数据加载器类(`TagsDataloaderWithContext`)来深入研究它。

有两种方法可以创建数据加载器类——有上下文或没有上下文。没有上下文的数据加载器实现`MappedBatchLoader`，它具有以下方法签名:

```java
CompletionStage<Map<K, V>> load(Set<K> keys);
```

另一方面，带有上下文的数据加载器实现了`MappedBatchLoaderWithContext`接口，该接口具有以下方法签名:

```java
CompletionStage<Map<K, V>> load(Set<K> keys, 
    BatchLoaderEnvironment environment);
```

就数据加载而言，两者是相同的。然而，带有上下文的数据加载器为您提供了额外的信息(通过`BatchLoaderEnvironment`)，这些信息可用于各种附加特性，比如认证、授权或传递数据库细节。

用下面的代码在`dataloaders`包的中创建一个名为`TagsDataloaderWithContext.java`的新 Java 文件:

```java
@DgsDataLoader(name = "tagsWithContext")
public class TagsDataloaderWithContext implements                    MappedBatchLoaderWithContext<String,                  List<Tag>> {
  private final TagService tagService;
  public TagsDataloaderWithContext(TagService tagService) {
    this.tagService = tagService;
  }
  @Override
  public CompletionStage<Map<String, List<Tag>>>       load(Set<String> keys,       BatchLoaderEnvironment environment) {
    return CompletableFuture.supplyAsync(() ->                     tagService.getTags(new ArrayList<>(keys)));
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagsDataloaderWithContext.java

这里，它从`MappedBatchLoaderWithContext`接口实现了`load()`方法。`BatchLoaderEnvironment`参数存在，它提供了上下文，但是我们没有使用它，因为我们不需要向存储库或底层数据访问层传递任何额外的信息。你可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 14/src/main/Java/com/packt/Modern/API/data loaders/tagdata loader . Java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/dataloaders/TagDataloader.java)找到没有上下文的数据加载器。这类似于我们为带有上下文的数据加载器编写的内容，因为我们不使用上下文。

您可以看到它让使用标签的服务来获取标签。然后，通过提供从标签服务接收的标签，简单地返回完成阶段。该操作由数据加载器批量执行。

您可以创建新的标记服务及其实现，如下所示:

```java
public interface TagService {
  Map<String, List<Tag>> getTags(List<String> productIds);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/services/TagService.java

这是`getTags`方法的签名，它返回带有相应标签的产品 id 的映射。

让我们实现这个接口，如下一个代码块所示:

```java
@Service
public class TagServiceImpl implements TagService {
  private final Repository repository;
  public TagServiceImpl(Repository repository) {
    this.repository = repository;
  }
  @Override
  public Map<String, List<Tag>> getTags(List<String> 
      productIds) {
    return repository.getProductTagMappings(productIds);
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/services/TagServiceImpl.java

这里，实现的方法很简单。它将调用传递给存储库，后者根据传递的产品 id 集合获取标签。

您可以将`getProductTagMappings`添加到`Repository`接口，如下一行所示:

```java
Map<String, List<Tag>> getProductTagMappings(List<String>     productIds);
```

然后，您可以在`InMemRepository`类中实现这个方法，如下一个代码块所示:

```java
@Override
public Map<String, List<Tag>> getProductTagMappings(    List<String> productIds) {
  return productEntities.entrySet().stream()
            .filter(e -> productIds.contains(e.getKey()))
            .collect(toMap(e -> e.getKey(),               e -> e.getValue().getTags()));
}
```

这里，它首先创建产品映射的条目集的流，然后过滤与这个方法传递的中的产品相匹配的产品。最后，它将过滤后的产品转换为映射，产品 ID 为`Key`，值为`Tags`，然后返回。

现在，如果您调用`"product"` GraphQL 查询，即使产品是通过一个适当的规范化数据库获取的，它也会批量加载产品标签，而不会出现 *N+1* 问题。

您已经完成了 GraphQL 查询实现，应该可以轻松地自己实现查询了。

接下来，您将实现 GraphQL 变异。

## 实现 GraphQL 突变

按照 GraphQL 模式，您将实现两个突变——`addTag`和`addQuantity`。

`addTag`变异将`productId`和一组`tags`作为参数，并返回`Product`对象。`addQuantity`变异将`productId`和`quantity`相加并返回`Product`。

让我们将这个实现添加到现有的`ProductDatafetcher`类中，如下面的代码块所示:

```java
// rest of the ProductDatafetcher class code
@DgsMutation(field = MUTATION.AddTag)
public Product addTags(@InputArgument("productId") String 
      productId,
    @InputArgument(value = "tags", collectionType = 
 TagInput.class) List<TagInput> tags) {
  return tagService.addTags(productId, tags);
}
@DgsMutation(field = MUTATION.AddQuantity)
public Product addQuantity(
    @InputArgument("productId") String productId,
    @InputArgument(value = "quantity") int qty) {
  return productService.addQuantity(productId, qty);
}
// rest of the ProductDatafetcher class code
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java

这里，这些签名遵循 GraphQL 模式中编写的各自的突变。您正在使用另一个 DGS 框架`@DgsMutation`注释，这是一种`@DgsData`注释，它被标记在方法上以表示它们是一个数据提取器方法。默认情况下，`@DgsMutation`注释的`Mutation`值被设置为`parentType`属性。您只需要在这个注释中设置`field`属性。这两种方法都将各自的值设置为`@DgsMutation`注释中的`field`属性。

如果您注意的话，您会发现标签的`@InputArgument`注释使用了另一个用于设置输入类型的`collectionType`属性。当输入类型不是标量时，它是必需的。如果你不使用它，你会得到一个错误。因此，只要有非标量类型的输入，就要确保使用`collectionType`属性。

这些方法使用标签和产品服务来执行所请求的操作。到目前为止，您还没有在`ProductDatafetcher`类中添加标签服务。因此，您需要首先添加`TagService`,如下一个代码块所示:

```java
// rest of the ProductDatafetcher class code
private final TagService tagService;
public ProductDatafetcher(ProductService productService,
                                  TagService tagService) {
  this.productService = productService;
  this.tagService = tagService;
}
// rest of the ProductDatafetcher class code
```

这里，已经使用构造函数注入了`TagService` bean。

现在，需要实现`TagService`中的`addTag()`方法和`ProductService`中的`addQuantity`方法。接口和它们的实现都很简单，将调用传递给存储库来执行操作。您可以查看 GitHub 代码库中的源代码([https://GitHub . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter14))来了解这些实现。

让我们将这两个方法添加到`Repository`接口，如下一个代码块所示:

```java
Product addTags(String productId, List<TagInput> tags);
Product addQuantity(String productId, int qty);
```

`Repository`接口中的这些签名也遵循 GraphQL 模式中编写的各自的变化。

让我们首先在`InMemRepository`类中实现`addTags()`方法，如下一个代码块所示:

```java
@Override
public Product addTags(String productId, List<TagInput> tags) {
  if (Strings.isBlank(productId)) {
    throw new RuntimeException("Invalid Product ID.");
  }
  Product product = productEntities.get(productId);
  if (Objects.isNull(product)) {
    throw new RuntimeException("Product not found.");
  }
  if (tags != null && !tags.isEmpty()) {
    List<String> newTags = tags.stream()
         .map(t -> t.getName()).collect(toList());
    List<String> existingTags = product.getTags().stream()
         .map(t -> t.getName()).collect(toList());
    newTags.stream().forEach(nt -> {
      if (!existingTags.contains(nt)) {
        product.getTags().add(Tag.newBuilder()
           .id(UUID.randomUUID().toString()).
                name(nt).build());
      }
    });
    productEntities.put(product.getId(), product);
  }
  return product;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java

这个实现很简单。它对传递的产品 ID 执行几个验证。然后，它比较新的和现有的标签，只有在现有标签不存在的情况下，才会将新标签添加到传递的产品中。最后，它更新并发映射并返回更新后的产品。

接下来让我们将`addQuantity()`方法的实现添加到`InMemRepository`类中，如下面的代码块所示:

```java
@Override
public Product addQuantity(String productId, int qty) {
  if (Strings.isBlank(productId)) {
    throw new RuntimeException("Invalid Product ID.");
  }
  if (qty < 1) {
    throw new RuntimeException("Quantity arg can't be less 
                               than 1");
  }
  Product product = productEntities.get(productId);
  if (Objects.isNull(product)) {
    throw new RuntimeException("Product not found.");
  }
  product.setCount(product.getCount() + qty);
  productEntities.put(product.getId(), product);
  return product;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/repository/InMemRepository.java

在这里，首先对`productId`和`qty`参数进行验证。如果一切顺利，那么您增加产品的数量，更新并发映射，并返回更新的产品。

您已经完成了 GraphQL 变异的实现。您现在可以测试您的更改。您需要在运行测试之前构建应用。让我们使用以下命令构建应用:

```java
$ gradlew clean build
```

构建成功完成后，您可以运行以下命令来运行应用:

```java
$ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar
```

如果您没有对端口设置做任何更改，应用应该在默认端口`8080`上运行。

现在，您可以打开一个浏览器窗口，并使用以下 URL 打开 graphisql:`http://localhost:8080/graphiql`(DGS 框架的一部分)。如果需要，相应地更改主机/端口。

您可以使用下面的 GraphQL 请求来执行`addTag`突变:

```java
mutation {
  addTag(productId: "a1s2d3f4-0", tags: [
    {
      name:"new Tags..."
    }
  ]) {
    id
    name
    price
    description
    tags {
      id
      name
    }
  }
}
```

这里，您将`productId`和`tags`作为参数传递。您可以使用下面的 GraphQL 请求来执行`addQuantity`变异:

```java
mutation {
 addQuantity(productId: "a1s2d3f4-0", quantity: 10) {
    id
    name
    description
    price
    count
    tags {
      id
      name
    }
  }
}
```

这里，将`productId`和`quantity`作为参数传递。您已经学习了如何在 GraphQL 服务器中实现 GraphQL 变异。让我们在下一小节中实现 GraphQL 订阅。

## 实现 GraphQL 订阅

Subscription 是另一种 GraphQL 根类型，它在特定事件发生时将对象发送给订阅者(客户机)。

让我们假设一家网店在产品库存达到一定水平时对产品提供折扣。您不能手动跟踪每件产品的数量，然后执行计算并触发折扣。这是您可以使用订阅的地方。

通过`addQuantity()`突变引起的产品库存(数量)的每次变化都应触发事件，用户应收到更新的产品和数量。然后，订户可以放置逻辑并自动化这个过程。

让我们编写订阅，将更新的产品对象发送给订阅者。您将使用反应流和 WebSocket 来实现这一功能。

让我们在`build.gradle`中添加额外的依赖项来处理 WebSocket 和 playground 工具的自动配置，以测试订阅功能。(默认情况下，DGS 提供了 GraphiQL 应用来浏览文档和模式，并进行查询。然而，捆绑的 GraphiQL 工具目前还不能很好地测试订阅。一旦它开始工作，你就不需要添加操场工具了。)

让我们将这些依赖项添加到`build.gradle`中，如下面的代码块所示:

```java
dependencies {
  // other dependencies …
  runtimeOnly 'com.netflix.graphql.dgs:graphql-dgs-
    subscriptions-websockets-autoconfigure'
  implementation 'com.graphql-java-kickstart:playground-
    spring-boot-starter:11.0.0'
  // other dependencies …
}
```

现在，您可以将以下订阅数据提取器添加到`ProductDatafetcher`类中，如以下代码所示:

```java
// rest of the ProductDatafetcher class code
@DgsSubscription(field = SUBSCRIPTION.QuantityChanged)
public Publisher<Product> quantityChanged(
                     @InputArgument("productId") String 
                     productId) {
  return productService.gerProductPublisher();
}
// rest of the ProductDatafetcher class code
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/datafetchers/ProductDatafetcher.java

这里，使用了另一个 DGS 框架注释，`@DgsSubscription`，这是一种`@DgsData`注释，它被标记在一个方法上，表示它是一个数据提取器方法。默认情况下，`@DgsSubscription`注释的`Subscription`值被设置为`parentType`属性。您只需要在这个注释中设置`field`属性。通过将该字段设置为`quantityChanged`，您指示 DGS 框架在调用`quantityChanged`的订阅请求时使用该方法。

`Subscription`方法返回`Publisher`实例，可以将无限数量的对象(在本例中是`Product`实例)发送给多个订阅者。因此，客户端只需订阅产品发布者。

您需要向`ProductService`接口及其在`ProductServiceImpl`类中的实现添加一个新方法。`ProductService`接口中的方法签名及其实现非常简单。它将调用传递给存储库来执行操作。你可以在[https://GitHub . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 14](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter14)查看 GitHub 代码库中的源代码。

存储库正在执行实际的工作。因此，您需要在存储库中进行某些更改，如以下步骤所示:

1.  首先将下面的方法签名添加到`Repository`接口:

    ```java
          Publisher<Product> getProductPublisher();
    ```

2.  接下来，您必须在`InMemRepository`类中实现`getProductPublisher()`方法。该方法返回产品发行商，如下面的代码所示:

    ```java
          public Publisher<Product> getProductPublisher() {
            return productPublisher;
          }
    ```

3.  现在，我们需要所有的魔法都由反应流来执行。首先，让我们声明`FluxSink<Product>`和`ConnectableFlux<Product>`(由存储库返回)变量:

    ```java
          private FluxSink<Product> productsStream;
          private ConnectableFlux<Product> productPublisher;
    ```

4.  现在，我们需要初始化这些声明的实例。让我们在`InMemRepository`的构造函数中这样做，如下面的代码所示:

    ```java
          Flux<Product> publisher = Flux.create(emitter -> {
            productsStream = emitter;
          });
          productPublisher = publisher.publish();
          productPublisher.connect();
    ```

5.  `Flux<Product>`是一个产品流发布者，它将接力棒传递给`productsStream` ( `FluxSink`)来发出下一个信号，然后是`onError()`或`onComplete()`事件。这意味着`productsStream`应该在产品数量发生变化时发出信号。当`Flux<Product>`调用`publish()`方法时，它返回一个`connectableFlux`的实例，该实例被分配给`productPublisher`(订阅返回的那个)。
6.  您几乎完成了设置。你只需要在产品发生变化时发出信号(产品)。让我们在`addQuantity()`方法返回产品之前将下面突出显示的行添加到该方法中，如下面的代码所示:

    ```java
          product.setCount(product.getCount() + qty);
          productEntities.put(product.getId(), product);
          productsStream.next(product);
          return product;
    ```

您已经完成了订阅`quantityChanged`的实现。接下来可以测试一下。

在运行测试之前，您需要来构建应用。让我们使用以下命令构建应用:

```java
$ gradlew clean build
```

构建成功完成后，您可以运行以下命令来运行应用:

```java
$ java –jar build/libs/chapter14-0.0.1-SNAPSHOT.jar
```

如果您没有对端口设置进行任何更改，应用应该在默认端口`8080`上运行。

如果应用在本地主机上运行，那么 playground 工具应该在`http://localhost:8080/playground`可用，否则在主机名中进行适当的更改。

playground 应用启动后，在其中运行以下查询:

```java
subscription {
  quantityChanged(productId: "a1s2d3f4-0") {
    id
    name
    description
    price
    count
  }
}
```

这将在监听模式下触发应用。应用将等待对象发布。

现在，您可以打开另一个浏览器窗口，并使用以下 URL 打开 graphisql:`http://localhost:8080/graphiql`。如果需要，相应地更改主机/端口。

在这里，您可以通过运行以下命令来触发`addQuantity`突变:

```java
mutation {
 addQuantity(productId: "a1s2d3f4-0", quantity: 10) {
    id
    name
    price
    count
  }
}
```

每一次成功的更改都会将更新后的产品发布到 playground 应用。

您应该了解有助于实现跟踪、日志记录和指标收集的工具。让我们在下一小节中讨论这个问题。

## 检测 GraphQL API

GraphQL Java 库支持 GraphQL API 的插装。这可以用来支持指标、跟踪和日志记录。DGS 框架也使用它。您只需用 Spring `@Component`注释来标记检测类。

instrumentation bean 应该实现`graphql.execution.instrumentation.Instumentation`接口，这是扩展`SimpleInstumentation`类的一种更简单的方法。

让我们添加一些工具来记录数据提取器和完成 GraphQL 请求处理所花费的时间。此指标可以帮助您微调性能，并识别需要更多时间来解决的字段。

让我们在`instrumentation`包中创建文件`TracingInstrumentation.java`，并添加以下代码:

```java
@Component
public class TracingInstrumentation extends 
      SimpleInstrumentation {
  private final Logger LOG = LoggerFactory.getLogger(
      getClass());
  @Override
  public InstrumentationState createState() {
    return new TracingState();
  }
  static class TracingState implements InstrumentationState {
    long startTime;
  }
// continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/main/java/com/packt/modern/api/instrumentation/TracingInstrumentation.java

这个类扩展了`SimpleInstrumentation`，并通过将其标记为`@Component`而被创建为一个 Spring bean。首先，您需要通过覆盖`createState()`方法来创建插装状态。因为您正在实现时间度量，所以您选择`startTime`作为状态。添加了一个静态内部类来声明`startTime`状态。

作为下一个活动，您希望初始化检测状态。为此，您可以覆盖`beginExecution()`方法，如以下代码所示:

```java
@Override
public InstrumentationContext<ExecutionResult> 
    beginExecution(
      InstrumentationExecutionParameters parameters) {
  TracingState tracingState = 
      parameters.getInstrumentationState();
  tracingState.startTime = System.currentTimeMillis();
  return super.beginExecution(parameters);
}
```

该方法允许您设置仪器参数。

设置`startTime`状态。接下来，您将覆盖`instrumentExecutionResult()`方法。这个帮助您测量执行结果，比如计算总的执行时间。让我们添加以下代码来计算总执行时间:

```java
@Override
public CompletableFuture<ExecutionResult>     instrumentExecutionResult(    ExecutionResult executionResult,    InstrumentationExecutionParameters parameters) {
  TracingState tracingState =     parameters.getInstrumentationState();
  long timeTaken = System.currentTimeMillis() -     tracingState.startTime;
  LOG.info("Request processing took: {} ms", timeTaken);
  return super.instrumentExecutionResult(
                                      executionResult, 
                                      parameters);
}
```

计算总执行时间是一个简单的实现。它从参数中提取出`startTime`状态，然后用它来计算`timeTaken`值。

到目前为止，已经覆盖了三个方法——初始的方法(`createState()`)、用于状态初始化的开始方法(`beginExecution()`)和用于最终计算或状态记录的结束方法(`instrumentExecutionResult()`)。

一个介于`beginExecution()`和`instrumentExecutionResult()`之间的中间方法(`instrumentDataFetcher()`)还没有被覆盖。与其他方法相比，它很复杂。因此，您将在其他方法之后重写它。

让我们添加以下代码来覆盖`instrumentDataFetcher()`方法:

```java
@Override
public DataFetcher<?> instrumentDataFetcher(DataFetcher<?>   
      dataFetcher, InstrumentationFieldFetchParameters 
      parameters) {
  if (parameters.isTrivialDataFetcher()) {
    return dataFetcher;
  }
  return environment -> {
    long initTime = System.currentTimeMillis();
    Object result = dataFetcher.get(environment);
    String msg = "Instrumentation of datafetcher {} took {} 
                  ms";
    if (result instanceof CompletableFuture) {
      ((CompletableFuture<?>) result).whenComplete((r, ex) 
          -> {
        long timeTaken = System.currentTimeMillis() – 
            initTime;
        LOG.info(msg, findDatafetcherTag(parameters), 
            timeTaken);
      });
    } else {
      long timeTaken = System.currentTimeMillis() – 
          initTime;
      LOG.info(msg, findDatafetcherTag(parameters), 
          timeTaken);
    }
    return result;
  };
}
```

此方法用于检测数据提取器。您已经添加了两个单独的块来计算数据获取时间，因为数据获取器方法可以以两种方式返回值——阻塞调用或异步调用(`CompletableFuture`)。无论是根类型还是对象类型的字段，每次数据提取调用都会调用此方法。

仪器实现的最后一部分是`findDatafetcherTag()`方法。添加这个私有方法是为了找出字段/根类型的数据获取类型。

让我们添加它，如下面的代码所示:

```java
private String findDatafetcherTag(
                 InstrumentationFieldFetchParameters parameters) {
  GraphQLOutputType type = 
    parameters.getExecutionStepInfo()
                                        .getParent().getType();
  GraphQLObjectType parent;
  if (type instanceof GraphQLNonNull) {
    parent = (GraphQLObjectType) 
                    ((GraphQLNonNull) 
                      type).getWrappedType();
  } else {
    parent = (GraphQLObjectType) type;
  }
  return parent.getName() + "." + 
      parameters.getExecutionStepInfo().getPath()
          .getSegmentName();
}
```

这里，`GraphQLNonNull`告诉我们该类型是否是包装类型。接下来，让我们看看您可以使用什么工具来记录 API。

# 记录 API

您可以使用 GraphQL 或提供图形界面的 playground 工具来研究 GraphQL 模式和文档。

然而，如果你正在寻找一个静态页面，那么你可以使用 graph doc([https://github.com/2fd/graphdoc](https://github.com/2fd/graphdoc))这样的工具来生成 GraphQL APIs 的静态文档。

接下来，让我们学习使用 DGS 框架的 GraphQL API 测试。

# 测试自动化

DGS 框架为您提供了可以用来测试 GraphQL APIs 的类和实用程序。

在测试目录的`datafetchers`包中创建一个名为`ProductDatafetcherTest.java`的新文件，并添加以下代码:

```java
@SpringBootTest(classes = {DgsAutoConfiguration.class, 
                  ProductDatafetcher.class, 
                  BigDecimalScalar.class})
public class ProductDatafetcherTest {
  private final InMemRepository repo = new 
    InMemRepository();
  private final int TEN = 10;
  @Autowired
  private DgsQueryExecutor dgsQueryExecutor;
  @MockBean
  private ProductService productService;
  @MockBean
  private TagService tagService;
// continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter14/src/test/java/com/packt/modern/api/datafetchers/ProductDatafetcherTest.java

这里，您使用了`@SpringBootTest`注释来执行测试。通过提供有限的类，如`DgsAutoConfiguration`、`ProductDatafetcher`和`BigDecimalScalar`，您限制了 Spring 上下文。您应该在这里添加将要参与测试的类。

首先，您将自动连接执行查询的`DgsQueryExecutor`类。之后，为`Product`和`Tag`服务添加两个 Spring 注入的模拟 beans。

您已经准备好运行测试所需的配置和实例。

让我们添加运行测试之前所需的设置方法。为此，您可以添加以下方法:

```java
@BeforeEach
public void beforeEach() {
  List<Tag> tags = new ArrayList<>();
  tags.add(Tag.newBuilder().id("tag1").name("Tag 
                               1").build());
  Product product = Product.newBuilder().id("any")
             .name("mock title").description("mock 
                   description")
             .price(BigDecimal.valueOf(20.20)).count(100)
             .tags(tags).build();
  given(productService.getProduct(    "any")).willReturn(product);
  tags.add(Tag.newBuilder().id("tag2").name(    "addTags").build());
  product.setTags(tags);
  given(tagService.addTags("any",            List.of(TagInput.newBuilder().name(               "addTags").build())))
      .willAnswer(invocation -> product);
}
```

在这个方法中，我们使用 Mockito 来清除服务方法。

您已经完成了设置。接下来，在运行 GraphQL `product`查询之后，让我们运行我们的第一个测试来获取 JSON 对象。

## 测试 GraphQL 查询

让我们添加下面的代码来测试`product`查询:

```java
@Test
@DisplayName("Verify the JSON attrs returned from query 
             'product'")
public void product() {
  String name = dgsQueryExecutor.executeAndExtractJsonPath(
         "{ product(id: \"any\") { name }}", 
         "data.product.name");
  assertThat(name).contains("mock title");
}
```

这里，您使用`DgsQueryExecutor`实例来执行`product`查询并提取 JSON 属性。

接下来，您将再次测试`product`查询，但是这次是为了测试异常。

您可以添加以下代码来测试由`product`查询引发的异常:

```java
@Test
@DisplayName("Verify exception for incorrect ID in query 
             'product'")
public void productWithException() {
  given(productService.getProduct("any"))
     .willThrow(new RuntimeException("Invalid Product 
                ID."));
  ExecutionResult result = dgsQueryExecutor.execute(
                              " { product (id: \"any\") { 
                                 name }}");
  verify(productService, times(1)).getProduct("any");
  assertThat(result.getErrors()).isNotEmpty();
  assertThat(result.getErrors().get(0).getMessage())
     .isEqualTo("java.lang.RuntimeException: Invalid 
                Product ID.");
}
```

这里，产品服务方法因抛出异常而被存根化。当`DgsQueryExecutor`运行时，Spring 注入的模拟 bean 使用 stubbed 方法抛出这里正在断言的异常。

接下来，让我们再次查询`product`，这一次探索`GraphQLQueryRequest`，它允许您以流畅的方式形成 GraphQL 查询。`GraphQLQueryRequest`构造有两个参数——第一个是`GraphQLQuery`的实例，可以是查询/变异或订阅，第二个是`BaseProjectionNode`的投影根类型，允许您选择字段。

让我们添加以下代码来使用`GraphQLQueryRequest`测试`product`查询:

```java
@Test
@DisplayName("Verify JSON attrs using GraphQLQueryRequest")
void productsWithQueryApi() {
  GraphQLQueryRequest graphQLQueryRequest = new 
      GraphQLQueryRequest(
           ProductGraphQLQuery.newRequest().id(
               "any").build(),
           new ProductProjectionRoot().id().name());
  String name = dgsQueryExecutor.executeAndExtractJsonPath(
           graphQLQueryRequest.serialize(), 
           "data.product.name");
  assertThat(name).contains("mock title");
}
```

这里，`ProductGraphQLQuery`类是 DGS GraphQL Gradle 插件自动生成代码的一部分。

我们在之前的测试中还没有测试的一件事是验证`product`的`tags`字段中的子字段。

让我们在下一个测试案例中验证一下。添加以下代码来验证标记:

```java
@Test
@DisplayName("Verify the Tags returned from the query 
    'product'")
void productsWithTags() {
  GraphQLQueryRequest graphQLQueryRequest = new 
    GraphQLQueryRequest(
        ProductGraphQLQuery.newRequest().id("any").build(),
        new ProductProjectionRoot().id().name()
            .tags().id().name());
  Product p = dgsQueryExecutor.
    executeAndExtractJsonPathAsObject(
        graphQLQueryRequest.serialize(), 
        "data.product", new TypeRef<>() {});
  assertThat(p.getId()).isEqualTo("any");
  assertThat(p.getName()).isEqualTo("mock title");
  assertThat(p.getTags().size()).isEqualTo(2);
  assertThat(p.getTags().get(0).getName()).isEqualTo("Tag 1");
}
```

在这里，可以看到，如果想要查询子字段，必须在`executeAndExtractJsonPathAsObject()`方法中使用第三个参数(`TypeRef`)。如果你不使用它，你会得到一个错误。

您已经完成了 GraphQL 查询测试。让我们在下一小节继续测试突变。

## 检测 GraphQL 突变

测试一个 GraphQL 变异与测试 GraphQL 查询没有什么不同。

让我们测试一下`addTag`突变，如下面的代码所示:

```java
@Test
@DisplayName("Verify the mutation 'addTags'")
void addTagsMutation() {
 GraphQLQueryRequest graphQLQueryRequest = new 
 GraphQLQueryRequest(
 AddTagGraphQLQuery.newRequest().productId("any")
 .tags(List.of(TagInput.newBuilder().name(
 "addTags").build()))
 .build(),new AddTagProjectionRoot().name().
 count());
 ExecutionResult executionResult =
 dgsQueryExecutor.execute(
 graphQLQueryRequest.serialize());
 assertThat(executionResult.getErrors()).isEmpty();
 verify(tagService).addTags("any", 
 List.of(
 TagInput.newBuilder().name("addTags").build()));
}
```

这里，`AddTagGraphQLQuery`类是 DGS GraphQL Gradle 插件自动生成代码的一部分。您触发请求，然后根据现有的配置和设置验证结果。

同样，你可以用测试`addQuantity`突变。只有论点和主张会改变；核心逻辑和类将保持不变。

您可以添加如下一个代码块所示的测试来测试`addQuantity`突变:

```java
@Test
@DisplayName("Verify the mutation 'addQuantity'")
void addQuantityMutation() {
  given(productService.addQuantity("a1s2d3f4-1", TEN))
      .willReturn(repo.addQuantity("a1s2d3f4-1", TEN));
  GraphQLQueryRequest graphQLQueryRequest = new 
    GraphQLQueryRequest(
      AddQuantityGraphQLQuery.newRequest().productId(
          "a1s2d3f4-1")
          .quantity(TEN).build(),
      new AddQuantityProjectionRoot().name().count());
  ExecutionResult executionResult =       dgsQueryExecutor.execute(        graphQLQueryRequest.serialize());
  assertThat(executionResult.getErrors()).isEmpty();
  Object obj = executionResult.getData();
  assertThat(obj).isNotNull();
  Map<String, Object> data = (Map)((Map) 
    executionResult.getData())
                    .get(MUTATION.AddQuantity);
  org.hamcrest.MatcherAssert
       .assertThat((Integer) data.get("count"), 
         greaterThan(TEN));
}
```

GraphQL 突变测试已经完成。让我们在下一小节中继续测试订阅。

## 测试 GraphQL 订阅

测试订阅需要额外的努力和小心，正如你在下面的代码中看到的，它为`quantityChanged`订阅执行测试。它使用现有的`addQuantity`变异来触发订阅发布者，该发布者在每次调用时发送一个`product`对象。您捕获第一次调用的乘积，并存储`count`字段的值。然后，使用它来执行断言，如以下代码所示:

```java
@Test
@DisplayName("Verify the subscription 'quantityChanged'")
void reviewSubscription() {
  given(productService.gerProductPublisher())      .willReturn(repo.getProductPublisher());
  ExecutionResult executionResult = 
    dgsQueryExecutor.execute(
      "subscription { quantityChanged(productId: 
         \"a1s2d3f4-0\") { id name price count } }");
  Publisher<ExecutionResult> publisher = 
    executionResult.getData();
  List<Product> product = new CopyOnWriteArrayList<>();
  publisher.subscribe(new Subscriber<>() {
    @Override
    public void onSubscribe(Subscription s) { s.request(2); }
    @Override
    public void onNext(ExecutionResult result) {
      if (result.getErrors().size() > 0) {
        System.out.println(result.getErrors());
      }
      Map<String, Object> data = result.getData();
      product.add(new ObjectMapper().convertValue(
          data.get(SUBSCRIPTION.QuantityChanged), 
                   Product.class));
    }
    @Override
    public void onError(Throwable t) {}
    @Override
    public void onComplete() {}
  });
  addQuantityMutation();
  Integer count = product.get(0).getCount();
  addQuantityMutation();
  assertThat(product.get(0).getId())
            .isEqualTo(product.get(1).getId());
  assertThat(product.get(1).getCount())
            .isEqualTo(count.intValue() + TEN);
}
```

这里，核心的逻辑在于通过调用`publisher.subscribe()`方法完成的订阅(检查突出显示的行)。您知道 GraphQL `quantityChanged`订阅返回发布者。该发布者是从执行结果的数据字段接收的。

发布者通过传递一个动态创建的对象`Subscriber`来订阅流。订阅者的`onNext()`方法用于接收 GraphQL 服务器发送的产品。这些对象被推入列表。然后，使用这个列表来执行断言。

# 总结

在本章中，您已经了解了实现 GraphQL 服务器的不同方法，包括联邦 GraphQL 服务。您还探索了完整的独立 GraphQL 服务器实现，它执行以下操作:

*   编写 GraphQL 模式
*   实现 GraphQL 查询 API
*   实现 GraphQL 变异 API
*   实现 GraphQL 订阅 API
*   编写用于解决 *N+1* 问题的数据加载器
*   添加自定义标量类型
*   添加 GraphQL API 的工具
*   使用网飞的 DGS 框架编写 GraphQL API 的测试自动化

您学习了使用 Spring 和 Spring Boot 技巧实现 GraphQL API，这将帮助您为您的工作任务和个人项目实现 graph QL API。

# 问题

1.  为什么要用网飞的 DGS 这样的框架来代替`graphql-java`库来实现 GraphQL APIs 呢？
2.  什么是联邦 GraphQL 服务？

# 延伸阅读

*   GraphQL Java 实现:https://www . graph QL-Java . com/和[https://github . com/graph QL-Java/graph QL-Java](https://github.com/graphql-java/graphql-java)
*   https://netflix.github.io/dgs/getting-started/网飞 DGS 文档:
*   *GraphQL 和 Apollo 与 Android 从新手到专家*(视频):[https://www . packtpub . com/product/graph QL-and-Apollo-with-Android-从新手到专家-video/9781800564626](https://www.packtpub.com/product/graphql-and-apollo-with-android-from-novice-to-expert-video/9781800564626)