# 五、异步 API 设计

到目前为止，我们已经开发了基于传统模型的 RESTful web 服务，其中调用是同步的。如果你想让代码异步和非阻塞的呢？这就是我们在本章要做的事情。在本章中，你将学习异步 API 设计，其中调用是异步和非阻塞的。我们将使用 Spring WebFlux 开发这些 API，Spring web flux 本身基于 Project Reactor([https://Project Reactor . io](https://projectreactor.io))。

首先，我们将遍历反应式编程基础，然后我们将现有的电子商务 REST API(我们在第四章 、*编写 API 的业务逻辑*中了解到)迁移到异步(反应式)API，通过关联和比较现有的(命令式)方式和反应式编程方式使事情变得更容易。

我们将在本章中讨论以下主题:

*   了解反应流
*   探索 Spring WebFlux
*   了解调度员 Handler
*   控制器
*   功能终点
*   为我们的电子商务应用实现反应式 API

在本章的最后，你将学习如何开发和实现反应式 API，并探索异步 API 开发。

# 技术要求

您需要以下内容来执行本章中的代码:

*   任何 Java IDE，如 NetBeans、IntelliJ 或 Eclipse
*   **Java 开发工具包** ( **JDK** ) 15
*   一个互联网连接来克隆代码并下载依赖项和升级
*   Postman/cURL(用于 API 测试)

本章中出现的代码位于[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 05](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter05)。

# 了解反应流

普通的 Java 代码通过使用线程池来实现异步。您的 web 服务器使用线程池来处理请求——它为每个传入的请求分配一个线程。应用使用线程池进行数据库连接。每个数据库调用使用一个单独的线程，并等待结果。因此，每个 web 请求和数据库调用都使用自己的线程。然而，有一个与此相关的等待，因此，这些是阻塞调用。线程等待并利用资源，直到从数据库收到响应或写入响应对象。当您扩展时，这是一种限制，因为您只能使用 JVM 可用的资源。您可以通过对服务的其他实例使用负载平衡器来克服这一限制，这是一种水平扩展。

在过去的十年中，客户机-服务器体系结构有所发展。出现了许多支持物联网的设备、具有原生应用的智能手机、一流的网络应用和传统的网络应用。应用不仅有第三方服务，而且有各种数据源，这导致了更高规模的应用。最重要的是，基于微服务的架构增加了服务本身之间的通信。您需要大量资源来满足这种更高层次的网络通信需求。这使得扩展成为必要。线程是昂贵的，并且不是无限的。为了有效利用，您不想阻止它们。这就是异步的好处。在异步调用中，一旦调用完成，线程就变得空闲，并使用回调实用程序，如 JavaScript。当数据源中的数据可用时，它会推送数据。反应流使用**发布者-订阅者模型**，其中数据源，即发布者，将数据推送给订阅者。

另一方面，您可能知道 Node.js 使用单线程来利用大多数资源。它基于异步非阻塞设计，被称为事件循环 T2。

反应式 API 也基于事件循环设计，使用推送式通知。仔细观察，Reactive Streams 还支持`map`、`flatMap`、`filter`等 Java 流操作。在内部，Reactive Streams 使用 push 风格，而 Java 流使用 pull 模型；也就是说，从源中提取项目，比如一个`Collection`。在反应式中，源(发布者)推送数据。

在**反应流**中，数据流是异步的、非阻塞的，并且支持背压。(参见本章的*用户*一节，了解背压的说明。)

根据反应流规范，有四种基本类型:

*   出版者
*   订户
*   签署
*   处理器

让我们看一看每一个。

## 出版商

发布者向一个或多个订阅者提供数据流。订阅者使用`subscriber()`方法订阅发布者。每个订阅服务器只能订阅一次发布服务器。最重要的是，发布者根据订阅者的需求推送数据。反应流是懒惰的；因此，发布者只会在有订阅者的情况下推送一个元素。

发布者的定义如下:

```java
package org.reactivestreams;

// T – type of element Publisher sends
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

## 订户

订阅者消费由发布者推送的数据。发布者-订阅者通信的工作方式如下:

1.  当一个`Subscriber`实例被传递给`Publisher.subscribe()`方法时，它会触发`onSubscribe()`方法。它包含一个控制背压的`Subscription`参数，即订阅者向发布者要求多少数据。
2.  After the first step, `Publisher` waits for the `Subscription.request(long)` call. It only pushes data to `Subscriber` after the `Subscription.request()` call is made. This method demands the number of elements from `Publisher`.

    通常，发布者将数据推送给订阅者，而不管订阅者是否能够安全地处理它。然而，订户最清楚它可以安全地处理多少数据；因此，在反应流中，`Subscriber`使用`Subscription`实例向`Publisher`传达对元素数量的需求。这就是被称为**背压**或**流量控制**的。

    你一定在想，如果`Publisher`要求`Subscriber`减速但它不能怎么办？在这种情况下，`Publisher`必须决定是失败、放弃还是缓冲。

3.  一旦使用*步骤 2* 发出请求，`Publisher`发送数据通知，然后使用`onNext()`方法消费它。直到`Publisher`根据`Subscription.request()`传达的需求推送数据通知时才会触发。
4.  At the end, either `onError()` or `onCompletion()` will be triggered as the terminal state. No notification will be sent after one of these invocations has been triggered even if you call `Subscription.request()`. The following are the terminal methods:

    a.一旦出现错误，就会调用`onError()`。

    b.当所有元素都被推送时，将调用`onCompletion()`。

`Subscriber`界面定义如下:

```java
package org.reactivestreams;
// T – type of element Publisher sends
public interface Subscriber<T> {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();
}
```

## 订阅

订阅是发布者和订阅者之间的中介。调用`Subscription.subscriber()`方法并让发布者知道需求是订阅者的责任。当订户需要时，可以调用它。`cancel()`方法要求发布者停止发送数据通知并清理资源。

订阅的定义如下:

```java
package org.reactivestreams;

public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

## 处理器

处理器是发布者和订阅者之间的桥梁，代表处理阶段。它既作为发布者又作为订阅者，并遵守双方定义的契约。其定义如下:

```java
package org.reactivestreams;

public interface Processor<T, R> extends Subscriber<T>, Publisher<R> {
}
```

让我们看看下面的例子。这里，我们通过使用`Flux.just()`静态工厂方法来创建`Flux`。`Flux`是 Project Reactor 中的一种发行商。这个发布器包含四个整数元素。然后，我们使用`reduce`操作符(类似于 Java 流)对其执行`sum`操作:

```java
Flux<Integer> fluxInt = Flux.just(1, 10, 100, 1000).log();
fluxInt.reduce(Integer::sum)
    .subscribe(sum -> System.out.printf("Sum is: %d", sum));
```

当您运行此代码时，它会打印以下输出:

```java
11:00:38.074 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
11:00:38.074 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onNext(1000)
11:00:38.084 [main] INFO reactor.Flux.Array.1 - | onComplete()
Sum is: 1111
Process finished with exit code 0
```

看输出，当`Publisher`被订阅时，`Subscriber`发送一个无界的`Subscription.request()`。当通知第一个元素时，调用`onNext()`，依此类推。最后，当发布者完成推送元素时，调用`onComplete()`事件。这就是反应流的工作方式。

现在您已经了解了反应流是如何工作的，让我们看看 Spring 如何以及为什么在 Spring WebFlux 模块中使用这些反应流。

# 探索 Spring WebFlux

现有的 Servlet API 正在阻塞 API。它们使用输入和输出流，这会阻塞 API。Servlet 3.0 容器发展并使用底层事件循环。异步请求是异步处理的，但是读写操作仍然使用阻塞的输入/输出流。Servlet 3.1 容器进一步发展，支持异步性，并具有非阻塞 I/O 流 API。然而，有一些 Servlet APIs，比如`request.getParameters()`，解析阻塞的请求体，并提供同步契约，比如`Filter`。Spring MVC T4 框架基于 Servlet API 和 Servlet 容器。

所以 Spring 提供了 **Spring WebFlux** ，完全无阻塞，提供回压功能。它使用少量线程提供并发性，并使用更少的硬件资源进行扩展。WebFlux 提供了流畅的、功能性的和延续风格的 API 来支持异步逻辑的声明式组合。编写异步功能代码比编写命令式代码更复杂。然而，一旦你接触到它，你会爱上它，因为它允许你写精确和可读的代码。

Spring WebFlux 和 Spring MVC 可以共存；然而，为了有效地使用反应式编程模型，您不应该将反应式流程与阻塞调用混合在一起。

Spring WebFlux 支持以下特性和原型:

*   事件循环并发模型
*   带注释的控制器和功能端点
*   被动的客户
*   Netty 和 Servlet 3.1 基于容器的 web 服务器，如 Tomcat、Undertow 和 Jetty

让我们通过了解反应式 API 和 Reactor Core 来深入了解 WebFlux 的工作原理。

## 反应型原料药

Spring WebFlux APIs 是反应式 API，接受`Publisher`作为普通输入。然后 WebFlux 将其改编为 Reactive 库支持的类型，如 Reactor Core 或 RxJava。然后，它处理输入，并根据支持的反应库类型返回输出。这使得 WebFlux APIs 可以与其他反应式库进行互操作。

默认情况下，Spring WebFlux 使用 Reactor([https://project Reactor . io](https://projectreactor.io))作为核心依赖。Project Reactor 提供反应流库。如前一段所述，WebFlux 接受输入作为`Publisher`，然后使其适应反应器类型，然后将其作为`Mono`或`Flux`输出返回。

您知道，Reactive Streams 中的`Publisher`根据需求将数据推送给它的订户。它可以推送一个或多个(可能是无限个)元素。Project Reactor 更进一步，提供了两个`Publisher`实现，即`Mono`和`Flux`。`Mono`可以将`0`或`1`返回给`Subscriber`，而`Flux`将 0 返回给 *N* 个元素。两者都是实现`CorePublisher`接口的抽象类。`CorePublisher`接口扩展了 publisher。

通常，我们在存储库中有以下方法:

```java
public Product findById(UUID id);
public List<Product> getAll();
```

这些可以替换为`Mono`和`Flux`:

```java
Public Mono<Product> findById(UUID id);
public Flux<Product> getAll();
```

有冷热流的概念。如果冷流有多个订户，则重新启动源，并且同一源用于热流中的多个订户。默认情况下，项目反应器流是冷的。因此，一旦您消耗了一个流，您就不能重用它，直到重新启动。然而，Project Reactor 允许你通过使用`cache()`方法将冷流变成热流。这两个方法在`Mono`和`Flux`抽象类中都可用。

让我们通过一些例子来理解冷流和热流的概念:

```java
Flux<Integer> fluxInt = Flux.just(1, 10, 100).log();
fluxInt.reduce(Integer::sum)
    .subscribe(sum -> System.out.printf("Sum is: %d\n", sum));
fluxInt.reduce(Integer::max)
    .subscribe(max -> System.out.printf("Maximum is: %d",                                          max));
```

这里，我们创建了三个数字的`Flux`。然后，我们分别执行两个操作—`sum`和`max`。您可以看到有两个订户。默认情况下，项目反应器流是冷的；因此，当第二个订户注册时，它会重新启动，如以下输出所示:

```java
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:23:35.060 [main] INFO reactor.Flux.Array.1 - | onComplete()
Sum is: 111
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:23:35.076 [main] INFO reactor.Flux.Array.1 - | onComplete()
Maximum is: 100
```

源是在同一个程序中创建的，但是如果源在其他地方，比如在 HTTP 请求中，或者您不想重启源，该怎么办呢？在这些情况下，您可以通过使用`cache()`将冷流转换成热流，如下一个代码块所示。这段代码与之前代码的唯一区别是我们添加了一个对`Flux.just()`的`cache()`调用:

```java
Flux<Integer> fluxInt = Flux.just(1, 10, 100).log().cache();
fluxInt.reduce(Integer::sum)
    .subscribe(sum -> System.out.printf("Sum is: %d\n", sum));
fluxInt.reduce(Integer::max)
    .subscribe(max -> System.out.printf("Maximum is: %d",                                          max));
```

现在，看看输出。源尚未重新启动；相反，再次使用相同的源:

```java
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | request(unbounded)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(1)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(10)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onNext(100)
11:29:25.665 [main] INFO reactor.Flux.Array.1 - | onComplete()
Sum is: 111
Maximum is: 100
```

现在我们已经了解了反应式 API 的关键，让我们看看 Spring WebFlux 的反应式核心由什么组成。

## 无功核心

这为用 Spring 开发一个反应式 web 应用提供了基础。web 应用需要三个级别的支持来处理 HTTP web 请求:

*   Handling of web requests by the server:

    a.`HttpHandler`:一个接口，它是不同 HTTP 服务器 API 上的请求/响应处理程序的抽象，例如 Netty 或 Tomcat

    ```java
    public interface HttpHandler {
      Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response);
    }
    ```

    b.`WebHandler`:提供对用户会话、请求和会话属性、请求的地区和主体、表单数据等的支持

*   客户端使用`WebClient`处理 web 请求调用
*   编解码器(`Encoder`、`Decoder`、`HttpMessageWriter`、`HttpMessageReader`和`DataBuffer`)，用于在服务器和客户端级别对请求和响应的内容进行序列化和反序列化

这些组件是 Spring WebFlux 的核心。WebFlux 应用配置还包含以下 bean—`webHandler`(`DispatcherHandler`)`WebFilter``WebExceptionHandler``HandlerMapping``HandlerAdapter`和`HandlerResultHandler`。

对于 REST 服务实现，以下 web 服务器有特定的`HandlerAdapter`实例——Tomcat、Jetty、Netty 和 Undertow。诸如 Netty 之类的支持反应流的 web 服务器处理订户的需求。然而，如果服务器处理器不支持反应流，那么就使用`org.springframework.http.server.reactive.ServletHttpHandlerAdapter` HTTP `HandlerAdapter`。它处理反应流和 Servlet 3.1 容器异步 I/O 之间的适配，并实现了一个`Subscriber`类。这使用操作系统 TCP 缓冲区。OS TCP 使用自己的背压(控制流)；也就是说，当缓冲区已满时，操作系统使用 TCP 反压来阻止传入的元素。

浏览器或任何 HTTP 客户端都使用 HTTP 协议来使用 REST APIs。当 web 服务器收到请求时，它会将请求转发给 Spring WebFlux 应用。然后，WebFlux 构建通向控制器的反应式管道。`HttpHandler`是 WebFlux 和 web 服务器之间的接口，使用 HTTP 协议进行通信。如果底层服务器支持反应式流，比如 Netty，那么订阅是由服务器本地完成的。否则，WebFlux 对 Servlet 3.1 基于容器的服务器使用`ServletHttpHandlerAdapter`。`ServletHttpHandlerAdapter`然后使流适应异步 I/O Servlet API，反之亦然。然后，`ServletHttpHandlerAdapter`发生反应流的订阅。

所以在总结中，`Mono` / `Flux`流被 WebFlux 内部类订阅，当控制器发送一个`Mono` / `Flux`流时，这些类将其转换成 HTTP 包。HTTP 协议支持事件流。然而，对于其他媒体类型，比如 JSON，Spring WebFlux 订阅`Mono` / `Flux`流，并等待直到`onComplete()`或`onError()`被触发。然后，它在一个 HTTP 响应中序列化整个元素列表，或者在`Mono`的情况下序列化单个元素。

Spring WebFlux 需要一个类似于 Spring MVC 中`DispatcherServlet`的组件——前端控制器。让我们在下一节讨论这个问题。

# 了解调度员

`DispatcherHandler`，Spring WebFlux 中的一个前端控制器，就是`DispatcherServlet`在 Spring MVC 框架中的作用。`DispatcherHandler`包含一个算法，该算法利用了特殊的组件——`HandlerMapping`(将请求映射到处理程序)；`HandlerAdapter`(一个`DispatcherHandler`助手来调用映射到请求的处理程序)，以及`HandlerResultHandler`(一个单词的回文，用于处理结果和形成结果)——用于处理请求。`DispatcherHandler`组件由名为`webHandler`的 bean 标识。

它以下列方式处理请求:

1.  `DispatcherHandler`收到一个 web 请求。
2.  `DispatcherHandler`使用`HandlerMapping`为请求找到一个匹配的处理程序，并使用第一个匹配。
3.  然后，它使用各自的`HandlerAdapter`来处理请求，这公开了`HandlerResult`(处理后的返回值)。返回值可以是下列值之一—`ResponseEntity`、`ServerResponse`、从`@RestController`返回的值，或者由视图解析器返回的值(`CharSequence`、`view`、`map`等等)。
4.  然后，根据从*步骤 2* 接收到的`HandlerResult`类型，使用相应的`HandlerResultHandler`来编写响应或呈现视图。`ResponseEntityResultHandler`用于`ResponseEntity`，`ServerResponseResultHandler`用于`ServerResponse`，`ResponseBodyResultHandler`用于`@RestController`或`@ResponseBody`注释方法返回的值，`ViewResolutionResultHandler`用于视图解析器返回的值。
5.  请求已完成。

您可以使用带注释的控制器(如 Spring MVC)或功能端点在 Spring WebFlux 中创建 REST 端点。让我们在接下来的部分中探索这些。

## 控制器

Spring 团队为 Spring MVC 和 Spring WebFlux 保留了相同的注释，因为这些注释是非阻塞的。因此，您可以使用我们在前面章节中使用的相同注释来创建 REST 控制器。在那里，注释运行在反应式核心上，并提供非阻塞流。但是，作为开发人员，您有责任维护一个完全无阻塞的流程，并维护反应链(管道)。反应链中的任何阻塞调用都会将反应链转换为阻塞调用。

让我们创建一个简单的 REST 控制器，它支持非阻塞和反应式调用:

```java
@RestController
public class OrderController {
  @RequestMapping(value = "/api/v1/orders",
                     method = RequestMethod.POST)
  public ResponseEntity<Order> addOrder(@RequestBody NewOrder      
                                            newOrder){
     // …
  }
  @RequestMapping(value = "/api/v1/orders/{id}",
                     method = RequestMethod.GET)
  public ResponseEntity<Order> getOrderById(@PathVariable("id") 
                                            String id){
    // …
  }
}
```

你可以看到它使用了我们在 Spring MVC 中使用过的所有注释:

*   `@RestController`用于将一个类标记为 REST 控制器。否则，端点不会注册，请求将作为`NOT FOUND 404`返回。
*   `@RequestMapping`用于定义路径和 HTTP 方法。在这里，您也可以只使用路径来使用`@PostMapping`。类似地，对于每个 HTTP 方法，都有各自的映射，比如`@GetMapping`。
*   `@RequestBody`注释将一个参数标记为请求体，一个合适的编解码器将用于转换。类似地，路径参数和查询参数分别有`@PathVariable`和`@RequestParam`。

我们将使用基于注释的模型来编写 REST 端点。当我们使用 WebFlux 实现电子商务应用控制器时，您将会有更深入的了解。Spring WebFlux 还提供了一种使用函数式编程风格编写 REST 端点的方法，这将在下一节中探讨。

## 功能终点

我们使用 Spring MVC 编写的其余控制器是用命令式编程编写的。另一方面，反应式编程是函数式编程。因此，Spring WebFlux 还允许使用另一种方法来定义 REST 端点，即使用功能端点。这些也使用相同的反应核心基础。

让我们看看如何使用功能端点编写相同的 order REST 端点:

```java
import static org.springframework.http.MediaType.APPLICATION_  JSON;
import static org.springframework.web.reactive.function.server.  RequestPredicates.*;
import static org.springframework.web.reactive.function.server.  RouterFunctions.route;
OrderRepository repository = ...
OrderHandler handler = new OrderHandler(repository);
RouterFunction<ServerResponse> route = route()
 .GET("/v1/api/orders/{id}", accept(APPLICATION_JSON),                handler::getOrderById)
 .POST("/v1/api/orders", handler::addOrder)
 .build();
public class OrderHandler {
    public Mono<ServerResponse> addOrder(ServerRequest req){
        // ...
    }
    public Mono<ServerResponse> getOrderById(ServerRequest req) {
        // ...
    }
}
```

你可以看到`RouterFunctions.route()`生成器允许你使用函数式编程风格在一条语句中编写所有的 REST 路线。然后，它使用 handler 类的方法引用来处理请求，这与基于注释的模型的`@RequestMapping`主体完全相同。

让我们在`OrderHandler`方法中添加以下代码:

```java
public class OrderHandler {
    public Mono<ServerResponse> addOrder(ServerRequest req){
       Mono<NewOrder> order = req.bodyToMono(NewOrder.class);
      return ok().build(repository.save(toEntity(order)));
    }
    public Mono<ServerResponse> getOrderById(ServerRequest req) {
      String orderId = req.pathVariable("id");
      return repository.getOrderById(UUID.fromString(orderId))
        .flatMap(order -> ok()
          .contentType(APPLICATION_JSON).                       bodyValue(toModel(order)))
        .switchIfEmpty(ServerResponse.notFound().build());
    }
}
```

与 REST 控制器中的`@RequestMapping()`映射方法不同，处理程序方法没有多个参数，比如主体、路径或查询参数。它们只有一个`ServerRequest`参数，可以用来提取主体、路径和查询参数。在`addOrder`方法中，使用`request.bodyToMono()`提取`Order`对象，解析请求体，然后将其转换为`Order`对象。类似地，使用`getOrderById()`处理程序方法中的`request.pathVariable()`从请求中提取 ID。

现在，我们来讨论一下回应。与 Spring MVC 中的`ResponseEntity`相比，handler 方法使用了`ServerResponse`对象。因此，`ok()`静态方法看似出自`ResponseEntity`，实则出自`org.springframework.web.reactive.function.server.ServerResponse.ok`。Spring 团队已经努力让 API 尽可能的和 Spring MVC 相似；但是，底层实现不同，它提供了一个非阻塞的反应式接口。

关于这些处理程序方法的最后一点是编写响应的方式。它使用功能性风格而不是命令性风格，并确保反应链不会中断。在这两种情况下，存储库都返回`Mono`对象(一个发布者),并将其作为封装在`ServerResponse`中的响应返回。

您可以在`getOrderById()`处理程序方法中找到有趣的代码。它对从存储库中接收到的`Mono`对象执行一个`flatMap`操作。它将它从一个实体转换成一个模型，然后包装在一个`ServerResponse`对象中并返回响应。您一定想知道如果存储库返回 null 会发生什么。存储库根据合同返回`Mono`，这在本质上类似于 Java `Optional`类。因此，按照约定，`Mono`对象可以为空，但不能为空。如果存储库返回一个空的`Mono`，那么将使用`switchIfEmpty()`操作符并发送一个`NOT FOUND 404`响应。

如果出现错误，可以使用不同的错误操作符，如`doOnError()`或`onErrorReturn()`。

我们已经讨论了使用`Mono`类型的逻辑流程；如果你用`Flux`型代替`Mono`型，同样的解释也适用。

我们已经在 Spring 上下文中讨论了许多与反应式、异步和非阻塞编程相关的理论。让我们进入编码阶段，将在第四章 、*为 API 编写业务逻辑*中开发的电子商务 API 迁移到一个反应式 API。

# 为我们的电子商务应用实现反应式 API

既然您已经对反应式流如何工作有了一个概念，我们可以继续实现异步和非阻塞的 REST APIs。

您还记得，我们遵循的是设计优先的方法，所以我们首先需要 API 设计规范。但是，我们可以重用之前在 [*第三章*](03.html#_idTextAnchor064) 、 *API 规范和实现*中创建的电子商务 API 规范。

OpenAPI Codegen 用于生成 API 接口/契约，该 API 接口/契约生成符合 Spring MVC 的 API Java 接口。让我们看看我们需要做什么改变来生成反应式 API 接口。

## 为反应式 API 更改 OpenAPI Codegen

您需要调整一些 OpenAPI Codegen 配置来生成符合 Spring WebFlux 的 Java 接口，如下所示:

```java
{
  "library": "spring-boot",
  "dateLibrary": "java8",
  "hideGenerationTimestamp": true,
  "modelPackage": "com.packt.modern.api.model",
  "apiPackage": "com.packt.modern.api",
  "invokerPackage": "com.packt.modern.api",
  "serializableModel": true,
  "useTags": true,
  "useGzipFeature" : true,
  "reactive": true,
  "interfaceOnly": true,
   …
   …
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/resources/api/config.json

只有当您选择`spring-boot`作为`library`时，才会有反应式 API 支持。另外，您需要将`reactive`标志设置为`true`。默认情况下，`reactive`标志为`false`。

现在，您可以运行以下命令:

```java
$ gradlew clean generateSwaggerCode 
```

这将生成符合 Reactive Streams 的 Java 接口，这是基于注释的 REST 控制器接口。当您打开任何 API 接口时，您会在其中找到`Mono` / `Flux`反应器类型，如下面的`OrderAPI`接口代码块所示:

```java
@ApiOperation(value = "Creates a new order for the given order request", nickname = "addOrder", notes = "Creates a new order for the given order request.", response = Order.class, tags = {"order",})
@ApiResponses(value = {
    @ApiResponse(code = 201, message = "Order added                   successfully", response = Order.class),
    @ApiResponse(code = 406, message = "If payment is not                  authorized.")})
@RequestMapping(value = "/api/v1/orders",
    produces = {"application/xml", "application/json"},
    consumes = {"application/xml", "application/json"},
    method = RequestMethod.POST)
Mono<ResponseEntity<Order>> addOrder(
    @ApiParam(value = "New Order Request object") @Valid @      RequestBody(required = false) Mono<NewOrder> newOrder,      ServerWebExchange exchange);
```

您会观察到另一个变化:反应式控制器还需要一个额外的参数`ServerWebExchange`。

现在，当你编译你的代码时，你可能会发现编译错误，因为我们还没有添加反应式支持所需的依赖项。让我们在下一节学习如何添加它们。

## 在 build.xml 中添加被动依赖关系

首先，我们将移除`spring-boot-starter-web`，因为我们现在不需要 Spring MVC。其次，我们将分别为 Spring WebFlux 和 Reactor support 测试添加`spring-boot-starter-webflux`和`reactor-test`。一旦成功添加了这些依赖项，您应该不会在 OpenAPI 生成的代码中看到任何编译错误。

您可以在`build.gradle`中添加所需的反应依赖关系，如下所示:

```java
implementation 'org.springframework.boot:spring-boot-starter-webflux'
// implementation 'org.springframework.boot:spring-boot-
// starter-web'
testImplementation('org.springframework.boot:spring-boot-                    starter-test')
testImplementation 'io.projectreactor:reactor-test'
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/build.gradle

我们需要从 REST 控制器到数据库有一个完整的反应管道。然而，现有的 JDBC 和 Hibernate 依赖项只支持阻塞调用。JDBC 是一个完全阻塞的 API。Hibernate 也在阻止。因此，我们需要数据库的反应依赖。

写这一章的时候，hibernate Reactive([https://github.com/hibernate/hibernate-reactive](https://github.com/hibernate/hibernate-reactive))还在测试版。Hibernate Reactive beta 只支持 PostgresSQL、MySQL 和 Db2。在撰写本文时，Hibernate Reactive 不支持 H2。因此，我们将简单地使用 Spring Data，这是一个 Spring 框架，它提供了用于处理反应流的`spring-data-r2dbc`库。

许多 NoSQL 数据库，比如 MongoDB，已经提供了一个反应式数据库驱动程序。基于 R2DBC 的驱动程序应该用于关系数据库，而不是用于完全非阻塞/反应式 API 调用的 JDBC。 **R2DBC** 代表**反应式关系数据库连接**。R2DBC 是一个反应式 API 开放规范，为数据库驱动建立了一个**服务提供者接口** ( **SPI** )。几乎所有流行的关系数据库都支持 R2DBC 驱动程序——H2、MySQL、MariaDB、SQL Server、PostgresSQL 和 Proxy。在撰写本文时，Oracle DB 提供了基于流的反应式 JDBC 扩展(DB 20c ),它集成了 Reactor、RxJava 和 Akka 流。然而，Oracle R2DBC 驱动程序即将推出(截至 2020 年尚未推出)。

让我们在`build.gradle`文件中添加 Spring 数据和 H2 的 R2DBC 依赖项:

```java
// DB Starts
implementation 'org.springframework.boot:spring-boot-starter-data-r2dbc'
implementation 'com.h2database:h2'
runtimeOnly 'io.r2dbc:r2dbc-h2'
// DB Ends
```

现在，我们可以编写端到端(从控制器到存储库)的代码，而没有任何编译错误。在开始编写 API 接口的实现之前，让我们添加全局异常处理。

## 处理异常

我们将添加全局异常处理程序，就像在第三章 ， *API 规范和实现*的 [*中在 Spring MVC 中添加一样。在此之前，您一定想知道如何在反应式管道中处理异常。反应式管道是一个流的流动，你不能像在命令式代码中那样添加异常处理。您只需要在管道流中引发错误。*](03.html#_idTextAnchor064)

查看以下代码:

```java
.flatMap(card -> {
  if (Objects.isNull(card.getId())) {
    return service.registerCard(mono)
        .map(ce -> status(HttpStatus.CREATED)
            .body(assembler.entityToModel(ce, exchange)));
  } else {
    return Mono.error(
 () -> new CardAlreadyExistsException(" for user with ID         - " + d.getId()));
  }
})
```

这里，执行`flatMap`操作。如果`card`无效，也就是说，如果`card`没有请求的 id，就会抛出一个错误。这里使用了`Mono.error()`，因为管道期望`Mono`作为返回对象。类似地，如果期望将`Flux`作为返回类型，则可以使用`Flux.error()`。

让我们假设您正在期待来自服务或存储库调用的对象，但是您收到的是一个空对象。然后您可以使用`switchIfEmpty()`操作符，如下面的代码所示:

```java
Mono<List<String>> monoIds = itemRepo.findByCustomerId(      customerId)
    .switchIfEmpty(Mono.error(new ResourceNotFoundException(
 ". No items found in Cart of customer with Id - " +            customerId)))
    .map(i -> i.getId().toString())
    .collectList().cache();
```

这里，代码期望从项目存储库中得到一个`List`的`Mono`对象。但是，如果返回的对象是空的，那么它就抛出`ResourceNotFoundException`。`switchIfEmpty()`接受备用的`Mono`实例。

到目前为止，您可能对异常的类型有疑问。它抛出一个运行时异常。参见这里的`ResourceNotFoundException`类声明:

```java
public class ResourceNotFoundException extends RuntimeException
```

类似地，您也可以使用来自反应流的`onErrorReturn()`、`onErrorResume()`或类似的错误操作符。看看`onErrorReturn()`在下一个代码块中的用法:

```java
return service.getCartByCustomerId(customerId)
    .map(cart ->
        assembler.itemfromEntities(cart.getItems().stream()
            .filter(i -> i.getProductId().toString().                    equals(itemId.trim())).collect(toList()))
            .get(0)).map(ResponseEntity::ok)
    .onErrorReturn(notFound().build())
```

应该处理所有异常，并向用户发送错误响应。这就是为什么我们要先看看全局异常处理程序。

### 处理控制器的全局异常

您在 Spring MVC 中使用`@ControllerAdvice`创建了一个全局异常处理程序。在 Spring WebFlux 中，我们将采用稍微不同的方法来处理错误。首先，我们将创建`ApiErrorAttributes`类，它也可以在 Spring MVC 中使用。这个类扩展了`DefaultErrorAttributes`，它是`ErrorAttributes`接口的默认实现。`ErrorAttributes`接口提供了一种处理映射、错误字段映射及其值的方法。然后，这些错误属性可用于向用户显示错误或记录错误。

以下属性由`DefaultErrorAttributes`类提供:

*   `timestamp`:捕获错误的时间
*   `status`:状态码
*   `error`:错误描述
*   `exception`:根异常的类名(如果配置的话)
*   `message`:异常信息(如果配置)
*   `errors`:来自`BindingResult`异常的任何`ObjectErrors`(如果已配置)
*   `trace`:异常栈跟踪(如果配置的话)
*   `path`:异常发生时的 URL 路径
*   `requestId`:与当前请求相关联的唯一 ID

我们在`ApiErrorAttributes`中为状态和消息添加了两个默认值——一个内部服务器错误和一个通用错误消息(`The system is unable to complete the request. Contact system support.`),如下所示:

```java
@Component
public class ApiErrorAttributes extends DefaultErrorAttributes {
  private HttpStatus status = HttpStatus.INTERNAL_SERVER_ERROR;
  private String message = ErrorCode.GENERIC_ERROR.      getErrMsgKey();
  @Override
  public Map<String, Object> getErrorAttributes(ServerRequest       request, ErrorAttributeOptions options) {
    var attributes = super.getErrorAttributes(                     request, options);
    attributes.put("status", status);
    attributes.put("message", message);
    attributes.put("code", ErrorCode.GENERIC_ERROR.                   getErrCode());
    return attributes;
  }
// Getter/Setters
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorAttributes.java

现在，我们可以在定制的全局异常处理程序类中使用这个`ApiErrorAttributes`类。我们将创建`ApiErrorWebExceptionHandler`类，它扩展了`AbstractErrorWebExceptionHandler`抽象类。

`AbstractErrorWebExceptionHandler`类实现了`ErrorWebExceptionHandler`和`InitializingBean`接口。`ErrorWebExceptionHandler`是扩展`WebExceptionHandler`接口的功能接口，表示`WebExceptionHandler`用于渲染异常。`WebExceptionHandler`是用于在服务器交换处理发生时处理异常的契约。

`InitializingBean`接口是 Spring 核心框架的一部分。当所有属性都被填充时，组件使用它进行反应。它还可以用来检查是否设置了所有的强制属性。

现在我们已经学习了基础知识，让我们开始编写`ApiErrorAttributes`类:

```java
@Component
@Order(-2)
public class ApiErrorWebExceptionHandler extends       AbstractErrorWebExceptionHandler {
  public ApiErrorWebExceptionHandler(ApiErrorAttributes       errorAttributes,
      ApplicationContext applicationContext,      ServerCodecConfigurer serverCodecConfigurer) {
    super(errorAttributes, new WebProperties().getResources(),           applicationContext);
    super.setMessageWriters(          serverCodecConfigurer.getWriters());
    super.setMessageReaders(          serverCodecConfigurer.getReaders());
  }
  @Override
 protected RouterFunction<ServerResponse>       getRoutingFunction(ErrorAttributes errorAttributes) {
    return RouterFunctions.route(
        RequestPredicates.all(), this::renderErrorResponse);
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java

关于这段代码的第一个重要观察是我们添加了`@Order`注释，它告诉我们执行的偏好。Spring 框架在`0`订购`ResponseStatusExceptionHandler`，在`-1`订购`DefaultErrorWebExceptionHandler`。两者都是异常处理程序，就像我们已经创建的那样。如果你不给`ApiErrorWebExceptionHandler`一个优先于这两者的顺序，那么它永远不会执行。因此，顺序设置在`-2`。

接下来，这个类覆盖了`getRoutingFunction()`方法，该方法调用私有定义的`renderErrorResponse()`方法，其中我们有自己的错误处理定制实现，如下所示:

```java
private Mono<ServerResponse> renderErrorResponse(    ServerRequest request) {
  Map<String, Object> errorPropertiesMap =       getErrorAttributes(request,      ErrorAttributeOptions.defaults());
  Throwable throwable = (Throwable) request
 .attribute("org.springframework.boot.web.reactive.error.                 DefaultErrorAttributes.ERROR")
      .orElseThrow(
          () -> new IllegalStateException("Missing exception           attribute in ServerWebExchange"));
  ErrorCode errorCode = ErrorCode.GENERIC_ERROR;
  if (throwable instanceof IllegalArgumentException
      || throwable instanceof DataIntegrityViolationException
      || throwable instanceof ServerWebInputException) {
    errorCode = ILLEGAL_ARGUMENT_EXCEPTION;
  } else if (throwable instanceof CustomerNotFoundException) {
    errorCode = CUSTOMER_NOT_FOUND;
  } else if (throwable instanceof ResourceNotFoundException) {
    errorCode = RESOURCE_NOT_FOUND;
  } // other else-if
    …
    …
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java

这里，首先我们提取`errorPropertiesMap`中的错误属性。这将在我们形成错误响应时使用。接下来，我们使用`throwable`捕获发生的异常。然后，我们检查异常的类型，并为其分配适当的代码。我们保留默认为`GenericError`，无非就是`InternalServerError`。

接下来，我们使用一个`switch`语句根据引发的异常形成一个错误响应，如下所示:

```java
switch (errorCode) {
    case ILLEGAL_ARGUMENT_EXCEPTION -> {
      errorPropertiesMap.put(        "status", HttpStatus.BAD_REQUEST);
      errorPropertiesMap.put("code", ILLEGAL_ARGUMENT_        EXCEPTION.getErrCode());
      errorPropertiesMap.put("error",         ILLEGAL_ARGUMENT_EXCEPTION);
      errorPropertiesMap.put("message", String
          .format("%s %s", ILLEGAL_ARGUMENT_EXCEPTION.                  getErrMsgKey(), throwable.getMessage()));
      return ServerResponse.status(HttpStatus.BAD_REQUEST)
          .contentType(MediaType.APPLICATION_JSON)
          .body(BodyInserters.fromValue(errorPropertiesMap));
    }
    case CUSTOMER_NOT_FOUND -> {
      errorPropertiesMap.put("status", HttpStatus.NOT_FOUND);
      errorPropertiesMap.put("code",         CUSTOMER_NOT_FOUND.getErrCode());
      errorPropertiesMap.put("error", CUSTOMER_NOT_FOUND);
      errorPropertiesMap.put("message", String           .format("%s %s", CUSTOMER_NOT_FOUND.getErrMsgKey(),              throwable.getMessage()));
      return ServerResponse.status(HttpStatus.NOT_FOUND)
          .contentType(MediaType.APPLICATION_JSON)
          .body(BodyInserters.fromValue(errorPropertiesMap));
    }
    case RESOURCE_NOT_FOUND -> {
                  // Rest of the code
                  …
                  …
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/exception/ApiErrorWebExceptionHandler.java

大概在 Java 的下一个版本中，我们将能够组合`if-else`和`switch`块，使代码更加简洁。您还可以创建一个单独的方法，将`errorPropertiesMap`作为参数，并基于它返回形成的服务器响应。然后，就可以用`switch`了。

自定义的应用异常类，如`CustomerNotFoundException`，以及其他支持异常处理的类，如`ErrorCode`和`Error`，都是从现有代码中使用的(来自 [*第四章*](04.html#_idTextAnchor086) ，*为 API 编写业务逻辑*)。

既然我们已经学习了异常处理，我们可以把注意力集中在 HATEOAS 上。

## 向 API 响应添加超媒体链接

HATEOAS 对反应式 API 的支持就在那里，有点类似于我们在上一章中使用 Spring MVC 所做的。我们再次创建这些汇编器是为了支持 HATEOAS。我们还使用 HATEOAS 汇编器类进行从模型到实体的转换，反之亦然。

Spring WebFlux 为形成超媒体链接提供了`ReactiveRepresentationModelAssembler`接口。我们将覆盖它的`toModel()`方法来添加到响应模型的链接。

这里，我们将为填充链接做一些基础工作。我们将用一个默认方法创建一个`HateoasSupport`接口，如下所示:

```java
public interface HateoasSupport {
    default UriComponentsBuilder getUriComponentBuilder(      @Nullable ServerWebExchange exchange) {
      if (exchange == null) {
        return UriComponentsBuilder.fromPath("/");
      }
      ServerHttpRequest request = exchange.getRequest();
      PathContainer contextPath = request.getPath().                                  contextPath();
      return UriComponentsBuilder.fromHttpRequest(request)
          .replacePath(contextPath.toString())
          .replaceQuery("");
    }
}
```

这个类包含一个默认方法`getUriCompononentBuilder()`，它接受`ServerWebExchange`作为参数并返回`UriComponentsBuilder`实例。然后，该实例可用于提取服务器 URI，该服务器将用于添加带有协议、主机和端口的链接。如果您还记得的话，控制器方法中添加了`ServerWebExchange`参数。这个接口用于获取 HTTP 请求、响应和其他属性。

现在，我们可以使用这两个接口——`HateoasSupport`和`ReactiveRepresentationModelAssembler`——来定义表示模型组装器。

让我们定义地址的代表性模型组装器，如下所示:

```java
@Component
public class AddressRepresentationModelAssembler implements     ReactiveRepresentationModelAssembler<AddressEntity,       Address>, HateoasSupport {
  private static String serverUri = null;
 private String getServerUri(@Nullable ServerWebExchange       exchange) {
    if (Strings.isBlank(serverUri)) {
      serverUri = getUriComponentBuilder(exchange).        toUriString();
    }
    return serverUri;
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java

这里，定义了另一个私有方法，`getServerUri()`，它从`UriComponentBuilder`中提取服务器 URI，后者本身是从`HateoasSupport`接口的默认`getUriComponentBuilder()`方法中返回的。

现在，我们可以覆盖`toModel()`方法，如下面的代码块所示:

```java
@Override
public Mono<Address> toModel(AddressEntity entity,       ServerWebExchange exchange) {
  return Mono.just(entityToModel(entity, exchange));
}
public Address entityToModel(AddressEntity entity,       ServerWebExchange exchange) {
  Address resource = new Address();
  if(Objects.isNull(entity)) {
    return resource;
  }
  BeanUtils.copyProperties(entity, resource);
  resource.setId(entity.getId().toString());
  String serverUri = getServerUri(exchange);
  resource.add(Link.of(String.format("%s/api/v1/addresses",                serverUri)).withRel("addresses"));
  resource.add(
      Link.of(String.format("%s/api/v1/addresses/%s",               serverUri, entity.getId())).withSelfRel());
  return resource;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java

`toModel()`方法使用`entityToModel()`方法返回带有超媒体链接的`Mono<Address>`对象，这些链接是由`AddressEntity`实例形成的。

`entityToModel()`将属性从实体实例复制到模型实例。最重要的是，它使用`resource.add()`方法将超媒体链接添加到模型中。`add()`方法将`org.springframework.hateoas.Link`实例作为参数。然后，我们使用`Link`类的`of()`静态工厂方法来形成链接。您可以看到这里使用了服务器 URI 将其添加到链接中。您可以创建任意多的链接，并使用`add()`方法将它们添加到资源中。

`ReactiveRepresentationModelAssembler`接口为`toCollectionModel()`方法提供了一个默认实现，该实现返回了`Mono<CollectionModel<D>>`集合模型。然而，我们也可以添加如下所示的`toListModel()`方法，它返回地址的`Flux`实例:

```java
public Flux<Address> toListModel(Flux<AddressEntity> entities,       ServerWebExchange exchange) {
  if (Objects.isNull(entities)) {
    return Flux.empty();
  }
  return Flux.from(entities.map(e -> entityToModel(                   e, exchange)));
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas/AddressRepresentationModelAssembler.java

这个方法在内部使用了`entityToModel()`方法。类似地，您可以为其他 API 模型创建一个表示模型组装器。你可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 05/src/main/Java/com/packt/Modern/API/hate OAS](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/hateoas)找到所有这些模型。

既然我们已经完成了基本的代码基础设施，我们可以基于 OpenAPI Codegen 生成的接口开发 API 实现了。在这里，我们将首先开发将被服务消费的存储库。最后，我们将编写控制器实现。让我们从存储库开始。

## 定义一个实体

实体的定义与我们在 [*第四章*](04.html#_idTextAnchor086) 、*为 API 编写业务逻辑*中定义和使用它们的方式大致相同。然而，我们不使用 Hibernate 映射和 JPA，而是使用 Spring 数据注释，如下所示:

```java
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
// other imports
@Table("ecomm.orders")
public class OrderEntity {
  @Id
  @Column("id")
  private UUID id;
  @Column("customer_id")
  private UUID customerId;
  @Column("address_id")
  private UUID addressId;
  @Column("card_id")
  private UUID cardId;
  @Column("order_date")
  private Timestamp orderDate;
  // other fields mapped to table columns
  private UUID cartId;
  private UserEntity userEntity;
  private AddressEntity addressEntity;
  private PaymentEntity paymentEntity;
  private List<ShipmentEntity> shipments = Collections.      emptyList();
  // other entities fields and getter/setters
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/entity/OrderEntity.java

我们使用`@Table`到将一个实体类关联到一个表名，使用`@Column`将一个字段映射到表的一列。很明显，`@Id`被用作标识符列。同样，您可以定义其他实体。

## 添加存储库

存储库是我们的应用代码和数据库之间的一个接口。它和 Spring MVC 中的一样。然而，我们正在使用反应式范例编写代码。因此，有必要使用基于 R2DBC/Reactive 的驱动程序的存储库，并在反应流之上返回反应类型的实例。这就是我们不能使用 JDBC 的原因。

Spring Data R2DBC 为 Reactor 和 RxJava 提供了不同的存储库，比如`ReactiveCrudRepository`、`ReactiveSortingRepository`、`RxJava2CrudRepository`和`RxJava3CrudRepository`。此外，您可以编写自己的自定义实现。

我们将使用`ReactiveCrudRepository`并编写一个自定义实现。

我们将为`Order`实体编写存储库。对于其他实体，你可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 05/src/main/Java/com/packt/Modern/API/repository](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter05/src/main/java/com/packt/modern/api/repository)找到这些库。

首先，为`Order`实体编写 **CRUD** ( **Create** ， **Read** ， **Update** ，以及 **Delete** 存储库，如下所示:

```java
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.     ReactiveCrudRepository;
@Repository
public interface OrderRepository extends     ReactiveCrudRepository<OrderEntity, UUID>,
    OrderRepositoryExt {
  @Query("select o.* from ecomm.orders o join ecomm.user u on       o.customer_id = u.id where u.id = :custId")
  Flux<OrderEntity> findByCustomerId(String custId);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepository.java

这就像图中所示的那样简单。`OrderRepository`接口扩展了`ReactiveCrudRepository`和我们自己的定制存储库接口`OrderRepositoryExt`。

稍后我们将讨论`OrderRepositoryExt`;先讨论一下`OrderRepository`。我们在`OrderRepository`接口中添加了一个额外的方法`findByCustomerId()`，它根据给定的客户 ID 查找订单。`ReactiveCrudRepository`接口和`Query()`注释是 Spring 数据 R2DBC 库的一部分。`Query()`与 Spring MVC 不同，使用原生 SQL 查询。

警告

在编写本文时，Spring Data R2DBC 库不支持嵌套实体。

我们也可以编写自己的自定义存储库。让我们为它写一个简单的契约，如下所示:

```java
public interface OrderRepositoryExt {
  Mono<OrderEntity> insert(Mono<NewOrder> m);
  Mono<OrderEntity> updateMapping(OrderEntity orderEntity);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExt.java

这里，我们编写了两个方法签名——第一个在数据库中插入新的订单记录，第二个更新订单项和购物车项的映射。这个想法是，一旦下了订单，商品应该从购物车中删除并添加到订单中。如果您愿意，也可以将这两种操作结合在一起。

让我们首先用定义扩展`OrderRepositoryExt`接口的`OrderRepositoryExtImpl`类，如下面的代码块所示:

```java
@Repository
public class OrderRepositoryExtImpl implements     OrderRepositoryExt {
  private ConnectionFactory connectionFactory;
  private DatabaseClient dbClient;
  private ItemRepository itemRepo;
  private CartRepository cartRepo;
  private OrderItemRepository oiRepo;
  public OrderRepositoryExtImpl(ConnectionFactory       connectionFactory, ItemRepository itemRepo,      OrderItemRepository oiRepo, CartRepository cartRepo,       DatabaseClient dbClient) {
    this.itemRepo = itemRepo;
    this.connectionFactory = connectionFactory;
    this.oiRepo = oiRepo;
    this.cartRepo = cartRepo;
    this.dbClient = dbClient;  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

我们刚刚定义了一些类属性，并将这些属性添加到构造函数中，作为基于构造函数的依赖注入的参数。

根据合同约定，收到`Mono<NewOrder>`。因此，我们需要在`OrderRepositoryExtImpl`类中添加一个将模型转换为实体的方法。我们还需要一个额外的参数，因为`CartEntity`包含购物车中的商品。这是:

```java
private OrderEntity toEntity(NewOrder order, CartEntity c) {
  OrderEntity orderEntity = new OrderEntity();
  BeanUtils.copyProperties(order, orderEntity);
  orderEntity.setUserEntity(c.getUser());
  orderEntity.setCartId(c.getId());
  orderEntity.setItems(c.getItems())
      .setCustomerId(UUID.fromString(order.getCustomerId()))
      .setAddressId(UUID.fromString(          order.getAddress().getId()))
      .setOrderDate(Timestamp.from(Instant.now()))
      .setTotal(c.getItems().stream().collect(Collectors.            toMap(k -> k.getProductId(),
          v -> BigDecimal.valueOf(v.getQuantity()).multiply(v.            getPrice())))
          .values().stream().reduce(BigDecimal::add).            orElse(BigDecimal.ZERO));
  return orderEntity;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

除了设置总数的代码之外，这个方法很简单。总数是使用流计算的。为了理解它，让我们按下图所示进行分解:

1.  首先，它从`cart`实体获取项目。
2.  然后，它从项目创建流。
3.  它创建一个映射，将键作为产品 ID，将值作为数量和价格的乘积。
4.  它从 map 中获取值，并将其转换为流。
5.  它通过向`BigDecimal`添加一个方法来执行 reduce 操作。然后给出总金额。
6.  如果值不存在，那么它简单地返回`0`。

在`toEntity()`方法之后，我们还需要另一个从数据库中读取行并将它们转换成`OrderEntity`的映射器。为此，我们将编写`BiFunction`，它是`java.util.function`包的一部分:

```java
class OrderMapper implements BiFunction<Row, Object,     OrderEntity> {
  @Override
  public OrderEntity apply(Row row, Object o) {
    OrderEntity oe = new OrderEntity();
    return oe.setId(row.get("id", UUID.class))
        .setCustomerId(row.get("customer_id", UUID.class))
        .setAddressId(row.get("address_id", UUID.class))
        .setCardId(row.get("card_id", UUID.class))
        .setOrderDate(Timestamp.from(
           ZonedDateTime.of((LocalDateTime)
           row.get("order_date"), ZoneId.of("Z")).toInstant()))
        .setTotal(row.get("total", BigDecimal.class))
        .setPaymentId(row.get("payment_id", UUID.class))
        .setShipmentId(row.get("shipment_id", UUID.class))
        .setStatus(StatusEnum.fromValue(row.get("status",
           String.class)));
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

我们通过将属性从行映射到`OrderEntity`，覆盖了返回`OrderEntity`的`apply()`方法。没有使用`apply()`方法的第二个参数，因为它包含了我们不需要的元数据。

让我们首先从`OrderRepositoryExt`接口实现`updateMapping()`方法:

```java
@Override
public Mono<OrderEntity> updateMapping(OrderEntity orderEntity) {
  return oiRepo.saveAll(orderEntity.getItems().stream()
      .map(i -> new OrderItemEntity()
        .setOrderId(orderEntity.getId()).setItemId(i.getId()))
        .collect(toList()))
      .then(
        itemRepo.deleteCartItemJoinById(orderEntity.getItems()
           .stream().map(i -> i.getId().toString())
           .collect(toList()),
        orderEntity.getCartId().toString())
           .then(Mono.just(orderEntity))
      );
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

在这里，我们已经创建了一个反应流管道，并执行了两个背靠背的数据库操作。首先，它使用`OrderItemRepository`创建订单项目映射，然后使用`ItemRepository`删除购物车项目映射。

Java Streams 用于在第一个操作中创建一个`OrderItemEntity`实例的输入列表，在第二个操作中创建一个条目 id 列表。

到目前为止，我们已经使用了`ReactiveCrudRepository`方法。让我们使用实体模板实现一个自定义方法，如下所示:

```java
@Override
public Mono<OrderEntity> insert(Mono<NewOrder> mdl) {
  AtomicReference<UUID> orderId = new AtomicReference<>();
  Mono<List<ItemEntity>> itemEntities = mdl
      .flatMap(m -> itemRepo.findByCustomerId(m.           getCustomerId())
      .collectList().cache());

  Mono<CartEntity> cartEntity = mdl
      .flatMap(m -> cartRepo.findByCustomerId(m.           getCustomerId()))
      .cache();
  cartEntity = Mono.zip(cartEntity, itemEntities, (c, i) -> {
    if (i.size() < 1) {
      throw new ResourceNotFoundException(String
        .format("No item found in customer's (ID:%s) cart.",                  c.getUser().getId()));
    }
    return c.setItems(i);
  }).cache();
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

这里，我们从`OrderRepositoryExt`接口中用覆盖了`insert()`方法。`insert()`方法充满了流畅的、功能性的和反应性的 API。`insert()`方法接收一个`NewOrder`模型`Mono`实例作为参数，它包含创建新订单的有效负载。Spring Data R2DBC 不允许提取嵌套实体。然而，您可以为`Cart`编写一个类似于`Order`的定制存储库，它可以一起获取`Cart`及其项目。

我们使用`ReactiveCrudRepository`来表示`Cart`和`Item`实体。因此，我们正在一个一个地获取它们。首先，我们使用商品存储库根据给定的客户 ID 获取购物车商品。`Customer`与`Cart`一一对应。然后，我们通过使用客户 ID 使用购物车存储库获取`Cart`实体。

我们得到了两个独立的`Mono`对象——`Mono<List<ItemEntity>>`和`Mono<CartEntity>`。现在，我们需要将它们结合起来。`Mono`有一个`zip()`操作符，允许你获取两个`Mono`对象，然后使用 Java `BiFunction`合并它们。`zip()`仅当两个给定的`Mono`对象都产生项目时，才返回一个新的`Mono`对象。`zip()`是多态的，因此其他形式也是可用的。

我们有购物车及其物品，加上`NewOrder`有效载荷。让我们使用这些项将它们插入到数据库中，如下一个代码块所示:

```java
  R2dbcEntityTemplate template = new               R2dbcEntityTemplate(connectionFactory);
  Mono<OrderEntity> orderEntity = Mono.zip(mdl, cartEntity,                              (m, c) -> toEntity(m, c)).cache();
  return orderEntity.flatMap(oe -> dbClient.sql("""
      INSERT INTO ecomm.orders (address_id, card_id, customer_      id, order_date, total, status)       VALUES($1, $2, $3, $4, $5, $6)""")
      .bind("$1", Parameter.fromOrEmpty(oe.getAddressId(),                                           UUID.class))
      .bind("$2", Parameter.fromOrEmpty(oe.getCardId(), UUID.                                          class))
      .bind("$3", Parameter.fromOrEmpty(oe.getCustomerId(), 
                                          UUID.class))
      .bind("$4", OffsetDateTime.ofInstant(oe.getOrderDate().                  toInstant(), 
              ZoneId.of("Z")).truncatedTo(ChronoUnit.MICROS))
      .bind("$5", oe.getTotal())
      .bind("$6", StatusEnum.CREATED.getValue())
                     .map(new OrderMapper()::apply)
      .one())
      .then(orderEntity.flatMap(x -> template.selectOne(
          query(where("customer_id").is(x.getCustomerId())
              .and("order_date")
            .greaterThanOrEquals(OffsetDateTime
              .ofInstant(x.getOrderDate().toInstant(),
                              ZoneId.of("Z"))
                .truncatedTo(ChronoUnit.MICROS))),
           OrderEntity.class).map(t -> x.setId(t.getId())
             .setStatus(t.getStatus()))
      ));
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/repository/OrderRepositoryExtImpl.java

我们再次使用`Mono.zip()`来创建一个`OrderEntity`实例。现在，我们可以使用该实例中的值插入到 orders 表中。

有两种方式与数据库交互来运行 SQL 查询——使用`DatabaseClient`或`R2dbcEntityTemplate`。现在，`DatabaseClient`是一个轻量级实现，它使用`sql()`方法直接处理 SQL，而`R2dbcEntityTemplate`为 CRUD 操作提供了一个流畅的 API。我们使用了这两个类来演示它们的用法。

首先，我们使用`DatabaseClient.sql()`在 orders 表中插入新订单。我们使用`OrderMapper`将从数据库返回的行映射到实体。然后，我们使用`then()`反应操作符选择新插入的记录，然后使用`R2dbcEntityTemplate.selectOne()`方法将其映射回`orderEntity`。

类似地，您可以为其他实体创建存储库。现在，我们可以在服务中使用这些存储库。让我们在下一小节中定义它们。

## 添加服务

让我们为`Order`添加一个服务。服务器界面没有变化，如下所示:

```java
public interface OrderService {
  Mono<OrderEntity> addOrder(@Valid Mono<NewOrder>      newOrder);
  Mono<OrderEntity> updateMapping(@Valid OrderEntity       orderEntity);
  Flux<OrderEntity> getOrdersByCustomerId(@NotNull @Valid       String customerId);
  Mono<OrderEntity> getByOrderId(String id);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderService.java

您只需要确保接口方法签名具有作为返回类型的反应类型，以保持非阻塞流。

现在，我们可以通过以下方式实现它:

```java
@Override
public Mono<OrderEntity> addOrder(@Valid Mono<NewOrder>     newOrder) {
  return repository.insert(newOrder);
}
@Override
public Mono<OrderEntity> updateMapping(@Valid OrderEntity     orderEntity) {
  return repository.updateMapping(orderEntity);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java

前两个直截了当；我们只是使用`OrderRepository`实例来调用各自的方法。第三个有点棘手，如下所示:

```java
private BiFunction<OrderEntity, List<ItemEntity>, OrderEntity> 
            biOrderItems = (o, fi) -> o.setItems(fi);
@Override
public Flux<OrderEntity> getOrdersByCustomerId(String     customerId) {
  // will use the dummy Card Id that doesn't exist 
  // if it is null
  return repository.findByCustomerId(customerId).flatMap(order   ->
      Mono.just(order)
          .zipWith(userRepo.findById(order.getCustomerId()))
          .map(t -> t.getT1().setUserEntity(t.getT2()))
          .zipWith(addRepo.findById(order.getAddressId()))
          .map(t -> t.getT1().setAddressEntity(t.getT2()))
          .zipWith(cardRepo.findById(
              order.getCardId() != null ? order.getCardId()
              : UUID.fromString(
                  "0a59ba9f-629e-4445-8129-b9bce1985d6a"))
              .defaultIfEmpty(new CardEntity()))
          .map(t -> t.getT1().setCardEntity(t.getT2()))
          .zipWith(itemRepo.findByCustomerId(
              order.getCustomerId().toString()).collectList(),
              biOrderItems)
  );
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java

这个方法看起来很复杂，但其实不然。您在这里所做的基本上是从多个存储库中获取数据，然后填充`OrderEntity`中的嵌套实体。这是通过使用`zipWith()`操作符来完成的，要么在它旁边使用`map()`操作符，要么使用`BiFunction`作为单独的参数。

它首先通过使用客户 ID 获取订单，然后平面映射订单以填充其嵌套实体。因此，我们在`flatMap()`操作符中使用了`zipWith()`。如果观察第一个`zipWith()`，它获取用户实体，然后使用`map()`操作符设置嵌套用户实体的属性。类似地，填充其他嵌套实体。

在最后一个`zipWith()`操作符中，我们使用`BiFunction` `biOrderItems`来设置`OrderEntity`实例中的条目实体。

相同的算法用于实现`OrderService`接口的最后一个方法，如下面的代码所示:

```java
@Override
public Mono<OrderEntity> getByOrderId(String id) {
  return repository.findById(UUID.fromString(id)).flatMap(order ->
      Mono.just(order)
          .zipWith(userRepo.findById(order.getCustomerId()))
          .map(t -> t.getT1().setUserEntity(t.getT2()))
          .zipWith(addRepo.findById(order.getAddressId()))
          .map(t -> t.getT1().setAddressEntity(t.getT2()))
          .zipWith(cardRepo.findById(order.getCardId()))
          .map(t -> t.getT1().setCardEntity(t.getT2()))
          .zipWith(itemRepo.findByCustomerId(
              order.getCustomerId().toString()).collectList(),
              biOrderItems)
  );
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/OrderServiceImpl.java

还有另一种方法使用`Mono.zip()`操作符合并两个`Mono`实例，如下所示:

```java
private BiFunction<CartEntity, List<ItemEntity>, CartEntity>         cartItemBiFun = (c, i) -> c
      .setItems(i);
 @Override
public Mono<CartEntity> getCartByCustomerId(String customerId) {
  Mono<CartEntity> cart = repository.        findByCustomerId(customerId)
      .subscribeOn(Schedulers.boundedElastic());
  Flux<ItemEntity> items = itemRepo.        findByCustomerId(customerId)
      .subscribeOn(Schedulers.boundedElastic());
  return Mono.zip(cart, items.collectList(), cartItemBiFun);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/service/CartServiceImpl.java

这个例子是取自`CartServiceImpl`类的。这里，我们进行了两个独立的调用——一个使用购物车存储库，另一个来自商品存储库。结果，这两个调用产生了两个`Mono`实例，并使用`Mono.zip()`操作符将它们合并。这个我们用`Mono`直接调用；前面的例子是在带有`zipWith()`操作符的`Mono` / `Flux`实例上使用的。

使用类似的技术，已经创建了剩余的服务。那些你可以在 https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 05/src/main/Java/com/packt/Modern/API/service 找到的。

让我们把注意力转移到我们的反应式 API 实现的最后一部分。

## 添加控制器实现

REST 控制器接口已经由 OpenAPI Codegen 工具生成。我们现在可以创建这些接口的实现。这一次唯一不同的事情是使用反应管道来调用服务和组装器。基于生成的契约，您还应该只返回包装在`Mono`或`Flux`中的`ResponseEntity`对象。

让我们实现`OrderApi`，它是`Orders` REST API 的控制器接口:

```java
@RestController
public class OrderController implements OrderApi {
  private final OrderRepresentationModelAssembler assembler;
  private OrderService service;
  public OrderController(OrderService service, 
             OrderRepresentationModelAssembler assembler) {
    this.service = service;
    this.assembler = assembler;
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java

在这里，`@RestController`是一个结合了`@Controller`和`@ResponseBody`的戏法。这些是我们在 [*第 4 章*](04.html#_idTextAnchor086) 、*为 API*编写业务逻辑中使用的相同注释，用于创建 REST 控制器。然而，这些方法现在具有不同的签名来应用反应式管道。确保你没有打断电话的反应链或者添加任何阻塞电话。如果这样做，要么 REST 调用将不会完全非阻塞，要么您可能会看到不希望的结果。

我们使用基于构造函数的依赖注入来注入订单服务和组装器。让我们添加方法实现:

```java
@Override
public Mono<ResponseEntity<Order>> addOrder(@Valid Mono<NewOrder> newOrder,
    ServerWebExchange exchange) {
  return service.addOrder(newOrder.cache())
      .zipWhen(x -> service.updateMapping(x))
      .map(t -> status(HttpStatus.CREATED)
        .body(assembler.entityToModel(t.getT2(), exchange)))
      .defaultIfEmpty(notFound().build());
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java

方法参数和返回类型都是反应类型(`Mono`)，用作包装器。反应式控制器还有一个额外的参数`ServerWebExchange`，我们之前已经讨论过了。

在这个方法中，我们简单地将`newOrder`实例传递给服务。我们使用了`cache()`,因为我们需要不止一次地订阅它。我们通过`addOrder()`调用得到新创建的`EntityOrder`。然后，我们使用`zipWhen()`操作符，它使用新创建的订单实体执行`updateMapping`操作。最后，我们将它包裹在`ResponseEntity`中发送出去。此外，当返回一个空实例时，它返回`NOT FOUND 404`。

让我们看看其他 API 接口实现:

```java
@Override
public Mono<ResponseEntity<Flux<Order>>>     getOrdersByCustomerId(@NotNull @Valid String customerId,    ServerWebExchange exchange) {
  return Mono.just(ok(assembler.toListModel(
    service.getOrdersByCustomerId(customerId), exchange)));
}
@Override
public Mono<ResponseEntity<Order>> getByOrderId(String id,     ServerWebExchange exchange) {
  return service.getByOrderId(id).map(o ->                           assembler.entityToModel(o, exchange))
      .map(ResponseEntity::ok)
      .defaultIfEmpty(notFound().build());
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/controller/OrderController.java

两者本质上有点相似；该服务基于给定的客户 ID 和订单 ID 返回`OrderEntity`。然后它被转换成一个模型，并被包装在`ResponseEntity`和`Mono`中。

类似地，其他 REST 控制器也是使用相同的方法实现的。你可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 05/src/main/Java/com/packt/Modern/API/controller](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter05/src/main/java/com/packt/modern/api/controller)找到其余的。

我们几乎完成了反应式 API 实现。让我们看看其他一些小的变化。

## 向应用添加 H2 控制台

H2 控制台应用在 Spring WebFlux 中默认不可用，而在 Spring MVC 中是可用的。但是，您可以通过自己定义 bean 来添加它，如下所示:

```java
@Component
public class H2ConsoleComponent {
    private final static Logger log = LoggerFactory.        getLogger(H2ConsoleComponent.class);
    private Server webServer;
    @Value("${modern.api.h2.console.port:8081}")
    Integer h2ConsolePort;
    @EventListener(ContextRefreshedEvent.class)
    public void start() throws java.sql.SQLException {
      log.info("starting h2 console at port           "+h2ConsolePort);
      this.webServer = org.h2.tools.Server.createWebServer(          "-webPort", h2ConsolePort.toString(),           "-tcpAllowOthers").start();
    }
    @EventListener(ContextClosedEvent.class)
    public void stop() {
      log.info("stopping h2 console at port           "+h2ConsolePort);
      this.webServer.stop();
    }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/java/com/packt/modern/api/H2ConsoleComponent.java

这很简单；我们添加了`start()`和`stop()`方法，分别在`ContextRefreshEvent`和`ContextStopEvent`上执行。`ContextRefreshEvent`是一个应用事件，当`ApplicationContext`被刷新或初始化时被触发。`ContextStopEvent`也是一个应用事件，当`ApplicationContext`关闭时会被触发。

`start()`方法使用 H2 库创建 web 服务器，并在给定的端口上启动它。`stop()`方法停止 H2 web 服务器，也就是 H2 控制台应用。

您需要一个不同的端口来执行 H2 控制台，这可以通过在`application.properties`文件中添加`modern.api.h2.console.port=8081`属性来配置。`h2ConsolePort`属性用`@Value("${modern.api.h2.console.port:8081}")`标注，因此当`H2ConsoleComponent` bean 被 Spring 框架初始化时，`application.properties`中配置的值将被选取并赋给`h2ConsolePort`。如果属性未在`application.properties`文件中定义，则值`8081`将被赋值。

既然我们在讨论`application.properties`，那就来看看其他的一些变化吧。

## 添加应用配置

我们将使用 Flyway 进行数据库迁移。让我们添加它所需的配置:

```java
spring.flyway.url=jdbc:h2:file:./data/ecomm;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;DATABASE_TO_UPPER=FALSE;DB_CLOSE_ON_EXIT=FALSE
spring.flyway.schemas=ecomm
spring.flyway.user=
spring.flyway.password=
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/resources/application.properties

你一定想知道为什么我们在这里使用 JDBC，而不是 R2DBC。因为 Flyway 还没有开始支持 R2DBC(在撰写本文时)。添加支持后，您可以将其更改为 R2DBC。

我们已经指定了`ecomm`模式，并设置了一个空白的用户名和密码。

让我们来看看 Spring 数据配置:

```java
spring.r2dbc.url=r2dbc:h2:file://././data/ecomm?options=AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1;IGNORECASE=TRUE;DATABASE_TO_UPPER=FALSE;DB_CLOSE_ON_EXIT=FALSE
spring.r2dbc.driver=io.r2dbc:r2dbc-h2
spring.r2dbc.name=
spring.r2dbc.password=
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/src/main/resources/application.properties

Spring Data 支持 R2DBC，因此我们使用基于 R2DBC 的 URL。我们已经将驱动程序的`io.r2dbc:r2dbc-h2`设置为 H2，并设置了一个空白的用户名和密码。

类似地，我们在`logback-spring.xml`中添加了以下日志属性，用于在 Spring R2DBC 和 H2 的控制台中添加调试语句，如下所示:

```java
<logger name="org.springframework.r2dbc" level="debug"     additivity="false">
  <appender-ref ref="STDOUT"/>
</logger>
<logger name="reactor.core" level="debug" additivity="false">
  <appender-ref ref="STDOUT"/>
</logger>
<logger name="io.r2dbc.h2" level="debug" additivity="false">
  <appender-ref ref="STDOUT"/>
</logger>
```

这就结束了我们对反应式 RESTful APIs 的实现。现在，你可以测试它们。

## 测试反应式 API

现在，你一定很期待测试。你可以在下面的位置找到 Postman (API 客户端)集合，它是基于 Postman 集合 2.1 版本的。您可以导入它，然后测试 API:

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter05/Chapter05.postman_collection.json

# 总结

我希望您喜欢学习使用异步、非阻塞和函数式范例进行反应式 API 开发。乍一看，如果您不太熟悉 fluent 和函数式范例，您可能会发现它很复杂，但是通过实践，您将开始只编写函数式风格的代码。毫无疑问，熟悉 Java 流和函数会让您更容易理解这些概念。

现在你已经读到了本章的末尾，你已经掌握了编写功能性和反应性代码的技巧。现在，您可以编写反应式、异步、非阻塞的代码和 REST APIs。您还了解了 R2DBC，只要反应式编程还在，它将来会变得更加坚实和增强。

在下一章，我们将探索 RESTful 服务开发的安全性。

# 问题

1.  应用开发真的需要反应式范式吗？
2.  使用反应范式有什么缺点吗？
3.  在 Spring WebFlux 的 HTTP 请求中，谁扮演订阅者的角色？

# 延伸阅读

*   Project Reactor:

    [https://project reactor . io](https://projectreactor.io)

*   Spring Reactive documentation:

    [https://docs . spring . io/spring-framework/docs/current/reference/html/we B- reactive . html](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)

*   Spring Data R2DBC – reference documentation

    [https://docs . spring . io/spring-data/r2dbc/docs/current/reference/html/#前言](https://docs.spring.io/spring-data/r2dbc/docs/current/reference/html/#preface)

*   *Hands-On Reactive Programming in Spring 5* (book)

    [https://www . packtpub . com/product/hands-on-reactive-programming-in-spring-5/9781787284951](https://www.packtpub.com/product/hands-on-reactive-programming-in-spring-5/9781787284951)

*   *Hands-On Reactive Programming with Java 12* (video)

    [https://www . packtpub . com/product/hands-on-reactive-programming-with-Java-12-video/9781789808773](https://www.packtpub.com/product/hands-on-reactive-programming-with-java-12-video/9781789808773)