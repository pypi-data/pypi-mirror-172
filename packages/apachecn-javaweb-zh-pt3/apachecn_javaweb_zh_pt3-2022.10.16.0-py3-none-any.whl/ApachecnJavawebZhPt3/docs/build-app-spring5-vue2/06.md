# 六、代码设计——为稳定性和可扩展性而设计

代码设计或软件设计通常被认为是应用开发过程中的一个分离步骤。一组 UML 图是记录设计最常见的方式。然而，一旦代码被写出来，它们将很快变得过时。实现和设计之间存在差异，这些差异不会同步回设计文档。保持设计文档最新的努力是相当大的，因为需求总是在变化。感觉就像一场我们一直在输的战斗。

那么，我们应该做代码设计吗？真的有必要吗？因为我们现在有了数据模型，为什么我们不开始写代码并实现特性呢？无论如何，我们可以稍后重构我们的代码。这听起来更敏捷。

中国有句老话，*磨一把柴刀不会耽误砍柴的工作*。做代码设计就像在劈柴就像写代码的地方磨一把菜刀。

所以，让我们更多地讨论代码设计，尤其是如何在敏捷项目中以正确的方式完成它。在本章中，您将了解以下主题:

*   敏捷代码设计
*   设计原则和设计模式
*   任务敏捷代码设计

# 敏捷代码设计

很多时候，当我们谈论做代码设计，或者软件设计的时候，首先弹出来的是画 UML 图。UML 图是设计的一部分，但它不是设计。那么，到底什么是代码设计呢？

# 什么是代码设计？

Robert C. Martin 在他的书《敏捷软件开发:原则、模式和实践》(Martin，2002)中说道:

软件项目的设计是一个抽象的概念。它与程序的整体形状和结构以及每个模块、类和方法的详细形状和结构有关。它可以由许多不同的媒体来表示，但它的最终体现是源代码。最后，源代码就是设计。

等等，源代码怎么可能是设计？这说不通吧？源代码是最终软件产品本身的一部分。如果源代码就是设计，我们就不需要再做设计了，因为我们只需要写代码。这似乎很荒谬，对吗？

这个**新鲜的**观点可能会打动你。在这里，我们不会试图证明源代码就是设计，因为 Jack W. Reeves 没有在他富有远见的文章*中证明什么是软件设计？*，1992 年秋天首次发表在 C++期刊上，现在可以在 developer 上获得。*([http://www . developer dotstar . com/mag/articles/reeves _ design _ main . html](http://www.developerdotstar.com/mag/articles/reeves_design_main.html))。

事实上，源代码就是设计的想法并不是一个需要证明的公式。只是对软件设计和编码关系的不同看法，换个角度看。听取别人的意见总是个好主意。

# 传统角度

现在，让我们从传统的角度来看源代码和编码的关系。这里的**传统**一词并不暗示这个角度是老的。实际上，到 2018 年，源代码就是设计的想法已经有 26 年了，自从 Reeves 发表了他的论文。

传统上，当我们谈论软件设计和编码时，我们经常将这种关系与设计蓝图和工程师建造房屋的过程之间的关系相比较，或者与汽车设计和汽车制造之间的关系相比较。基于这种假设，我们需要预先的软件设计来指导我们应用的实现。

然而，有多少次我们发现我们不能按照设计来编写代码，因为设计中缺少一些东西或者需求已经被改变了？代码一写出来，设计文档就过时了。您可能会认为这是因为投入代码设计的精力不够，或者设计不够全面，无法涵盖所有需求。基于这一点，你需要在编写代码之前为设计分配更多的时间。实际上，这并不总是有效的。

以下是软件应用开发中常见的内容。在一个项目的开始，一个干净优雅的代码设计被精心制作。然而，随着新功能的增加或变化的实现，事情开始出错。代码不再遵循设计，为了赶上已经落后的紧张进度，开发人员被迫在正确完成和快速完成之间做出妥协。然后，代码变得凌乱，变成一堆**意大利面条式的代码**。你可以看到很多黑客和评论，比如*稍后重构*。*这是一次黑客攻击。稍后将在代码中提出更好的解决方案*。然后，对一个特性的简单更改会级联到代码的其他部分，甚至是那些不相关的部分，维护成本会呈指数级上升。这意味着现有的代码已经变得如此脆弱，以至于开发人员开始围绕它编写新的代码，这使得事情变得更糟，最终，他们告诉他们的经理，如果不重新设计或重写，就不能实现更多的更改，因为他们可能会破坏其他已经在工作的功能，而修复这些潜在的问题需要几周甚至几个月的时间。

重新设计能解决这个问题吗？这看起来很乐观，因为现在我们对应用的特性有了更好的了解。重新设计可以体现最初设计中没有包括的那些变化。然而，正如 Robert C. Martin 在他的书*敏捷软件开发:原则、模式和实践*中所说，这样的重新设计很少成功。这是因为旧的系统会不断发展变化，新的设计必须跟上。总会有设计者预见不到的变化，除非有水晶球。即使当新设计首次发布时，也可能只是另一轮循环的开始。

# 第二个角度

编写代码是一个过程，让你理解需求，以及如何实现这些需求的想法，以你喜欢的编程语言编写的代码的形式出现在你的脑海中。创建设计文档是一个以代码之外的形式概述解决方案的过程，例如，UML 图。本质上，代码和设计文档是代表你想法的媒介。

设计文档非常有用，因为它们是解决方案的轮廓。您可以将它们作为编写代码的指南。在编写代码的过程中，通常，你可以获得解决方案的灵感。新的想法会出现，或者你会在大纲中发现瑕疵。最终，解决方案被写入源代码。从产品的角度来看，唯一用于创建最终产品的也是源代码，它由计算机构建成 0 和 1。从这个角度，你可以把计算机想象成工厂里的工人，源代码就是它们用来创造产品的设计。

# 两个角度之间的差异

这个角度和传统的有什么区别？最大的区别在于，在传统观点看来，设计过程和编码过程是两个脱节的步骤。这种分离切断了设计活动和编码活动。也就是说，你只在设计阶段做设计，只在实现阶段写代码。事实上，这是没有认识到，当在我们的大脑中编写代码时，发生的事情不是简单的从设计到源代码的翻译，而是大脑进行的强烈的创造性活动。

另一方面，当我们说源代码是设计时，这并不意味着我们反对使用 UML 图或任何其他工具和符号。事实上，我们应该使用任何有助于设计的东西。只是我们必须记住，源代码是最终的设计，其他的设计文档都是辅助文档，对于一个软件项目来说，就像设计蓝图对于盖房子一样重要。

在本书中，我们认为源代码就是设计。在我们讨论如何在敏捷项目中进行代码设计之前，让我们先来看看不同层次的代码设计。

# 代码设计的层次

在 Jack W. Reeves 的文章*什么是软件设计:13 年后*中，他提到了设计的三个层次:

我认为我们需要好的架构(顶层设计)、好的抽象(类设计)和好的实现(底层设计)。

这里，我们将把它重新表述为架构级设计、抽象级设计和实现级设计。

# 架构级别

在这一关的设计中，你可以找到如下问题的答案:

*   系统会采用多层设计吗？
*   是整块还是用微服务？
*   什么是子系统，它们如何使用 SOAP、REST 或 AMQP 进行通信？
*   有没有和第三方系统的交互？他们是如何交流的？

这一级别的设计是基本的，大多数情况下，您预先进行架构设计，一旦完成，您就不要更改它，除非有根本性的错误，或者如果没有这一级别的重新设计，就不可能实现需求更改。您在设计文档中编写这一级别的设计，因为通过检查源代码来搞清楚架构级设计通常是一种令人畏惧的体验，而且当有大量代码围绕该架构构建时，这是不可能的。

# 抽象层次

在这个层次上，设计集中在子系统的包和主要组件上，它应该是一个高层次的设计。如果它相对简单的话，你通常把它保存在设计文档或 package— `info.java`类中。这个层次的设计提供了一个子系统的抽象概述。您应该在设计中只包含关键类及其关系。其他任何细节都要尽量避免。当你看这个层次的设计时，你应该能够理解那个子系统的结构和主要逻辑。

当你开始实现一个子系统时，你做了抽象层次的设计。通常，这个层次的设计是稳定的，或者接近稳定的。在实现过程中，随着对应用逻辑的深入了解，您可能会对其进行改进。但是，您应该不需要经常更改它。否则，这就暗示着设计本身肯定有问题。

# 实现水平

在这一级，设计集中于类的实现，主要是字段和方法。它充满了具体和低级信息的细节。源代码是这一级设计的主要表现形式。您可能会为复杂的逻辑创建一些 UML 图，但是您应该保持它们的最小化，因为细节会改变，而且它们会改变很多。您当然不希望花费太多的精力去更新那些图。相反，你应该在源代码本身上投入更多的时间。保持它的干净、简单和有表现力。

在这个层面上，由于这些变化，将会有大量的重构来保持设计尽可能的好。

# 细节中的魔鬼

如果你把我们刚才讲的三个层次的设计想象成一栋房子，那么建筑层次就像那栋房子的地基和整体结构；一旦你建立了它，你就不能改变它。抽象层次就像房子里的墙。有时，你可能会添加另一面墙，将一个大房间分成两个小房间，或者你可能会拆掉一面墙，以创造更多空间。但是你不需要经常这样做。实现层就像家具、地毯、墙纸、窗帘等等，都是房子里那些小的可移动的物品。你可以经常改变这些，例如，你可以把沙发移近电视，把餐桌换成新的，或者再重新装修一次。你还需要定期打扫房子。否则，不管最初设计时有多美好，都会变成一团糟。

在一个软件应用中，所有的细节都在源代码中，这也是需要你不断努力保持它干净、简单和有表现力的部分。否则，你会在细节中看到魔鬼。

# 糟糕设计的症状

当细节中的魔鬼出现时，设计就出现了严重的问题。通常，您会在代码中看到糟糕设计的症状。

以下是 Robert C. Martin 在他的书《敏捷软件开发:原则、模式和实践》中提到的设计味道:

*   刚性:系统很难改变，因为每一个改变都会迫使系统的其他部分发生许多变化
*   **脆弱性**:变更导致系统在与被变更的部分没有概念关系的地方崩溃
*   **不可移动性**:很难将系统分解成可以在另一个系统中重用的组件
*   **粘度**:把事情做对比做错更难
*   **不必要的复杂性**:设计包含没有增加直接利益的基础设施
*   不必要的重复:设计包含重复的结构，这些结构可以统一在一个抽象下
*   **不透明**:难以阅读和理解。它没有很好地表达它的意图

在这些设计气味中，刚性、脆弱、不动、粘性和不透明是糟糕设计的症状。不用说，复杂性和不必要的重复是这些症状的两个原因。让我们仔细看看所有这些症状。

# 严格

当软件变得僵化时，很难做出改变；不是因为一个变化本身是复杂的，而是因为由这个变化引起的所有后续变化通常比你预期的要多。更糟糕的是，您可能无法验证在更改之后，系统是否仍能正常工作，除非您对受该更改影响的所有功能进行手动测试，这对于规模不小的应用来说是相当令人生畏的。因此，一个小的变化可能需要几天，甚至几周才能完成和验证，这比最初的估计要长得多。

# 脆弱

当一个软件变得脆弱时，它经常会崩溃，而且大多数时候都是意想不到的，即使你所做的改变很简单，而且毫不相关。开发人员害怕对现有代码进行修改，因为他们可能会无意中破坏系统。然而，只要软件没有被抛弃，变化总是会出现的。对脆弱的系统进行更改可能会使其更加脆弱，并且系统的复杂性会随着黑客攻击和覆盖代码的死角而增加。

# 不透明

当一个系统遭受不透明时，阅读代码是困难的，理解它更困难。维护这样一个系统需要比那些有清晰的表达性代码的系统付出更多的努力。不透明的原因可能有很多，例如，糟糕的命名、不必要的复杂性和过度设计。把简单的事情变复杂很容易，而把复杂的事情变简单就难多了。

# 不动

不可移动性是可重用性的对立面。当一个系统没有可以被其他系统重用部分时，这并不意味着这个系统设计糟糕。这意味着，当需要这种可重用性时，使代码的一部分可被另一个系统重用的努力太高了。当一个系统有不动的症状时，它也有僵硬和脆弱的症状。

# 粘性

当软件变得粘性时，开发人员倾向于在不同的解决方案中选择一种易于实现的方式来实现变更。然而，他们不会保留设计，并放弃那些会保留更难实现的设计的解决方案。这可能是因为设计本身过于复杂，缺乏清晰性使得它不可能在紧张的时间表内完成。

# 敏捷代码设计实践

到目前为止，我们已经讨论了什么是代码设计，代码设计的三个层次，以及糟糕设计的症状。在这一节中，我们将讨论敏捷代码设计在不同层面上的实践。

# 架构级别

当我们开始一个新的项目时，通常，我们已经有了一个我们将要构建什么样的应用的想法，并且在顶层，系统是如何工作的。我们应该能够创建一个架构级别的设计。有时，可能会引入一些新技术，您需要做一些研究或创建原型来验证您的设计。

# 抽象层次

在实现一个子系统的开始，我们应该为这个子系统或者模块做抽象层次的设计。如前所述，这种设计应该避免细节，只提供高层次的信息。它更像是一种指导，这样开发人员就可以在完成时理解子系统或模块内部是如何工作的。

# 实现水平

实现级别的设计需要最大的努力，这样您就可以保持代码尽可能的好。您需要采用以下几种做法:

*   **测试驱动开发**:在实现层面，我们必须实践测试驱动开发。这对于敏捷项目来说至关重要，因为我们依靠这些单元测试来确保我们编写的代码在重构后能够正确运行。我们还使用单元测试作为源代码的客户端，来帮助我们改进代码设计，使其解耦，并提高代码质量。当我们有测试用例来验证我们的代码时，我们可以频繁地进行重构来清理代码中的混乱，这样系统就不会遭受我们谈到的所有这些症状。
*   **验收测试** : 除了单元测试，我们还应该编写验收测试来验证客户指定的用户故事的细节。这些验收测试需要能够重复运行。它们提供了比单元测试更高级别的验证。单元测试和验收测试一起验证实现级别的设计，并在重构过程中提供信心。
*   **重构** : 另一种实践，我们多次提到的，就是重构。这就像重新整理你家的家具或做家务，以防止事情变得凌乱。重构是一种通过修改代码来改进设计的技术，以便在必要时应用设计原则或使用设计模式。也就是说，当你写代码时，你从简单开始，只写足够的代码来通过测试用例。不多不少。通过这种方式，您在实现级别保留了一个简单的设计，只有当代码中有变化或有味道时，您才重构它。
*   **关注当前故事** : 在做实现层面的代码设计时，要关注当前 sprint 的用户故事，把代码设计得尽可能好。不用太担心未来的用户故事。您可以记住它们，但不要为它们编写代码。以下是原因:
    *   未来的故事可能会被改变或丢弃。在这种情况下，为未来故事编写的代码会给设计带来不必要的复杂性。
    *   到时候可以写。早点写出来对你没什么好处。相反，你这样做是在冒险。

综上所述，在实践中，我们创建高层次的架构级设计和抽象级设计。在实现层面，我们做了以下工作:

*   我们采用测试驱动的开发实践，并编写验收测试来检测代码的问题
*   我们应用设计原则来找出代码的味道
*   我们应用适当的设计模式通过重构来解决问题

因此，敏捷代码设计更多的是一个过程，而不是一组设计文档或一个事件。罗伯特·c·马丁对其定义如下:

它是原则、模式和实践的持续应用，以改进软件的结构和可读性。它致力于使系统的设计在任何时候都尽可能的简单、干净和有表现力。

# 设计原则和设计模式

我们前面提到了设计原则和设计模式。在本节中，我们将进一步讨论它们。我们将从 SOLID 开始，它是我们将要介绍的五个设计原则的首字母缩写。由于本书的范围，我们将只沿途谈论相关的设计模式。

可靠的设计原则在 Robert C. Martin 的书*敏捷软件开发:原则、模式和实践*中有介绍，他在书中给出了这些原则的详细解释和例子。在这里，我们将介绍它们，作为我们将在 TaskAgile 应用中应用的原则。

# 坚实的设计原则

让我们从前五个设计原则开始:

*   **S** RP: **单一责任原则**
*   **O** CP: **开闭原理**
*   **L** SP: **利斯科夫替代原理**
*   **I** SP: **界面偏析原理**
*   **D** IP: **依存倒置原则**

# 单一责任原则

一个类应该只有一个改变的理由。

这个原则是最简单的原则之一，但也是最容易混淆的，主要是因为它的名字。

正如在《敏捷软件开发:原则、模式和实践》一书中提到的，在 SRP 的上下文中，责任是*一个改变的理由*。当你改变一个类时，如果你能想到另外一个单独改变它的理由，比如在不同的时间，那么这个类就违反了 SRP。

另一种解释是责任是变化的轴心。在一个类中，所有的变化都应该围绕一个中心点或一个连续体发生。你可以把一堂课想象成一个讨论室。在一个房间里，人们在谈论自己的爱好，比如远足、滑雪、潜水，以及他们喜欢的踢足球方式。然后有人提到看电影，突然几个人开始激烈的讨论他们最喜欢什么电影，他们最喜欢的角色是谁，以及那些电影里的场景细节。此时，最好将小组分成两个不同的房间；一个继续聊兴趣爱好，一个讨论电影。这样，任何一组的讨论都不会受到另一组的影响。在这个比喻中，话题*爱好*是变化的轴心。

正如 Martin 所说:*只有当变化真正发生时，变化轴才是变化轴*。

所以，如果没有关于电影的激烈讨论，而只是简短地提及，那么就没有理由把这些人转移到另一个讨论室。

因为这个原理的名字，很容易让人觉得每个类应该做一件事，而且只做一件事。如果我们在设计类时遵循这种解释，我们将会给设计增加不必要的复杂性，因为我们将会破坏一个类的内聚性，这个类的代码为了一个单一的职责紧密地绑定在一起，即使这个类似乎在做不同的事情。这还会降低代码的可读性，因为您需要在不同的、更小的类之间跳转，以链接片段来理解逻辑。

事实上，有一个原则说，一个方法应该做一件事，而且只能做一件事。然而，那是为了将大方法重构为小方法，应该用在底层设计，也就是实现层设计。

# 开闭原则(OCP)

软件工件应该对扩展开放，但对修改关闭。

Bertrand Meyer 在 1988 年创造了 OCP，为我们提供了如何在变化面前创造稳定的设计的指导。

在这里，我们将借用*敏捷软件开发:原则、模式和实践*中的`DrawAllShapes`例子来解释这个原则。我们将在 ES6 中编写示例；省略了不相关的细节:

```java
class Circle extends Shape {
 constructor(radius, point) {
    this.type = 'circle' 
    // ...
  }
}

class Square extends Shape {
  constructor(width, point) {
    this.type = 'square'
    // ...
  }
}

function drawCircle(circle) {
  // Draw circle logic here
}

function drawSquare(square) {
  // Draw square logic here
}

function drawAllShapes(shapes) {
  shapes.forEach((shape) => {
    if (shape.type === 'circle') {
      drawCircle(shape)
    } else if (shape.type === 'square') {
      drawSquare(shape)
    }
  })
}
```

如你所见，我们有`Circle`和`Square`类，它们扩展了`Shape`。两者都有字段类型。`drawCircle()`和`drawSquare()`是分别负责画圆和正方形的两个函数。现在，让我们检查一下`drawAllShapes()`函数。它遍历一个`shapes`数组，检查每个形状的类型，并调用相应的`draw`函数来绘制该形状。这个`drawAllShapes()`函数违反了 OCP，因为当我们需要支持新类型的形状时，它是不可扩展的。它并不排斥新的变化。

我们可以对其进行如下重构，使其符合 OCP:

```java
class Circle {
  //...
  draw() {
    // Draw circle logic here
  }
}

class Square {
  //...
  draw() {
    // Draw square logic here
  }
}

function drawAllShapes(shapes) {
  shapes.forEach((shape) => {
    shape.draw()
  })
}
```

如你所见，我们将`draw`函数移动到每种类型的形状中，在`drawAllShapes()`函数中，我们简单地调用该形状的`draw()`方法。现在，`drawAllShapes()`功能支持`Triangle`、`Rectangle`以及任何其他类型的形状，只要它有`draw()`功能。这种设计现在符合 OCP。它是通过添加新的代码来改变的，比如`Triangle`和`Rectangle`，而不是改变现有的代码。

然而，它并没有真正关闭。它接近于需要支持一种新的形状类型的需求，但是它不接近于需求，例如，如果我们需要应用在绘制任何正方形之前绘制所有的圆，或者我们需要按照形状的位置顺序来绘制形状。

那么，我们是否应该重构我们的`drawAllShapes()`函数，使其接近我们刚刚提到的两个需求呢？不，还没有！我们一直等到变化发生。也就是说，我们只在需要改变的时候重构函数。如果还是未来，那就等着吧。因为，如前所述，在敏捷项目中，变更经常发生。这些需求可能会被移到产品计划的最后，甚至可能不再需要。现在重构它将是一种过度设计的行为，代码将显示不透明的症状，更不用说重构它的开发时间和努力可能会被浪费。

# 利斯科夫替代原理(LSP)

1988 年，Barbara Liskov 以如下方式写下了这一原则，作为识别亚型的一种方法:

*What is wanted here is something like the following substitution property: if for each object o1 of type S there is an object o2 of type T so that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T.*

Robert C. Martin 在他的书《敏捷软件开发:原则、模式和实践》中解释如下:

*子类型必须可以替换它们的基本类型*。

这里，我们将使用*敏捷软件开发:原则、模式和实践*中的正方形/矩形问题，作为违反 LSP 的一个例子，因为我们知道，从逻辑上讲，正方形就是矩形。如下图所示，`Square`类继承了`Rectangle`类。通常，继承被视为**是-一种**关系。`App`级依赖于`Rectangle`级:

![](img/7010123c-bf2a-4ace-aba3-c07c472110d4.png)

图 6.1:矩形和正方形

如您所见，`Rectangle`类有两个字段及其 setters 和 getters，以及`calculateArea()`方法。在`Square`类中，`setWidth()`和`setHeight()`方法覆盖了其基类中的设置器。

下面是`Square`类和`App`类的代码。为了简洁起见，这里没有显示`Rectangle`类:

```java
public class Square extends Rectangle {
  public void setWidth(int width) {
    this.width = width;
    this.height = width;
  } 
  public void setHeight(int height) {
    this.height = height;
    this.width = height;
  }
}

public class App {
  public void resize(Rectangle rectangle) {
    rectangle.setWidth(10);
    rectangle.setHeight(5);
    int area = rectangle.calculateArea(); 
    assert area == 50;
  }
}
```

正如你在`Square`类的`setWidth()`和`setHeight()`方法中看到的，我们保持宽度和高度相同的值，这非常有意义。

那么，这样的设计有什么问题呢？问题是在`App`类的`resize()`方法内部，当我们用一个`Square`的对象调用这个方法时，断言会是`false`。在`rectangle.setHeight(5)`之后，在该对象内部，宽度和高度的值都是`5`。`area`的值将是`25`而不是`50`。但是，当我们传入的参数是`Rectangle`的对象时，断言将是`true`。

这违反了 LSP。在`resize()`方法中，`Square`子类型不能替换它的基类型`Rectangle`。那么，为什么这是一个问题呢？因为，从`App`类的角度来看，`Rectangle`及其所有子类型应该表现相同。

# 接口隔离原则(ISP)

**客户不应该被迫依赖他们不使用的方法**。

这个原理处理**重**接口。这些繁重接口的客户端被迫承担额外的负担。也就是说，它们会根据其他客户端的请求进行更改。让我们来看一个例子。

未来无人机是一家生产无人机的公司。他们的研发部门最近设计了一种可以飞行和驾驶的无人机。这架无人机有两个独立的遥控设备——一个控制它的飞行，另一个控制它的驾驶。下面是他们的`DroneController` API 的设计:

![](img/7a7af48e-79ea-43a7-9f23-c961353709e8.png)

图 6.2:drone controller API

如您所见，两个远程控制设备都可以访问它们不需要的方法。这是严重错误的。为什么？因为未来无人机公司 R&D 部门的工程师们工作非常努力，他们制造出了还能航行的无人机。现在，他们需要在`DroneController` API 中添加一个`sail()`方法，这样`SailRemoteControlDevice`就可以让无人机航行了，如下图所示:

![](img/37b1e1a3-13ce-4601-8754-0de276baf70f.png)

图 6.3:drone controller API 的新版本

现在，`DroneController`的新版本迫使`FlyRemoteControlDevice`和`DriveRemoteControlDevice`被重新编译并重新部署到所有那些远程控制设备上。这就是为什么`DroneController`的设计严重错误！

我们按照 ISP 来重构一下，如下图所示:

![](img/92e0cd25-46a4-4a11-b731-dfa4d8ed78b7.png)

图 6.4:隔离界面

如您所见，为每个设备分别创建了较小的接口。这减轻了`DroneController` API 给他们带来的不必要的负担。它们不受其他接口上未来变化的影响。

然而，这种设计仍然违反了 SRP。`DroneControllerManager`，`DroneController`的实现，包含多个变更原因。为使其符合 SRP，`DroneController`应淡出并弃用。`DroneControllerManager`中的`fly()`、`drive()`和`sail()`实现也应该被移到每个更小的控制器 API 的单独实现中，如下图所示:

![](img/2165d498-65b3-43ed-9830-f26b7cf06ee1.png)

图 6.5:符合 SRP 的实现

**立面设计模式**:该模式是**四人组** ( **GoF** )设计模式的一部分，归类于结构设计模式下。该模式用于为子系统中的一组接口提供统一的接口。外观定义了一个更高层次的接口，使子系统更容易使用。

在下图的左侧，子系统的客户端需要知道子系统内部类的详细信息。在右侧，子系统的**外观**向其客户端提供了统一的接口，并隐藏了子系统的实现细节。只要**外观**的 API 保持不变，客户端就看不到子系统内部的变化:

![](img/8ddcd7a6-4394-485c-ab85-645c2c90f0b6.png)

图 6.6:外观设计模式

如果你想想这个**外观**设计模式和 ISP，似乎 ISP 建议你做的事情与**外观**的工作方式相反。显然，**外观**设计模式违反了 ISP，对吗？这取决于你将在哪个层次上应用**外观**设计模式。这是什么意思？让我们以未来无人机为例:

![](img/e610f25a-16c6-4bd7-829d-964d8beea0dc.png)

图 6.7:控制器界面

如您所见，`ControllerFacade`是`DroneController` API 的一个实现，它将调用委托给其他控制器管理器。这是违反 ISP 的。

但是，如果我们将 faade 设计模式应用到负责控制无人机飞行能力的飞行子系统，那么这并不违反 ISP，如下图所示:

![](img/d96c0112-bd0d-4640-9bdb-f3ca533b5892.png)

图 6.8:飞行控制器子系统的外观

你可以看到，`FlyControllerManager`是一个外观，它实现了`FlyController`接口，这个接口有四个方法来控制无人机，它将调用委托给飞行子系统内部的其他类。这样，客户端`FlyRemoteControlDevice`不需要知道飞行子系统的内部细节。它所要做的就是与一个简单的统一界面`FlyControllerManager`进行交互。在这种设计中，客户端不会被迫依赖它不需要的方法。因此，本设计中使用的外观设计模式并不违反 ISP。

# 依赖性倒置原则

该原则集中在以下两个部分:

*   **高层模块不应该依赖低层模块**。**两者都应该依赖抽象**。
*   抽象不应该依赖于细节。**细节应该依赖于抽象**。

首先，什么是高级模块，什么是低级模块？简而言之，高层模块包含业务规则，低层模块包含实现细节。

根据这个原则的第一部分，高级模块应该只关心高级抽象。这个高层抽象定义了组件是什么，这些组件之间的交互是什么，以及这些组件必须遵循什么业务规则。低级模块也应该依赖于高级抽象。它们不应该依赖于其他低级模块。

根据该原则的第二部分，高级抽象不应该依赖于经常变化的实现细节。实现细节的变化对高层抽象的影响应该最小化，这样抽象才能保持稳定。此外，当细节依赖于高层抽象时，它们是相互解耦的。因此，变更是在内部管理的。

现在，让我们看一个数据导出应用的例子。在这个应用中，`Exporter`类包含高级抽象。它使用`JdbcRepository`类从数据库中查询记录，然后使用`CsvGenerator`类将记录保存到一个`.csv`格式的文件中。之后，它将调用`ZipCompressor`类的`zip()`方法来压缩文件。

在下图所示的设计中，`Exporter`类直接依赖于`JdbcRepository`类、`CsvGenerator`类和`ZipCompressor`类:

![](img/83d2a6d7-149d-472f-8419-fd2159dd02ed.png)

图 6.9:刚性数据导出应用

下面是`Exporter`类的样子:

```java
public class Exporter {
  public Exporter(JdbcRepository repository, 
      CsvGenerator genenerator, ZipCompressor compressor) {
    // ...
  }

  public void export() {
    List<Item> items = repository.find();
    if (items.isEmpty()) {
      // Business rules to handle empty result
      return;
    } 
    String csvFilePath = genenerator.generate(items);
    String compressed = compressor.zip(csvFilePath);
    // Business logics to handle the compressed file
   }
}
```

如您所见，依赖项是通过`Exporter`类的构造函数注入的。`export()`方法包含这个数据导出应用主要逻辑的高级抽象。没有关于如何从数据库中检索记录、如何生成`.csv`文件或者如何压缩文件的实现细节。这些在这里无关紧要！这个`Exporter`类唯一关心的是这个数据导出逻辑的高级抽象。

这种设计的问题是,`Exporter`类直接依赖于具体的类，对这些依赖关系的改变会对`Exporter`类产生影响，使其不稳定。这是对倾角的违反。这不仅导致不封闭的高层抽象发生变化，也使得这个`Exporter`类无法扩展。例如，它不能扩展到支持从 MongoDB 导出数据，也不能扩展到支持以 XML 格式导出数据。所有这些变化都需要修改`export()`方法。

正如 DIP 所建议的，高级模块应该依赖于抽象。让我们重构数据导出应用以使用该设计，如下图所示:

![](img/05586b46-d8d8-4c58-b3ae-8486c7a5a1d1.png)

图 6.10:应用于数据导出应用的依赖性反转

如您所见，`Exporter`类现在依赖于`Repository`接口、`Generator`接口和`Compressor`接口。这些接口由它们对应的具体类实现。要扩展这个应用以支持 MongoDB，只需添加一个新的`Repository`接口实现，例如`MongoRepository`，这样就不必修改`Exporter`类。

实际上，我们可以将`Exporter`类和三个接口放在同一个包中，并为实现细节添加子包，如下面的代码所示:

```java
app.dataexport.Exporter
app.dataexport.Compressor
app.dataexport.Generator
app.dataexport.Repository
app.dataexport.compressor.ZipCompressor
app.dataexport.generator.CsvGenerator
app.dataexport.repository.JdbcRepository
```

还有其他封装设计选项。我们将在实现 TaskAgile 应用时详细讨论包设计的原则。

# 任务敏捷代码设计

对于 TaskAgile 应用，代码设计将分三个层次——架构层、抽象层和实现层。这里只谈架构层面的设计。当我们开始实现时，我们将致力于抽象层次的设计。大多数实现级设计将在实现阶段进行。我们将实践测试驱动的开发，编写验收测试，并不断重构代码，以保持其干净、简单和有表现力。

现在，让我们看看架构级设计。我们将介绍两种设计——分层架构和六边形架构。每种设计都有其优缺点。让我们一个一个地看。

# 分层架构

分层架构模式是一种常用的技术，用于将复杂的系统分解成独立的层，其中每一层都关注自己的问题。通常的分离是使用层，即表示层、业务层和数据访问层。高层依赖于低层，而低层不知道依赖于它的高层的存在。在严格分层的体系结构中，较高层只能依赖于直接的较低层。在松散的分层体系结构中，较高层可以依赖于它下面的任何层。例如，在严格的分层架构中，表示层只能依赖于业务层，而在宽松的分层架构中，它可以依赖于数据访问层。

有时，业务层被称为**应用层**、服务层或领域层。或者，它可以分为应用层和服务层，从而创建一个四层架构。无论这一层的名称是什么，它都包含了应用的业务逻辑:

![](img/eff20c7d-3bb8-42d3-aa6c-ca4f604f9c5a.png)

图 6.11:分层架构

上图显示了这种架构的一个示例。**用户**发送一个获取任务的请求。**表示层**接收该请求，并将其转换为对由**业务层**提供的 API 的内部调用，该 API 执行一系列业务逻辑，并最终向**数据访问层**请求数据。**数据访问层**生成一个 **SQL** 查询，并发送给数据库。一旦数据库返回结果，数据访问层将把基于行的数据转换成对象，这些对象将被一路发送回表示层，在表示层，结果被转换成 JSON 格式的字符串，然后发送回用户。

如您所见，分层架构简单易懂。对于没有复杂业务逻辑的应用来说，这种架构工作得很好。它倾向于将焦点从业务逻辑转移到数据操作，也称为 CRUD。这个架构的底层是数据库。对于只有少量业务规则的应用，其中大多数请求都是关于从数据库中读取数据或将数据保存回数据库，这种架构非常适合。在这些应用中，域模型，比如实体，都是带有一包 getters 和 setters 的 POJOs。它们不包含领域逻辑。经常有设计规则说模型中不应该有领域逻辑。相反，域逻辑应该放入业务层的服务对象中。这些领域模型通常被称为**贫血领域模型**。

这种以数据为中心的设计的症状之一是，随着应用复杂性的增加，很容易看到域逻辑泄漏到其他层。让我们看一个激活免费试用用户的简单示例，如下面的代码所示:

```java
public class UserController {
  @PostMapping("/users/{userId}/activate")
  public void activate(@PathVariable(value="userId") int userId){
    // get the user and calculate free trial end date
    user.setActive(true);
 user.setInFreeTrial(true)
 user.setFreeTrialEndDate(trialEndDate);
 user.setLastModifiedDate(now);
 userService.save(user);
 sendFreeTrialStartedEmail(user);
  }
}
```

如您所见，在`activate()`方法中，我们使用 setters 来修改用户实体，然后要求`userService`保存更改，随后向用户发送一封免费试用的电子邮件。更好的实现是在`UserService` API 中添加一个`activate()`方法，并将设置器和发送电子邮件逻辑移动到该方法中，然后将`UserController`更改为以下内容:

```java
public class UserController {
  @PostMapping("/users/{userId}/activate")
  public void activate(@PathVariable(value="userId") int userId){
    // get the user
    userService.activate(user);
  }
}
```

这种设计仍然存在潜在的严重问题。如您所见，`User`实体有两个独立的字段，`active`和`inFreeTrial`。当用户开始免费试用时，两者都需要设置为`true`。想象一下:有一天，另一个不熟悉这个逻辑的开发人员 Frank 需要创建一个新的 API 来允许移动 app 用户注册，而不需要阅读功能规范；嗯，他可能在一个敏捷团队中，所以很可能不会有全面的规范，而只是用户故事。总之，Frank 不知道当一个新注册的用户被激活时，`inFreeTrial`字段需要被设置为`true`。这样就引入了一个严重的 bug。希望 QA 团队能在发布前发现这个 bug。

的确，在这个例子中，使用分层架构并不是这种问题的原因。但关键是分层架构倾向于让开发人员从数据的角度而不是领域模型的角度来看待系统。

# 六角形建筑

阿利斯泰尔·考克伯恩提出了六边形结构，即端口和适配器。在他的博客中，他写下了这个架构的意图，如下:

允许应用同样由用户、程序、自动化测试或批处理脚本驱动，并独立于其最终运行时设备和数据库进行开发和测试。

下图描绘了六边形架构，摘自 Vaughn Vernon 的书*Implementation Domain-Driven Design*，做了一些修改:

![](img/2c78cf4c-5d7c-4ec8-af89-078ce3ff1935.png)

图 6.12:六边形架构

正如您在前面的图表中看到的，在中间的是**应用**核心。它包含了所有的业务逻辑，并创建了一个边界。核心是**领域模型**，它包含丰富的行为领域模型，而不是贫血的模型。围绕**应用**内核的是**适配器**，它们将到达不同端口的外部事件转换成对**应用**内核的 API 调用，比如图中的 **A** 、 **B** 和 **C** 适配器。其他适配器，如**适配器 E** 与数据库交互，而**适配器 F** 与**弹性搜索**交互。**适配器 G** 将数据保存在内存中。请注意，图中的所有箭头都是单向的，表示哪一方触发了哪些交互。并不意味着交互是单向的。

六边形架构自然适合于**领域驱动设计**(**)。它将域逻辑与基础设施隔离开来，比如数据库、搜索引擎、消息队列、邮件传递和缓存系统。它可以很容易地扩展以支持不同类型的客户端。只需给它添加一个新的适配器。**

 **对于 TaskAgile，我们会用六边形架构，练习 DDD。我们将一路详细讨论这个架构。与此同时，如果你有兴趣了解更多关于六边形建筑的知识，我推荐你阅读阿利斯泰尔·考克伯恩关于六边形建筑的博客和位于 http://wiki.c2.com/?HexagonalArchitecture[的 C2 维基。](http://alistair.cockburn.us/Hexagonal+architecture)

# 摘要

在本章中，你已经学习了什么是敏捷代码设计，代码设计的层次，糟糕设计的症状，代码设计的层次，以及如何实践敏捷代码设计。

您还学习了立体设计原则和立面设计模式。之后，您学习了两种类型的架构设计:分层架构和六边形架构。

在下一章，你将学习如何用 RESTful API 设计前端和后端之间的**语言**。**