# 十一、状态管理和 i18n——构建主页

我们在前两章构建的注册页面和登录页面主要处理表单提交，相对简单。在本章中，我们将构建 TaskAgile 的主页，它包含了更多的功能，您将会看到。我们将介绍 Vuex，Vue 应用中状态管理的官方库。

像往常一样，在这一章中，我们将向您展示主页的外观，然后将实现该页面的任务分解成小步骤，以便您可以看到它是如何一步一步地创建的。我们将跳过之前已经提到的部分的细节。和往常一样，您可以在提交历史中找到那些被跳过的细节。

在本章中，您将了解以下内容:

*   用 Vuex 实现前端状态管理
*   用引导模式组件构建模式窗口
*   管理一对多和多对多关系的不同方法
*   使用 Vue-i18n 添加 i18n 支持
*   记录 Hibernate 发送给数据库用于性能调优的 SQL 查询

# 使用 Vuex 进行状态管理

在介绍 Vuex 之前，我们先来看看不同 web 应用中不同的状态管理方法。

在传统的 web 应用中，当通过超链接导航时创建新的页面，需要很少的状态管理，因为一旦用户导航到另一个页面，状态就会丢失。在这些应用中，页面是在后端动态生成的。应用的大部分状态都保存在服务器端。

另一种类型的 web 应用是一个单页面应用 ( **SPA** )。与传统应用不同，SPA 没有页面刷新，它将一些逻辑从后端移到前端。因此，它需要在客户端保存一些状态。这给前端开发带来了复杂性。有了 Backbone.js 之类的框架，前端就引入了类似 MVC 的模式。(这些图案通常被称为 **MV*** 。)并且，通常，应用的状态保存在全局变量中，或者，如果您使用像 RequireJS 这样的库，您将在 JS 文件中定义一个数据模型并将其导入到其他模块中。导入数据模型的代码可以对它做任何事情，甚至完全替换它。的确，您可以向数据模型添加一些保护，但是您无法控制数据流，在下一节我们讨论传统状态管理的缺点时，您将会看到这一点。

现在，当我们创建一个 SPA 时，比如我们的 TaskAgile 应用，而不使用 Vuex，我们可以创建一个单独的对象并在该对象中存储状态，并在 Vue 组件之间共享它。例如，我们可以如下创建`front-end/src/local-data.js`:

```java
export default {
  name: 'Unknown'
}
```

然后我们可以将其导入到不同的 Vue 组件中，例如`front-end/src/components/ComponentA.vue`，如下所示:

```java
<template>
  <div>{{ name }} in Component A</div>
</template>
<script>
Import localData from '../local-data'
export default {
  data: function () {
    return localData
  }
}
</script>
```

Vue 组件`front-end/src/components/ComponentB.vue`，如下所示:

```java
<template>
  <div>{{ name }} in Component B</div>
</template>
<script>
Import localData from '../local-data'
export default {
  data: function () {
    return localData
  },
  mounted: function () {
    this.name = 'Sunny'
  }
}
</script>
```

如您所见，在两个组件的`<template>`部分中，我们可以直接引用在`local-data.js`中定义的`name`属性。在`ComponentB`中，我们可以改变它的值。此更改将自动更新到`ComponentA`。Vue.js 会处理这些，非常方便。

# 传统国家管理的弊端

我们描述的三种状态管理被认为是前端管理状态的传统方式。尽管 Vue 应用中的最后一种类型提供了对数据模型的反应，但它们也有同样的缺点，即缺乏对数据流的控制。对于小型应用或不需要跨组件共享状态的应用来说，这不是问题。另一方面，对于大规模的应用，缺乏对数据流的控制将会引入数据不一致的问题。

假设您有一个组件，例如，`Messages`显示消息列表，另一个组件`UnreadMessageCounter`显示未读消息总数。一旦一条新消息被阅读，在`Messages`组件中，它的状态将被标记为已读。`UnreadMessageCounter`组件中的未读计数器应相应更新。同时，应用可能通过实时连接接收新消息。新收到的消息将被添加到消息列表中，未读计数器也将被更新。当一切正常时，`Messages`组件中的未读消息数将与`UnreadMessageCounter`组件中的未读消息数相匹配。实际上，这两个数字有时并不匹配，这导致看似不可能发生的错误时不时随机出现，并且很难重现和修复。

这实际上是脸书在 2011 年遇到的聊天问题。那时，脸书页面顶部的未读信息计数器有时会显示有新信息。但是当聊天窗口打开时，没有新的消息显示出来，这是相当烦人的。为了解决这个问题，来自脸书的工程师陈静提出了一个名为 Flux 的应用架构，它本质上是一种实现单向数据流的模式。对于大规模的应用，它解决了由糟糕的状态管理引起的问题。受 Flux 启发的状态管理库有很多，包括，Redux，Vuex，Alt。

如果你有兴趣了解更多关于 Flux 以及它如何解决脸书聊天问题的信息，你可以看看 YouTube 上的这个演讲，*黑客之路:在脸书*(【https://www.youtube.com/watch?v=nYkdrAPrdcw】)反思 Web 应用开发。

# 现代国家管理

现代国家管理始于 Flux，它不是一个库或框架。它更多的是一种不同于传统 MVC 模式的模式。

在使用 MVC 的大规模应用中，您很容易得到如下结果:

![](img/cb3c5ca6-ca88-4f7e-a1d2-55b286601284.png)

图 11.1:未被管理的数据流(来源:https://www.youtube.com/watch?v=nYkdrAPrdcw)

如你所见，在**模型**和**视图**之间流动的数据是难以管理的。很难试图弄清楚数据变更流程。

在 Flux 中，数据沿同一方向流动，如您在*图 11.2* 中所见:

![](img/67bb46bf-d656-47e2-b11a-1bb0a1cada5f.png)

图 11.2:流动中的单向数据流(来源:https://www.youtube.com/watch?v=nYkdrAPrdcw)

当用户与页面上称为视图的组件交互时，**视图**将通过中央**调度器**将动作传播到保存应用数据的**存储库**，存储库中所做的更改将相应地更新到所有关联的视图。

如您所见，在 Flux 中，数据流比在 MVC 中简单得多，也更容易理解。

# nutshell 中的 Vuex

Vuex 是专门为 Vue 应用定制的状态管理解决方案。如前所述，它是由通量激发的。您可以使用 Vuex 作为状态的集中存储，在应用的组件之间共享。它有规则确保状态只能以可预测的方式改变。

正如你在*图 11.1* 中看到的，在 Vuex 中数据流是单向的。通常，它从一个 Vue 组件开始，该组件调度一个可以提交突变的操作，并且只有突变可以对状态进行更改，这些更改存在于存储中。商店是每个 Vuex 应用的中心。与我们之前看到的`localData`不同，Vuex 商店是反应式的。也就是说，通过突变对存储进行的更改将通过 Vue.js 的反应系统同步到 Vue 组件:

![](img/17600f69-81e3-4d17-926e-4418421e3181.png)

图 11.3: Vuex 概述(来源:https://vuex . vuej . org)

除了提交突变，动作还可以与后端 API 通信，或者在提交突变之前进行任意的异步操作。通过突变，Vuex 应用可以与 Vue.js DevTools 集成，以提供高级功能，如时间旅行调试和状态快照导出/导入。

在 Vuex 中，状态是包含所有应用级状态的单个对象。它作为*真理*的单一来源。通常，我们只会为每个 Vue 应用创建一个存储来保存状态。将应用的所有状态放在一个对象中会随着应用的增长而增加存储空间。为了解决这个问题，Vuex 提供了对模块化的支持。它允许我们将我们的商店分成模块，每个模块可以包含自己的状态。我们将在本章的后面看到它是如何工作的。

除了状态、动作、变异和模块，Vuex 还提供了 getters。当我们需要根据存储状态计算派生状态时，这些是有用的。例如，如果我们将所有的消息都放在存储中，我们可以创建一个 getter 来计算未读消息的数量。您可以将 Vuex 的 getters 视为存储的计算属性。我们将在本章的后面看到它是如何工作的。

# 构建主页前端

与登录和注册页面大多是关于表单和验证不同，主页的前端更多的是关于如何渲染项目，如何管理 app 状态，如何支持**国际化** ( **i18n** )。

# 主页的用户界面

首先，我们来看看首页的 UI，看看这一章我们在构建什么。*图 11.4* 显示了一个空白的主页。这是用户登录后应用的外观:

![](img/39283ef1-19c4-4046-a877-3326a749fa3e.png)

图 11.4:空白主页

此页面的顶部是页面标题，包括徽标、论坛菜单、搜索框和个人资料菜单。在 boards 菜单上，将列出用户有权访问的所有电路板。用户可以使用此菜单轻松地在电路板间导航。标题中央的搜索框用于搜索全球的电路板和卡。此页面的主要区域用于显示用户有权访问的讨论板列表，讨论板将按团队分组。那些不属于任何团队的个人板将在顶部列出。对于一个新用户来说，这个主页一开始是空的。用户可以点击【新建板卡】创建个人板卡，或者点击【新建团队】创建团队，然后在该团队下创建板卡，如图*图 11.5* 所示:

![](img/157a4f6f-09c7-450a-981e-b6c2c5c83dde.png)

图 11.5:团队板

# 主页布局和组件

现在，我们来思考一下如何实现这个主页的 UI。最好从布局图开始，就像我们创建注册页面时一样。*图 11.6* 显示了主页的布局:

![](img/341a4b37-02d7-4189-9b94-f619ff61aafb.png)

图 11.6:主页的布局

如您所见，我们在`.board`元素之间使用省略号来表示可能有零个或多个`.board`元素，类似于`.boards-section`元素之间的垂直省略号。

对于`.page-header`元素，我们需要将它放在一个名为`PageHeader.vue`的 Vue 组件中，这样我们就可以与其他页面共享它。对于`.boards-section`元素，我们可以创建一个 Vue 组件，例如`BoardsSection.vue`，并使用一个列表来重复它。但是，这不是我们要做的，因为除了主页之外，这个元素在其他任何地方都不会用到。将它保存在一个单独的组件中并没有真正的好处。

*图 11.7* 显示了 boards 菜单和 profile 菜单的外观:

![](img/fadb6049-ae6f-4c05-a4fb-1b08fd2b8249.png)

图 11.7:电路板菜单和配置文件菜单

对于这些弹出窗口和菜单，我们不会创建布局图，因为这些元素的布局相对容易理解。

# 数据结构和状态管理

在编写前端代码之前，让我们考虑一下主页上需要的数据结构，以及我们需要将哪些数据放入 Vuex。

在浏览了主页的 UI 之后，我们可以看到我们需要以下三段数据来初始化主页:

*   登录用户的姓名
*   用户加入的团队
*   用户有权访问的板

有两种方法可以获得用户名。第一个是将它添加到登录响应中，这样一旦用户登录，我们就可以获取名称并将其保存在 Vuex 存储中。这种方法有一个问题。由于 Vuex 存储将在页面刷新后初始化，因此刷新后用户名将会丢失。的确，我们可以将该名称放入浏览器的本地存储中，以便可以在页面刷新之间恢复它。然而，这将引入不必要的负担，因为我们将不得不管理本地存储。我们还需要在注销后清除用户名，并将本地存储插入 Vuex 存储。这使得代码比它需要的更复杂。

第二种方法更简单也更有效，那就是在页面初始化期间，在一个将被发送到服务器的请求中获得所有这三段数据。那么，我们应该从哪里触发这个请求呢？从`HomePage.vue`、`PageHeader.vue`还是别的地方？

在回答这个问题之前，我们先来考虑一下数据结构。`HomePage.vue`和`PageHeader.vue`要求的数据结构是什么？

对于用户名，这很简单。在`PageHeader.vue`中，我们需要这样的东西:

```java
{
  "user": {
    "name": "Sunny Hu"
  }
}
```

对于团队和董事会数据，我们可以将个人董事会和团队董事会放在一起，然后使用一个计算属性让个人董事会填充顶部的第一个`.boards-section`元素，因为个人董事会将始终放在顶部。我们将需要另一个计算属性来让团队和相关的板填充一个`.boards-section`元素的列表。如果我们这样做，我们将会在`HomePage.vue`和`PageHeader.vue`中有重复的代码来提取不同类型的电路板。

在`HomePage.vue`和`PageHeader.vue`中使用类似下面的数据结构会更加容易和直接:

```java
{
  "personalBoards": [{
    "id": 1,
    "name": "vuejs.spring-boot.mysql",
    "description": "An implementation of TaskAgile application with 
    Vue.js, Spring Boot, and MySQL"
  }],
  "teams": [{
    "id": 1,
    "name": "Sales & Marketing",
    "boards": [{
      "id": 2,
      "name": "2018 Planning",
      "description": "2018 sales and marketing plan"
    }, {
      "id": 3,
      "name": "Ongoing Campaigns",
      "description": "2018 ongoing marketing campaigns"
    }]
  }]
}
```

我们放入 Vuex 商店的数据结构如何？对于用户名，它将与前面提到的结构相同。对于团队和董事会，我们最好将团队和董事会数据保存在两个独立的数组中，如下所示:

```java
{
  "boards": [{
    "id": 1,
    "name": "vuejs.spring-boot.mysql",
    "description": "An implementation of TaskAgile application with 
    Vue.js, Spring Boot, and MySQL",
    "teamId": 0
  }, {
    "id": 2,
    "name": "2018 Planning",
    "description": "2018 sales and marketing plan",
    "teamId": 1
  }, {
    "id": 3,
    "name": "Ongoing Campaigns",
    "description": "2018 ongoing marketing campaigns",
    "teamId": 1
  }],
  "teams": [{
    "id": 1,
    "name": "Sales & Marketing"
  }]
}
```

如您所见，`"boards"`和`"teams"`之间的链接是`teamId`属性。这种结构非常类似于团队和董事会在服务器端的数据库中的保存方式。我们需要将这个数据结构转换成`HomePage.vue`和`PageHeader.vue`需要的数据结构。在 Vuex 中，我们为这种转换提供了一个完美的场所——吸气剂。Vuex 允许我们在存储中定义 getters，类似于 Vue 实例中的计算属性。getter 的结果基于其依赖关系被缓存。一旦依赖关系改变，Vuex 将重新评估 getter 并自动更新依赖它的其他 getter。我们将在本章的后面看到它是如何工作的。

# 后端 API

现在，我们知道我们需要什么样的数据，以及它看起来如何。让我们考虑一下主页前端完成以下操作所需的后端 API:

*   创建个人董事会
*   创建一个团队
*   创建团队公告板
*   获取用户的姓名、董事会和团队

我们将详细讨论每一个。

# 创建个人董事会 API

这将是一个发送到`/api/boards`的`POST`请求，其有效载荷如下:

```java
{
  "name": "<Board name>",
  "description": "<Board description>"
  "teamId": 0
}
```

我们将使用`teamId`参数的`0`值来表示这是个人板。对该请求的成功响应将具有状态代码`201`，并且主体如下所示:

```java
{
  "id": 12345,
  "name": "<Board name>",
  "description": "<Board description>"
  "teamId": 0
}
```

一旦创建了一个公告板，前端会将用户重定向到公告板页面，我们将在下一章创建。

# 创建团队 API

这也将是一个`POST`请求，它被发送到`/api/teams`,其有效载荷如下所示:

```java
{
  "name": "Sales & Marketing"
}
```

成功的响应还将具有状态代码`201`，并且主体如下:

```java
{
  "id": 123
  "name": "Sales & Marketing"
}
```

一旦创建了一个团队，它将显示在主页上，下面没有讨论板。

# 创建小组委员会 API

这个 API 类似于创建个人板的 API。唯一的例外是`teamId`参数的值将是一个团队的有效 id。

# 一个组合的 API 来获取用户的名字、董事会和团队

如前所述，我们将使用一个请求来获取用户的姓名、董事会以及用户可以访问的团队。合并请求有几个好处:

*   最重要的是，它减少了获取初始化主页所需的所有数据的请求数量。
*   第二，它节省了组合两个不同响应的结果的努力。否则，您将需要使用一种机制，比如 Bluebird 的`Promise.all`,在呈现页面之前等待两个请求都完成。
*   因此，它改善了用户体验，因为在我们的例子中，更少的请求意味着更快的页面呈现。

`GET`请求将被发送到`/api/me`，响应体如下:

```java
{
  "user": {
    "name": "Sunny Hu"
  },
  "boards": [{
    "id": 1,
    "name": "vuejs.spring-boot.mysql",
    "description": "An implementation of TaskAgile application with 
     Vue.js, Spring Boot, and MySQL",
    "teamId": 0
  },
  ...],
  "teams": [{
    "id": 1,
    "name": "Sales & Marketing"
  }]
}
```

如您所见，响应的数据结构与我们放入 Vuex 存储的数据结构相同。

# 实现主页前端

现在，让我们做一个任务分解，看看我们需要做些什么来实现主页:

*   创建一个与后端 API 交互的服务
*   在 Vuex 商店中保存用户的姓名、董事会和团队
*   添加`PageHeader.vue`
*   添加`HomePage.vue`
*   添加创建纸板弹出窗口
*   添加创建团队弹出窗口
*   创建空白留言板页面，以便在留言板创建后将用户重定向到该页面

在这一节中，我们将开始编写前端代码，我们将跳过构建注册页面和登录页面时已经讨论过的部分。我们将关注以下主题:

*   如何使用 Vuex
*   如何用 Bootstrap 模型实现弹出窗口

在我们继续之前，让我们创建主页的 UI。以下是提交记录:

![](img/568380d9-f87a-4e63-8ef7-3028848df523.png)

图 11.8:添加主页 UI 提交

# 实现服务和 Vuex 商店

在我们实现 Vuex 商店之前，让我们创建这些服务。我们需要在`front-end/src/services/teams.js`文件中创建`teamService`，如下所示:

```java
...
export default {
  /**
   * Create a team
   * @param {*} detail the detail of the team
   */
  create (detail) {
    return new Promise((resolve, reject) => {
      axios.post('/teams', detail).then(({data}) => {
        resolve(data)
      }).catch((error) => {
        reject(errorParser.parse(error))
      })
    })
  }
}
```

正如您所看到的，这个服务只有一个方法，`create()`，它在一个`POST`请求中将团队的详细信息发送给`/api/teams`。

我们还需要创建`boardService`，它与`teamService`非常相似，如您所见:

```java
...
export default {
  /**
   * Create a new board
   * @param {*} detail the board detail
   */
  create (detail) {
    return new Promise((resolve, reject) => {
 axios.post('/boards', detail).then(({data}) => {
        resolve(data)
      }).catch((error) => {
        reject(errorParser.parse(error))
      })
    })
  }
}
```

唯一的区别是请求被发送到`/api/boards`。至于参数细节，这取决于 Vue 实例，在我们的例子中是`HomePage.vue`，来决定包含哪些数据，因为服务不需要关心它。

我们在这个阶段需要创建的最后一个服务是`meService`，它看起来是这样的:

```java
...
export default {
  /**
   * Fetch current user's name, boards, and teams
   */
  getMyData () {
    return new Promise((resolve, reject) => {
 axios.get('/me').then(({data}) => {
        resolve(data)
      }).catch((error) => {
        reject(errorParser.parse(error))
      })
    })
  }
}
```

如您所见，它所做的只是向`/api/me`发送一个`GET`请求。

现在，让我们实现 Vuex 存储。默认生成的`front-end/src/store.js`将 Vuex 的`actions`、`mutations`、`getters`和`state`放在一个文件中。通过将`actions`、`mutations`和`getters`分离到单独的文件中或者通过模块分离来重新组织它会更实际。对于大型应用，最好按模块拆分 Vuex。在每个模块内部，我们可以将`actions`、`mutations`和`getters`放在单独的文件中。对于我们的应用，我们将采用第一种方法。让我们删除`front-end/src/store.js`文件，并创建具有以下结构的`front-end/src/store`文件夹:

```java
.
└── store
    ├── actions.js
    ├── getters.js
    ├── index.js
    └── mutations.js
```

下面是`store/index.js`的样子:

```java
import Vue from 'vue'
import Vuex from 'vuex'
import * as getters from './getters'
import * as actions from './actions'
import mutations from './mutations'
import createLogger from 'vuex/dist/logger'

Vue.use(Vuex)

const state = {
  user: {
    name: null
  },
  teams: [/* {id, name} */],
  boards: [/* {id, name, description, teamId} */]
}

export default new Vuex.Store({
  state,
  getters,
  actions,
  mutations,
  plugins: process.env.NODE_ENV !== 'production'
    ? [createLogger()]
    : []
})
```

如你所见，我们定义了`state`的数据结构，然后用`state`、`getters`、`actions`和`mutations`创建了一个`Vuex.Store`的实例。

我们放在团队和公告板中的注释是为了提醒这两个数组中的项目将有哪些字段。

按照设计，只有`mutations`可以改变保存在 Vuex 存储中的状态。这是我们的`store/mutations.js`的样子:

```java
export default {
  updateMyData (state, data) {
    state.user.name = data.user.name
    state.teams = data.teams
    state.boards = data.boards
  },
  addTeam (state, team) {
    state.teams.push(team)
  },
  addBoard (state, board) {
    state.boards.push(board)
  }
}
```

如您所见，我们定义了三个`mutation`方法，`updateMyData()`、`addTeam()`和`addBoard()`。`updateMyData()`方法用于更新用户的名字，以及用户可以使用`/api/me`请求的结果访问的所有团队和董事会。`addTeam()`方法和`addBoard()`方法分别用于添加新创建的团队和新创建的板卡。这些方法中的第一个参数`state`由 Vuex 提供。第二个参数是变异的有效负载，它是从动作中传递过来的。

如前所述，只有动作才能`commit`突变。来看看我们的`store/actions.js`长什么样:

```java
import meService from '@/services/me'

export const getMyData = ({ commit }) => {
  meService.getMyData().then(data => {
    commit('updateMyData', data)
  })
}

export const addTeam = ({commit}, team) => {
  commit('addTeam', team)
}

export const addBoard = ({commit}, board) => {
  commit('addBoard', board)
}
```

如你所见，我们定义了三个动作，`getMyData`、`addTeam`和`addBoard`。我们在`getMyData`动作内部调用`meService.getMyData()`，这是一个异步调用。然后，我们用调用的结果提交`updateMyData`变异。这样，我们将服务器的响应保存到存储中。在`addTeam`和`addBoard`动作中，我们简单地用传递给动作的数据进行`commit`变异。传递给动作方法的第一个参数是 Vuex 提供的上下文。它有一个`commit`方法。我们在这里使用参数析构来简化方法的参数。

您可能还记得，`actions`是从 Vue 组件分派的。现在，让我们看看如何从`PageHeader.vue`获取当前用户的数据，如下面的代码片段所示:

```java
<script>
export default {
  name: 'PageHeader',
  created () {
 this.$store.dispatch('getMyData')
  }
}
</script>
```

我们在 Vue 实例的`created()`生命周期钩子内使用`this.$store.dispatch('getMyData')`，稍后我们将看到如何调度`addTeam`和`addBoard`动作。

现在，我们来看看`store/getters.js`，它看起来是这样的:

```java
export const user = state => state.user

export const hasBoards = state => {
  return state.boards.length > 0
}

export const personalBoards = state => {
  return state.boards.filter(board => board.teamId === 0) 
}

export const teamBoards = state => {
  const teams = []

  state.teams.forEach(team => {
    teams.push({
      id: team.id,
      name: team.name,
      boards: state.boards.filter(board => board.teamId === team.id)
    })
  })

  return teams 
}
```

如你所见，我们定义了四个`getters` — `user`、`hasBoards`、`personalBoards`和`teamBoards`。前三个`getters`很简单。在最后一个数组`teamBoards`中，我们没有直接从状态中发送团队，而是创建了一个新的数组并过滤`state.boards`来获取属于相关团队的那些。

现在，让我们看看如何使用`getters`。要访问`getters`，我们可以使用 Vuex 提供的助手方法`mapGetters`，将这些`getters`作为计算属性添加到 Vue 组件中。以下是我们对`PageHeader.vue`的改动:

```java
<script>
...
import { mapGetters } from 'vuex'

export default {
  name: 'PageHeader',
  computed: {
    ...mapGetters([
      'user',
      'hasBoards',
      'personalBoards',
      'teamBoards'
    ])
  },
  created () {
    this.$store.dispatch('getMyData')
  },
  ...
}
</script>
```

如您所见，我们使用`...mapGetters([])`将所需的`getters`映射到计算的属性中。这样，在视图中，我们可以直接访问这些`getters`。比如用`{{ user.name }}`获取用户名。

我们不会深入讨论如何在主页上呈现 boards 菜单、团队和板的其余细节。您可以查看提交历史以了解详细信息。因为后端的 API 还没有准备好，我们不能测试 Vuex 商店的实现，除非我们使用模拟数据。因此，在这个提交中，您将看到`store/getters.js`实际上正在返回模拟数据:

![](img/2f89170d-bff2-4841-8a0b-65eb68610e9b.png)

图 11.9:实现 Vuex 存储提交

# 用 Bootstrap 模式实现弹出窗口

现在，让我们实现创建板和创建团队弹出窗口。由于这两个弹出窗口是相似的，我们将只讨论实现创建纸板弹出窗口的细节。我们将在`front-end/src/modals/CreateBoardModal.vue`中创建它，所有的弹出窗口也将放在这个`modals`文件夹中。

在实现该组件之前，我们需要首先找到以下问题的答案:

*   `HomePage.vue`和`CreateBoardModal.vue`的职责是什么？
*   `HomePage.vue`如何与`CreateBoardModal.vue`沟通？

对于第一个问题，由于创建板窗口显示在主页上，打开该窗口自然是`HomePage.vue`的责任。因此，我们需要将`CreateBoardModal.vue`导入到`HomePage.vue`中，引导它，并在点击 Create New Board 按钮后打开它。`HomePage.vue`创建公告板后，应将用户重定向至公告板页面。`CreateBoardModal.vue`负责调用`boardService.create()`方法保存板卡，然后当请求成功时向 Vuex store 发送一个`addBoard`动作，或者当请求失败时在窗口显示一条错误消息。

对于第二个问题，在`HomePage.Vue`内部，`teamId`的值将通过其属性传递给`CreateBoardModal.vue`。而`HomePage.vue`会监听`CreateBoardModal.vue`发出的`created`事件。

以下是我们对`HomePage.vue`所做的更改:

```java
<template>
  <div>
    ...
    <CreateBoardModal
 :teamId="selectedTeamId"
 @created="onBoardCreated" />
  </div>
</template>

<script>
...
import CreateBoardModal from '@/modals/CreateBoardModal.vue'

export default {
  name: 'HomePage',
  ...
  components: {
    ...
    CreateBoardModal
  },
  methods: {
    ...
    createBoard (team) {
      this.selectedTeamId = team ? team.id : 0
 $('#createBoardModal').modal('show')
    },
    ...
    onBoardCreated (boardId) {
      this.$router.push({name: 'board', params: {boardId: boardId}})
    }
  }
}
</script>
```

如您所见，我们导入`CreateBoardModal.vue`，将其添加到`components`列表中，然后在视图中引导它。`createBoard()`方法就是简单地打开窗户。在`onBaordCreated()`方法中，我们将用户重定向到公告板页面。

下面是`CreateBoardModal.vue`的样子。为简单起见，`<template>`和`<style>`未列出:

```java
<script>
...
export default {
  name: 'CreateBoardModal',
 props: ['teamId'],
  ...
  mounted () {
    $('#createBoardModal').on('shown.bs.modal', () => {
      $('#boardNameInput').trigger('focus')
    })
  },
  methods: {
    saveBoard () {
      this.$v.$touch()
      if (this.$v.$invalid) { return }

      const board = {
        teamId: this.teamId,
        name: this.board.name,
        description: this.board.description
      }

      boardService.create(board).then((createdBoard) => {
        this.$store.dispatch('addBoard', createdBoard)
        this.$emit('created', createdBoard.id)
        this.close()
      }).catch(error => { this.errorMessage = error.message })
    },
    close () { ... },
  }
}
</script>
```

如您所见，我们为这个组件定义了一个`teamId`属性。一旦窗口在`mouted()`生命周期挂钩内打开，我们就使`boardNameInput`字段成为焦点。在`saveBoard()`方法中，我们使用 Vuelidate 执行数据验证。当所有字段都有效时，我们调用`boardService`来保存板子。一旦保存了电路板，我们就分派动作将它放入 Vuex 存储中，然后通过发出 created 事件告诉`HomePage.vue`新电路板的 ID。然后，我们关闭模态窗口。在`close()`方法内部，我们将需要清理，比如通过将数据模型重置为初始值。当事情出错时，我们将以与在`LoginPage.vue`中相同的方式显示错误消息。

由于`CreateTeamModal.vue`和`CreateBoardModal.vue`差不多，这里就不一一列举了。以下是创建这两个窗口的提交历史:

![](img/5450fa9e-8714-4237-ae0a-fc44ba0f5122.png)

图 11.10:实现创建团队和创建董事会窗口提交

# 构建主页后端

现在，前端准备好了。让我们实现后端，它包括以下子任务:

*   在`com.taskagile.web.apis`包中创建 API 处理程序
*   在`com.taskagile.domain.application`包中创建应用服务
*   在`com.taskagile.domain.model`包中创建模型
*   在`com.taskagile.infrastructure.repository`包中创建一个存储库实现

# 领域模型

使用 ORM，有一种趋势是使用`@OneToMany`和`@ManyToMany`注释来建立实体之间的关系，你可以很容易地从一个实体转到另一个实体。它确实提供了一些便利，并减少了代码量。

在这里，我们将采用不同的方法；我们不会使用这些注释来建立关系。我们将使用一个包装器 ID 来建立关系。

下面是`com.taskagile.domain.model.team.Team`模型的样子。这里没有列出一些字段和方法:

```java
@Entity
@Table(name = "team")
public class Team extends AbstractBaseEntity {
  ...
  @Column(name = "userId")
 private long userId;
  ...
  /**
   * Create new team
   */
  public static Team create(String name, UserId creatorId) {
    Team team = new Team();
    team.name = name;
    team.archived = false;
    team.userId = creatorId.value();
    team.createdDate = new Date();
    return team;
  }

  public TeamId getId() { return new TeamId(id); }

  public UserId getUserId() { return new UserId(userId); }
  ...
}
```

如您所见，我们使用一个简单的`userId`来连接创建这个团队的用户。在`create()`工厂方法中，我们需要传入一个`UserId`的实例，它只是一个长值的包装器。

下面是`com.taskagile.domain.model.board.Board`模型的样子。有些字段和方法没有列出:

```java
@Entity
@Table(name = "board")
public class Board extends AbstractBaseEntity {
  ...
  @Column(name = "user_id")
  private long userId;

  @Column(name = "team_id")
 private Long teamId;
  ...
  /**
   * Create new board
   */
  public static Board create(UserId userId, String name, String 
  description, TeamId teamId) {
    Board board = new Board();
    board.userId = userId.value();
    board.name = name;
    board.description = description;
    board.teamId = teamId.isValid() ? teamId.value() : null;
    board.archived = false;
    board.createdDate = new Date();
    return board;
  }

  public BoardId getId() { return new BoardId(id); }

  public UserId getUserId() { return new UserId(userId); }

  public TeamId getTeamId() {
    return teamId == null ? new TeamId(0) : new TeamId(teamId);
  }
  ...
}
```

因为个人董事会不属于任何团队，所以我们需要将`teamId`字段定义为一个`Long`值。此外，在`create()`工厂方法中，我们传递创建该板的用户和该板所属团队的包装 id。创建个人板时，`teamId`参数为空。这里我们可以做的一个改进是，通过使用`createPersonalBoard()`和`createTeamBoard()`等方法，将个人董事会和团队董事会的创建分开。

`com.taskagile.domain.model.board.BoardMember`模型如下所示:

```java
@Entity
@Table(name = "board_member")
public class BoardMember extends AbstractBaseEntity {

 @EmbeddedId
 private BoardMemberId id;

  public static BoardMember create(BoardId boardId, UserId userId) {
    BoardMember boardMember = new BoardMember();
    boardMember.id = new BoardMemberId(boardId, userId);
    return boardMember;
  }
  ...

 @Embeddable
  public static class BoardMemberId implements Serializable {

    @Column(name = "board_id")
    private long boardId;

    @Column(name = "user_id")
    private long userId;
    ...
  }
}
```

如您所见，我们创建了带有`@Embeddable`注释的`BoardMemberId`，这样我们就可以使用 board ID 和 user ID 作为`BoardMember`实体的复合 ID。

# API 处理程序

我们将把 API 处理程序放在不同资源的独立控制器中。我们需要创建的控制器如下:

*   `com.taskagile.web.apis.MeController`处理`/api/me`请求
*   `com.taskagile.web.apis.BoardController`处理`/api/boards`请求
*   `com.taskagile.web.apis.TeamController`处理`/api/teams`请求

与`RegistrationApiController`的一个区别是，我们将需要从 Spring Security 的`SecurityContext`中获取登录用户的信息，或者，姑且称之为*当前用户*。有几种方法可以检索当前用户的信息:

*   我们可以从`HttpServletRequest.getUsePrincipal()`得到。这将需要 Spring 将`HttpServletRequest`注入 API 处理程序方法。
*   我们也可以直接从`SecurityContextHolder`得到，像这样— `SecurityContextHolder.getContext().getAuthentication()`。
*   我们可以创建一个应用 Spring Security 的`@AuthenticationPrincipal`的注释，然后我们可以要求 Spring 将我们的`UserDetails`实现注入到 API handler 方法中。

我们将采用最后一种方法，因为它使代码易于理解和测试。我们创建的注释叫做`@CurrentUser`，看起来像这样:

```java
@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@AuthenticationPrincipal
public @interface CurrentUser {
}
```

如您所见，这是一个非常简单的注释。这里的关键是对它应用`@AuthenticationPrincipal`注释。

有了这个注释，我们可以很容易地获得当前用户在`BoardController`、`TeamController`和`MeController`中的信息。`BoardController`外观如下:

```java
@Controller
public class BoardApiController {
  ...
  @PostMapping("/api/boards")
  public ResponseEntity<ApiResult> createBoard(
    @RequestBody CreateBoardPayload payload,
    @CurrentUser SimpleUser currentUser) {

    Board board = 
    boardService.createBoard(payload.
    toCommand(currentUser.getUserId()));
    return CreateBoardResult.build(board);
  }
}
```

如您所见，在`createBoard()` API 处理程序方法中，我们将`@CurrentUser`注释应用于`currentUser`参数，Spring 将传递一个`SimpleUser`实例给我们的方法。对于这个方法，我们使用它来检索当前用户的 ID，并从`CreateBoardPayload`的实例中创建`CreateBoardCommand`，这是一个用于捕获请求体中参数的类。一旦服务创建了电路板，我们就使用`CreateBoardResult`类创建`ResponseEntity`来将新的电路板信息发送回前端。

`TeamController`和`BoardController`类似，这里不列出它的代码。`MeController`长相如下:

```java
@Controller
public class MeApiController {
  ...
  @GetMapping("/api/me")
  public ResponseEntity<ApiResult> getMyData(
  @CurrentUser SimpleUser currentUser) {

    List<Team> teams = 
    teamService.findTeamsByUserId(currentUser.getUserId());
    List<Board> boards = 
    boardService.findBoardsByMembership(currentUser.getUserId());
    return MyDataResult.build(currentUser, teams, boards);
  }
}
```

如你所见，我们调用`teamService.findTeamsByUserId()`方法和`boardService.findBoardsByMembership()`方法来获取当前用户可以访问的所有团队和董事会，然后使用`MyDataResult`来创建`ResponseEntity`。

# 应用服务程序

在我们的应用核心中，我们需要创建两个应用服务，`TeamService`和`BoardService`，以提供`Controller`所需的能力。如前所述，应用服务需要尽可能保持精简；他们应该尽量不涉及任何业务逻辑，因为业务逻辑应该保存在域模型和域服务中。

下面是`com.taskagile.domain.application.TeamService`的实现:

```java
@Service
@Transactional
public class TeamServiceImpl implements TeamService {
  ...
  @Override
  public List<Team> findTeamsByUserId(UserId userId) {
    return teamRepository.findTeamsByUserId(userId);
  }

  @Override
  public Team createTeam(CreateTeamCommand command) {
    Team team = Team.create(command.getName(), command.getUserId());
    teamRepository.save(team);
    domainEventPublisher.publish(new TeamCreatedEvent(this, team));
    return team;
  }
}
```

如您所见，`findTeamsByUserId()`方法非常简单，`createTeam()`方法接受一个参数，`CreateTeamCommand`。它保存了`Team.create()`工厂方法创建新团队所需的所有必要信息，我们只在应用服务中使用这个命令。我们不在我们的领域模型或领域服务中使用它，因为`CreateTeamCommand`是应用服务的 API 契约的一部分，并且它可能在将来被改变。我们当然不希望`CreateTeamCommand`的变化影响我们的领域。应用服务应该依赖于域，而不是相反。

下面是`com.taskagile.domain.application.BoardService`的实现:

```java
@Service
@Transactional
public class BoardServiceImpl implements BoardService {
  ...
  @Override
  public List<Board> findBoardsByMembership(UserId userId) {
    return boardRepository.findBoardsByMembership(userId);
  }

  @Override
  public Board createBoard(CreateBoardCommand command) {
   Board board = boardManagement.createBoard(
       command.getUserId(), command.getName(), 
       command.getDescription(), command.getTeamId()); 
    domainEventPublisher.publish(new BoardCreatedEvent(this, board));
    return board;
  }
}
```

如你所见，在`BoardServiceImpl`的`createBoard()`方法中，我们调用了`BoardManagement`的`createBoard()`方法，封装了创建板的业务逻辑。这是应用服务不需要知道的。

下面是`com.taskagile.domain.model.board.BoardManagement`的样子:

```java
@Component
public class BoardManagement {
  ...
  public Board createBoard(UserId creatorId, String name, String 
  description, TeamId teamId) {
    Board board = Board.create(creatorId, name,
      description, teamId);
    boardRepository.save(board);
    // Add the creator to as a board member
    BoardMember boardMember = BoardMember.create(board.getId(), 
    creatorId);
    boardMemberRepository.save(boardMember);
    return board;
  }
}
```

正如你所看到的，在它的`createBoard()`方法中，我们使用`Board.create()`工厂方法来创建电路板，然后将其保存到存储库中。之后，我们创建一个`BoardMember`的实例，并保存到它的存储库中。正如您之前看到的，`BoardMember`模型非常简单。它只有`boardId`和`userId`属性。在 TaskAgile 的未来版本中，我们可以添加一些属性，例如一个用于记录用户加入董事会的日期和时间的`joinedDate`字段，一个用于指示成员在董事会中可以做什么的`permissions`字段，以及一个用于区分客户和合作伙伴的`memberType`字段。鉴于 TaskAgile 第一版的范围有限，我们将只保留`boardId`和`userId`在其中。

# 存储库和通用的 save()方法

主页后端实现的最后一部分是为每个实体实现存储库。我们需要创建以下存储库:

*   `com.taskagile.domain.model.board.BoardRepository`
*   `com.taskagile.domain.model.board.BoardMemberRepository`
*   `com.taskagile.domain.model.team.TeamRepository`

这些存储库以及`UserRepository`都有一个`save()`方法来持久化实体。不同存储库的`save()`方法之间的唯一区别是要保存的实体。我们最好在`HibernateSupport`中创建一个通用的`save()`方法来消除代码重复。

以下是对`HibernateSupport`的修改:

```java
abstract class HibernateSupport<T> {
  ...
  public void save(T object) {
    entityManager.persist(object);
    entityManager.flush();
  }
}
```

如您所见，我们向类中添加了一个泛型类型`<T>`，并在`save()`方法中使用它。

下面是`TeamRepository`的 Hibernate 实现:

```java
@Repository
public class HibernateTeamRepository extends HibernateSupport<Team> implements TeamRepository {
  ...
  @Override
  public List<Team> findTeamsByUserId(UserId userId) {
    String sql =
      " SELECT t.* FROM team t WHERE t.user_id = :userId " +
      " UNION " +
      " ( " +
      " SELECT t.* FROM team t, board b, board_member bm " +
      " WHERE t.id = b.team_id AND bm.board_id = b.id AND bm.user_id = 
      :userId " +
      " ) ";
    NativeQuery<Team> query = getSession().createNativeQuery(sql, 
    Team.class);
    query.setParameter("userId", userId.value());
    return query.list();
  }
}
```

如您所见，它只需要实现`findTeamsByUserId()`方法并从`HibernateSupport`继承`save()`方法。在这个`findTeamsByUserId()`方法中，我们使用一个`UNION`操作来检索用户创建的团队，以及当前用户因为加入董事会而可以访问的团队。我们使用 Hibernate 的`NativeQuery`来执行查询。

下面是`BoardRepository`的 Hibernate 实现:

```java
@Repository
public class HibernateBoardRepository extends HibernateSupport<Board> implements BoardRepository {
  ...
  @Override
  public List<Board> findBoardsByMembership(UserId userId) {
 String sql = "SELECT b.* FROM board b LEFT JOIN board_member bm ON 
    b.id = bm.board_id WHERE bm.user_id = :userId";
    NativeQuery<Board> query = getSession().createNativeQuery(sql, 
    Board.class);
    query.setParameter("userId", userId.value());
    return query.list();
  }
}
```

如您所见，在`findBoardsByMembership()`方法中，我们需要在`board`表和`board_member`表之间执行一个`LEFT JOIN`操作，因为我们没有使用`@ManyToMany`注释来构建`Board`实体和`User`实体之间的关系。相反，我们创建了`BoardMember`实体来保存董事会成员信息。如前所述，通过`BoardMember`实体，我们可以在未来版本中扩展这个董事会成员。

我们在这里跳过`BoardMemberRepository`,因为它从`HibernateSupport`继承了`save()`方法，并且没有任何其他方法。

以下是后端的提交记录:

![](img/2d4c01b0-cb74-4b51-9252-8faefd273e4f.png)

图 11.11:实现主页后端提交

# 使用 Vue-i18n 添加 i18n 支持

现在，让我们看看如何使用 Vue-i18n([https://kazupon.github.io/vue-i18n](https://kazupon.github.io/vue-i18n))在 Vue 应用中添加对 i18n 的支持。

首先，我们将创建一个`front-end/src/locale`目录来存放我们的本地化消息。该文件夹如下所示:

```java
.
└── locale
    ├── index.js
    └── messages
        ├── en_US.json
        └── zh_CN.json
```

下面是`front-end/src/locale/index.js`的样子:

```java
import enUSMessages from './messages/en_US.json'
import zhCNMessages from './messages/zh_CN.json'

export const enUS = enUSMessages
export const zhCN = zhCNMessages
```

`en_US.json`和`zh_CN.json`只是包含本地化消息的 JSON 文件。例如，以下是`en_US.json`的片段:

```java
{
  "logo": {
    "tagLine": "Open source task management tool"
  },
  ...
  "error": {
    "request": {
      ... 
      "notAuthorized": "Request not authorized.",
      ...
    }
  }
}
```

请注意，对于本地化的消息，我们不必使用 JSON。我们可以只使用一个 JavaScript 文件。例如，我们可以将`en_US.json`改为`en_US.js`，内容如下:

```java
export default {
  "logo": { ... },
  ...
  "error": { ... }
}
```

现在我们已经准备好了本地化的消息，让我们在`front-end/src/i18n.js`中创建一个`VueI18n`的实例，如下所示:

```java
import Vue from 'vue'
import VueI18n from 'vue-i18n'
import { enUS, zhCN } from './locale'

Vue.use(VueI18n)

// Create VueI18n instance with options
export const i18n = new VueI18n({
  locale: 'en_US',
  messages: {
    'en_US': enUS,
    'zh_CN': zhCN
  }
})
```

如您所见，我们从`./locale`文件夹中导入`enUS`和`zhCN`消息，然后将它们映射到`en_US`地区和`zh_CN`地区。在`VueI18n`实例中，我们通过设置`VueI18n`选项的`locale`属性，将默认区域设置为`en_US`。

现在，让我们对引导程序`VueI18n`的`front-end/src/main.js`进行以下更改:

```java
...
import { i18n } from './i18n'
...
new Vue({
  router,
  store,
  i18n,
  render: h => h(App)
}).$mount('#app')
```

如您所见，我们导入了`VueI18n`实例`i18n`，并将其添加到根 Vue 实例中。

为了在 Vue 组件中使用本地化的消息，我们可以使用`VueI18n`创建的`$t()`实例方法。例如，在`front-end/src/components/Logo.vue`中，我们可以使用`{{ $t("logo.tagLine") }}`来获取本地化的消息:

```java
<template>
  <div class="logo-wrapper">
    <img class="logo" srcimg/logo.png">
    <div class="tagline">{{ $t("logo.tagLine") }}</div>
  </div>
</template>
```

要在 JavaScript 文件中使用`VueI18n`，我们可以导入`front-end/src/i18n.js`并使用`i18n.t()`方法。例如，下面是对`front-end/src/utils/error-parser.js`的更改:

```java
import { i18n } from '@/i18n'

export default {
      ...
      } else if (status === 401) {
        return new Error(i18n.t('error.request.notAuthorized'))
      } 
      ...
  }
}
```

一旦所有的标签都被本地化，如果您运行`npm run test:unit`命令，您将会看到错误，抱怨`_vm.$t is not a function`或`[vue-i18n] Cannot find VueI18n instance!`，等等。是因为我们没有在这些测试中加入`VueI18n`。

让我们现在做那件事。在`LoginPage.spec.js`和`RegisterPage.spec.js`中，我们将`VueI18n`实例`i18n`添加到`wrapper`中，如下所示:

```java
...
import { i18n } from '@/i18n'
...
describe('LoginPage.vue', () => {
  ...
  beforeEach(() => {
    wrapper = mount(LoginPage, {
      localVue,
      router,
      i18n
    })
    ...
  })
  ...
})
```

您可以在提交历史中找到关于添加 i18n 支持的详细信息:

![](img/40b01842-aad6-4ed6-b67c-d6c07b16e1b3.png)

图 11.12:添加 i18n 支持提交

# 记录 SQL 查询和性能调优

在这一节中，我们将介绍一种方法来记录`JdbcDriver`发送给数据库的 SQL 查询。我们将使用 P6Spy([https://github.com/p6spy/p6spy](https://github.com/p6spy/p6spy))。

我们需要做的第一个改变是将以下依赖项添加到`pom.xml`中:

```java
<dependency>
  <groupId>p6spy</groupId>
  <artifactId>p6spy</artifactId>
  <version>${p6spy.version}</version>
</dependency>
```

在撰写本文时，我们使用的 P6Spy 版本是 3.7.0。要定制 P6Spy，我们可以添加`src/main/resources/spy.properties`配置文件。我们将使用的方法如下所示:

```java
driverlist=com.mysql.jdbc.Driver
logfile=spy.log
dateformat=yyyy-MM-dd HH:mm:ss.SS
logMessageFormat=com.p6spy.engine.spy.appender.CustomLineFormat
customLogMessageFormat=- %(currentTime) | took %(executionTime)ms | connection %(connectionId) \nEXPLAIN %(sql);\n
filter=true
exclude=select 1 from dual
```

为了让 P6Spy 捕获 SQL 查询，我们需要更改数据源配置。让我们对`application-dev.properties`进行如下更改:

```java
spring.datasource.url=jdbc:p6spy:mysql://localhost:3306/task_agile?useSSL=false
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver
```

如你所见，我们需要将 URL 的`jdbc:mysql`改为`jdbc:p6spy:mysql`，并将驱动程序类名改为`com.p6spy.engine.spy.P6SpyDriver`。

一切就绪后，一旦应用启动，您就可以看到在`spy.log`中捕获的 SQL 查询，如下所示:

```java
- 2018-08-30 20:55:53.333 | took 1ms | connection 0
EXPLAIN SELECT b.* FROM board b LEFT JOIN board_member bm ON b.id = bm.board_id WHERE bm.user_id = 34;
```

在`spy.properties`的`customLogMessageFormat`自定义格式中增加了`EXPLAIN`关键字。这样，您可以复制 SQL 来对查询进行 MySQL 解释，并找出如何调优查询的性能。

以下是提交记录:

![](img/70be6628-23be-406c-bebb-1624cbe82030.png)

图 11.13:添加 P6Spyto 来记录 SQL 查询提交

# 最后的修正

让我们来看看如下所做的修复:

*   **修复** — **使用包装 ID 代替** `BoardMember`中的原生 ID:`com.taskagile.domain.model.board.BoardMember`中的，`getUserId()``getBoardId()`返回原生 long 值。最好使用包装的 id:

![](img/314c1b5d-e216-43f6-ae23-f88530ca90fd.png)

图 11.14:修复:在 BoardMember 提交中使用包装 id 而不是本机 id

*   **修复** — **移除不必要的模仿**:在`LoginPage.spec.js`和`RegisterPage.spec.js`中，除了`i18n`之外，还在包装器中增加了一个`$t`的`mocks`对象，这是不必要的。最好删除它以避免混淆:

![](img/7a154322-3654-4679-a619-4e047054df93.png)

图 11.15:修复:删除不必要的模拟提交

*   **页眉 logo 图像不显示**:在`PageHeader.vue`中，logo 图像路径仍然是`/statimg/logo.png`。应该改img/logo.png`:

![](img/9dd935cb-1c59-4fa4-9459-1b0918001eaa.png)

图 11.16:修复:页眉徽标图像不显示

# 摘要

在这一章中，我们学习了前端状态管理的不同方式，并比较了 MVC 应用和 Flux 使用的应用中的数据流。后来，我们学习了 Vuex 的核心概念以及如何在应用中使用它们。我们还学习了如何使用引导模式组件创建弹出窗口。

我们还实现了主页的前端和后端。由于范围有限，我们没有在本章中讨论单元测试和主页的端到端测试。我们鼓励你自己尝试一下。你可以使用[第 9 章](09.html)、*表单和验证中的那些——从注册页面*开始，以及[第 10 章](10.html)、*Spring Security——使我们的应用安全*作为例子。

除此之外，我们在前端添加了 i18n 支持，并介绍了用 P6Spy 记录 SQL 查询的方法。

在下一章中，我们将创建公告板页面，并使用 WebSocket 实现实时更新，以及使用 Elasticsearch 实现全局搜索。

# 使用 WebSocket 创建板进行 Flexbox 布局和实时更新

CSS3 Flexbox 布局是用于构建 web 应用布局的新模型。它使得构建灵活的响应性布局结构更加容易，而不需要使用浮动或定位，我们将使用它来构建我们的公告板页面。

如今，实时协作在 web 应用中已经变得流行和普遍，尤其是随着 WebSocket API 的标准化。在 TaskAgile 应用中，我们将基于 SockJS 实现卡片变化的实时更新，SockJS 是一个跨浏览器的库，提供了类似 WebSocket 的接口。在服务器端，我们将使用 Spring WebSocket 实现。

在本章中，您将学习以下内容:

*   用 Flexbox 实现纸板页面的用户界面
*   实现卡片列表和卡片的拖放功能
*   使用 WebSocket 实现实时更新
*   为跨组件通信创建事件总线
*   使用 JWT 进行身份验证

# 构建公告板页面的前端

在这一节中，我们将关注构建公告板页面前端的两个部分。第一个是如何让页面的高度和屏幕一样高。第二个是如何实现拖拽重组卡片列表和卡片的功能。

# 公告板页面的用户界面

现在，让我们看看我们正在构建的公告板页面的 UI。*图 12.1* 是页面的 UI 设计:

![](img/324dd04c-4e1d-435f-bbd6-577279b96364.png)

图 12.1:公告板页面的用户界面

如您所见，我们在页面上以列的形式显示了卡片列表。在待办事项列表中，卡片垂直列出，并显示其标题。对于上传了图像的卡片，我们将显示一个缩略图作为卡片封面，如第四张卡片所示。在这一章中，卡片将只列出它们的标题。一旦我们上传了实现的附件特性，我们将在下一章实现封面图像。

*图 12.2* 显示了点击(+添加列表)按钮时的板卡页面 UI；“添加列表”表单以内联方式显示。用户可以输入列表的名称并按下 *Enter* 键或点击(+ Add List)按钮添加一个新列表。单击表单外的任何地方都会自动关闭表单:

![](img/f7012a27-fc21-4d90-98d2-9a368d4bb293.png)

图 12.2:添加列表字段的用户界面

*图 12.3* 显示了点击(+添加卡)按钮时的用户界面。正如您所看到的，当单击按钮时，add card 表单会内嵌显示在卡片列表中。用户可以按*回车*键或点击(添加)按钮提交表单。此外，单击表单外的任何地方都会关闭表单。我们将使用与添加列表表单相同的机制来实现它:

![](img/2c19ee30-e31b-4bcf-a488-a963beec240d.png)

图 12.3:添加卡片字段的用户界面

用户可以点击列表头，如等待中、进行中、完成等，拖动卡片列表到左侧或右侧，改变卡片列表的位置。同样的，使用拖放，用户可以在同一个卡片列表中上下移动卡片，或者将其移动到另一个卡片列表中。

用户可以根据需要向白板添加任意数量的卡片列表。当有更多的卡片列表显示在屏幕上时，卡片列表会溢出到页面之外，页面底部会有一个水平滚动条。当卡片列表包含的卡片数量超过屏幕显示的数量时，底部的卡片将被隐藏，并显示垂直滚动条。*图 12.4* 显示了卡片列表水平溢出且卡片隐藏在卡片列表底部时页面的外观:

![](img/4f5cb047-ac81-4c4c-bb15-080c9e93cf92.png)

图 12.4:全高卡列表和溢出卡列表的 UI(来源 1:https://www.rawpixel.com/image/53168/artisan-pottery-shop,来源 2:https://www.rawpixel.com/image/412056/man-jumping-joy-lake)

# 纸板页面的布局

现在，我们来考虑一下如何实现 board 页面的 UI。与我们实现的所有页面相比，这个页面最大的不同是它的高度需要固定在与屏幕相同的高度。卡片列表的高度不会超过页面的可用区域，如图*图 12.4* 所示。

存档的一种方法是使用 JavaScript 计算屏幕的可用高度，然后在 JavaScript 中设置卡片列表的高度。这还需要将一个侦听器附加到浏览器的 resize 事件，以便可以相应地调整卡片列表的高度。更好的方法是使用 CSS 的 Flexbox 布局来实现。我们将使用 Flexbox 来构建公告板页面的布局。

# 设计整体布局

公告板页面的整体布局不同于应用中的所有其他页面。我们将把所有内容放在一个`.page` division 中，如下所示；`<body>`标签和`#app`分区的高度将为 100%；

```java
<body>
  <div id="app">
    <div class="page">
      <div class="page-header"></div>
      <div class="page-body">
        <div class="board-wrapper">
          <div class="board"></div>
        </div>
      </div>
    </div>
  </div>
</body>
```

在`.page`元素中，我们将有一个`.page-header`元素，它与主页的标题相同，还有一个`.page-body`元素，它包含一个`.board-wrapper`元素。在`.board-wrapper`里面，我们会放一个`.board`元素。*图 12.5* 显示了纸板页面的高级布局:

![](img/488b78af-709a-42f3-aacb-6df13e30e4e0.png)

图 12.5:公告板页面的整体布局

以下是之前显示的部门的 CSS:

```java
.page {
  display: flex;
  flex-direction: column;
}

.page-header {
  flex: none;
}

.page-body {
  flex-grow: 1;
  position: relative;
}

.board-wrapper {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
```

正如你所看到的，我们通过将`flex`分配给它的`display`属性来使用`.page`部门作为一个 flex 容器。因为我们将垂直对齐分割，所以我们将`column`值赋给`flex-direction`属性。

对于`.page-header`，我们用`flex: none`，相当于`flex: 0 0 auto`，本身就是`flex-grow: 0 flex-shrink: 0 flex-basis: auto`的简写。这样，`.page-header`将根据其内容的宽度/高度来调整大小。

对于`.page-body`，我们使用`flex-grow: 1`告诉浏览器让`.page-body`元素占据屏幕上所有垂直可用的区域。

对于`.board-wrapper`，顾名思义，它是`.board`分部的包装器。我们让它完全占据了`.page-body`的所有区域。这样，`.board`分区作为其内部分区的 flex 容器，可以使用 100%的高度来填充`.board-wrapper`内部的所有区域。

如果你对 Flexbox 不熟悉，可以在 MDN 上找到 Flexbox 的详细介绍:[https://developer . Mozilla . org/en-US/docs/Learn/CSS/CSS _ layout/Flexbox](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)和 CSS 的窍门在:【https://css-tricks.com/snippets/css/a-guide-to-flexbox/】T2。

*图 12.6* 显示了`.board-wrapper`内部零件的布局。在`.board` flex 容器中，`.board-header`和`.board-body`具有与`.page-header`和`.page-body`相似的 CSS 属性:

![](img/a45389fb-6db1-4191-b750-59cf52d701d3.png)

图 12.6:公告板页面的详细布局

以下是`.board-wrapper`内部各分部的 CSS:

```java
.board {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.board-header { 
  flex: none;
  height: auto;
}

.board-body { 
  flex-grow: 1;
  position: relative;
}

.list-container {
  position: absolute;
  bottom: 0;
  left: 8px; 
  right: 0;
  top: 0;
  overflow-x: auto;
  overflow-y: hidden; 
}

.list-wrapper { 
  display: inline-block;
  height: 100%; 
  vertical-align: top; 
}
```

如你所见，`.board`、`.board-header`和`.board-body`定义了相同的布局，可以让`.board-body`填满所有的垂直可用区域。对于`.list-container`，我们通过使用`overflow-x: auto`让它可以水平滚动。对于每个卡片列表，我们会把它放在`.list-wrapper`里面，用`display: inline-block`横向并排定位。

在`.list-wrapper`中，`.list`是其子元素`.list-header`、`.cards`和`.add-card-button`的 flex 容器。接下来你可以看到，对于`.list`，我们给它一个最大的高度`100%`，以确保它不会超出可用区域。对于`.cards`，我们允许它可以垂直滚动，这样它可以根据需要容纳尽可能多的`.card-items`:

```java
.list { 
  display: flex;
  flex-direction: column;
  max-height: 100%;
}

.cards {
  min-height: 1px;
  overflow-y: auto;
}
```

对于任何其他细节，您可以在 GitHub 上的提交历史中找到它们。

# 实现拖放

如今，在页面上拖放元素已经成为一种常见的用户体验。有许多库可以帮助开发人员轻松实现这个特性。我们将使用 Vue。draggable([https://github.com/SortableJS/Vue.Draggable](https://github.com/SortableJS/Vue.Draggable))，这是一个基于 Sortable.js 库([https://github.com/RubaXa/Sortable](https://github.com/RubaXa/Sortable))的 Vue 组件。

通过`npm install vuedraggable --save`命令安装后，我们需要将其导入到`BoardPage.vue`中，如下所示:

```java
    <script>
import draggable from 'vuedraggable'
...
export default {
  name: 'BoardPage',
  ...
  components: {
    ...
    draggable
  },
  ...
}
</script>
```

为了使卡片列表支持拖放，我们需要如下包装`.list-wrapper`元素:

```java
<div class="board-body">
  <draggable v-model="cardLists" class="list-container" 
    @end="onCardListDragEnded" :options="{handle: '.list-header', 
    ...}">
    <div class="list-wrapper" v-for="cardList in cardLists" v-
    bind:key="cardList.id">
      <div class="list">
        <div class="list-header">{{ cardList.name }}</div>
        ... 
      </div>
    </div>
    ...
  </draggable>
</div>
```

如您所见，`<draggable>`组件有一个绑定到`cardLists`的`v-model`属性，这是在`data`属性中定义的。这样，拖放后对卡片列表的修改会自动同步到`cardLists`数据模型中。一旦拖动结束，它将发出一个`end`事件。在我们的代码中，我们使用`onCardListDragEnded(event)`处理程序来监听该事件，并将更改保存到服务器端的卡片列表位置。在它的`:options`属性中，我们指定拖动只能由`.list-header`元素触发。有了这个`<draggable>`组件，里面所有的`.list-wrappers`都可以拖拽。

以下是如何使`.card-items`可拖动:

```java
<div class="list">
  <div class="list-header">{{ cardList.name }}</div>
  <draggable class="cards" v-model="cardList.cards" 
    @end="onCardDragEnded" :options="{draggable: '.card-item', group:     
  'cards', ghostClass: 'ghost-card', ...}" ...>
    <div class="card-item" v-for="card in cardList.cards" ...>
      <div class="card-title">{{ card.title }}</div>
    </div>
    <div class="add-card-form-wrapper">
      ...
    </div>
  </draggable>
  ...
</div>
```

如您所见，我们将`.card-items`和`.add-card-form-wrapper`包装在另一个`<draggable>`组件中，该组件嵌套在`<draggable>`组件中，使卡片列表可拖动。我们还定义了一个事件监听器`onCardDragEnded(event)`方法来保存卡片位置的变化到服务器。在`options`属性的值中，我们使用`draggable`选项来指定只能拖动具有`.card-item`类的元素。这样，`.add-card-form-wrapper`就不会拖泥带水了，这就是我们想要的。我们使用 Sortable.js 中的选项`group`，这样就可以将一个`.card-item`元素从一个`.cards`元素拖到另一个`.cards`元素中。这样，我们可以在卡片列表之间移动一张卡片。`ghostClass`选项用于定义放置占位符的 CSS 类。

我们不会在本书中讨论`BoardPage.vue`UI 实现的其他细节。您可以在 GitHub 上的提交记录中找到所有细节。

# 构建公告板页面的后端

现在，让我们看看我们需要做些什么来实现公告板页面的后端。简而言之，我们需要做到以下几点:

*   创建卡片列表、卡片和`BoardMember`的域模型
*   创建应用服务
*   创建存储库实现
*   在控制器中创建 API 处理程序

# 公告板页面的 API

首先，让我们看看我们将需要实现的 API:

*   获取电路板的 API
*   添加董事会成员的 API
*   添加卡片列表的 API
*   改变卡片列表位置的 API
*   添加卡的 API
*   改变卡片位置的 API

让我们逐一了解一下，如下所示:

*   **获取板卡 API**:**T5】这将是一个`GET`请求发送到`/api/boards/{boardId}`。通过这个 API，我们将返回董事会信息，以及董事会成员、卡片列表及其卡片。如果这是一个团队公告板，我们还需要返回团队信息。下面是响应的样子:**

```java
{
  "team": {
    "name": "Sales & Markerting"
  },
  "board": {
    "name": "Ongoing Campaigns",
    "personal": false,
    "id": 1
  },
  "members": [{
    "userId": 1,
    "shortName": "JY"
  }],
  "cardLists": [{
    "id": 1,
    "name": "Todo",
    "position": 1,
    "cards": [{
      "id": 1,
      "title": "Come up with a marketing strategy",
      "position": 1
    }]
  }]
}
```

*   **添加板卡成员 API** :这将是一个发送给`/api/boards/{boardId}/members`的`POST`请求，以用户名为有效载荷；

```java
{ "usernameOrEmailAddress": "sunny" }
```

或者，我们可以使用如下所示的电子邮件地址:

```java
{ "usernameOrEmailAddress": "sunny@taskagile.com" }
```

API 响应将如下所示:

```java
{ "id": 3, "shortName": "SH" }
```

*   **添加卡片列表 API** :这将是一个发送到`/api/card-lists`的`POST`请求，其有效载荷如下所示:

```java
{
  "boardId": 1,
  "name": "Todo",
  "position": 1
}
```

API 响应将如下所示:

```java
{
  "id": 2,
  "name": "Todo"
}
```

如您所见，在响应中，服务器将发回新创建的卡片列表。

*   **更改卡列表位置 API** :这将是一个发送到`/api/card-lists/positions`的`POST`请求，其有效载荷如下所示:

```java
{
  "boardId": 6,
  "cardListPositions": [
    { "cardListId": 1, "position": 1 }, 
    { "cardListId": 2, "position": 3 }, 
    { "cardListId": 3, "position": 2 }
  ]
}
```

如您所见，在请求中，我们将所有卡片列表的位置发送到服务器。当请求成功时，服务器将简单地返回一个没有响应体的 HTTP 状态`200`。

*   **添加卡 API** :这将是一个发送到`/api/cards`的`POST`请求，其有效载荷如下所示:

```java
{
  "boardId": 1,
  "cardListId": 1,
  "title": "Come up with a marketing strategy",
  "position": 1
}
```

成功后，API 响应将类似于以下内容:

```java
{
  "id": 1,
  "position": 1,
  "title": "Come up with a marketing strategy"
}
```

如您所见，在响应中，服务器将发回新创建的卡。

*   **更改卡位置 API** :这将是一个发送到`/api/cards/positions`的`POST`请求，其有效载荷如下所示:

```java
{
  "boardId": 6,
  "cardPositions": [
    { "cardListId": "1", "cardId": 2, "position": 1 }, 
    { "cardListId": "1", "cardId": 3, "position": 2 }, 
    { "cardListId": "2", "cardId": 1, "position": 1 }, 
    { "cardListId": "2", "cardId": 4, "position": 2 }
  ]
}
```

当一张牌在同一个牌列表中简单地上下移动时，在`cardPositions`数组中，我们将只发送该列表中所有牌的位置。当一张卡从一个列表移动到另一个列表时，我们将发送两个列表中所有卡的位置。当请求成功时，服务器将简单地返回一个没有响应体的 HTTP 状态`200`。

# 批量改变位置

在领域模型、应用服务和存储库的实现中，大部分与我们在前面章节中讨论的相似。在本节中，我们将重点介绍如何更改卡片列表和卡片的位置。

正如您在用于更改卡片列表和卡片位置的 API 中所看到的，在一个请求中，可能会有多次位置更改。我们将使用 Spring 的`JdbcTemplate`的`batchUpdate()`方法来实现更改。

我们来看看`HibernateCardRepository`，大概是这样的:

```java
...
@Repository
public class HibernateCardRepository extends HibernateSupport<Card> implements CardRepository {
 private JdbcTemplate jdbcTemplate;
  HibernateCardRepository(EntityManager entityManager, 
 JdbcTemplate jdbcTemplate) {
    super(entityManager);
    this.jdbcTemplate = jdbcTemplate;
  }
  ...
  @Override
  public void changePositions(final List<CardPosition> cardPositions) {
    String sql = "update card set card_list_id=?,`position`=? where 
    id=?";

 jdbcTemplate.batchUpdate(sql, new BatchPreparedStatementSetter() {
      @Override
      public void setValues(PreparedStatement ps, int i) 
           throws SQLException {
 CardPosition cardPosition = cardPositions.get(i);
        ps.setLong(1, cardPosition.getCardListId().value());
        ps.setInt(2, cardPosition.getPosition());
        ps.setLong(3, cardPosition.getCardId().value());
      }
      @Override
      public int getBatchSize() {
        return cardPositions.size();
      }
    });
  }
}
```

如你所见，除了`EntityManager`，我们还要求 Spring 通过构造函数注入一个`JdbcTemplate`的实例。在`changePositions()`方法中，我们创建了一个`BatchPreparedStatementSetter`的实现，通过使用`java.sql.PreparedStatement`的一个实例为每个 SQL 查询设置值，并通过`getBatchSize()`方法提供批处理的大小。这样，我们可以在一条 update SQL 语句中更新多张卡的位置。

改变卡片列表位置的实现类似于改变卡片位置的实现。这里就不列举了。以下是实现公告板页面的提交记录:

![](img/d9863c84-8cd3-4e07-a737-ea8f5bd781d0.png)

图 12.7:实现纸板页面提交

# 使用 WebSocket 实现实时更新

我们需要构建两个部分来实现实时通信——一个是客户端，另一个是服务器端。如前所述，我们将使用 SockJS([http://sockjs.org](http://sockjs.org))实现客户端，在服务器端使用 Spring 的 WebSocket 实现。

# SockJS 简介

在幕后，SockJS 客户端将尝试使用浏览器提供的本机 WebSocket。如果它不可用，它将回退到其他传输协议，如 XHR 流和 XHR 轮询。它的 API 使用起来非常简单。以下是在`/rt`路径建立与本地服务器的 WebSocket 连接的示例:

```java
let socket = new SockJS('http://localhost:8080/rt')
socket.onopen = function (event) {
  // Connection established
  console.log(socket.readyState)
}

socket.onmessage = function (message) {
  // Message received via WebSocket
}

socket.onclose = function (event) {
  // Connection closed
}

socket.onerror = function (error) {
  // An error occurred
}
```

如您所见，它有四个事件处理程序:

*   当与服务器的连接建立后，将调用`onopen()`事件处理程序。在这个阶段，`SockJS`对象的`readyState`属性已经从`SockJS.COLLECTING`更改为`SockJS.OPEN`。
*   当客户端收到来自服务器端的消息时，将调用`onmessage()`事件处理程序。
*   当 WebSocket 连接关闭时，将调用`onclose()`事件处理程序。
*   发生错误时会调用`onerror()`事件处理程序。

除了这些事件处理程序之外，SockJS 还提供了`send()`方法，供客户端向服务器发送数据。这个 API 非常简单。看起来是这样的:

```java
socket.send(data)
```

数据可以是字符串、blob、`ArrayBuffer`或`ArrayBufferView`。

另外，SockJS 为客户端提供了一个`close()`方法来关闭与服务器的连接，如下所示:

```java
socket.close()
```

SockJS 最大的优势是其 API 紧跟 HTML5 WebSocket API。它为应用构建自己的通信模式提供了一个通用的基础层。如果你对最新的 WebSocket API 规范感兴趣，可以在这里找到:[https://html.spec.whatwg.org/multipage/web-sockets.html](https://html.spec.whatwg.org/multipage/web-sockets.html)。

# Spring WebSocket 简介

Spring 的 WebSocket 实现在其他 WebSocket 运行时之上提供了一个抽象层，比如 Tomcat、Jetty 和 Undertow。借助 Spring 的抽象，创建一个 WebSocket 服务器就像实现`WebSocketHandler`接口一样简单。Spring 也提供了基类，比如`TextWebSocketHandler`和`BinaryWebSocketHandler`，我们可以直接扩展。

除了实现`WebSocketHandler`，我们还需要提供配置，以便 Spring 知道如何引导我们的 WebSocket 服务器。我们可以通过实现`WebSocketConfigurer`接口来做到这一点。下面是一个简单 WebSocket 配置的示例:

```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

  @Override
  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
    registry.addHandler(realTimeHandler(), "/ws");
  }

  @Bean
  public WebSocketHandler realTimeHandler() {
    return new RealTimeHandler();
  }
}
```

如您所见，我们将`@EnableWebSocket`注释应用于配置类，在`registerWebSocketHandlers()`方法中，我们将`realTimeHander`注册到`/ws`路径。这样，发送到`/ws`路径的请求将由`RealTimeHandler`类处理。

# 基于渠道的沟通模式

如前所述，SockJS 的 API 是通用的。它不强制任何交流模式。它通过 WebSocket 在客户端和服务器之间提供实时连接。这给了我们构建适合我们应用的通信模式的自由。

在我们的应用中，当多个用户打开同一个面板时，面板上发生的所有事情都需要自动更新给所有其他用户，而不需要刷新页面。例如，一旦用户向待办事项列表添加了一张新卡片，该卡片应该立即出现在所有其他用户的待办事项列表中。这里的通信是一种发布/订阅模式。添加新卡的用户触发在服务器端发布新卡添加消息。服务器将此消息发布给订阅了此消息的所有客户端。此消息不应发布给任何其他客户端。

除了*新卡增加了*的消息，我们还可以有很多其他的消息，比如*新卡列表增加了* *卡位改变了*。如果我们要求客户单独订阅这些消息中的每一条，将会有大量的样板代码。在我们的应用中，这是不必要的，因为有权访问公告板的每个人都应该能够接收来自公告板的消息。

因此，我们可以创建一个消息通道并向该通道发送各种消息，而不是要求客户端订阅各个消息。订阅了该频道的客户端将会收到这些消息。由客户端决定如何处理每条消息。通道就是一个以`/`开头的字符串。我们可以随意命名通道，只要它是唯一的并且对我们的应用有意义。例如，我们可以创建一个名为`/board/1`的板通道。`1`是董事会的 ID。

通过板通道，每个打开板的人都将向服务器发送消息来订阅该板通道。在用户离开板后，客户端将发送另一条消息来取消订阅该板通道。

# 实时客户端的前端实现

在我们的实现中，我们将创建一个`RealTimeClient`类来包装一个`SockJS`对象，以提供基于通道的通信。我们将这个客户端的实例绑定到`Vue.prototype.$rt`，这样所有的 Vue 组件都可以通过实例的`$rt`属性访问实时客户端。以下是`RealTimeClient`级的概述。

让我们来看看`frontend/src/real-time-client.js`文件:

```java
import Vue from 'vue'
import SockJS from 'sockjs-client'

class RealTimeClient { 
  constructor () {
    ...
  }
  init (serverUrl, token) {
    ...
  }
  logout () {
    ...
  }
  connect () {
    ...
  }
  subscribe (channel, handler) {
    ...
  }
  unsubscribe (channel, handler) {
    ...
  }
}

export default new RealTimeClient()
```

如您所见，除了构造函数之外，它还提供了`init()`、`logout()`、`connect()`、`subscribe()`和`unsubscribe()`API。`RealTimeClient`的实例是`real-time-client.js`的默认导出。这样，应用中将只有一个`RealTimeClient`实例。

在构造函数内部，`RealTimeClient`的属性被初始化，如下所示:

```java
constructor () {
  this.serverUrl = null
  this.token = null
  this.socket = null
  this.authenticated = false
  this.loggedOut = false
  this.$bus = new Vue()
  this.subscribeQueue = {
    /* channel: [handler1, handler2] */
  }
  this.unsubscribeQueue = {
    /* channel: [handler1, handler2] */
  }
}
```

`serverUrl`是 WebSocket 服务器的 URL，默认设置为`null`。`token`是客户端用于在服务器端执行身份验证的实时令牌。这是一个 JWT 令牌字符串。我们将在下一节详细讨论 jwt。`socket`属性是`SockJS`的一个实例，它将在`connect()`方法中创建。`authenticated`属性用于标识客户端是否已经通过服务器端的认证。`loggedOut`属性用于指示用户是否已经注销，实时客户端是否因为注销而关闭。

`$bus`属性是`Vue`的一个实例。它充当实时客户端的内部事件总线。在实时客户端与服务器建立连接之前，`subscribeQueue`和`unsubscribeQueue`分别持有订阅和取消订阅动作。一旦建立了连接，实时客户端将执行队列中的所有订阅和取消订阅操作，并清空队列。我们将会看到这是如何使实时客户端的使用变得更加容易的。

`init()`方法是我们初始化连接的地方。它看起来像下面这样:

```java
init (serverUrl, token) {
  if (this.authenticated) {
    console.warn('[RealTimeClient] WS connection already authenticated.')
    return
  }
  console.log('[RealTimeClient] Initializing')
  this.serverUrl = serverUrl
  this.token = token
  this.connect()
}
```

正如您所看到的，我们在方法的开头放置了一个防护，以确保一旦实时客户端通过了身份验证，即连接已经建立，连接就不会被再次初始化。在这个方法的最后，我们调用`connect()`方法来执行实际的连接初始化。

类似下面的`logout()`方法用于清除实时客户端的状态，方法是将其属性重置为初始值，然后关闭套接字:

```java
logout () {
  console.log('[RealTimeClient] Logging out')
  this.subscribeQueue = {}
  this.unsubscribeQueue = {}
  this.authenticated = false
  this.loggedOut = true
  this.socket && this.socket.close()
}
```

`connect()`方法是在实时客户机和服务器之间建立连接的地方。它看起来像下面这样:

```java
connect () {
  console.log('[RealTimeClient] Connecting to ' + this.serverUrl)
 this.socket = new SockJS(this.serverUrl + '?token=' + this.token)
  this.socket.onopen = () => {
    this.authenticated = true
    this._onConnected()
  }
  this.socket.onmessage = (event) => {
    this._onMessageReceived(event)
  }
  this.socket.onerror = (error) => {
    this._onSocketError(error)
  }
  this.socket.onclose = (event) => {
    this._onClosed(event)
  }
}
```

正如您所看到的，我们通过创建一个带有`serverUrl`和`token`作为查询参数的`SockJS`实例来建立连接。然后，我们将事件处理程序分配给套接字实例。我们不会在这里详细讨论每个事件处理程序。您可以在提交历史中找到实现。

`subscribe()`方法是实时客户端的客户端将用来订阅他们感兴趣的频道的 API。它看起来像下面这样:

```java
subscribe (channel, handler) {
  if (!this._isConnected()) {
    this._addToSubscribeQueue(channel, handler)
    return
  }
  const message = {
    action: 'subscribe',
    channel
  }
 this._send(message)
 this.$bus.$on(this._channelEvent(channel), handler)
  console.log('[RealTimeClient] Subscribed to channel ' + channel)
}
```

正如您所看到的，在方法的开始，我们检查实时客户机是否连接到服务器。如果不是，一旦连接建立或恢复，我们将把`'subscribe'`动作添加到队列中进行处理。然后，我们调用内部的`_send()`方法向服务器发送订阅消息，以便服务器将这个客户端添加到通道的订阅者，然后我们将`channel`消息处理程序绑定到内部事件总线，以便当收到来自服务器的消息时，我们将使用内部事件总线`$emit()`方法通知该通道的所有处理程序。这样，我们就可以订阅`BoardPage.vue`里面的一个频道，如下:

```java
this.$rt.subscribe('/board/' + this.board.id, this.onRealTimeUpdated)
```

`unsubscribe()`方法与`subscribe()`方法相反，正如您在这里看到的:

```java
unsubscribe (channel, handler) {
  // Already logged out, no need to unsubscribe
  if (this.loggedOut) {
    return
  }

  if (!this._isConnected()) {
    this._addToUnsubscribeQueue(channel, handler)
    return
  }
  const message = {
    action: 'unsubscribe',
    channel
  }
  this._send(message)
  this.$bus.$off(this._channelEvent(channel), handler)
  console.log('[RealTimeClient] Unsubscribed from channel ' + channel)
}
```

如您所见，在方法的开始，我们检查实时客户端是否已经注销。如果它已经注销，我们不再需要执行取消订阅操作，因为在服务器端，一旦实时客户端注销，所有的订阅操作都将被清除。当实时客户端没有注销时，我们将检查它是否已连接。对于离线实时客户端，取消订阅操作将被添加到队列中，供以后处理。要取消订阅某个频道，实时客户端还会向服务器发送一条消息，该消息的动作值为`'unsubscribe'`。之后，我们将从内部事件总线中移除处理程序。

如您所见，实时客户端的实现非常简单。这里我们没有提到的一件事是我们将在哪里调用实时客户端的`init()`方法。由于应用中只有一个实时客户端实例，初始化连接的最佳位置是在`App.vue`的`created()`生命周期钩子内。

另一个问题是—我们应该什么时候进行初始化？如您所见，`init()`方法需要两个参数— `serverUrl`和`token`。我们将把这两个值从服务器传递给客户机。放置这两个值的好地方是`getMyData` API ( `/api/me`)的响应。一旦收到响应，我们将使用我们在`frontend/src/event-bus.js`中创建的全局事件总线来通知`App.vue`。

以下是我们对`App.vue`的改动:

```java
<script>
export default {
  name: 'App',
  created () {
    this.$bus.$on('myDataFetched', myData => {
      // Initializing the real time connection
      this.$rt.init(myData.settings.realTimeServerUrl, 
      myData.user.token)
    })
  }
}
</script>
```

正如你所看到的，在`App.vue`的`created()`钩子中，我们监听`myDataFetched`事件，并使用这两个值来初始化实时连接。

对于实时客户机前端实现的其他细节，您可以在提交历史中找到它们。

# 向 JWT 认证实时客户端

Spring 的 WebSocket 实现提供了一个`WebSocketSession`接口，允许您从`WebSocketSession.getPrincipal()`方法访问经过身份验证的用户的信息。当用户没有被认证时，这个方法的结果将是`null`。我们可以用这个来判断用户是否经过认证，非常方便。

然而，当我们需要将与实时相关的特性分离到一个独立的应用中时，我们不能使用`WebSocketSession.getPrincipla()`方法来检索经过身份验证的用户的信息，除非我们使用 Spring Session 建立一个集群会话。但这不是唯一的方法。我们还可以使用 JWT 来执行身份验证。

在本节中，我们将介绍如何生成 JWT 实时令牌，以便在我们的应用中对 WebSocket 连接执行身份验证。

如前所述，实时令牌将在`/api/me` API 的响应中发送给客户端。在这里，我们将生成用户 ID 作为 JWT 主题的令牌。我们将使用`jjwt`库(【https://github.com/jwtk/jjwt】)来生成和验证令牌。

我们将创建`TokenManager`来将生成 JWT 的逻辑与应用的其余部分隔离开来。下面是`com.taskagile.domain.common.security.TokenManager`的样子:

```java
@Component
public class TokenManager {
  private Key secretKey;
  public TokenManager(
      @Value("${app.token-secret-key}") String secretKey) {
    this.secretKey = 
       Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKey));
  }

  public String jwt(UserId userId) {
    return Jwts.builder()
      .setSubject(String.valueOf(userId.value()))
      .signWith(secretKey).compact();
  }

  public UserId verifyJwt(String jws) {
    String userIdValue = Jwts.parser().setSigningKey(secretKey)
       .parseClaimsJws(jws).getBody().getSubject();
    return new UserId(Long.valueOf(userIdValue));
  }
}
```

如你所见，我们将把一个将要添加到`application.properties`的密钥注入到`TokenManager`中。这个类中有两个方法，`jwt()`，用于根据`UserId`生成一个 JWT 字符串，和`verifyJwt()`方法，用于验证我们从客户端收到的令牌。

下面是对`MeApiController`的修改:

```java
@Controller
public class MeApiController {
  ...
 private TokenManager tokenManager;
  public MeApiController(...TokenManager tokenManager) {
    ...
    this.tokenManager = tokenManager;
  }

  @GetMapping("/api/me")
  public ResponseEntity<ApiResult> getMyData(@CurrentUser SimpleUser 
  currentUser) {
    ...
 String realTimeToken = tokenManager.jwt(user.getId());
    return MyDataResult.build(user, teams, boards, realTimeServerUrl, 
    realTimeToken);
  }
}

```

如您所见，我们注入了`TokenManager`的实例，并使用它生成一个 JWT 字符串作为实时令牌。

一旦实时客户端使用令牌初始化连接，我们的`WebSocketHandler`实现将在其`afterConnectionEstablished()`方法中接收请求。在这里，我们将通过验证实时令牌来执行身份验证。

我们对`WebSocketHandler`的实现是一个请求分配器，叫做`WebSocketRequestDispatcher`。它有以下责任:

*   一旦建立了连接，就对请求进行认证
*   将请求分派给通道处理程序，我们将在下一节详细讨论这一点
*   连接关闭后清理会话

现在，我们将只实现第一个。下面是`WebSocketRequestDispatcher`的样子:

```java
@Component
public class WebSocketRequestDispatcher extends TextWebSocketHandler {
 private TokenManager tokenManager;
  public WebSocketRequestDispatcher(TokenManager tokenManager,     
      ChannelHandlerResolver channelHandlerResolver) {
    this.tokenManager = tokenManager;
  }

  @Override
  public void afterConnectionEstablished(WebSocketSession 
  webSocketSession) {
    log.debug("WebSocket connection established");
    RealTimeSession session = new RealTimeSession(webSocketSession);
    String token = session.getToken();

    try {
 UserId userId = tokenManager.verifyJwt(token);
      session.addAttribute("userId", userId);
      session.reply("authenticated");
    } catch (JwtException exception) {
      log.debug("Invalid JWT token value: {}", token);
      session.fail("authentication failed");
    }
  }
}
```

如您所见，我们将`TokenManager`的实例注入到请求调度程序中，并使用它来验证在`afterConnectionEstablished()`方法中收到的令牌。`RealTimeSession`是`WebSocketSession`的包装器，提供一些方便的方法。

随着`WebSocketRequestDispatcher`的实现，我们的实时客户端可以被认证。让我们提交代码，下面是提交记录:

![](img/b7fd4f2f-8f6a-431c-8fd4-b9042eb2dbd4.png)

图 12.8:实现实时客户端提交

# 通道处理程序的服务器实现

现在，让我们开始服务器端实时通信的其余实现。如前所述，我们使用基于通道的模式构建通信，但是`WebSocketHandler`提供的默认 API 没有通道的概念。它定义了一个通用接口。我们将需要延长它。

如前所述，我们这个接口的实现是`WebSocketRequestDispatcher`。灵感来源于 Spring MVC 的`DispatcherServlet`。在`WebSocketRequestDispatcher`的`handleTextMessage()`方法中，我们将要求`ChannelHandlerResolver`找到注册的通道处理程序，以处理发送到指定通道的消息。一旦找到通道处理程序，我们将使用相应的`ChannelHandlerInvoker`来调用通道处理程序的 action 方法，该方法被绑定来处理消息。当找不到通道处理程序或操作方法时，服务器将向客户端发送一条错误消息。否则，通道处理程序的 action 方法将接管消息的处理。

下图显示了`WebSocketRequestDispatcher`及其依赖关系:

![](img/45e70607-f647-44d9-b894-ada2bd1a71de.png)

图 12.9:WebSocket request dispatcher 及其依赖项

我们将不深究这些类的细节。您可以在提交记录中找到它们。相反，让我们来看看`com.taskagile.web.socket.handlers.BoardChannelHandler`板通道的处理程序，看起来如下:

```java
@ChannelHandler("/board/*")
public class BoardChannelHandler {

 @Action("subscribe")
  public void subscribe(RealTimeSession session, @ChannelValue String 
  channel) {
    log.debug("RealTimeSession[{}] Subscribe to channel `{}`", 
    session.id(), channel);
    SubscriptionHub.subscribe(session, channel);
  }

 @Action("unsubscribe")
  public void unsubscribe(RealTimeSession session, @ChannelValue String 
  channel) {
    log.debug("RealTimeSession[{}] Unsubscribe from channel `{}`", 
    session.id(), channel);
    SubscriptionHub.unsubscribe(session, channel);
  }
}
```

如您所见，这个`BoardChannelHandler`是一个简单的 Java 类。你不需要扩展任何基类或者实现任何接口。您所需要做的就是在类级别应用`@ChannelHandler`注释，并将`@Action`注释应用于将处理请求的方法。

`subscribe()`动作方法和`unsubscribe()`动作方法中传递的两个参数由`ChannelHandlerInvoker`传递。这是受 Spring MVC 将参数传递给控制器方法的方式的启发。如果您不需要调用者来传递`RealTimeSession`实例或通道，您只需不将它作为 action 方法的参数添加即可。

您可能还记得，在`RealTimeClient`的`subscribe()`方法中，我们发送给服务器的消息有两个参数，动作和通道:

```java
subscribe (channel, handler) {
  ...
 const message = {
 action: 'subscribe',
 channel
 }
  this._send(message)
  ...
}
```

`channel`参数将与我们在`@ChannelHandler("/board/*")`中指定的参数相匹配。`action`参数将匹配我们在`@Action("subscribe")`中指定的值。您可以在`channel`处理程序中创建除`subscribe`和`unsubscribe`之外的动作。

由于本书范围所限，我们只实现添加新卡的实时更新。在 TaskAgile 的未来版本中，我们将添加其余的实时更新。您可以在下面的提交记录中找到如何在前端进行添加新卡的实时更新的详细信息:

![](img/623c09cd-23ca-43f5-8507-340c9e6280cf.png)

图 12.10:实现加卡提交的实时更新

# 最后的修正

让我们来看看以下修复:

*   **修复** — **从菜单切换板卡不起作用** : 当我们从表头的板卡菜单切换板卡时，`BoardPage.vue`的执行不起作用。问题的原因是，我们只在进入路由器时加载板。之后，使用板卡菜单切换板卡并不会真正触发路由器进入，反而会触发对路由器的更新。修复方法是将加载电路板数据的逻辑移到一个独立的方法中，并从`beforeRouteEnter()`导航保护和`beforeRouteUpdate()`导航保护中调用它:

![](img/a552466b-ec5c-42f1-808f-db2d7d79cbd6.png)

图 12.11:从菜单中修复开关板，但不工作

*   **修复** — **添加板卡** **缺失映射**页面:

![](img/647bb963-5349-4777-8a80-28d658d7ff06.png)

图 12.12:修复添加缺少的纸板页面提交映射

# 摘要

在这一章中，我们实现了 board 页面。我们使用 CSS3 Flexbox 来设计布局，以便电路板的高度可以拉伸以填充屏幕，而无需使用 JavaScript hacks。我们还基于 SockJS 和 Spring 的 WebSocket API 实现了实时通信。

我们介绍了使用 Spring 的`JdbcTemplate`对数据库执行批量更新的方法，以及基于`jjwt`库使用 JSON Web 令牌验证请求的方法。

在下一章，我们将看到如何实现卡片窗口。