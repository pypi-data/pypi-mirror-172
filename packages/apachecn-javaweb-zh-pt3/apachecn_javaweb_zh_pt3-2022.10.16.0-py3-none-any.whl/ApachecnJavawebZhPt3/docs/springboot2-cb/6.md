# 六、应用打包和部署

在本章中，我们将讨论以下主题:

*   创建 Spring Boot 可执行 JAR
*   创建 Docker 图像
*   构建自动执行的二进制文件
*   Spring Boot 环境配置、层次结构和优先级
*   使用 EnvironmentPostProcessor 将自定义属性源添加到环境中
*   使用属性文件外部化环境配置
*   使用环境变量外部化环境配置
*   使用 Java 系统属性外部化环境配置
*   使用 JSON 外部化环境配置
*   设立领事
*   使用 Consul 和 envconsul 外部化环境配置

# 介绍

如果一个应用没有被使用，它有什么用呢？在当今时代，当 DevOps 成为软件开发的方式，当云为王，当构建微服务被认为是应该做的事情时，很多注意力都集中在如何在指定的环境中打包、分发和部署应用上。

十二要素应用方法在定义现代**软件即服务** ( **SaaS** )应用应该如何构建和部署方面发挥了重要作用。其中一个关键原则是将环境配置定义从环境中的应用和存储中分离出来。十二因素应用方法还支持依赖性的隔离和捆绑、开发与生产的对等性、应用的部署和可处置性等。

十二因素 App 方法论可以在[http://12factor.net/](http://12factor.net/)找到。

DevOps 模型还鼓励我们对自己的应用拥有完全的所有权，从编写和测试代码一直到构建和部署它。如果我们要承担这种所有权，我们需要确保维护和管理成本不会过高，并且不会占用我们开发新功能的主要任务的太多时间。这可以通过拥有干净的、定义良好的、隔离的可部署工件来实现，这些工件是自包含的、自执行的，并且可以部署在任何环境中，而不必重新构建。

下面的秘籍将带领我们完成所有必要的步骤，以实现低工作量部署和维护的目标，同时拥有干净优雅的代码。

# 创建 Spring Boot 可执行 JAR

如果不提供一种很好的方法来将整个应用(包括它的所有依赖项、资源等)打包到一个复合的可执行 JAR 文件中，Spring Boot 魔术就不完整。创建 JAR 文件后，只需运行一个`java -jar <name>.jar`命令就可以启动它。

我们将继续使用我们在前面章节中构建的应用代码，并将添加必要的功能来打包它。让我们继续，看看如何创建 Spring Boot 优步罐。

优步 JAR 通常被认为是封装在单个复合 JAR 文件中的应用包，该文件内部包含一个包含所有相关内部 JAR 的`/lib`目录，以及一个包含可执行文件的可选的`/bin`目录。

# 怎么做...

1.  从[第五章](5.html)、*应用测试*进入我们的代码目录，执行`./gradlew clean build`
2.  构建好优步 JAR 之后，让我们通过执行`java -jar build/libs/ch6-0.0.1-SNAPSHOT.jar`来启动应用
3.  这将导致我们的应用在 JAR 文件中运行，控制台输出如下:

```java
      .   ____          _            __ _ _
    /\ / ___'_ __ _ _(_)_ __  __ _ 
    ( ( )___ | '_ | '_| | '_ / _` | 
     \/  ___)| |_)| | | | | || (_| |  ) ) ) )
      '  |____| .__|_| |_|_| |___, | / / / /
     =========|_|==============|___/=/_/_/_/
     :: Spring Boot ::  (v2.0.0.BUILD-SNAPSHOT)
    ...
    (The rest is omitted for conciseness)
    ...
    2017-12-17 INFO: Registering beans for JMX exposure on startup
    2017-12-17 INFO: Tomcat started on port(s): 8080 (http) 8443  
    (https)
    2017-12-17 INFO: Welcome to the Book Catalog System!
    2017-12-17 INFO: BookRepository has 1 entries
    2017-12-17 INFO: ReviewerRepository has 0 entries
    2017-12-17 INFO: PublisherRepository has 1 entries
    2017-12-17 INFO: AuthorRepository has 1 entries
    2017-12-17 INFO: Started BookPubApplication in 12.156 seconds (JVM 
    running for 12.877)
    2017-12-17 INFO: Number of books: 1

```

# 它是如何工作的...

如您所见，获得打包的可执行 JAR 文件相当简单。所有的魔法都已经被编码并作为 Spring Boot·格拉德插件的一部分提供给我们。插件的添加增加了许多任务，允许我们打包 Spring Boot 应用，运行它并构建 JAR、TAR、WAR 文件等等。例如，我们在本书中一直使用的`bootRun`任务，是由 Spring Boot·格拉德插件提供的。通过执行`./gradlew tasks`，我们可以看到可用 Gradle 任务的完整列表。当我们运行这个命令时，我们将得到以下输出:

```java
    ------------------------------------------------------------
    All tasks runnable from root project
    ------------------------------------------------------------

    Application tasks
    -----------------
    bootRun - Run the project with support for auto-detecting main 
    class and reloading static resources
    run - Runs this project as a JVM application

    Build tasks
    -----------
    assemble - Assembles the outputs of this project.
    bootJar - Assembles an executable jar archive containing the main 
    classes and their dependencies.
    build - Assembles and tests this project.
    buildDependents - Assembles and tests this project and all projects 
    that depend on it.
    buildNeeded - Assembles and tests this project and all projects it 
    depends on.
    classes - Assembles classes 'main'.
    clean - Deletes the build directory.
    jar - Assembles a jar archive containing the main classes.
    testClasses - Assembles classes 'test'.

    Build Setup tasks
    -----------------
    init - Initializes a new Gradle build. [incubating]

    Distribution tasks
    ------------------
    assembleBootDist - Assembles the boot distributions
    assembleDist - Assembles the main distributions
    bootDistTar - Bundles the project as a distribution.
    bootDistZip - Bundles the project as a distribution.
    distTar - Bundles the project as a distribution.
    distZip - Bundles the project as a distribution.
    installBootDist - Installs the project as a distribution as-is.
    installDist - Installs the project as a distribution as-is.      
```

前面的输出不完整；我已经排除了不相关的任务组，如 IDE、文档等，但是您将在控制台上看到它们。在任务列表中，我们会看到`bootRun`、`bootJar`等任务。这些任务是由 Spring Boot Gradle 插件添加的，执行它们会将所需的 Spring Boot 步骤添加到构建管道中。如果您执行`./gradlew tasks --all`，您可以看到实际的任务依赖关系，它不仅会打印可见的任务，还会打印依赖的、内部的任务，以及任务依赖关系。例如，当我们运行`build`任务时，以下所有相关任务也被执行:

```java
    build - Assembles and tests this project. [assemble, check]
    assemble - Assembles the outputs of this project. [bootJar, 
    distTar, distZip, jar]

```

您可以看到,`build`任务将执行`assemble`任务，后者又将调用`bootJar`,优步 JAR 的创建实际上是在这里发生的。

该插件还提供了许多非常有用的配置选项。虽然我不打算详细介绍它们，但我会提到我认为非常有用的两个:

```java
bootJar { 
  classifier = 'exec' 
  baseName = 'bookpub' 
} 
```

这个配置允许我们指定可执行 JAR 文件`classifier`，以及 JAR `baseName`，允许常规 JAR 只包含应用代码和名称中带有`classifier`的可执行 JAR，`bookpub-0.0.1-SNAPSHOT-exec.jar`。

另一个有用的配置选项允许我们指定哪些依赖关系 jar 需要解包，因为出于某种原因，它们不能作为嵌套的内部 jar 包含在内。当您需要在系统`Classloader`中提供一些东西时，例如通过启动系统属性设置一个自定义`SecurityManager`，这非常方便:

```java
bootJar { 
  requiresUnpack = '**/some-jar-name-*.jar' 
} 
```

在本例中，当应用启动时，`some-jar-name-1.0.3.jar`依赖项的内容将被解压到文件系统上的一个临时文件夹中。

# 创建 Docker 图像

DockerDockerDocker。在我参加的所有会议和技术会议中，我越来越多地听到这个短语。Docker 的到来受到了社区的热烈欢迎，并立即成为热门。Docker 生态系统一直在快速扩张，许多其他公司提供服务、支持和补充框架，例如 **Apache Mesos** 、Amazon Elastic Beanstalk、ECS 和 Kubernetes 等等。甚至微软也在他们的 Azure 云服务中提供 Docker 支持，并与 Docker 合作将 Docker 引入 Windows 操作系统。

Docker 大受欢迎的原因在于它能够以自包含容器的形式打包和部署应用。这些容器比传统的成熟虚拟机更加轻量级。多个虚拟机可以在单个操作系统实例上运行，因此与传统虚拟机相比，可以在同一硬件上部署的应用数量增加了。

在这个菜谱中，我们将看看如何将我们的 Spring Boot 应用打包成 Docker 映像，以及如何部署和运行它。

构建 Docker 映像并在您的开发机器上运行它是可行的，但不如与世界共享有趣。您需要将它发布到某个地方以便部署，特别是如果您想在 Amazon 或其他类似云的环境中使用它。幸运的是，Docker 不仅为我们提供了容器解决方案，还提供了一个存储库服务，Docker Hub，位于[https://hub.docker.com](https://hub.docker.com)，在这里我们可以创建存储库并发布我们的 Docker 图像。所以把它想象成 Docker 的 Maven Central。

# 怎么做...

1.  第一步将是在 Docker Hub 上创建一个帐户，以便我们可以发布我们的图像。前往[https://hub.docker.com](https://hub.docker.com)创建一个账户。您也可以使用您的 GitHub 帐户，并使用它登录(如果您有)。
2.  一旦您有了一个帐户，我们将需要创建一个名为`springbootcookbook`的存储库。
3.  创建了这个帐户后，现在是构建映像的时候了。为此，我们将使用一个 Gradle Docker 插件。我们将从更改`build.gradle`开始，通过以下更改修改`buildscript`块:

```java
buildscript { 
  dependencies { 
    classpath("org.springframework.boot:spring-boot-gradle- 
      plugin:${springBootVersion}") 
    classpath("se.transmode.gradle:gradle-docker:1.2") 
  } 
} 
```

4.  我们还需要通过将`apply plugin: 'docker'`指令添加到`build.gradle`文件来应用这个插件。
5.  我们还需要显式地将`application`插件添加到`build.gradle`中，因为它不再自动包含在 Spring Boot Gradle 插件中。
6.  将`apply plugin: 'application'`添加到`build.gradle`文件的插件列表中。
7.  最后，我们还需要将以下 Docker 配置添加到`build.gradle`文件中:

```java
task distDocker(type: Docker,  
                overwrite: true,  
                dependsOn: bootDistTar) { 
    group = 'docker' 
    description = "Packs the project's JVM application
    as a Docker image." 

    inputs.files project.bootDistTar 
    def installDir = "/" + project.bootDistTar.archiveName  
                         - ".${project.bootDistTar.extension}" 

    doFirst { 
        tag "ch6" 
        push false 
        exposePort 8080 
        exposePort 8443 
        addFile file("${System.properties['user.home']}
        /.keystore"), "/root/" 
        applicationName = project.applicationName 
        addFile project.bootDistTar.outputs.files.singleFile 

        entryPoint = ["$installDir/bin/${project.applicationName}"] 
    } 
} 
```

8.  假设您的机器上已经安装了 Docker，我们可以通过执行`./gradlew clean distDocker`来创建映像。

9.  有关 Docker 安装说明，请访问位于[https://docs.docker.com/installation/#installation](https://docs.docker.com/installation/#installation)的教程。如果一切正常，您应该会看到以下输出:

```java
> Task :distDocker
Sending build context to Docker daemon  68.22MB
  Step 1/6 : FROM aglover/java8-pier
   ---> 3f3822d3ece5
  Step 2/6 : EXPOSE 8080
   ---> Using cache
   ---> 73717aaca6f3
  Step 3/6 : EXPOSE 8443
   ---> Using cache
   ---> 6ef3c0fc3d2a
  Step 4/6 : ADD .keystore /root/
   ---> Using cache
   ---> 6efebb5a868b
  Step 5/6 : ADD ch6-boot-0.0.1-SNAPSHOT.tar /
   ---> Using cache
   ---> 0634eace4952
  Step 6/6 : ENTRYPOINT /ch6-boot-0.0.1-SNAPSHOT/bin/ch6
   ---> Using cache
   ---> 39a853b7ddbb
  Successfully built 39a853b7ddbb
  Successfully tagged ch6:0.0.1-SNAPSHOT

  BUILD SUCCESSFUL
  Total time: 1 mins 0.009 secs. 
```

10.  我们还可以执行以下 Docker images 命令来查看新创建的图像:

```java
$ docker images
REPOSITORY           TAG                IMAGE ID         CREATED             VIRTUAL  SIZE
ch6                  0.0.1-SNAPSHOT     39a853b7ddbb     17 minutes ago      1.04 GB
aglover/java8-pier   latest             69f4574a230e     11 months ago       1.01 GB
```

11.  成功构建映像后，我们现在可以通过执行以下命令在 Docker 中启动它了:

```java
docker run -d -P ch6:0.0.1-SNAPSHOT.  
```

12.  容器启动后，我们可以查询 Docker 注册中心的端口绑定，这样我们就可以访问服务的 HTTP 端点。这可以通过`docker ps`命令来完成。如果容器运行成功，我们应该会看到以下结果(名称和端口会有所不同):

```java
    CONTAINER ID        IMAGE               COMMAND               
    CREATED             STATUS              PORTS                                                  
    NAMES
    37b37e411b9e        ch6:latest         "/ch6-boot-0.0.1-S..." 
    10 minutes ago      Up 10 minutes       0.0.0.0:32778-
    >8080/tcp,      0.0.0.0:32779->8443/tcp   drunk_carson

```

13.  从这个输出中，我们可以看出内部端口`8080`的端口映射已经被设置为`32778`(您的端口将在每次运行时发生变化)。让我们在浏览器中打开`http://localhost:32778/books`,看看我们的应用的运行情况，如下图所示:

![](img/425c27f4-c4c1-4e8e-876e-c45ddf26145f.png)

如果你使用的是带有`boot2docker`的 macOS X，那么你不会在本地运行 Docker 容器。在这个场景中，您将使用`boot2docker ip`而不是本地主机来连接应用。关于如何使`boot2docker`集成更容易的更多提示，请访问[http://viget . com/extend/how-to-use-docker-on-OS-x-the-missing-guide](http://viget.com/extend/how-to-use-docker-on-os-x-the-missing-guide)。还可以使用由 Ian Sinnott 创建的一个漂亮的 Docker 外观，它将自动启动 boot2docker 并处理环境变量。要获取包装纸，请前往[https://gist.github.com/iansinnott/0a0c212260386bdbfafb](https://gist.github.com/iansinnott/0a0c212260386bdbfafb)。

# 它是如何工作的...

在前面的例子中，我们看到让我们的`build`将应用打包到 Docker 容器中是多么容易。额外的 Gradle-Docker 插件完成了`Dockerfile`创建、图像构建和发布的大部分工作；我们所要做的就是给它一些指令，告诉它我们想要的图像是什么样的，以及怎样的。因为 Spring Boot Gradle 插件使用了一个`boot`发行版，Gradle-Docker 插件不知道它需要使用一个引导的 TAR 存档。为此，我们覆盖了`distDocker`任务。让我们详细检查一下这些指令:

*   当执行`./gradlew tasks`命令时，`group`和`description`属性仅仅帮助正确显示任务。
*   指令非常重要。这就是指示`distDocker`任务使用由 Spring Boot 发行版创建的 TAR 归档文件，而不是通用归档文件的原因。
*   `def installDir = "/" + project.bootDistTar.archiveName - ".${project.bootDistTar.extension}"`指令创建了一个变量，其中包含了 Docker 容器中放置未加星号的工件的目录。
*   `exposePort`指令告诉插件向 Dockerfile 添加一个`EXPOSE <port>`指令，这样当我们的容器启动时，它将通过端口映射向外部公开这些内部端口。我们在运行`docker ps`命令时看到了这个映射。
*   `addFile`指令告诉插件向 Dockerfile 添加一个`ADD <src> <dest>`指令，这样当构建容器时，我们将从源文件系统复制文件到容器映像的文件系统中。在我们的例子中，我们将需要复制我们在之前的一个秘籍中为 HTTPS 连接器配置的`.keystore`证书文件，我们在`tomcat.https.properties`中指示从`${user.home}/.keystore`加载该文件。现在，我们需要它在`/root/ directory`目录中，因为在容器中，我们的应用将在根目录下执行。(这可以通过更多配置来改变。)

默认情况下，Gradle-Docker 插件使用项目名称作为图像的名称。除非配置了明确的属性值，否则 Gradle 会从项目的目录名中推断出项目名称。由于代码示例为[第六章](6.html)、*应用打包部署*项目目录命名为`ch6`，因此图像的名称。可以通过在`gradle.properties`中添加`name='some_project_name'`来明确配置项目名称。

如果您查看生成的 docker 文件(可以在项目根目录下的`build/docker/`目录中找到),您会看到以下两条指令:

```java
ADD ch6-boot-0.0.1-SNAPSHOT.tar / 
ENTRYPOINT ["/ch6-boot-0.0.1-SNAPSHOT/bin/ch6"] 
```

`ADD`指令添加了由`bootDistTar`任务生成的 TAR 应用档案，其中包含了我们打包成一个 tarball 的应用。我们甚至可以通过执行`tar tvf build/distributions/ch6-boot-0.0.1-SNAPSHOT.tar`看到生成的 tarball 的内容。在构建容器的过程中，TAR 文件的内容将被提取到容器中的`/`目录中，稍后用于启动应用。

其后是`ENTRYPOINT`指令。这告诉 Docker，一旦容器启动，就执行`/ch6-boot-0.0.1-SNAPSHOT/bin/ch6`，我们将它视为 tarball 内容的一部分，从而自动启动我们的应用。

docker 文件中的第一行是`FROM aglover/java8-pier`，是使用`aglover/java8-pier`映像的指令，它包含安装了 Java 8 的 Ubuntu OS 作为我们容器的基础映像，我们将在其上安装我们的应用。该图像来自 Docker Hub 存储库，由插件自动使用，但如果需要，可以通过配置设置进行更改。

如果您在 Docker Hub 上创建了一个帐户，我们也可以将创建的 Docker 映像发布到注册表。作为一个公平的警告，生成的图像可能有几百兆大小，所以上传它可能需要一些时间。为了发布这个图像，我们需要将标签改为`tag "<docker hub username>/<docker hub repository name>"`，并将`push true`设置添加到`build.gradle`中的`distDocker`任务定义中:

```java
task distDocker(type: Docker,  
                overwrite: true,  
                dependsOn: bootDistTar) { 
    ... 
    doFirst { 
        tag "<docker hub username>/<docker hub repository name>" 
        push true 
        ... 
    } 
} 
```

属性设置创建的图像标签，默认情况下，插件假设它位于 Docker Hub 存储库中。如果`push`配置被设置为`true`，它将在这里发布它，就像我们的例子一样。

关于所有 Gradle-Docker 插件配置选项的完整列表，请看一下[https://github.com/Transmode/gradle-docker](https://github.com/Transmode/gradle-docker)GitHub 项目页面。

当启动 Docker 映像时，我们使用`-d`和`-P`命令行参数。它们的用途如下:

*   `-d`:该参数表示希望以分离模式运行容器，其中进程在后台启动
*   这个参数指示 Docker 向外部发布所有内部暴露的端口，以便我们可以访问它们

有关所有可能的命令行选项的详细解释，请参考[https://docs.docker.com/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)。

# 构建自动执行的二进制文件

从 Spring Boot 1.3 版开始，Gradle 和 Maven 插件支持生成真正的可执行二进制文件。这些看起来像普通的 JAR 文件，但是将 JAR 的内容与包含命令构建逻辑的启动脚本融合在一起，并且能够在不需要显式执行`java -jar file.jar`命令的情况下自行启动。这个功能非常方便，因为它允许简单地配置 Linux 自动启动服务，如 macOS X 上的`init.d`或`systemd`和`launchd`

# 做好准备

对于这个菜谱，我们将使用我们现有的应用构建。我们将研究如何创建自启动的可执行 JAR 文件，以及如何修改缺省启动脚本来添加对定制 JVM 启动参数的支持，例如`-D`启动系统属性、JVM 内存、垃圾收集和其他设置。

对于该秘籍，确保`build.gradle`使用的是 Spring Boot 版本 2.0.0 或更高版本。如果不是，则在`buildscript`配置块中更改以下设置:

```java
ext { 
  springBootVersion = '2.0.0.BUILD-SNAPSHOT' 
} 
```

Spring Boot 版本的相同升级也应该在`db-counter-starter/build.gradle`文件中完成。

# 怎么做...

1.  构建一个默认的自执行 JAR 文件非常容易；实际上，一旦我们执行了`./gradlew clean bootJar`命令，它就会自动完成。
2.  我们可以简单地通过调用`./build/libs/bookpub-0.0.1-SNAPSHOT.jar`来启动创建的应用。

3.  在企业环境中，我们很少对默认的 JVM 启动参数感到满意，因为我们经常需要调整内存设置、GC 配置，甚至传递启动系统属性，以确保我们使用的是所需版本的 XML 解析器或类加载器或安全管理器的专有实现。为了满足这些需求，我们将修改默认的`launch.script`文件来添加对 JVM 选项的支持。让我们首先从项目根目录下的[https://GitHub . com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/spring framework/boot/loader/tools/launch . script](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script)Spring Boot GitHub 资源库中复制默认的`launch.script`文件。

仅在 Linux 和 OS X 环境中支持`launch.script`文件。如果您想为 Windows 开发自动执行的 jar，您需要提供自己的`launch.script`文件，该文件是为 Windows shell 命令执行定制的。好消息是，这是唯一需要的特殊东西；只要使用了兼容的`launch.script`模板，这个菜谱中的所有说明和概念在 Windows 上也能很好地工作。

4.  我们将修改复制的`launch.script`文件，并在*行 142* 标记的正上方添加以下内容(这里只显示了脚本的相关部分，以节省空间):

```java
...
# Find Java
if [[ -n "$JAVA_HOME" ]] &amp;&amp; [[ -x "$JAVA_HOME/bin/java" ]]; then
javaexe="$JAVA_HOME/bin/java"
elif type -p java 2>&amp;1> /dev/null; then
javaexe=java
elif [[ -x "/usr/bin/java" ]]; then
javaexe="/usr/bin/java"
else
echo "Unable to find Java"
exit 1
fi
# Configure JVM Options
jvmopts="{{jvm_options:}}"
arguments=(-Dsun.misc.URLClassPath.disableJarChecking=true $jvmopts $JAVA_OPTS -jar $jarfile $RUN_ARGS "$@")
# Action functions
start() {
...
```

5.  定制的`launch.script`文件准备就绪后，我们需要将选项设置添加到我们的`build.gradle`文件中，内容如下:

```java
applicationDefaultJvmArgs = [ 
    "-Xms128m", 
    "-Xmx256m" 
] 

bootJar { 
    classifier = 'exec' 
    baseName = 'bookpub' 
    launchScript { 
        script = file('launch.script') 
        properties 'jvm_options' : applicationDefaultJvmArgs.join(' ') 
    } 
} 
```

6.  We are now ready to launch our application. First, let's use the `./gradlew clean bootRun` command, and if we look at the JConsole VM Summary tab, we will see that our arguments indeed have been passed to the JVM, as follows:

    ![](img/dd0b250c-6176-4663-9d7f-d74644feb2fe.png)

7.  我们还可以通过运行`./gradlew clean bootJar`命令，然后执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来构建自启动的可执行 JAR，以便启动我们的应用。我们应该期待在 JConsole 中看到类似的结果。

8.  或者，我们也可以使用`JAVA_OPTS`环境变量来覆盖一些 JVM 参数。假设我们想将最小内存堆大小改为 128 兆字节。我们可以使用`JAVA_OPTS=-Xmx128m ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`命令启动我们的应用，这将向我们展示 JConsole 中的以下效果:

![](img/20ed07bc-00c6-490b-89c5-9d1e20772536.png)

# 它是如何工作的...

通过对`launch.script`的一个小的定制，我们能够创建一个自我执行的可部署应用，打包成一个自包含的 JAR 文件，除此之外，它还可以被配置为使用各种特定于操作系统的自动启动框架来启动。

Spring Boot Gradle 和 Maven 插件为我们提供了许多参数定制选项，甚至能够在`launch.script`中嵌入类似小胡子的模板占位符，这些占位符稍后可以在构建时替换为值。我们利用这个功能，通过使用`launchScript{properties}`配置设置将我们的 JVM 参数注入到文件中。

在我们的定制版本`launch.script`中，我们添加了`jvmopts="{{jvm_options:}}"`行，在构建和打包期间，它将被替换为`jvm_options`参数的值。这个参数在我们的`build.gradle`文件中被声明为`launchScript.properties`参数`: launchScript{properties 'jvm_options' : applicationDefaultJvmArgs.join(' ')}`的值。

JVM 参数可以硬编码，但是最好保持应用开始使用`bootRun`任务的方式和从自执行 JAR 启动时的方式之间的一致性。为了实现这一点，我们将使用为`bootRun`执行目的定义的相同的`applicationDefaultJvmArgs`参数集合，只是所有不同的参数都折叠在一行文本中，由空格分隔。使用这种方法，我们只需定义一次 JVM 参数，并在两种执行模式下使用它们。

值得注意的是，这种重用也适用于使用 Gradle 的`application`插件定义的`distZip`和`distTar`任务构建的应用发行版，以及 Spring Boot·grad le 的`bootDistZip`和`bootDistTar`。

我们可以修改构建来创建 Docker 映像，方法是启动我们的自执行 JAR，而不是默认情况下由`distTar`任务生成的 TAR 文件的内容。为此，我们需要使用以下代码来更改我们的`distDocker`配置块:

```java
task distDocker(type: Docker, overwrite: true, 
                dependsOn: bootJar) { 
  ... 
  inputs.files project.bootJar 
  doFirst { 
    ... 
    addFile file("${System.properties['user.home']}/.keystore"), 
       "/root/" 
    applicationName = project.applicationName 
    addFile project.bootJar.outputs.files.singleFile 

    def executableName = "/" + 
       project.bootJar.outputs.files.singleFile.name 
    entryPoint = ["$executableName"] 
  } 
} 
```

这将使我们的`distDocker`任务把可执行的 jar 放在 Docker 映像中，而不是 TAR 归档中。

# Spring Boot 环境配置、层次结构和优先级

在前面的几个秘籍中，我们研究了如何以多种方式打包我们的应用，以及如何部署它。下一个逻辑步骤是需要配置应用，以便提供一些行为控制以及一些特定于环境的配置值，这些值可能并且很可能会因环境而异。

这种环境配置差异的一个常见例子是数据库设置。我们当然不希望连接到一个在我们的开发机器上运行应用的生产环境数据库。也有这样的情况，我们希望应用在不同的模式下运行，或者使用不同的配置文件集，正如 Spring 所提到的。一个例子是以实时或模拟器模式运行应用。

对于这个秘籍，我们将从代码库的先前状态开始，添加对不同配置文件的支持，并研究如何在其他属性中使用属性值作为占位符。

# 怎么做...

1.  我们将从添加一个`@Profile`注释到`schedulerRunner`的`@Bean`创建开始，将位于我们项目根目录下`src/main/java/org/test/bookpub`目录中的`BookPubApplication.java`中`schedulerRunner(...)`方法的定义修改为以下内容:

```java
@Bean 
@Profile("logger") 
public StartupRunner schedulerRunner() { 
    return new StartupRunner(); 
} 
```

2.  通过运行`./gradlew clean bootRun`启动应用。
3.  一旦应用开始运行，我们就不会再看到之前来自`StartupRunner`类的日志输出，如下所示:

```java
2017-12-17 --- org.test.bookpub.StartupRunner : Number of books: 1
```

4.  现在，让我们通过运行`./gradlew clean bootJar`来构建应用，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`来启动它；我们将再次看到日志输出行。
5.  配置文件选择器支持的另一个功能是添加特定于配置文件的属性文件。让我们在项目根目录下的`src/main/resources`目录中创建一个`application-inmemorydb.properties`文件，内容如下:

```java
spring.datasource.url = jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE 
```

6.  让我们通过运行`./gradlew clean bootJar`来构建应用，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger,inmemorydb`来启动它，这将使用`inmemorydb`概要文件配置，以便使用内存数据库而不是基于文件的数据库。

# 它是如何工作的...

在这个菜谱中，我们尝试使用概要文件，并根据活动的概要文件应用附加的配置设置。概要文件最早是在 Spring Framework 3.2 中引入的，用于根据哪些概要文件是活动的，有条件地配置上下文中的 beans。在 Spring Boot，这个设施被进一步扩展，以允许配置分离。

通过在我们的`StartupRunner@Bean`创建方法上放置一个`@Profile("logger")`注释，Spring 将被指示只有在 logger 配置文件被激活时才创建 bean。通常，这是通过在应用启动时在命令行中传递`--spring.profiles.active`选项来完成的。在测试中，可以做到这一点的另一种方法是在`Test`类上使用`@ActiveProfiles("profile")`注释，但是它不支持普通应用的执行。也可以否定`@Profile("!production")`等轮廓。当使用这样的注释时(用`!`标记否定)，只有当没有配置文件生产活动时，才会创建 bean。

在启动过程中，Spring Boot 将所有通过命令行传递的选项都视为应用属性，因此启动过程中传递的任何内容最终都将作为可以使用的属性值。这种相同的机制不仅适用于新属性，也可以用作覆盖现有属性的一种方式。让我们想象这样一种情况，我们已经在我们的`application.properties`文件中定义了一个活动概要文件，看起来像这样:`spring.profiles.active=basic`。通过命令行传递`--spring.profiles.active=logger`选项，我们将把激活的概要文件从`basic`替换为`logger`。如果我们想包括一些配置文件而不考虑激活的配置，Spring Boot 给了我们一个`spring.profiles.include`选项来配置。任何以这种方式设置的配置文件都将被添加到活动配置文件列表中。

由于这些选项只不过是常规的 Spring Boot 应用属性，因此它们都遵循相同的覆盖优先级层次结构。这些选择概述如下:

*   **命令行参数**:这些值取代列表中的所有其他属性源，您可以放心，通过`--property.name=value`传递的任何内容都将优先于其他方式。
*   **JNDI 属性**:他们是下一个优先级。如果您使用通过 JNDI `java:comp/env`名称空间提供数据的应用容器，这些值将覆盖下面的所有其他设置。
*   **Java 系统属性**:这些值是通过`-Dproperty=name`命令行参数或者通过在代码中调用`System.setProperty(...)`将属性传递给应用的另一种方式。它们提供了替换现有属性的另一种方式。任何来自`System.getProperty(...)`的消息都会赢得名单中其他人的支持。
*   **OS 环境变量**:无论是来自 Windows、Linux、OS X 还是其他，它们都是指定配置的常用方式，尤其是对于位置和值。最值得注意的一个是`JAVA_HOME`，这是指示 JVM 在文件系统中的位置的常用方法。如果上述设置都不存在，则`ENV`变量将用于属性值，而不是下面提到的那些:

由于操作系统环境变量通常不支持点(`.`)或破折号(`-`)，Spring Boot 提供了一种自动重新映射机制，在属性评估期间用点(`.`)替换下划线(`_`)；它还处理大小写转换。因此，`JAVA_HOME`成为了`java.home`的同义词。

*   `random.*`:这为可以在配置属性中用作占位符的原始类型的随机值提供了特殊支持。例如，我们可以定义一个名为`some.number=${random.int}`的属性，其中`${random.int}`将被某个随机整数值替换。文本值的`${random.value}`和长整型的`${random.long}`也是如此。
*   `application-{profile}.properties`:它们是配置文件特定的文件，仅当相应的配置文件被激活时才被应用。
*   `application.properties`:它们是包含基本/默认应用配置的主要属性文件。与特定于配置文件的值类似，这些值可以从以下位置列表中加载，最高的值优先于较低的值:
    *   `file:config/`:这是位于当前目录下的`/config`目录；
    *   `file:`:这是当前目录
    *   `classpath:/config`:这是类路径中的一个`/config`包
    *   `classpath:`:这是类路径的根目录
*   用@PropertySource 注释的@Configuration 注释类:这些是已经使用注释配置的任何代码内属性源。我们已经在[第三章](3.html)、 *Web 框架行为调优*中看到了这种用法的一个例子*添加定制连接器*。它们在优先级链中处于非常低的位置，并且仅位于默认属性之前。
*   **默认属性**:它们是通过`SpringApplication.setDefaultProperties(...)`调用配置的，很少使用，因为感觉很像代码中的硬编码值，而不是在配置文件中具体化它们。

# 使用 EnvironmentPostProcessor 将自定义属性源添加到环境中

如果企业已经在使用定制的或现成的特定配置系统，Spring Boot 为我们提供了一种工具，通过创建定制的`PropertySource`实现将其集成到应用中。

# 怎么做...

假设我们有一个现有的配置设置，它使用一个流行的 Apache Commons 配置框架，并将配置数据存储在 XML 文件中:

1.  为了模仿我们假设的预先存在的配置系统，将以下内容添加到`build.gradle`文件的依赖关系部分:

```java
dependencies { 
  ... 
  compile project(':db-count-starter') 
  compile("commons-configuration:commons-
     configuration:1.10") 
  compile("commons-codec:commons-codec:1.6") 
  compile("commons-jxpath:commons-jxpath:1.3") 
  compile("commons-collections:commons-collections:3.2.1") 
  runtime("com.h2database:h2") 
  ... 
} 
```

2.  接下来，在我们项目的根目录下的`src/main/resources`目录中创建一个名为`commons-config.xml`的简单配置文件，其内容如下:

```java
<?xml version="1.0" encoding="ISO-8859-1" ?> 
<config> 
  <book> 
    <counter> 
      <delay>1000</delay> 
      <rate>${book.counter.delay}0</rate> 
    </counter> 
  </book> 
</config> 
```

3.  接下来，我们将在我们项目的根目录下的`src/main/java/org/test/bookpub`目录中创建名为`ApacheCommonsConfigurationPropertySource.java`的`PropertySource`实现文件，其内容如下:

```java
public class ApacheCommonsConfigurationPropertySource 
   extends EnumerablePropertySource<XMLConfiguration> { 
  private static final Log logger = LogFactory.getLog(
   ApacheCommonsConfigurationPropertySource.class); 

  public static final String 
     COMMONS_CONFIG_PROPERTY_SOURCE_NAME = "commonsConfig"; 

  public ApacheCommonsConfigurationPropertySource(
     String name, XMLConfiguration source) { 
    super(name, source); 
  } 

  @Override 
  public String[] getPropertyNames() { 
    ArrayList<String> keys = 
       Lists.newArrayList(this.source.getKeys()); 
    return keys.toArray(new String[keys.size()]); 
  } 

  @Override 
  public Object getProperty(String name) { 
    return this.source.getString(name); 
  } 

  public static void addToEnvironment(
     ConfigurableEnvironment environment, XMLConfiguration 
       xmlConfiguration) { 
    environment.getPropertySources().addAfter(
      StandardEnvironment.
        SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, new 
          ApacheCommonsConfigurationPropertySource( 
           COMMONS_CONFIG_PROPERTY_SOURCE_NAME, 
             xmlConfiguration)); 
    logger.trace("ApacheCommonsConfigurationPropertySource 
      add to Environment"); 
  } 
} 
```

4.  我们现在将创建`EnvironmentPostProcessor`实现类，以便在项目根目录下的`src/main/java/org/test/bookpub`目录中引导名为`ApacheCommonsConfigurationEnvironmentPostProcessor.java`的`PropertySource`,内容如下:

```java
package com.example.bookpub;

import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.XMLConfiguration;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.env.ConfigurableEnvironment;

public class ApacheCommonsConfigurationEnvironmentPostProcessor  
       implements EnvironmentPostProcessor {

    @Override
    public void postProcessEnvironment( 
                   ConfigurableEnvironment environment,  
                   SpringApplication application) {
        try {
            ApacheCommonsConfigurationPropertySource 
               .addToEnvironment(environment,
                    new XMLConfiguration("commons- 
                                         config.xml"));
        } catch (ConfigurationException e) {
            throw new RuntimeException("Unable to load commons-config.xml", e);
        }
    }
} 
```

5.  最后，我们需要在项目根目录下的`src/main/resources`目录中创建一个名为`META-INF`的新目录，并在其中创建一个名为`spring.factories`的文件，内容如下:

```java
# Environment Post Processors
org.springframework.boot.env.EnvironmentPostProcessor=\
com.example.bookpub.ApacheCommonsConfigurationEnvironmentPostProcessor 
```

6.  设置完成后，我们现在可以在应用中使用新的属性了。让我们为位于项目根目录下的`src/main/java/org/test/bookpub`目录中的`StartupRunner`类更改`@Scheduled`注释的配置，如下所示:

```java
@Scheduled(initialDelayString = "${book.counter.delay}", 
   fixedRateString = "${book.counter.rate}") 
```

7.  让我们通过运行`./gradlew clean bootJar`来构建应用，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`来启动它，以确保我们的`StartupRunner`类仍然像预期的那样，每十秒记录一次图书数量。

# 它是如何工作的...

在这个菜谱中，我们探索了如何添加我们自己的定制`PropertySource`,使我们能够在 Spring Boot 环境中桥接现有系统。让我们来看看这些部分是如何组合在一起的。

在上一节中，我们学习了不同的配置定义是如何堆叠的，以及使用了什么规则来将它们重叠在一起。这将有助于我们更好地理解使用定制的`PropertySource`实现来桥接 Apache Commons 配置是如何工作的。(这不应该与`@PropertySource`注释混淆！)

在[第 4 章](4.html)、*编写定制 Spring Boot 启动器*中，我们学习了`spring.factories`的用法，因此我们已经知道这个文件用来定义在应用启动时 Spring Boot 应该自动合并的类。这次唯一的不同是，我们将配置`SpringApplicationRunListener`设置，而不是配置`EnableAutoConfiguration`设置。

我们创建了以下两个类来支持我们的需求:

*   `ApacheCommonsConfigurationPropertySource`:这是`EnumerablePropertySource`基类的扩展，它为您提供了内部功能，以便通过提供转换将 XMLConfiguration 从 Apache Commons 配置连接到 Spring Boot 世界，通过`getProperty(String name)`实现按名称获取特定的属性值，通过`getPropertyNames()`实现获取所有受支持的属性名称的列表。在您处理可用属性名称的完整列表未知或者计算起来非常昂贵的用例的情况下，您可以只扩展`PropertySource`抽象类，而不使用`EnumerablePropertySource`。
*   `ApacheCommonsConfigurationEnvironmentPostProcessor`:这是`EnvironmentPostProcessor`接口的实现，该接口在应用启动期间由 Spring Boot 实例化，并在初始环境初始化完成之后、应用上下文启动之前接收通知回调。该类在`spring.factories`配置，由 Spring Boot 自动创建。

在我们的后处理器中，我们实现了`postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application)`方法，该方法允许我们访问`ConfigurableEnvironment`实例。当这个回调被调用时，我们将获得一个环境实例，该实例已经填充了前面层次结构中的所有属性。然而，我们将有机会在列表中的任何地方注入我们自己的`PropertySource`实现，我们将在`ApacheCommonsConfigurationPropertySource.addToEnvironment(...)`方法中成功地做到这一点。

在我们的例子中，我们将选择将我们的源按照优先级顺序插入到`systemEnvironment`的正下方，但是如果需要的话，我们可以将这个顺序更改为我们想要的最高优先级。只是注意不要把它放得太高，以至于您的属性无法通过命令行参数、系统属性或环境变量来覆盖。

# 使用属性文件外部化环境配置

上一个方法告诉了我们应用属性以及它们是如何配置的。正如本章开始时提到的，在应用部署期间，几乎不可避免地会有一些依赖于环境的属性值。它们可以是数据库配置、服务拓扑，甚至是简单的功能配置，其中某些东西可能在开发中启用，但还没有准备好投入生产。

在这个菜谱中，我们将学习如何为特定于环境的配置使用外部驻留的属性文件，该文件可能驻留在本地文件系统中，也可能驻留在互联网上。

在这个秘籍中，我们将使用与上一个秘籍中相同的应用和所有现有的配置。我们将使用它来试验使用本地文件系统中的外部配置属性从一个 internet URL(比如 GitHub 或任何其他 URL)启动。

# 怎么做...

1.  让我们从添加一些代码来记录我们的特定配置属性的值开始，这样我们就可以在做不同的事情时很容易地看到它的变化。向位于我们项目根目录下的`src/main/java/org/test/bookpub`目录中的`BookPubApplication`类添加一个`@Bean`方法，内容如下:

```java
@Bean 
public CommandLineRunner configValuePrinter(
   @Value("${my.config.value:}") String configValue) { 
  return args -> LogFactory.getLog(getClass()).
     info("Value of my.config.value property is: " + 
       configValue); 
} 
```

2.  让我们通过运行`./gradlew clean bootJar`来构建应用，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`来启动它，以便看到下面的日志输出:

```java
    2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of 
    my.config.value property is:

```

3.  如我们所料，该值为空。接下来，我们将在我们的家中直接创建一个名为`external.properties`的文件，其内容如下:

```java
my.config.value=From Home Directory Config

```

4.  让我们通过执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger --spring.config.location=file:/home/<username>/external.properties`来运行我们的应用，以便在日志中看到以下输出:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Home Directory Config

```

对于 macOS 用户，主目录可以在`/Users/<username>`文件夹中找到。

5.  我们也可以将文件作为 HTTP 资源加载，而不是从本地文件系统加载。因此，在 web 上的某个地方放置一个名为`external.properties`的文件，其内容为`my.config.value=From HTTP Config`。它甚至可以在 GitHub 或 BitBucket 存储库中进行检查，只要它不需要任何身份验证就可以访问。
6.  让我们通过执行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger --spring.config.location=http://<your file location path>/external.properties`来运行我们的应用，以便在日志中看到以下输出:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From HTTP Config

```

# 它是如何工作的...

在深入研究外部配置设置的细节之前，让我们快速查看一下为了在日志中打印属性值而添加的代码。焦点元素是可用于类字段或方法参数的`@Value`注释；它还指示 Spring 用注释中定义的值自动注入带注释的变量。如果该值位于以美元符号(`${ }`)为前缀的花括号中，Spring 将通过在冒号(`:`)后添加文本数据，用相应应用属性中的值或缺省值(如果提供)来替换它。

在我们的例子中，我们将其定义为`@Value("${my.config.value:}")String configValue`，所以除非名为`my.config.value`的应用属性存在，否则空字符串的默认值将被赋给`configValue`方法参数。这种构造非常方便，消除了仅仅为了获取特定属性值而显式连接环境对象实例的需要，还简化了测试期间的代码，减少了要模仿的对象。

支持指定应用属性配置文件的位置是为了支持动态的多种环境拓扑，尤其是在云环境中。当编译后的应用被捆绑到不同的云映像中时，通常会出现这种情况，这些云映像将用于不同的环境，并由部署工具(如 Packer、vagger 等)专门组装。

在这种情况下，在制作映像时将配置文件放到映像文件系统中是很常见的，这取决于它的目标环境。Spring Boot 提供了一种非常方便的能力，可以通过命令行参数指定应该添加到应用配置包中的配置属性文件所在的位置。

使用`--spring.config.location`启动选项，我们可以指定一个或多个文件的位置，然后用逗号(`,`)将它们分隔开，添加到默认文件中。文件指定可以是本地文件系统、类路径或远程 URL 中的文件。位置将由`DefaultResourceLoader`类解析，或者，如果通过`SpringApplication`构造器或设置器配置，则由`SpringApplication`实例提供的实现解析。

如果该位置包含目录，名称应该以`/`结尾，以便让 Spring Boot 知道它应该在这些目录中查找`application.properties`文件。

如果你想改变文件的默认名称，Spring Boot 也为你提供了这种能力。只需将`--spring.config.name`选项设置为您想要的文件名。

重要的是要记住，无论`--spring.config.location`设置是否存在，都将始终使用`classpath:,classpath:/config,file:,file:config/`配置的默认搜索路径。这样，你可以在`application.properties`中一直保留你的默认配置，只需通过启动设置覆盖你需要的配置。

# 使用环境变量外部化环境配置

在前面的秘籍中，我们已经多次提到，Spring Boot 应用的配置值可以通过使用操作系统环境变量来传递和覆盖。操作系统依靠这些变量来存储各种信息。我们可能需要设置几次`JAVA_HOME`或`PATH`，这些都是环境变量的例子。如果使用 PaaS 系统(如 Heroku 或 Amazon AWS)部署应用，操作系统环境变量也是一个非常重要的特性。在这些环境中，数据库访问凭证和各种 API 令牌等配置值都是通过环境变量提供的。

它们的强大之处在于能够将简单的键-值数据对的配置完全外部化，而不需要依赖于将属性或其他一些文件放在特定的位置，并将其硬编码在应用代码库中。这些变量对于特定的操作系统来说也是不可知的，并且可以以同样的方式在 Java 程序中被使用，不管程序运行在哪个操作系统上。

在这个菜谱中，我们将探索如何利用这种能力将配置属性传递给我们的 Spring Boot 应用。我们将继续使用上一个方法中的代码库，并尝试一些不同的方法来启动应用和使用 OS 环境变量，以便更改一些属性的配置值。

# 怎么做...

1.  在前面的秘籍中，我们添加了一个名为`my.config.value`的配置属性。让我们通过运行`./gradlew clean bootJar`来构建应用，并通过运行`MY_CONFIG_VALUE="From ENV Config" ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger`来启动它，以便在日志中看到以下输出:

```java
    2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of 
    my.config.value property is: From ENV Config
```

2.  如果我们想在通过 Gradle `bootRun`任务运行我们的应用时使用环境变量，命令行将是`MY_CONFIG_VALUE="From ENV Config" ./gradlew clean bootRun`，并且应该产生与上一步相同的输出。
3.  非常方便的是，我们甚至可以混合和匹配如何设置配置。我们可以使用环境变量来配置`spring.config.location`属性，并使用它从外部属性文件中加载其他属性值，就像我们在前面的秘籍中所做的那样。让我们通过执行`SPRING_CONFIG_LOCATION= file:/home/<username>/external.properties ./gradlew bootRun`来启动我们的应用。我们应该在日志中看到以下内容:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of 
my.config.value property is: From Home Directory Config

```

虽然使用环境变量非常方便，但是如果这些变量的数量太多，就会产生维护开销。为了帮助解决这个问题，最好使用一种委托方法，通过设置`SPRING_CONFIG_LOCATION`变量来配置特定于环境的属性文件的位置，通常是通过从 URL 位置加载它们。

# 它是如何工作的...

正如您从环境配置层次结构一节中了解到的，Spring Boot 提供了多种方式来提供配置属性。每一个都通过适当的`PropertySource`实现来管理。当我们实现`ApacheCommonsConfigurationPropertySource`时，我们看了如何创建一个自定义的`PropertySource`实现。Spring Boot 已经提供了一个`SystemEnvironmentPropertySource`实现供我们开箱即用。这甚至会自动注册到环境接口的默认实现:`SystemEnvironment`。

由于`SystemEnvironment`实现在众多不同的`PropertySource`实现之上提供了一个复合外观，覆盖无缝地发生，仅仅是因为`SystemEnvironmentPropertySource`类在列表中比`application.properties`文件类更靠前。

您应该注意到的一个重要方面是使用了带下划线(`_`)的`ALL_CAPS`来分隔单词，而不是使用传统的带点(`.`)的`all.lower.cased`格式来分隔在 Spring Boot 用于命名配置属性的单词。这是由于一些操作系统的性质，即 Linux 和 OS X，它们禁止在名称中使用点(`.`)，而是鼓励使用`ALL_CAPS`下划线分隔符号。

在不希望使用环境变量来指定或覆盖配置属性的情况下，Spring 为我们提供了`-Dspring.getenv.ignore`系统属性，该属性可以设置为 true 并防止使用环境变量。如果由于在某些应用服务器上运行代码或特定的安全策略配置可能不允许访问环境变量而在日志中看到错误或异常，您可能希望将此设置更改为 true。

# 使用 Java 系统属性外部化环境配置

虽然在极少数情况下，环境变量可能会被命中或错过，但是可以相信，良好的旧 Java 系统属性总是会为您提供的。除了使用以双破折号(`--`)为前缀的属性名表示的环境变量和命令行参数之外，Spring Boot 还为您提供了使用普通 Java 系统属性来设置或覆盖配置属性的能力。

这在很多情况下都很有用，特别是如果您的应用运行在一个容器中，该容器在启动时通过您想要访问的系统属性设置某些值，或者如果属性值不是通过命令行`-D`参数设置的，而是通过代码和调用`System.setProperty(...)`在某个库中设置的，特别是如果属性值是从静态方法内部访问的。虽然可以说这些情况很少，但只需要一次就能让您竭尽全力尝试将这种价值集成到您的应用中。

在这个秘籍中，我们将使用与上一个秘籍相同的应用可执行文件，唯一的区别是我们使用 Java 系统属性而不是命令行参数或环境变量来设置运行时的配置属性。

# 怎么做...

1.  让我们通过设置`my.config.value`配置属性继续我们的实验。通过运行`./gradlew clean bootJar`构建应用，并通过运行`java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`启动它，以便在日志中看到以下内容:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From System Config

```

2.  如果我们希望能够在使用 Gradle 的`bootRun`任务运行我们的应用时设置 Java 系统属性，我们需要将它添加到`build.gradle`文件中的`applicationDefaultJvmArgs`配置中。让我们将`-Dmy.config.value=Gradle`添加到这个列表中，并通过运行`./gradlew clean bootRun`来启动应用。我们应该在日志中看到以下内容:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: Gradle

```

3.  当我们将`applicationDefaultJvmArgs`设置与`launch.script`共享时，通过运行`./gradlew clean bootJar`重新构建应用，并通过运行`./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`启动它，应该会在日志中产生与上一步相同的输出。

# 它是如何工作的...

您可能已经猜到，Java 系统属性是由用于环境变量的类似机制使用的，您可能猜对了。唯一真正的区别是`PropertySource`的实现。这一次，`StandardEnvironment`使用了更通用的`MapPropertySource`实现。

您可能还注意到，需要使用`java -Dmy.config.value="From System Config" -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`命令启动我们的应用，而不是简单地调用自动执行的打包 JAR 本身。这是因为，与环境变量和命令行参数不同，Java 系统属性必须先在 Java 可执行文件上设置。

我们确实设法通过有效地硬编码我们的`build.gradle`文件中的值来解决这一需求，结合我们对`launch.script`的增强，允许我们在自执行 jar 的命令行中嵌入`my.config.value`属性，并将其用于 Gradle 的`bootRun`任务。

对配置属性使用这种方法的风险是，它将总是覆盖我们在配置的更高层中设置的值，例如`application.properties`和其他。除非您显式地构造 Java 可执行命令行，并且不使用打包的 JAR 的自启动功能，否则最好不要使用 Java 系统属性，而是考虑使用命令行参数或环境变量。

# 使用 JSON 外部化环境配置

我们已经研究了从外部添加或覆盖特定属性的值的许多不同方法，或者是通过使用环境变量、系统属性，或者是命令行参数。所有这些选项都为我们提供了很大的灵活性，但是除了外部属性文件之外，都被限制为一次只能设置一个属性。当涉及到使用属性文件时，语法并不完全适合表示嵌套的、层次化的数据结构，并且会变得有点棘手。为了避免这种情况，Spring Boot 为我们提供了一种能力，也可以向外传递 JSON 编码的内容，其中包含整个配置层次结构的设置。

在这个秘籍中，我们将使用与上一个秘籍相同的应用可执行文件，唯一的区别是使用外部 JSON 内容在运行时设置我们的配置属性。

# 怎么做...

1.  让我们通过设置`my.config.value`配置属性继续我们的实验。通过运行`./gradlew clean bootJar`构建应用，并通过运行`java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.application.json={"my":{"config":{"value":"From external JSON"}}}`启动它，以便在日志中看到以下内容:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From external JSON

```

2.  如果我们希望能够使用 Java 系统属性来设置内容，我们可以使用`-Dspring.application.json`来代替，分配相同的 JSON 内容作为值。
3.  或者，我们也可以依靠`SPRING_APPLICATION_JSON`环境变量以如下方式传递相同的 JSON 内容:

```java
SPRING_APPLICATION_JSON={"my":{"config":{"value":"From external JSON"}}} java -jar ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar --spring.profiles.active=logger 
```

# 它是如何工作的...

就像我们看到的其他配置方法一样，JSON 内容由一个专用的`EnvironmentPostProcessor`实现消费。唯一的区别是将 JSON 树扁平化成一个扁平的属性映射，以匹配点分隔的属性命名风格。在我们的例子中，`my->config->value`嵌套映射被转换成只有一个键`my.config.value`，值为`From external JSON`的平面映射。

JSON 内容的设置可以来自任何属性源，在加载时可以从环境中获得，它包含一个名为`spring.application.json`的键，该键具有有效 JSON 内容的值，并且不仅限于通过环境变量或使用`SPRING_APPLICATION_JSON`名称或 Java 系统属性来设置。

这种能力对于批量提供外部定义的、特定于环境的配置非常有用。最好的方法是通过使用机器/映像供应工具(如 Chef、Puppet、Ansible、Packer 等)在机器实例上设置`SPRING_APPLICATION_JSON`环境变量来实现。这使您能够在外部将整个配置层次结构存储在一个 JSON 文件中，然后只需设置一个环境变量，就可以在配置期间在特定机器上配置正确的内容。在该机器上运行的所有应用将在启动时自动使用它。

# 设立领事

到目前为止，我们对配置所做的一切都与本地数据集相关联。在真实的大规模企业环境中，情况并不总是这样，而是经常希望能够跨数百甚至数千个实例或机器进行大规模的配置更改。

有许多工具可以帮助您完成这项任务，在本指南中，我们将看一看在我看来脱颖而出的一种工具，它使您能够使用分布式数据存储为启动应用干净而优雅地配置环境变量。这个工具的名字叫**consult**。它是 Hashicorp 的开源产品，旨在发现和配置大型分布式基础设施中的服务。

在这个菜谱中，我们将看看如何安装和配置 Consul，并试验它提供的一些关键功能。这将使我们对下一个秘籍有必要的了解，在下一个秘籍中，我们将使用 Consul 来提供启动应用所需的配置值。

# 怎么做...

1.  根据您使用的操作系统，转到[https://consul.io/downloads.html](https://consul.io/downloads.html)并下载适当的归档文件。Consul 支持 Windows、OS X 和 Linux，所以它应该适用于大多数读者。

如果你是 OS X 用户，你可以通过运行`brew install caskroom/cask/brew-cask`然后运行`brew cask install consul`来安装 Consul。

2.  安装完成后，我们应该能够运行`consul --version`并看到以下输出:

```java
Consul v1.0.1
Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol >2 when speaking to compatible agents) 
```

3.  成功安装 Consul 后，我们应该能够通过运行`consul agent -server -bootstrap-expect 1 -data-dir /tmp/consul`命令来启动它，我们的终端窗口将显示以下内容:

```java
==> WARNING: BootstrapExpect Mode is specified as 1; this is the same as Bootstrap mode.
==> WARNING: Bootstrap mode enabled! Do not enable unless necessary
==> WARNING: It is highly recommended to set GOMAXPROCS higher than 1
==> Starting Consul agent...
==> Starting Consul agent RPC...
==> Consul agent running!
 Node name: <your machine name>'
 Datacenter: 'dc1'
 Server: true (bootstrap: true)
       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)
      Cluster Addr: 192.168.1.227 (LAN: 8301, WAN: 8302)
    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false
             Atlas: <disabled>

==> Log data will now stream in as it occurs:

 2017/12/17 20:34:43 [INFO] serf: EventMemberJoin: <your machine name> 192.168.1.227
    2017/12/17 20:34:43 [INFO] serf: EventMemberJoin: <your machine name>.dc1 192.168.1.227
 2017/12/17 20:34:43 [INFO] raft: Node at 192.168.1.227:8300 [Follower] entering Follower state
 2017/12/17 20:34:43 [INFO] consul: adding server <your machine name> (Addr: 192.168.1.227:8300) (DC: dc1)
 2017/12/17 20:34:43 [INFO] consul: adding server <your machine name>.dc1 (Addr: 192.168.1.227:8300) (DC: dc1)
 2017/12/17 20:34:43 [ERR] agent: failed to sync remote state: No cluster leader
 2017/12/17 20:34:45 [WARN] raft: Heartbeat timeout reached, starting election
 2017/12/17 20:34:45 [INFO] raft: Node at 192.168.1.227:8300 [Candidate] entering Candidate state
 2017/12/17 20:34:45 [INFO] raft: Election won. Tally: 1
 2017/12/17 20:34:45 [INFO] raft: Node at 192.168.1.227:8300 [Leader] entering Leader state
 2017/12/17 20:34:45 [INFO] consul: cluster leadership acquired
 2017/12/17 20:34:45 [INFO] consul: New leader elected: <your machine name>
 2017/12/17 20:34:45 [INFO] raft: Disabling EnableSingleNode (bootstrap)
 2017/12/17 20:34:45 [INFO] consul: member '<your machine name>' joined, marking health alive
 2017/12/17 20:34:47 [INFO] agent: Synced service 'consul'

```

4.  在 Consul 服务运行的情况下，我们可以通过运行`consul members`命令来验证它是否包含一个成员，并且应该会看到以下结果:

```java
Node                 Address        Status  Type    Build  Protocol  DC
<your_machine_name> 2.168.1.227:8301 alive  server   0.5.2     2    dc1

```

5.  虽然 Consul 还可以提供服务发现、健康检查、分布式锁等等，但是我们将把重点放在键/值服务上，因为这将用于在下一个秘籍中提供配置。因此，让我们通过执行`curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value`命令将`From Consul Config`值放入键/值存储中。

如果你用的是 Windows，你可以从[http://curl.haxx.se/download.html](http://curl.haxx.se/download.html)得到 curl。

6.  我们还可以通过运行`curl http://localhost:8500/v1/kv/bookpub/my/config/value`命令来检索数据，应该会看到以下输出:

```java
        [{"CreateIndex":20,"ModifyIndex":20,"LockIndex":0,"Key":"bookpub/my/config/value","Flags":0,"Value":"RnJvbSBDb25zdWwgQ29uZmln"}]

```

7.  我们可以通过运行`curl -X DELETE http://localhost:8500/v1/kv/bookpub/my/config/value`命令来删除这个值。
8.  为了修改现有值并将其更改为其他值，执行`curl -X PUT -d 'newval' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=20`命令。

# 它是如何工作的...

关于 Consul 如何工作以及它的键/值服务的所有可能选项的详细解释将需要一本单独的书，所以这里我们将只看基本的部分。强烈建议您在 https://consul.io/intro/getting-started/services.html 阅读领事文件。

在*步骤 3* 中，我们以服务器模式启动了 Consul 代理。它充当主要的主节点，在实际部署中，运行在各个实例上的本地代理将使用服务器节点来连接和检索数据。出于测试目的，我们将只使用这个服务器节点，就像它是一个本地代理一样。

启动时显示的信息告诉我们，我们的节点已经作为一个服务器节点启动，在端口`8500`上建立了一个 HTTP 服务以及 DNS 和 RPC 服务，如果人们选择这样连接的话。我们还可以看到，集群中只有一个节点，我们的，我们是运行在健康状态下的当选领导者。

因为我们将通过 cURL 使用方便的 RESTful HTTP API，所以我们所有的请求都将在端口`8500`上使用 localhost。作为一个 RESTful API，它完全遵循 CRUD 动词术语，为了插入数据，我们将在一个`/v1/kv`端点上使用一个`PUT`方法来设置`bookpub/my/config/value`键。

检索数据甚至更简单:我们只需使用所需的键向同一个`/v1/kv`服务发出一个`GET`请求。对于`DELETE`也是一样，唯一的区别是方法名。

更新操作需要 URL 中更多的信息，即`cas`参数。该参数的值应该是所需键的`ModifyIndex`，可以从`GET`请求中获得。在我们的例子中，它的值是 20。

# 使用 Consul 和 envconsul 外部化环境配置

在前面的方法中，我们安装了 Consul 服务，并试验了它的键/值功能，以了解我们如何操作其中的数据，从而将 Consul 与我们的应用集成，并从应用的角度来看，使数据提取过程无缝且无干扰。

由于我们不希望我们的应用知道任何关于 Consul 的信息，并且必须显式地连接到它，即使这种可能性存在，我们也将使用另一个实用程序，也是由 Hashicorp 作为开源创建的，名为 **envconsul** 。它将为我们连接到 Consul 服务，提取指定的配置键/值树，并将其作为环境变量公开，以便在启动我们的应用时使用。很酷，对吧？

# 做好准备

在开始启动我们的应用之前，我们需要安装 envconsul 实用程序。

从[https://github.com/hashicorp/envconsul/releases](https://github.com/hashicorp/envconsul/releases)下载各自操作系统的二进制文件，并把可执行文件解压到你选择的任何目录，尽管最好把它放在路径中的某个地方。

一旦从下载的归档文件中提取出 envconsul，我们就可以开始使用它来配置我们的应用了。

# 怎么做...

1.  如果您还没有将`my/config/value`键的值添加到 Consul 中，让我们通过运行`curl -X PUT -d 'From Consul Config' http://localhost:8500/v1/kv/bookpub/my/config/value`来添加它。
2.  第一步是确保 envconsul 可以连接到 consul 服务器，并根据我们的配置密钥提取正确的数据。让我们通过运行`envconsul --once --sanitize --upcase --prefix bookpub env`命令来执行一个简单的测试。我们应该在输出中看到以下内容:

```java
    ...
    TERM=xterm-256color
    SHELL=/bin/bash
    LANG=en_US.UTF-8
    HOME=/Users/<your_user_name>
    ...
    MY_CONFIG_VALUE=From Consul Config
```

3.  在我们确认 envconsul 返回了正确的数据之后，我们将通过运行`envconsul --once --sanitize --upcase --prefix bookpub ./gradlew clean bootRun`来使用它启动我们的`BookPub`应用。应用启动后，我们应该会在日志中看到以下输出:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Consul Config

```

4.  我们可以通过运行`./gradlew clean bootJar`构建自启动的可执行 JAR 来做同样的事情，并通过运行`envconsul --once --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动它，以确保我们在日志中看到与上一步相同的输出。如果你看到的是`Gradle`而不是`From Consul Config`，确保`build.gradle`中的`applicationDefaultJvmArgs`配置中没有`-Dmy.config.value=Gradle`。
5.  envconsul 的另一个惊人的能力不仅是将配置键值导出为环境变量，还可以监视任何更改，并在 consul 中的值发生更改时重新启动应用。让我们通过运行`envconsul --sanitize --upcase --prefix bookpub ./build/libs/bookpub-0.0.1-SNAPSHOT-exec.jar`来启动我们的应用，我们应该在日志中看到以下值:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From Consul Config

```

6.  我们现在将使用 consul 命令来获取我们的密钥的当前`ModifyIndex`，并通过打开另一个终端窗口并执行`curl http://localhost:8500/v1/kv/bookpub/my/config/value`，获取`ModifyIndex`值，并使用它来执行`curl -X PUT -d 'From UpdatedConsul Config' http://localhost:8500/v1/kv/bookpub/my/config/value?cas=<ModifyIndex Value>`，从而将其值更新为`From UpdatedConsul Config`。我们应该看到我们正在运行的应用神奇地重新启动自己，并且我们最新更新的值显示在最后的日志中:

```java
2017-12-17 --- ication$$EnhancerBySpringCGLIB$$b123df6a : Value of my.config.value property is: From UpdatedConsul Config

```

# 它是如何工作的...

我们刚刚做的很甜蜜，对吧？让我们更详细地研究一下幕后的魔法。我们将从剖析命令行和解释每个参数控制选项的作用开始。

我们的第一个执行命令行是`envconsul --once --sanitize --upcase --prefix bookpub ./gradlew clean bootRun`，所以让我们看看我们到底做了什么，如下所示:

*   首先，人们可能会注意到，没有任何迹象表明我们应该连接到哪个 Consul 节点。这是因为有一种隐含的理解或假设，即您已经有一个咨询代理在本地运行于`localhost:8500`。如果由于某种原因不是这样，您总是可以通过添加到命令行的`--consul localhost:8500`参数显式地指定要连接的 Consul 实例。
*   `--prefix`选项指定在其中寻找不同值的起始配置键段。我们在给 Consul 添加键的时候，使用了下面这个键:`bookpub/my/config/value`。通过指定`--prefix bookpub`选项，我们告诉 envconsul 去掉键的`bookpub`部分，并使用`bookpub`中的所有内部树元素来构造环境变量。因此，`my/config/value`成为环境变量。
*   `--sanitize`选项告诉 envconsul 用下划线(`_`)替换所有无效字符。所以，如果我们只使用`--sanitize`，我们最终会得到`my_config_value`作为环境变量。
*   正如您可能已经猜到的那样，`--upcase`选项将环境变量键更改为全部大写字符，因此当与`--sanitize`选项结合使用时，`my/config/value`键被转换为`MY_CONFIG_VALUE`环境变量。
*   `--once`选项表示我们只想将键作为环境变量外部化一次，而不想持续监控 Consul 集群中的变化。如果我们的前缀树中的一个键改变了它的值，我们将这些键作为环境变量重新具体化，并重新启动应用。

最后一个选项`--once`，提供了一个非常有用的功能选择。如果您只对通过使用 Consul 共享配置的应用的初始引导感兴趣，那么这些键将被设置为环境变量，应用将被启动，envconsul 将认为它的工作已经完成。但是，如果您想要监视 Consul 集群的键/值的更改，并且在更改发生后，重新启动您的应用以反映新的更改，那么移除`--once`选项，一旦更改发生，envconsul 将重新启动应用。

这种行为对于数据库连接配置的即时更改非常有用和方便。假设您需要从一个数据库快速故障转移到另一个数据库，并且您的 JDBC URL 是通过 Consul 配置的。您需要做的只是推送一个新的 JDBC URL 值，envconsul 几乎会立即检测到这一变化并重启应用，告诉它连接到一个新的数据库节点。

目前，这种功能是通过向运行进程的应用发送传统的 SIGTERM 信号来实现的，告诉它终止，并且一旦退出进程，就重新启动应用。这可能并不总是我们想要的行为，尤其是当应用需要一些时间来启动并能够接受流量时。您不希望关闭整个 web 应用集群，即使只关闭几分钟。

为了更好地处理这种情况，envconsul 得到了增强，能够发送大量标准信号，这些信号可以通过新添加的`--kill-signal`选项进行配置。使用此选项，我们可以指定 SIGHUP、SIGTERM、SIGINT、SIGQUIT、SIGUSR1 或 SIGUSR2 信号中的任何一个来代替默认的 SIGTERM，以便在检测到键/值更改时发送到正在运行的应用进程。

Java 中的进程信号处理并不清晰直接，因为大多数行为都是特定于特定的操作系统和运行在其上的 JVM 的。列表中的一些信号将终止应用，或者在 SIGQUIT 的情况下，JVM 将把核心转储打印到标准输出中。然而，根据操作系统的不同，有一些方法可以配置 JVM，让我们使用 SIGUSR1 和 SIGUSR2，而不是对这些信号本身进行操作，但不幸的是，这个主题超出了本书的范围。

这里有一个如何处理**信号处理程序**:[https://github.com/spotify/daemon-java](https://github.com/spotify/daemon-java)的示例，或者查看位于[https://docs . Oracle . com/javase/8/docs/technotes/guides/trouble shooting/signals . html](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/signals.html)的 Oracle Java 文档获得详细解释。