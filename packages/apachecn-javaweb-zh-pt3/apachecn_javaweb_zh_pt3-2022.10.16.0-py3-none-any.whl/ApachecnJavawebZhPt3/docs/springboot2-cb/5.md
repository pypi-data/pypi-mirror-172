# 五、应用测试

在本章中，我们将讨论以下主题:

*   为 MVC 控制器创建测试
*   配置数据库模式并填充它
*   使用内存数据库创建测试
*   使用模拟对象创建测试
*   创建 JPA 组件测试
*   创建 WebMvc 组件测试
*   使用黄瓜编写测试
*   使用 Spock 编写测试

# 介绍

在前几章中，我们做了大量的编码工作。我们从头开始创建了一个新的 Spring Boot 应用，添加了一个 MVC 组件和一些数据库服务，对应用的行为做了一些调整，甚至编写了我们自己的 Spring Boot 启动器。现在是时候采取下一步措施，了解 Spring Boot 在测试所有这些代码时提供了什么样的工具和功能，以及它与其他流行的测试框架集成得如何。

我们将看到如何使用 Spring JUnit 集成来创建单元测试。接下来，我们将探索用测试数据设置数据库的选项，以对其进行测试。然后我们将着眼于**行为驱动开发** ( **BDD** )工具 Cucumber 和 Spock，看看它们如何与 Spring Boot 整合。

# 为 MVC 控制器创建测试

在前面的章节中，我们在逐步创建我们的应用方面取得了很多进展，但是我们如何知道它实际上做了我们想要它做的事情呢？更重要的是，我们如何确定六个月后，甚至一年后，它还会继续做我们一开始期望它做的事情？这个问题最好通过创建一组测试来回答，最好是自动化的，对我们的代码运行一套断言。这确保了在给定特定输入的情况下，我们不断得到相同的预期输出。测试让我们放心，我们的应用不仅编码优雅，看起来漂亮，而且运行可靠，尽可能没有错误。

在[第 4 章](4.html)、*编写定制的 Spring Boot 启动器*中，我们停止了为我们的 web 应用安装一个定制的 Spring Boot 启动器。我们现在将创建一些基本测试来测试我们的 web 应用，并确保所有控制器都公开预期的 RESTful URLs，我们可以依赖它作为服务 API。这种类型的测试有点超出了通常所说的**单元测试**，因为它测试整个 web 应用，它要求应用上下文被完全初始化，并且所有的 beans 应该被连接在一起才能工作。这种测试有时被称为**集成**或**服务测试**。

# 怎么做...

1.  Spring Boot 在我们项目的根目录下的`src/test/java/com/example/bookpub`目录中创建了一个占位符测试文件`BookPubApplicationTests.java`，它包含以下内容:

```java
@RunWith(SpringRunner.class) 
@SpringApplicationConfiguration(classes = 
   BookPubApplication.class) 
public class BookPubApplicationTests { 
  @Test 
  public void contextLoads() { 
  } 
} 
```

2.  在`build.gradle`中，我们也得到了对`spring-boot-starter-test`的测试依赖，如下所示:

```java
testCompile("org.springframework.boot:spring-boot-starter-test") 
```

3.  我们将继续扩展基本模板测试，以包含以下代码:

```java
import static org.hamcrest.Matchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.springframework.test.web.servlet.setup.MockMvcBuilders.webAppContextSetup;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class BookPubApplicationTests {
   @Autowired
   private WebApplicationContext context; 
   @Autowired
   private TestRestTemplate restTemplate;
   @Autowired
   private BookRepository repository;

   @LocalServerPort
   private int port;

   private MockMvc mockMvc; 

   @Before
   public void setupMockMvc() {
       mockMvc = webAppContextSetup(context).build();
   }

   @Test
   public void contextLoads() {
       assertEquals(1, repository.count());
   }

   @Test
   public void webappBookIsbnApi() {
       Book book =
         restTemplate.getForObject("http://localhost:" +
           port + "/books/978-1-78528-415-1", Book.class);
       assertNotNull(book);
       assertEquals("Packt", book.getPublisher().getName());
   }

   @Test
   public void webappPublisherApi() throws Exception {
       mockMvc.perform(get("/publishers/1")).
               andExpect(status().isOk()).andExpect(content().
                  contentType(MediaType.parseMediaType
                    ("application/hal+json;charset=UTF-8"))).
               andExpect(content().
                            string(containsString("Packt"))).
               andExpect(jsonPath("$.name").value("Packt"));
   }
} 
```

4.  通过运行`./gradlew clean test`执行测试。
5.  通过查看控制台输出，我们可以知道我们的测试已经成功并且正在运行，但是除了下面几行(为了简洁起见，被截断了)之外，我们看不到太多的信息:

```java
:compileJava
:compileTestJava
:testClasses
:test
2016-10-13 21:40:44.694  INFO 25739 --- [       Thread-4] ationConfigEmbeddedWebApplicationContext : Closing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@206f4aa6: startup date [Mon Apr 13 21:40:36 CDT 2015]; root of context hierarchy
2016-10-13 21:40:44.704  INFO 25739 --- [       Thread-4] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'
2016-10-13 21:40:44.705  INFO 25739 --- [       Thread-4] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000227: Running hbm2ddl schema export
2016-10-13 21:40:44.780  INFO 25739 --- [       Thread-4] org.hibernate.tool.hbm2ddl.SchemaExport  : HHH000230: Schema export complete

BUILD SUCCESSFUL
Total time: 24.635 secs
```

6.  Better insight can be gathered by viewing the HTML reports that are generated by Gradle, which can be opened in the browser and reside in `build/reports/tests/index.html`, as shown in the following screenshot:

    ![](img/a8e039b4-e823-4444-844c-b06e415813e1.png)

7.  Clicking on `com.example.bookpub.BookPubApplicationTests` will take us to the individual test case breakdown, which shows the status of each test and how long it took to get executed, as follows:

    ![](img/5eb6b09a-d98f-485a-b232-0fb40bfcc16d.png)

8.  更好奇的人也可以点击标准输出按钮，以便查看在测试执行期间产生的运行时应用日志。

# 它是如何工作的...

现在我们已经创建了第一个测试，让我们详细检查一下代码。

我们首先来看看下面为`BookPubApplicationTests`类声明的注释:

*   `@RunWith(SpringRunner.class)`:这是一个标准的 JUnit 注释，我们可以配置它来使用`SpringRunner`，提供将 Spring Boot 框架引导到标准 JUnit 测试的功能。
*   这是一个将类标记为 Spring Boot 测试的注释。它将使用 Spring Boot 框架来配置测试类实例，提供适当的配置、自动连接等等。`webEnvironment=SpringBootTest.WebEnvironment.RANDOM_PORT`属性意味着当前的测试将使用一个真实的、正在运行的服务实例，并且将需要一个完整的上下文初始化和应用启动，就像它是真实的交易一样。`RANDOM_PORT`值用于告诉 Spring Boot 在一个随机选择的 HTTP 端口上启动 Tomcat 服务器，稍后我们将通过声明`@LocalServerPortprivate int port;`值字段来获得这个端口。在 Jenkins 或任何其他 CI 服务器上运行测试时，这种选择随机 HTTP 端口的能力非常方便，如果多个作业并行运行，您可能会遇到端口冲突。

随着类注释魔力的消散，让我们来看看类本身的内容。由于这是一个 Spring Boot 测试，我们可以在执行过程中声明任何由 Spring 管理的对象为`@Autowired`，或者使用`@Value`注释设置为特定的环境值。在我们的测试中，我们自动连接了`WebApplicationContext`和`BookRepository`对象，以及`TestRestTemplate`的一个实例，我们将在标准 JUnit `@Test`注释测试用例的执行中使用它们。

在第一个测试用例中，`contextLoads()`方法，我们将断言我们已经建立了`BookRepository`连接，并且它包含一个图书条目。

我们的第二个测试将确保我们的 web 应用通过`ISBN - "/books/{isbn}"`响应 RESTful URL 的`Book`查询。对于这个测试，我们将使用`TestRestTemplate`的实例，并在随机选择的端口上对正在运行的实例进行 RESTful 调用。Spring Boot 提供了`port`字段的值。

在`webappBookIsbnApi`测试中，我们使用一个完整的 URL，开始部分是`"http://localhost:" + port`，如果`TestRestTemplate`是由 Spring Boot 自动连接和注入的，这在技术上是不需要的。在这种情况下，可以使用相对 URL，看起来像`Book book = restTemplate.getForObject("/books/978-1-78528-415-1", Book.class);`，`TestRestTemplate`将自动确定运行测试服务器实例的端口。

或者，我们可以通过遍历`MockMvc`对象来执行相同风格的测试。这是由 Spring Test Framework 提供的，它允许您执行 MVC 测试，而不需要通过`RestTemplate`实际执行基于客户端的测试，而是完全在服务器端执行，其中控制器请求从与被测试应用相同的上下文中执行。

为了使用`MockMvc`，我们将使用`MockMvcBuilders`实用程序来构建一个使用`@Autowired WebApplicationContext`的实例。我们将在 setup 方法中这样做，这样我们就不必在每个测试中显式地这样做。

如果我们使用`WebEnvironment.MOCK`而不是`RANDOM_PORT`来注释我们的测试，也有可能让 Spring Boot 自动创建一个`MockMvc`的实例。该配置将只让测试在模拟上下文中运行，而不会启动真正的服务器。我们的例子展示了如何在同一个测试类中将真实的服务器实例和`MockMVC`结合起来。

为我们提供了一套非常广泛的功能，以便在几乎所有与 web 请求相关的事情上执行断言。它被设计成以方法链的方式使用，允许我们将各种测试链接在一起，并形成一个良好的、连续的逻辑链:

*   `perform(get(...))`:该方法设置 web 请求。在我们的特例中，我们执行一个 GET 请求，但是`MockMvcRequestBuilders`类为我们提供了所有公共方法调用的静态帮助函数。
*   `andExpect(...)`:这个方法可以被多次调用，其中每个调用代表一个针对`perform(...)`调用结果的条件评估。这个调用的参数是`ResultMatcher`接口的任何实现，以及由`MockMvcResultMatchers`静态实用程序类提供的许多常用接口。这实际上提供了无限数量的不同检查的可能性，例如验证响应状态、内容类型、会话中存储的值、flash 范围、验证重定向、呈现模型或头的内容等等。我们将使用一个第三方的`json-path`插件库(它作为一个`spring-boot-test`依赖项自动带来)来测试 JSON 响应数据，以确保它在正确的树层次结构中包含正确的元素。`andExpect(jsonPath("$.name").value("Packt"))`验证 JSON 文档的根中有一个值为`Packt`的 name 元素。

要了解更多关于 MockMvc 中可用的各种可能性，可以参考[https://github . com/spring-projects/spring-MVC-showcase/tree/master/src/test/Java/org/spring framework/samples/MVC](https://github.com/spring-projects/spring-mvc-showcase/tree/master/src/test/java/org/springframework/samples/mvc)。

# 配置数据库模式并填充它

在本书的前面，在第二章、*配置 Web 应用*中，我们用`StartupRunner's run(...)`方法手工添加了一些条目到数据库中。虽然以编程方式这样做是一种快速简单的方法，可以让事情快速进行，但从长远来看，这样做并不是一个好主意，尤其是在处理大量数据的时候。将数据库准备、变更和其他配置与正在运行的应用代码的其余部分分开也是一个好的实践，即使它正在设置测试用例。幸运的是，Spring 为您提供了支持，使这项任务变得相当简单明了。

我们将继续应用的状态，就像我们在上一个秘籍中留下的那样。Spring 为我们提供了几种方法来定义应该如何在数据库中填充结构和数据。第一种方式依赖于使用 Hibernate 自动创建表结构，方法是从我们定义的`@Entity`对象进行推断，并使用`import.sql`文件填充数据。第二种方法是使用普通的老 Spring JDBC 功能，它依赖于使用包含数据库表定义的`schema.sql`文件和包含数据的相应的`data.sql`文件。

# 怎么做...

1.  首先，我们将删除我们在第 2 章、*配置 Web 应用*中创建的编程数据库。所以让我们注释掉下面来自`StartupRunner's run(...)`方法的代码:

```java
Author author = new Author("Alex", "Antonov"); 
author = authorRepository.save(author); 
Publisher publisher = new Publisher("Packt"); 
publisher = publisherRepository.save(publisher); 
Book book = new Book("978-1-78528-415-1", "Spring Boot Recipes", author, publisher); 
bookRepository.save(book); 
```

2.  如果我们运行我们的测试，如果`test.h2.db`文件丢失，他们可能会失败，因为他们期望数据在数据库中。我们将通过在项目根目录下的`src/main/resources`目录中创建一个 Hibernate `import.sql`文件来填充数据库，该文件包含以下内容:

```java
INSERT INTO author (id, first_name, last_name) VALUES (1, 'Alex', 'Antonov') 
INSERT INTO publisher (id, name) VALUES (1, 'Packt') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78528-415-1', 'Spring Boot Recipes', 1, 1) 
```

3.  通过运行`./gradlew clean test`再次运行测试时，它们会神奇地启动并再次通过。
4.  另一种方法是使用 Spring JDBC 支撑`schema.sql`和`data.sql`。让我们将新创建的`import.sql`文件重命名为`data.sql`，并在同一个目录下创建一个`schema.sql`文件，内容如下:

```java
-- Create syntax for TABLE 'author' 
DROP TABLE IF EXISTS `author`; 
CREATE TABLE `author` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `first_name` varchar(255) DEFAULT NULL, 
  `last_name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'publisher' 
DROP TABLE IF EXISTS `publisher`; 
CREATE TABLE `publisher` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'reviewer' 
DROP TABLE IF EXISTS `reviewer`; 
CREATE TABLE `reviewer` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `first_name` varchar(255) DEFAULT NULL, 
  `last_name` varchar(255) DEFAULT NULL, 
  PRIMARY KEY (`id`) 
); 
-- Create syntax for TABLE 'book' 
DROP TABLE IF EXISTS `book`; 
CREATE TABLE `book` ( 
  `id` bigint(20) NOT NULL AUTO_INCREMENT, 
  `description` varchar(255) DEFAULT NULL, 
  `isbn` varchar(255) DEFAULT NULL, 
  `title` varchar(255) DEFAULT NULL, 
  `author_id` bigint(20) DEFAULT NULL, 
  `publisher_id` bigint(20) DEFAULT NULL, 
  PRIMARY KEY (`id`), 
  CONSTRAINT `FK_publisher` FOREIGN KEY (`publisher_id`) REFERENCES `publisher` (`id`), 
  CONSTRAINT `FK_author` FOREIGN KEY (`author_id`) REFERENCES `author` (`id`) 
); 
-- Create syntax for TABLE 'book_reviewers' 
DROP TABLE IF EXISTS `book_reviewers`; 
CREATE TABLE `book_reviewers` ( 
  `book_id` bigint(20) NOT NULL, 
  `reviewers_id` bigint(20) NOT NULL, 
  CONSTRAINT `FK_book` FOREIGN KEY (`book_id`) REFERENCES `book` (`id`), 
  CONSTRAINT `FK_reviewer` FOREIGN KEY (`reviewers_id`) REFERENCES `reviewer` (`id`) 
); 
```

5.  因为我们现在手动创建数据库模式，所以我们需要告诉 Hibernate mapper 不要从实体中自动派生一个模式，并用它填充数据库。因此，让我们在项目根目录下的`src/main/resources`目录下的`application.properties`文件中设置`spring.jpa.hibernate.ddl-auto=none`属性。
6.  通过运行`./gradlew clean test`来执行测试，它们应该会通过。

# 它是如何工作的...

在这个秘籍中，我们实际上探索了两种方法来实现同样的事情，当你生活在春天的生态系统中时，这是很常见的。根据所使用的组件，无论是普通的 Spring JDBC、带 Hibernate 的 Spring JPA，还是 Flyway 或 Liquibase 迁移，填充和初始化数据库的方法会有所不同，但最终结果基本相同。

Flyway 和 Liquibase 都是提供增量数据库迁移功能的框架。当希望以可编程、可描述的方式维护数据库变更的增量日志，并能够快速将数据库置于特定版本的期望状态时，这非常方便。虽然这些框架在提供这种支持的方法上有所不同，但它们的目的是相似的。更详细的信息可以在他们各自的网站[http://flywaydb.org](http://flywaydb.org)和[http://www.liquibase.org](http://www.liquibase.org)获得。

在前面的示例中，我们探索了填充和初始化数据库的两种不同方式。

# 用 Spring JPA 和 Hibernate 初始化数据库

在这种方法中，大部分工作实际上是由`Hibernate`库完成的，我们只需设置适当的配置，并创建 Hibernate 完成这些工作所需的常规预期文件:

*   `spring.jpa.hibernate.ddl-auto=create-drop`设置指示 Hibernate 使用`@Entity`模型，并根据它们的结构自动推导出数据库模式。在启动应用时，计算的模式将用于预初始化数据库表结构；当应用关闭时，它将全部被销毁。即使在应用被强制终止或突然崩溃的情况下，在启动时，如果检测到现有的表，它们将被删除并从头开始重新创建。因此，在生产环境中依赖它可能不是一个好主意。

如果没有显式配置`spring.jpa.hibernate.ddl-auto`属性，默认情况下，Spring Boot 为嵌入式数据库(如 H2)使用 create-drop，所以要小心并适当地设置它。

*   Hibernate 希望`import.sql`文件驻留在类路径的根目录中。这用于在应用启动时执行声明的 SQL 语句。虽然任何有效的 SQL 语句都可以放在文件中，但建议您放入数据导入语句，如`INSERT`或`UPDATE`，并避开表结构的变化，因为模式定义已经由 Hibernate 处理了。

# 用 Spring JDBC 初始化数据库

如果应用不使用 JPA，或者您不想明确依赖 Hibernate 功能，Spring 提供了另一种建立数据库的方法，只要存在`spring-boot-starter-jdbc`依赖关系。因此，让我们来看看我们是如何让它工作的，如下表所示:

*   `spring.jpa.hibernate.ddl-auto=none`设置告诉 Hibernate，如果 Hibernate 依赖项也存在，就像我们的例子一样，不要自动处理数据库。这个设置对于生产环境来说是一个很好的实践，因为您可能不想无意中清除所有数据库表。那肯定会是一场大灾难！
*   `schema.sql`文件应该存在于类路径的根目录中。在应用每次启动时，在数据库的模式创建过程中，Spring 会执行它。然而，与 Hibernate 不同，它不会自动删除任何现有的表，所以在创建新表之前使用`DROP TABLE IF EXISTS`删除现有的表，或者如果您只想在新表不存在时创建新表，则使用`CREATE TABLE IF NOT EXISTS`作为表创建 SQL 的一部分，这可能是个好主意。这使得声明数据库结构演化逻辑更加灵活，因此在生产中使用也更加安全。
*   `data.sql`文件应该存在于类路径的根目录中。这用于执行数据填充 SQL，所以这是所有`INSERT INTO`语句的目的地。

鉴于这是 Spring 的原生功能，我们还将能够定义模式和数据文件，不仅是全局的，也是每个特定数据库平台的。例如，我们可以为 Oracle 使用一组文件，`schema-oracle.sql`，为 MySQL 使用另一组文件，`schema-mysql.sql`。这同样适用于`data.sql`的变种；然而，它们不必在每个平台上定义，所以虽然您可能有特定于平台的模式文件，但也可能有共享的数据文件。如果您想覆盖 Spring Boot 自动推导出的值，可以明确设置`spring.datasource.platform`配置值。

如果有人想覆盖默认名称`schema.sql`和`data.sql`，Spring Boot 提供了配置属性，我们可以用它来控制`spring.datasource.schema`和`spring.datasource.data`。

# 使用内存数据库创建测试

在前一个菜谱中，我们探讨了如何用所需的表建立数据库，并用所需的数据填充数据库。当谈到测试时，一个典型的挑战是正确地和可预测地设置环境，以便当测试被执行时，我们可以安全地以确定的方式断言行为。在连接到数据库的应用中，确保数据库包含可以评估断言的确定性数据集是极其重要的。对于一个复杂的测试套件来说，能够基于测试来刷新或更改数据集也是必要的。谢天谢地，Spring 有一些很好的工具来帮助你完成这个任务。

我们将从我们的`BookPub`应用的状态开始，就像我们在上一个秘籍中离开时一样。此时，我们有了定义所有表的`schema.sql`文件，我们还需要包含一些在`data.sql`中定义的起始数据的数据库。在这个菜谱中，我们将扩展我们的测试，以使用为特定测试套件定制的特定数据夹具文件。

# 怎么做...

1.  我们的第一步将是在项目根目录下的`src/test`目录中创建一个`resources`目录。
2.  在这个目录中，我们将开始放置我们的夹具 SQL 数据文件。让我们在 resources 目录下创建一个名为`test-data.sql`的新文件，其内容如下:

```java
INSERT INTO author (id, first_name, last_name) VALUES (2, 'Greg', 'Turnquist') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78439-302-1', 'Learning Spring Boot', 2, 1) 
```

3.  我们现在需要一种方法在测试运行时加载这个文件。我们将以如下方式修改我们的`BookPubApplicationTests`类:

```java
public class BookPubApplicationTests { 
   ... 
   @Autowired 
   private BookRepository repository; 
   @Autowired 
   private RestTemplate restTemplate; 
   @Autowired 
   private DataSource ds; 
   @LocalServerPort 
   private int port; 

   private MockMvc mockMvc; 
   private static boolean loadDataFixtures = true; 

   @Before 
   public void setupMockMvc() { 
      ... 
   } 

   @Before 
   public void loadDataFixtures() { 
      if (loadDataFixtures) { 
         ResourceDatabasePopulator populator = 
           new ResourceDatabasePopulator(
               context.getResource("classpath:/test-data.sql")); 
         DatabasePopulatorUtils.execute(populator, ds); 
         loadDataFixtures = false; 
      } 
   } 

   @Test 
   public void contextLoads() { 
      assertEquals(2, repository.count()); 
   } 

   @Test 
   public void webappBookIsbnApi() { 
      ... 
   } 

   @Test 
   public void webappPublisherApi() throws Exception { 
      ... 
   } 
} 
```

4.  通过运行`./gradlew clean test`来执行测试，尽管我们向数据库中添加了另一本书及其作者，它们应该会继续通过。
5.  我们还可以使用我们在前面的秘籍中学到的填充数据库的方法。由于测试代码有自己的`resources`目录，所以可以向其中添加另一个`data.sql`文件，Spring Boot 将使用这两个文件来填充数据库。让我们继续在我们项目的根目录下的`src/test/resources`目录中创建`data.sql`文件，内容如下:

```java
INSERT INTO author (id, first_name, last_name) VALUES (3, 'William', 'Shakespeare') 
INSERT INTO publisher (id, name) VALUES (2, 'Classical Books') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-23456-789-1', 'Romeo and Juliet', 3, 2) 
```

由于 Spring Boot 从类路径中收集数据文件的所有实例，因此可以将数据文件放在 jar 或不同的物理位置，这些位置最终都位于类路径的根位置。同样重要的是要记住，这些脚本的加载顺序是不确定的，如果您依赖于某些引用 id，最好使用选择来获取它们，而不是做出假设。

6.  由于我们向数据库中添加了另一本书，现在我们有了三本书，我们应该在我们的`contextLoads()`测试方法中修复断言:

```java
assertEquals(3, repository.count()); 
```

7.  通过运行`./gradlew clean test`来执行测试，它们应该会继续通过。
8.  公平地说，在运行单元测试时，内存数据库可能比持久数据库更适合这个角色。让我们在项目的根目录下的`src/test/resources`目录中创建一个专用的`application.properties`文件的测试配置实例，其内容如下:

```java
spring.datasource.url = jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.jpa.hibernate.ddl-auto=update
```

要知道 Spring Boot 只从类路径中加载一个`application.properties`文件，这一点很重要。当我们在`src/test/resources`中创建另一个`application.properties`时，来自`src/main/resources`的前一个不再被加载，因此在环境中没有合并其中定义的属性。因此，您应该配置所有必需的属性值。在我们的例子中，我们必须重新定义`spring.jpa.hibernate.dll-auto`属性，即使它已经在`src/main/resources/application.properties`位置声明了。

9.  通过运行`./gradlew clean test`执行测试，测试应该会继续通过。

# 它是如何工作的...

在这个方法中，我们依靠 Spring 提供的工具来初始化和填充数据库，以便用运行测试和断言测试所需的数据填充我们的数据库。然而，我们也希望能够使用一些只与特定测试套件相关的数据。为此，我们求助于`ResourceDatabasePopulator`和`DatabasePopulatorUtils`类，在测试执行之前插入所需的数据。这些是 Spring 内部使用的完全相同的类，用来处理`schema.sql`和`data.sql`文件，除了现在，我们明确定义了我们想要执行的脚本文件。

所以，让我们把我们所做的一步一步分解开来，如下:

*   我们创建了一个名为`loadDataFixtures()`的设置方法，我们用一个`@Before`注释对其进行了注释，告诉 JUnit 在每次测试之前运行它。
*   在这个方法中，我们获得了驻留在应用的类路径中的`classpath:/test-data.sql`数据文件的资源句柄，我们在这个类路径中存储测试数据并针对`@Autowired DataSource ds`执行它。
*   由于 Spring 只能自动连接类实例中的依赖项，并且每次测试都会执行`@Before`带注释的设置方法，我们必须有点创造性，以避免每次测试都用重复数据填充数据库，而不是每个测试套件/类一次。为了实现这一点，我们创建了一个`static boolean loadDataFixtures`变量，为`BookPubApplicationTests`类的每个实例保留其状态，从而确保我们只执行了一次`DatabasePopulatorUtils`。变量必须是静态的原因是，对于它在类中运行的每个测试方法，都会创建一个测试类的新实例；在实例级别使用`boolean`标志并不能解决问题。

或者，我们可以使用`@Sql`注释来代替`loadDataFixtures()`方法，并将我们的`BookPubApplicationTests`类标记为`@Transactional`，以确保在运行每个测试方法之前填充`test-data.sql`文件。那么我们就可以回滚到数据库的执行前状态。

这使得测试设置变得简单了一些，事务性部分允许测试改变数据库中的数据，而不用担心竞争情况，但是这样做的缺点是在每个测试之前执行 SQL 填充，这会增加一些额外的延迟。

为了实现这一点，我们需要移除`loadDataFixtures()`方法，并向`BookPubApplicationTests`类添加以下注释:

```java
@Transactional
@Sql(scripts = "classpath:/test-data.sql")
```

*   最后，我们决定有一个单独的`application.properties`文件用于测试目的。我们用内存数据库的测试配置将它添加到我们的`src/test/resources`类路径中，而不是使用基于文件的持久化配置。

*   与只能从类路径加载一个文件的`application.properties`不同，Spring 支持许多将被合并在一起的概要文件配置。因此，我们可以创建一个`application-test.properties`文件，并在运行测试时设置一个要测试的活动概要文件，而不是声明一个完全独立的`application.properties`文件。

# 使用模拟对象创建测试

在前面的方法中，我们使用了一个数据固定文件来填充内存中的数据库，以便在可预测的静态数据集上运行我们的测试。虽然这使得测试具有一致性和确定性，但我们仍然要付出代价，必须创建一个数据库，用数据填充它，并初始化所有的 JPA 和连接组件，这可能被视为测试的多余步骤。幸运的是，Spring Boot 提供了内部支持，能够模拟 beans，并在测试中将其作为组件注入，以便进行设置，并进一步用作应用上下文中的依赖项。

让我们检查一下如何使用 Mockito 的功能，这样我们就完全不需要依赖数据库了。我们将学习如何使用 Mockito 框架和一些`@MockBean`注释技巧优雅地模仿`Repository`实例对象。

# 怎么做...

1.  首先，我们将在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个新的`MockPublisherRepositoryTests`测试类，其内容如下:

```java
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;
import static org.mockito.BDDMockito.reset; 

@RunWith(SpringRunner.class) 
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE) 
public class MockPublisherRepositoryTests { 
    @MockBean 
    private PublisherRepository repository; 

    @Before 
    public void setupPublisherRepositoryMock() { 
        given(repository.count()).willReturn(5L); 
    } 

    @Test 
    public void publishersExist() { 
        assertThat(repository.count()).isEqualTo(5L); 
    } 

    @After 
    public void resetPublisherRepositoryMock() { 
        reset(repository); 
    } 
} 
```

2.  通过运行`./gradlew clean test`执行测试，测试应该会通过

# 它是如何工作的...

这里发生了一些神奇的事情。让我们从放入`MockPublisherRepositoryTests`类的注释开始:

*   `@SpringBootTest`注释的`webEnvironment`属性被替换为`WebEnvironment.NONE`。这是为了通知 Spring Boot，我们不希望为这个测试初始化一个完整的应用 web 服务器，因为我们将只与存储库对象交互，而不调用控制器或使用 WebMvc 栈的任何部分。我们这样做是为了节省测试启动时间，如果有人想知道差异，只要简单地将其切换回`WebEnvironment.RANDOM_PORT`值并重新运行测试，就会显示时间几乎增加了一倍。(在我结实的 MacBook Pro 上，它从 5 秒增加到了几乎 9 秒。)

检查完应用的更改后，现在让我们看看我们在`MockPublisherRepositoryTests`类本身中做了什么:

*   `@MockBean`注释指示 Spring 这个依赖项不是一个真实的实例，而是一个目前由 Mockito 框架支持的`mock`对象。这有一个有趣的效果，因为它实际上用模拟实例替换了上下文中的`PublisherRepository` bean 实例，因此，在上下文中的任何地方，`PublisherRepository`的所有依赖项都与模拟版本关联，而不是真实的、数据库支持的版本。

现在我们知道了被模仿的实例`PublisherRepository`是如何被注入到我们的测试中的，让我们来看看新创建的测试设置方法。特别感兴趣的两种方法是`setupPublisherRepositoryMock()`和`resetPublisherRepositoryMock()`。它们描述如下:

*   用`@Before`注释了`setupPublisherRepositoryMock()`方法，这告诉 JUnit 在运行类中的每个`@Test`方法之前执行这个方法。我们将使用 Mockito 框架来配置模拟实例的行为。我们这样配置它，当调用`repository.count()`方法时，它将返回`5`作为结果。Mockito、Junit 和 Hamcrest 库为我们提供了许多方便的类似 DLS 的方法，我们可以用它们来定义类似英语的、易读的规则。
*   用`@After`注释了`resetPublisherRepositoryMock()`方法，这告诉 JUnit 在运行了类中的每个`@Test`方法之后执行这个方法。在每个测试结束时，我们需要重置被模仿的行为，所以我们将使用`reset(...)`方法调用来清除我们所有的设置，并为下一个测试准备好模仿，这可以在另一个测试套件中一起使用。

理想情况下，不需要在测试运行结束时重置`mock`对象，因为每个测试类都会产生自己的上下文，所以测试类之间不会共享 mock 的实例。创建许多较小的测试而不是一个大的测试被认为是好的实践。然而，当 mock 由容器注入管理时，有一些用例需要重置 mock，所以我认为这是值得一提的。关于使用`reset(...)`的最佳实践，请参见[https://github . com/mock ITO/mock ITO/wiki/FAQ # can-I-reset-a-mock](https://github.com/mockito/mockito/wiki/FAQ#can-i-reset-a-mock)。

# 创建 JPA 组件测试

我们之前的大多数测试示例都必须启动整个应用并配置所有 beans 才能执行。虽然这对于我们的简单应用(代码很少)来说不是什么大问题，但对于一些更大、更复杂的企业级服务来说，这可能是一个昂贵而漫长的过程。考虑到良好的测试覆盖率的一个关键方面是低执行时间，我们可能想要选择不启动整个应用，以便只测试一个组件，或者像 Spring Boot 所说的*片*。

在这个菜谱中，我们将尝试创建一个与之前的`PublisherRepository`测试相似的测试，但是不启动整个容器和初始化所有的 beans。方便的是，Spring Boot 为我们提供了`@DataJpaTest`注释，我们可以把它放到我们的测试类中，它会自动配置 JPA 功能所需的所有组件，但不是整个上下文。因此，控制器、服务等 beans 将会丢失。这个测试非常适合于快速测试实体域对象绑定的有效性，以确保字段名、关联等配置正确。

# 怎么做...

1.  让我们在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个新的`JpaAuthorRepositoryTests`测试类，内容如下:

```java
import static org.assertj.core.api.Assertions.assertThat; 

@RunWith(SpringRunner.class) 
@DataJpaTest 
public class JpaAuthorRepositoryTests { 
    @Autowired 
    private TestEntityManager mgr; 

    @Autowired 
    private AuthorRepository repository; 

    @Test 
    public void testAuthorEntityBinding() { 
        Long id = mgr.persistAndGetId(createAuthor(),  
                                      Long.class); 

        Author author = repository.findById(id).get(); 

        assertThat(author.getFirstName()). 
                   isEqualTo("Mark"); 
        assertThat(author.getLastName()). 
                   isEqualTo("Twain"); 
    } 

    private Author createAuthor() { 
        return new Author("Mark", "Twain"); 
    } 
} 
```

2.  通过运行`./gradlew clean test`执行测试，测试应该会继续通过

# 它是如何工作的...

与我们之前测试的关键区别是没有了`@SpringBootTest`注释，它被替换为`@DataJpaTest`注释。由于`@DataJpaTest`注释完成了配置测试环境的大部分声明和工作量，测试类本身表面上的简单是可能的。如果我们看一下注释定义，我们会看到无数不同的内部注释配置了所有必要的组件。重要的是`@AutoConfigure*`注解，比如`@AutoConfigureDataJpa`或者`@AutoConfigureTestDatabase`。这些注释实际上是指导 Spring Boot 在引导测试时导入必要的组件配置。例如，在`@DataJpaTest`中，只有`Cache`、`DataJpa`、`TestDatabase`和`TestEntityManager`组件将被配置并变得可用，这显著减少了测试占用的内存以及启动和执行时间。然后，正如我们之前看到的，从各种工件提供的`META-INF/spring.factories`描述符中加载特定的配置类。

初始化正确的组件后，我们可以利用一些预配置的 beans，例如`TestEntityManager`，它使我们能够与数据库的测试实例进行交互，预初始化其内容的期望状态，并操纵测试数据。这为我们提供了保证，在每个测试套件完成执行后，我们将为下一个测试套件获得一个干净的石板，而不需要显式的清理。这使得编写测试变得更加容易，而不必担心执行的顺序和从一个测试套件到另一个测试套件的潜在变化，避免了使测试不一致的不经意的脏状态。

# 创建 WebMvc 组件测试

`*Test`片集合中的另一个是`@WebMvcTest`，它允许我们为应用的 WebMvc 部分创建测试，快速测试控制器、过滤器等等，同时提供使用`@MockBean`来配置必要的依赖项的能力，比如服务、数据存储库等等。

这是 Spring Boot 测试框架提供的另一个非常有用的测试片段，我们将在这个菜谱中探索它的用途，看看我们如何为我们的`BookController`文件创建 Mvc 层测试，用预定义的数据集模拟`BookRepository`服务，并确保返回的 JSON 文档是我们基于该数据所期望的。

# 怎么做...

1.  首先，我们将在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个新的`WebMvcBookControllerTests`测试类，其内容如下:

```java
import static org.hamcrest.Matchers.containsString; 
import static org.mockito.BDDMockito.given; 
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 

@RunWith(SpringRunner.class) 
@WebMvcTest 
public class WebMvcBookControllerTests { 
    @Autowired 
    private MockMvc mockMvc; 

    @MockBean
    private BookRepository repository;

    // The 2 repositories below are needed to 
    //successfully initialize StartupRunner
    @MockBean
    private AuthorRepository authorRepository;
    @MockBean
    private PublisherRepository publisherRepository; 

    @Test 
    public void webappBookApi() throws Exception { 
        given(repository.findBookByIsbn("978-1-78528-415-1")) 
             .willReturn(new Book("978-1-78528-415-1", 
                                  "Spring Boot Recipes", 
                                  new Author("Alex", "Antonov"), 
                                  new Publisher("Packt"))); 

        mockMvc.perform(get("/books/978-1-78528-415-1")). 
                andExpect(status().isOk()). 
                andExpect(content().
                          contentType(MediaType.parseMediaType
                          ("application/json;charset=UTF-8"))). 
                andExpect(content().
                          string(containsString("Spring Boot Recipes"))). 
                andExpect(jsonPath("$.isbn").
                                  value("978-1-78528-415-1")); 
    } 
} 
```

2.  通过运行`./gradlew clean test`执行测试，测试应该会继续通过

# 它是如何工作的...

`@WebMvcTest`的功能与我们在之前的秘籍中看到的`@DataJpaTest`注释非常相似。区别实际上只是一组在测试引导期间被初始化的组件。与`@DataJpaTest`不同，这次没有为我们提供数据库组件，而是我们得到了`WebMvc`和`MockMvc`配置，它们为初始化控制器、过滤器、拦截器等等提供了所有必要的基础。出于这个原因，我们必须将`AuthorRepository`和`PublisherRepository`作为模拟 bean 添加到我们的测试代码中，因为否则测试将无法启动，因为 Spring Boot 将无法满足`StartupRunner`类对这两个存储库的 bean 依赖性。

这个问题的另一个解决方案是从`StartupRunner`类中移除对这两个存储库的依赖，因为我们已经在本章前面的*配置数据库模式并填充它*方法中注释掉了使用它们的代码。如果这不可能，我想演示如何处理这样的情况:在其他类中有 bean 依赖项，与测试直接无关，但在初始化和执行期间会导致启动失败。

可以看到，与我们之前的秘籍测试不同，我们没有使用任何 bean 模拟，因为它测试的是一个更低层的组件，而没有进一步的依赖关系，这一次我们需要提供一个由我们的`BookController`类使用的`BookRepository`模拟，我们正在测试它的功能。

我们已经看到了如何使用`@Before`注释来预配置`MockPublisherRepositoryTests`类中的模拟对象，所以这次我们直接在`webappBookApi`测试方法中进行配置，类似于我们学习使用 Spock 框架编写测试时看到的风格。

在`given(...)`调用中，我们预先配置了`BookRepository`模拟对象的行为，指示它在使用`"978-1-78528-415-1"`作为参数调用其`findBookByIsbn`方法时返回一个特定的`Book`实例。

我们用`/books/978-1-78528-415-1`对`mockMvc.perform`的下一次调用触发了对`BookController` `getBook`方法的调用，该方法委托了`bookRepository`的预连线模拟实例，并使用我们预配置的`Book`对象实例来运行验证逻辑。

从日志中可以明显看出，只有 WebMvc 层被引导。没有初始化任何数据库或其他组件，这极大地节省了运行时间，只需要 3 秒钟，而之前进行完整的应用引导测试需要 9 秒钟。

# 使用黄瓜编写测试

很长一段时间以来，单元测试一直是软件开发生命周期的预期部分，人们很难想象在编写代码时没有单元测试。测试的艺术不是一成不变的，测试哲学的进步已经进一步扩展了单元测试的概念，引入了诸如服务测试、集成测试以及最后的 BDD，BDD 建议创建描述应用行为的测试套件，而无需在代码的较低层次上处理微小的实现细节。一个这样的框架是 Cucumber BDD，它首先在 Ruby 领域获得了广泛的流行，后来扩展到了包括 Java 在内的其他语言。

出于本菜谱的目的，我们将继续我们之前的示例，并通过添加 Cucumber-JVM 实现来增强测试套件，这将为我们提供原始 Ruby Cucumber 框架的基于 Java 的版本，并创建一些测试来展示 Spring Boot 应用的功能和集成点。

这个菜谱并不打算覆盖 Cucumber 测试框架提供的所有功能，它主要关注 Cucumber 和 Spring Boot 的集成点。想了解更多关于 Cucumber-JVM 的信息，可以去[https://cukes.info/docs#cucumber-implementations](https://cukes.info/docs#cucumber-implementations)或者[https://github.com/cucumber/cucumber-jvm](https://github.com/cucumber/cucumber-jvm)了解详情。

# 怎么做...

1.  我们需要做的第一件事是将 Cucumber 库的必要依赖项添加到我们的`build.gradle`文件，如下所示:

```java
dependencies { 
    compile("org.springframework.boot:spring-boot-starter-data-jpa") 
    compile("org.springframework.boot:spring-boot-starter-jdbc") 
    compile("org.springframework.boot:spring-boot-starter-web") 
    compile("org.springframework.boot:spring-boot-starter-data-rest") 
    compile project(":db-count-starter") 
    runtime("com.h2database:h2") 
    runtime("mysql:mysql-connector-java") 
    testCompile("org.springframework.boot:spring-boot-starter-test") 
    testCompile("info.cukes:cucumber-spring:1.2.5") 
    testCompile("info.cukes:cucumber-java8:1.2.5") 
    testCompile("info.cukes:cucumber-junit:1.2.5") 
} 
```

2.  接下来，我们需要创建一个测试驱动程序类来运行 Cucumber 测试。让我们在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个`RunCukeTests.java`文件，内容如下:

```java
@RunWith(Cucumber.class) 
@CucumberOptions(plugin={"pretty", "html:build/reports/cucumber"},   
                 glue = {"cucumber.api.spring",           
                         "classpath:com.example.bookpub"},  
                 monochrome = true) 
public class RunCukeTests { 
} 
```

3.  创建了驱动程序类之后，我们就可以开始编写 Cucumber 所说的步骤定义了。我将简单谈谈这些在*中是如何工作的...*本秘籍的一节。现在，让我们在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个`RepositoryStepdefs.java`文件，内容如下:

```java
@WebAppConfiguration 
@ContextConfiguration(classes = BookPubApplication.class, 
                  loader = SpringBootContextLoader.class)  
public class RepositoryStepdefs { 
    @Autowired 
    private WebApplicationContext context; 
    @Autowired 
    private DataSource ds; 
    @Autowired 
    private BookRepository bookRepository; 

    private Book loadedBook; 

    @Given("^([^\"]*) fixture is loaded$") 
    public void data_fixture_is_loaded(String fixtureName)
      throws Throwable { 
        ResourceDatabasePopulator populator 
          = new ResourceDatabasePopulator
                (context.getResource("classpath:/" + fixtureName + ".sql")); 
        DatabasePopulatorUtils.execute(populator, ds); 
    } 

    @Given("^(\d+) books available in the catalogue$") 
    public void books_available_in_the_catalogue(int bookCount)    
      throws Throwable { 
        assertEquals(bookCount, bookRepository.count()); 
    } 

    @When("^searching for book by isbn ([\d-]+)$") 
    public void searching_for_book_by_isbn(String isbn) 
      throws Throwable { 
        loadedBook = bookRepository.findBookByIsbn(isbn); 
        assertNotNull(loadedBook); 
        assertEquals(isbn, loadedBook.getIsbn()); 
    } 

    @Then("^book title will be ([^"]*)$") 
    public void book_title_will_be(String bookTitle) 
      throws Throwable { 
        assertNotNull(loadedBook); 
        assertEquals(bookTitle, loadedBook.getTitle()); 
    } 
} 
```

4.  现在，我们需要在我们项目的根目录下的`src/test/resources/com/example/bookpub`目录中创建一个相应的名为`repositories.feature`的测试特性定义文件，其内容如下:

```java
@txn 
Feature: Finding a book by ISBN 
  Background: Preload DB Mock Data 
    Given packt-books fixture is loaded 

  Scenario: Load one book 
    Given 3 books available in the catalogue 
    When searching for book by isbn 978-1-78398-478-7 
    Then book title will be Orchestrating Docker 
```

5.  最后，我们将在项目根目录下的`src/test/resources`目录中再创建一个名为`packt-books.sql`的数据 SQL 文件，其内容如下:

```java
INSERT INTO author (id, first_name, last_name) VALUES (5, 'Shrikrishna', 'Holla') 
INSERT INTO book (isbn, title, author_id, publisher_id) VALUES ('978-1-78398-478-7', 'Orchestrating Docker', 5, 1) 
```

6.  通过运行`./gradlew clean test`执行测试，测试应该会通过。

7.  With the addition of Cucumber, we also get the results of the tests in both the JUnit report and Cucumber-specific report HTML files. If we open `build/reports/tests/index.html` in the browser and click on the Classes button, we will see our scenario in the table, as shown in the following screenshot:

    ![](img/2f667267-e14b-457e-9ecc-f67e44bbc81e.png)

8.  Selecting the Scenario: Load one book link will take us to the detailed report page, as shown in the following screenshot:

    ![](img/eb744c2f-eb47-4d40-a585-809d15dfc6c8.png)

9.  正如我们所看到的，这些描述比我们在最初的基于 JUnit 的测试用例中看到的类名和方法名更好。
10.  Cucumber 还会生成自己的报告，可以在浏览器中打开`build/reports/cucumber/index.html`查看。
11.  作为一个行为驱动的测试框架，特性文件不仅允许我们定义单独的条件，还允许我们声明整个场景概要，这使得定义相似数据的多个断言更加容易。让我们在项目根目录下的`src/test/resources/com/example/bookpub`目录中创建另一个名为`restful.feature`的特性文件，其内容如下:

```java
@txn 
Feature: Finding a book via REST API 
  Background: 
    Given packt-books fixture is loaded 

  Scenario Outline: Using RESTful API to lookup books by ISBN 
    Given catalogue with books 
    When requesting url /books/<isbn> 
    Then status code will be 200 
    And response content contains <title> 

    Examples: 
      |isbn             |title               | 
      |978-1-78398-478-7|Orchestrating Docker| 
      |978-1-78528-415-1|Spring Boot Recipes | 
```

12.  我们还将在项目根目录下的`src/test/java/com/example/bookpub`目录中创建一个相应的`RestfulStepdefs.java`文件，内容如下:

```java
import cucumber.api.java.Before; 
import cucumber.api.java.en.Given; 
import cucumber.api.java.en.Then; 
import cucumber.api.java.en.When; 

import static org.hamcrest.CoreMatchers.containsString; 
import static org.junit.Assert.assertTrue; 
import static org.junit.Assert.assertNotNull; 
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content; 

@WebAppConfiguration 
@ContextConfiguration(classes = BookPubApplication.class, loader = SpringBootContextLoader.class)  
public class RestfulStepdefs { 
  @Autowired 
  private WebApplicationContext context; 
  @Autowired 
  private BookRepository bookRepository; 

  private MockMvc mockMvc; 
  private ResultActions result; 

  @Before 
  public void setup() throws IOException { 
    mockMvc = 
       MockMvcBuilders.webAppContextSetup(context).build(); 
  } 

  @Given("^catalogue with books$") 
  public void catalogue_with_books() { 
    assertTrue(bookRepository.count() > 0); 
  } 

  @When("^requesting url ([^"]*)$") 
  public void requesting_url(String url) throws Exception { 
    result = mockMvc.perform(get(url)); 
  } 

  @Then("^status code will be ([\d]*)$") 
  public void status_code_will_be(int code) throws 
     Throwable { 
    assertNotNull(result); 
    result.andExpect(status().is(code)); 
  } 

  @Then("^response content contains ([^"]*)$") 
  public void response_content_contains(String content) 
     throws Throwable { 

    assertNotNull(result);     
    result.andExpect( 
      content().string(containsString(content)) 
    ); 
  } 
} 
```

13.  通过运行`./gradlew clean test`执行测试，测试应该会继续通过。

# 它是如何工作的...

如果您在看完所有这些代码并没有完全理解到底发生了什么之后感到有点迷茫，在这里您会发现我们所做的一切的详细分类。

让我们先快速概述一下什么是**步骤定义**。由于 Cucumber 框架使用**小黄瓜**特性文档文件来描述要测试的业务规则，这些业务规则以类似英语的语句形式表示，因此需要将它们翻译成可执行代码。这是步骤定义类的工作。定义的特性场景中的每一步都需要与执行它的步骤定义类中的方法相匹配。这种匹配是通过在方法上方的步骤注释中声明正则表达式来完成的。regex 包含 Cucumber 用来提取方法参数并将它们传递给执行方法的匹配组。

在`RepositoryStepdefs`中，我们可以通过以下方法看到这一点:

```java
@Given("^([^\"]*) fixture is loaded$") 
public void data_fixture_is_loaded(String fixtureName) {...} 
```

`@Given`注释包含匹配`Given packt-books fixture is loaded`文本的正则表达式，从`repositories.feature`文件加载，并从模式中提取`packt-books`文本，然后作为`fixtureName`参数传递给方法。`@When`和`@Then`注释的工作原理完全相同。因此，实际上，Cucumber 框架所做的是将特征文件中类似英语的措辞规则与执行方法的匹配模式进行匹配，并提取部分规则作为匹秘籍法的参数。

更多关于小黄瓜和如何使用它的信息可以在[https://cukes.info/docs/reference#gherkin](https://cukes.info/docs/reference#gherkin)找到。

在解释了基本的 Cucumber 概述之后，让我们将注意力转移到测试如何与 Spring Boot 集成以及如何配置。

这一切都从 driver harness 类开始，在我们的例子中是`RunCukeTests`。这个类本身不包含任何测试，但是它有两个重要的注释将事情联系在一起，`@RunWith(Cucumber.class)`和`@CucumberOptions`:

*   `@RunWith(Cucumber.class)`:这是一个 JUnit 注释，指示 JUnit runner 应该使用 Cucumber 特性文件来执行测试。

`@CucumberOptions`:这为黄瓜提供了额外的配置:

*   `plugin={"pretty", "html:build/reports/cucumber"}`:这告诉 Cucumber 在`build/reports/cucumber`目录下生成 HTML 格式的报告。
*   这是一个非常重要的设置，因为它告诉 Cucumber 在测试执行过程中加载哪些包以及从哪里加载。为了利用`cucumber-spring`集成库，需要有`cucumber.api.spring`包，而`com.example.bookpub`包是我们的步骤定义实现类的位置。
*   `monochrome = true`:这告诉 Cucumber 在我们与 JUnit 集成时不要打印 ANSI 颜色的输出，因为它在保存的控制台输出文件中看起来不正确。

完整的选项列表可以在 https://cukes.info/docs/reference/jvm#list-all-options 找到。

现在我们来看看`RepositoryStepdefs`类。它从类级别的以下注释开始:

*   `@WebAppConfiguration`指示 Spring 这个类需要`WebApplicationContext`初始化，它将在执行过程中用于测试目的
*   `@ContextConfiguration(classes = BookPubApplication.class`和`loader = SpringBootContextLoader.class)`指示 Spring 使用`BookPubApplication`类作为 Spring 应用上下文的配置，并使用来自 Spring Boot 的`SpringBootContextLoader`类来引导测试工具

值得注意的是，这些注释必须匹配所有的步骤定义类，否则只有一个类会用`@ContextConfiguration`注释进行注释，以连接到 Cucumber 测试的 Spring 支持中。

由于`cucumber-spring`集成不知道 Spring Boot，而只知道春天，所以我们不能使用`@SpringBootTest`元注释。我们不得不求助于仅使用来自 Spring 的注释来将事情缝合在一起。值得庆幸的是，我们不必经历许多麻烦，只需通过传递所需的配置类和加载器来声明`SpringBootTest` facades 的确切注释即可。

一旦正确的注释就位，Spring 和 Spring Boot 将接管并为我们提供自动装配 beans 的便利，就像依赖我们的步骤定义类一样。

Cucumber 测试的一个有趣的特征是，每次执行**场景**时，都会实例化一个步骤定义类的新实例。尽管方法名称空间是全局的——这意味着我们可以使用在不同的步骤定义类中声明的方法——它们对在其中定义的状态进行操作，并且不直接共享。然而，可以在不同的步骤定义实例中`@Autowire`另一个步骤定义的实例，并依靠公共方法或字段来访问和改变数据。

当每个场景创建一个新的实例时，定义类是有状态的，并依赖内部变量在断言之间的转换中保持状态。例如，在`@When`带注释的方法中，一个特定的状态被设置，而在`@Then`带注释的方法中，该状态上的一组断言被评估。在我们的`RepositoryStepdefs`类的例子中，我们将在内部设置`loadedBook`类变量在它的`searching_for_book_by_isbn(...)`方法中的状态，这个变量后来被用来断言 on，以便以后在`book_title_will_be(...)`方法中验证书名的匹配。由于这个原因，如果我们在我们的特征文件中混合不同定义类的规则，内部状态将不能在多个类中访问。

当与 Spring 集成时，可以使用被模仿对象的注入——正如我们在前面的一个例子的`MockPublisherRepositoryTests`中看到的——并且可以使用共享的`@Given`注释方法为给定的测试设置模仿的特定行为。然后我们可以使用同一个依赖实例，并将其注入到另一个定义类中，该定义类可用于评估`@Then`注释断言方法。

另一种方法是我们在第二个定义类`RestfulStepdefs`中看到的，我们在其中注入了`BookRepository`。然而，在`restful.feature`中，我们将使用`Given packt-books fixture is loaded`行为声明，该声明转换为来自`RepositoryStepdefs`类的`data_fixture_is_loaded`方法的调用，该方法共享注入的`BookRepository`对象的相同实例，将`packt-books.sql`数据插入其中。

如果我们需要从`RestfulStepdefs`类中的`RepositoryStepdefs`实例中访问`loadedBook`字段的值，我们可以在`RestfulStepdefs`中声明`@Autowired RepositoryStepdefs`字段，并使`loadedBook`字段成为`public`而不是`private`，以使外部世界可以访问它。

Cucumber 和 Spring 集成的另一个优秀特性是在特性文件中使用了`@txn`注释。这告诉 Spring 在事务包装器中执行测试，在测试执行之间重置数据库，并保证每个测试都有一个干净的数据库状态。

由于所有步骤定义类和测试行为定义特性文件之间的全局方法命名空间，我们可以利用 Spring injection 的强大功能，以便重用测试模型，并为所有测试提供一个公共的设置逻辑。这使得测试的行为类似于我们的应用在真实生产环境中的运行方式。

# 使用 Spock 编写测试

另一个同样流行的测试框架是 Spock，它是由 Peter Niederwieser 用 Groovy 编写的。作为一个基于 Groovy 的框架，它非常适合为大多数基于 JVM 的语言创建测试套件，尤其是 Java 和 Groovy 本身。Groovy 的动态语言特性使它非常适合用 Groovy 语言编写优雅、高效和富于表现力的规范，而不需要翻译。这是在黄瓜库的帮助下完成的。它基于 JUnit 之上，并通过 JUnit 的`@RunWith`工具与它集成，就像 Cucumber 所做的那样，它是对传统单元测试的一个简单的增强，并与所有现有工具很好地配合，这些工具具有内置的支持或与 JUnit 的集成。

在这个秘籍中，我们将从上一个秘籍停止的地方继续，用几个基于 Spock 的测试来增强我们的测试集合。在这些测试中，我们将看到如何使用 Spring 依赖注入和测试工具来设置 MockMVC。这些将由 Spock 测试规范使用，以便验证我们的数据存储库服务将按预期返回数据的事实。

# 怎么做...

1.  为了将 Spock 测试添加到我们的应用中，我们首先需要对我们的`build.gradle`文件做一些修改。因为 Spock 测试是用 Groovy 编写的，所以要做的第一件事就是给我们的`build.gradle`文件添加一个`groovy`插件，如下所示:

```java
apply plugin: 'java' 
apply plugin: 'eclipse' 
apply plugin: 'groovy' 
apply plugin: 'spring-boot' 
```

2.  我们还需要将必要的 Spock 框架依赖项添加到`build.gradle`依赖项块中:

```java
dependencies { 
  ... 
  testCompile('org.spockframework:spock-core:1.1-groovy-2.4-rc-2') 
  testCompile('org.spockframework:spock-spring:1.1-groovy-2.4-rc-2') 
  ... 
} 
```

3.  由于测试将在 Groovy 中进行，我们需要为文件创建一个新的源目录。让我们在项目的根目录下创建`src/test/groovy/com/example/bookpub`目录。
4.  现在我们准备编写我们的第一个测试。在我们项目的根目录下的`src/test/groovy/com/example/bookpub`目录中创建一个`SpockBookRepositorySpecification.groovy`文件，内容如下:

```java
package com.example.bookpub;

import com.example.bookpub.entity.Author;
import com.example.bookpub.entity.Book
import com.example.bookpub.entity.Publisher
import com.example.bookpub.repository.BookRepository
import com.example.bookpub.repository.PublisherRepository
import org.mockito.Mockito
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.mock.mockito.MockBean
import org.springframework.jdbc.datasource.init.DatabasePopulatorUtils
import org.springframework.jdbc.datasource.init.ResourceDatabasePopulator
import org.springframework.test.web.servlet.MockMvc
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.context.ConfigurableWebApplicationContext
import spock.lang.Specification

import javax.sql.DataSource

import static org.hamcrest.CoreMatchers.containsString
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 

@SpringBootTest 
@AutoConfigureMockMvc 
class SpockBookRepositorySpecification extends Specification { 
  @Autowired 
  private ConfigurableWebApplicationContext context 

  @Autowired 
  private DataSource ds; 

  @Autowired 
  private BookRepository repository; 

  @Autowired 
  private MockMvc mockMvc; 

  void setup() { 
    ResourceDatabasePopulator populator = 
       new ResourceDatabasePopulator(
         context.getResource("classpath:/packt-books.sql")); 
    DatabasePopulatorUtils.execute(populator, ds); 
  } 

  @Transactional 
  def "Test RESTful GET"() { 
    when: 
      def result = mockMvc.perform(get("/books/${isbn}")); 

    then: 
      result.andExpect(status().isOk()) 
      result.andExpect( 
        content().string(containsString(title)) 
      ); 

    where: 
      isbn               | title 
      "978-1-78398-478-7"|"Orchestrating Docker" 
      "978-1-78528-415-1"|"Spring Boot Recipes" 
  } 

  @Transactional 
  def "Insert another book"() { 
    setup: 
      def existingBook =  
        repository.findBookByIsbn("978-1-78528-415-1") 
      def newBook = new Book("978-1-12345-678-9",
         "Some Future Book", existingBook.getAuthor(), 
         existingBook.getPublisher() 
      ) 

    expect: 
      repository.count() == 3 

    when: 
      def savedBook = repository.save(newBook) 

    then: 
      repository.count() == 4 
      savedBook.id > -1 
  } 
} 
```

5.  通过运行`./gradlew clean test`执行测试，测试应该会通过。

6.  随着 Spock 与 JUnit 的集成，我们可以看到 Spock 测试的执行报告以及测试套件的其余部分。如果我们在浏览器中打开`build/reports/tests/index.html`并点击 Classes 按钮，我们将在表格中看到我们的规范，如下面的截图所示:

![](img/a534256a-f4a6-4297-995e-5e37da0f0deb.png)

7.  选择 com . example . book pub . spockbookrespositoryspecification 链接会将我们带到详细报告页面，如下所示:

![](img/a2d3fda6-0523-4366-a865-e45b874fdb76.png)

8.  接下来，我们将进一步测试，探索数据库存储库的模拟功能。让我们使用`PublisherRepository`作为我们的候选来模仿，并将其连接到`BookController`类中以提供一个`getBooksByPublisher`功能。让我们将以下内容添加到项目根目录下的`src/main/java/com/example/bookpub/controllers`目录中的`BookController`类中:

```java
@Autowired 
private PublisherRepository publisherRepository; 

@RequestMapping(value = "/publisher/{id}", method = RequestMethod.GET) 
public List<Book> getBooksByPublisher(@PathVariable("id") Long id) { 
    Optional<Publisher> publisher =
        publisherRepository.findById(id);
    Assert.notNull(publisher);
    Assert.isTrue(publisher.isPresent());
    return publisher.get().getBooks(); 
} 
```

9.  让我们将以下内容添加到项目根目录下的`src/main/java/com/example/bookpub/entity`目录中的`Publisher`类中:

```java
@OneToMany(mappedBy = "publisher") 
@JsonBackReference 
private List<Book> books; 

```

10.  最后，让我们将书籍的 getter 和 setter 也添加到`Publisher`实体类:

```java
public List<Book> getBooks() { 
    return books; 
} 

public void setBooks(List<Book> books) { 
    this.books = books; 
} 
```

11.  添加完所有代码后，我们准备向项目根目录下的`src/test/groovy/com/example/bookpub`目录中的`SpockBookRepositorySpecification.groovy`文件添加另一个测试，内容如下:

```java
... 
class SpockBookRepositorySpecification extends Specification { 
    ... 
    @MockBean 
    private PublisherRepository publisherRepository 

    @Transactional 
    def "Test RESTful GET books by publisher"() { 
        setup: 
          Publisher publisher =  
                    new Publisher("Strange Books") 
          publisher.setId(999) 
          Book book = new Book("978-1-98765-432-1", 
                "Mystery Book", 
                new Author("John", "Doe"), 
                publisher) 
          publisher.setBooks([book]) 
          Mockito.when(publisherRepository.count()). 
                thenReturn(1L)                    
          Mockito.when(publisherRepository.findById(1L)). 
                thenReturn(Optional.of(publisher)) 

        when: 
          def result =  
            mockMvc.perform(get("/books/publisher/1")) 

        then: 
          result.andExpect(status().isOk()) 
          result.andExpect(content(). 
                string(containsString("Strange Books"))) 

        cleanup: 
          Mockito.reset(publisherRepository) 
    } 
} 
```

12.  通过运行`./gradlew clean test`执行测试，测试应该会继续通过。

# 它是如何工作的...

正如您从这个例子中看到的，编写测试可以像被测试的产品代码本身一样精细和复杂。让我们检查一下为了将 Spock 测试集成到我们的 Spring Boot 应用中所采取的步骤。

我们做的第一件事是添加一个 Groovy 插件，以使我们的构建 Groovy 友好，我们还添加了所需的 Spock 库依赖项`spock-core`和`spock-spring`，这两者都是使 Spock 与 Spring 的依赖项注入和上下文一起工作所必需的。

下一步是创建`SpockBookRepositorySpecification` Spock 规范，它扩展了 Spock 的规范抽象基类。扩展`Specification`类非常重要，因为这是 JUnit 知道我们的类是需要执行的测试类的方式。如果我们查看`Specification`源代码，我们会看到`@RunWith(Sputnik.class)`注释，就像我们在黄瓜秘籍中使用的那个一样。除了 JUnit 引导，`Specification`类也为我们提供了许多有用的方法和模仿支持。

有关 Spock 提供的详细功能的更多信息，您可以参考位于[http://Spock framework . github . io/Spock/docs/current/index . html](http://spockframework.github.io/spock/docs/current/index.html)的 Spock 文档。

同样值得一提的是，我们对`SpockBookRepositorySpecification`类使用了与基于 Spring Boot 的测试相同的注释，如下面的代码所示:

```java
@SpringBootTest
@AutoConfigureMockMvc 
```

除了`@SpringBootTest`之外，我们还必须添加`@AutoConfigureMockMvc`的原因是为了增加功能，允许我们使用`@Autowire MockMvc`实例，而不是必须自己创建一个。常规的`@SpringBootTest`不会自动创建和配置一个`MockMvc`对象的实例，所以我们可以手动创建它，就像我们在`BookPubApplicationTests`中做的那样，或者添加`@AutoConfigureMockMvc`注释，这是在`@WebMvcTest`中使用的，让 Spring 为我们处理它。好消息是，我们可以一直使用 Spring Boot 使用的注释组合，直接注释我们的类，这正是我们所做的。

与 Cucumber 不同，Spock 将测试的所有方面结合在一个`Specification`类中，将它分成多个块，如下所示:

*   `setup`:这个模块用于用变量配置特定的测试，填充数据，构建模型，等等。
*   这个模块是刺激模块之一，正如斯波克所定义的那样，它被设计成包含简单的表达方式来断言一种状态或条件。除了对条件求值，我们只能在这个块中定义变量，其他都不允许。
*   `when`:该块是另一种刺激类型的块，总是与`then`搭配。它可以包含任意代码，并且被设计用来定义我们试图测试的行为。
*   `then`:该块为响应型块。它类似于`expect`，只能包含条件、异常检查、变量定义和对象交互，比如某个特定方法被调用了多少次等等。

关于交互测试的更多信息可以在 Spock 的网站上获得，网址是 http://Spock framework . github . io/Spock/docs/current/interaction _ based _ testing . html。

*   这个块用于清理环境的状态，并潜在地撤销作为单独测试执行的一部分所做的任何改变。在我们的菜谱中，这是我们重置`PublisherRepository`模拟对象的地方。

Spock 也为我们提供了基于实例的`setup()`和`cleanup()`方法，它们可以用来定义规范中所有测试的设置和清理行为。

如果我们看一下我们的`setup()`方法，这是我们可以用测试数据配置数据库群体的地方。一个有趣而重要的细微差别是，`setup()`方法在每个测试方法之前执行，而不是每个类执行一次。在进行填充数据库这样的操作时，记住这一点很重要，这样可以避免多次重复插入相同的数据而没有正确的回滚。

帮助我们的是测试方法的`@Transactional`注释。就像 Cucumber 特性文件中的`@txn`标签一样，这个注释指示 Spock 执行带注释的方法及其对应的具有事务范围的`setup()`和`cleanup()`执行，这些执行在特定的测试方法完成后回滚。我们依靠这种行为来为每个测试获得一个干净的数据库状态，所以我们不会在每次测试运行时在执行`setup()`方法的过程中插入重复的数据。

你们中的大多数人可能想知道为什么我们必须将`@JsonBackReference`注释添加到我们的`Publisher`实体类中。答案与 Jackson JSON 解析器以及它如何处理循环依赖有关。在我们的模型中，我们有一本书属于一个出版商，每个出版商有多本书。当我们用`Books` mock 创建了我们的`Publisher`类，并为一本书分配了一个 publisher 实例时——这本书后来被放入了 publisher 的图书收藏中——我们创建了一个循环引用。在执行`BookController.getBooksByPublisher(...)`方法的过程中，Jackson 渲染器在试图将对象模型写入 JSON 时会抛出`StackOverflowError`。通过给`Publisher`添加这个注释，我们告诉 Jackson 对象是如何相互引用的，因此 Jackson 现在可以正确地处理它，从而避免了循环引用的情况，而不是试图写出完整的对象树。

需要记住的最后一件重要的事情是，Spring Boot 如何处理用`@RepositoryRestResource`注释的存储库接口。不像`BookRepository`接口，我们用一个普通的`@Repository`注释进行了注释，后来明确声明为我们的`BookController`类的 autowire 依赖项，我们没有创建一个明确的控制器来处理我们的库接口的其余部分的 RESTful 请求，比如`PublisherRepository`和其他。这些接口被 Spring Boot 扫描，并被映射的端点自动包装，这些端点捕获请求并将调用委托给后台`SimpleJpaRepository`代理。由于这种设置，我们只能对这些对象使用模拟对象替换方法，这些对象已经被显式地注入为 bean 依赖项，例如我们的示例`BookRepository`。好消息是，在这些情况下，我们并不明确期望 beans 被连接起来，只使用一些注释来构造 Spring Boot 的接口，我们可以依靠 Spring Boot 来正确地完成这项工作。我们知道它已经测试了它背后的所有功能，所以我们不必测试它们。为了测试实际的存储库和实体功能，我们可以使用`@DataJpaTest`注释来进行特定的 JPA 切片测试。