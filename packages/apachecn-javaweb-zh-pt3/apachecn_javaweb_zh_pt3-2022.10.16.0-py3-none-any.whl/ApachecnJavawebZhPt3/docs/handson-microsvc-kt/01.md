# 一、了解微服务

微服务及其不断发展的架构已经成为企业应用中最常用的方法之一。在这本书里，我们将试着去理解它们到底是什么，以及它们所基于的原则。使用领域驱动的设计，我们将强化那些原则，以维护一个可以与我们的应用一起发展的干净的架构。

由于微服务没有静态架构，我们将发现新的反应范式如何改变我们创建它们的方式。最后，我们将概述云架构，以及为什么我们应该创建云原生微服务。

在本章中，您将了解:

*   微服务到底是什么
*   了解微服务原则
*   为干净的架构使用领域驱动的设计
*   无阻塞反应式微服务
*   云原生微服务及其优势

# 什么是微服务？

微服务是模块化、松散耦合的服务，提供细粒度的协议。它们在物理上分离了关注点，并允许我们独立地设计、开发、测试和部署它们。

由于它们的模块化能力，它们可以由小型的跨职能团队创建，这些团队正在接受敏捷方法和 DevOps 文化的好处。它们也是持续交付和部署的理想选择。

**DevOps** is a software development and delivery process that emphasizes communication and collaboration between product management, software development, and operations professionals.

它们易于理解并与其他服务良好连接，使得复杂应用的集成成为一项轻量级任务。它们可以独立扩展、监控和控制，以便充分受益于云架构。

# 理解 SoA

微服务是**面向服务架构** ( **SoA** )的演化。所以，如果我们想要理解什么是微服务，我们需要理解什么是 SoA。SoA 的基础是让应用组件通过一组服务进行通信，这些服务是可以远程访问的独立功能单元。服务是 SoA 的基石，这同样适用于微服务。

如 SoA 中所述，服务有四个属性:

*   它在逻辑上代表了具有特定结果的业务活动
*   它是独立的
*   对消费者来说，这是一个黑盒子
*   它可能包含其他底层服务

为了理解这些属性，让我们看一个使用 SoA 的应用的例子:

![](img/00005.jpeg)

SoA 应用示例

在这种典型的 n 层架构中，应用分为三层:

*   **表示层**:为我们的客户保存用户界面
*   **业务层**:拥有为我们的业务能力实现领域逻辑的服务
*   **数据层**:保持我们的领域模型

每个组件都包括在特定的业务活动中与客户进行交互的逻辑，为此，使用业务层提供的服务。每个服务代表一个业务活动的实现。例如，您登录到由登录服务提供的应用，检查由报价服务提供的报价，或者通过订单服务创建订单。这些服务在业务层中是自包含的，它们充当消费者的黑盒——组件不知道服务是如何实现的，也不知道域模型是如何持久化的。所有的服务都依赖于客户服务来获取客户数据，或者返回客户信息，但是客户并不知道这些细节。

这种方法为使用它的任何体系结构提供了几个好处:

*   标准化服务合同，允许与组件轻松集成
*   可重用性，允许服务相互委托职责
*   业务价值，实现业务能力
*   隐藏复杂性；如果我们需要更改数据库，客户端不会受到影响
*   Autonomyl 每一层都可以分离并远程访问

# 区分微服务和 SoA

微服务架构从 SoA 发展而来，但它有一些我们需要了解的关键区别。让我们用微服务架构重现前面的 SoA 示例，并回顾这种类型的架构的差异和优势:

![](img/00006.jpeg)

微服务应用示例

在这种架构中，各层没有绑定在一起，因为它们在逻辑上是完全分开的。每个微服务都与其他服务完全分离，因此即使是我们的 UI 组件也可以是完全独立的、可部署的模块。这些微服务拥有自己的数据，它们可以在不影响彼此的情况下被改变。当面临持续集成或交付时，这是一个突出的功能，因为我们可以为我们的测试和管道提供数据，而不会影响应用的其他部分。

由于他们的独立性，他们可以非常具体。我们可以利用这一优势将专业知识融入到我们的团队中。从业务能力控制领域逻辑的专家团队可以有效地向我们的产品交付更好的价值。

我们可以改变开发语言、平台或技术的范围来构建每个微服务。由于它们是完全独立的，我们可以为每一个不同的业务需求使用不同的数据库，或者使用某些技术，这些技术将使我们能够更容易地适应某些需求。

由于它们是模块化的，我们可以独立地部署它们，并拥有不同的发布周期。当我们需要监控它们时，我们可以根据它们的工作性质和工作方式创建不同的警报或 KPI。对于我们会计流程中使用的微服务，它可能与只为我们的营销横幅提供内容的微服务不一样。出于类似的原因，我们可以分别对它们进行缩放；我们可以为一些微服务提供更多的服务器，或者为其他服务提供更多的 CPU 或资源。

Taking advantage of how we can control and monitor microservices independently will grant us the ability to optimize scaling.

微服务的基础设施通常更简单，因为没有那么多复杂的服务器需要管理、配置、监控和控制，没有庞大的数据库模式，而且由于团队内部的专业知识更高，更多的事情可以轻松自动化。这将使微服务团队中的 DevOps 文化成为一种普遍做法，有了它，我们的产品将获得更大的灵活性。

由于微服务团队通常规模较小，业内普遍认为微服务团队的最佳规模是可以吃两个披萨的规模。不管这是不是现实，保持你的团队小将有助于最大化这种类型的架构的价值。

如果我们先看 SoA，再看微服务，我们能看到的是一个自然的演变。微服务架构利用了 SoA 的优势，然后在同一方向定义了额外的步骤。所以，我们可以肯定地说:

*"Microservices are SoA but all SoA are not microservices."*

# 从整体到微服务

那么，SoA 为什么会进化成微服务呢？也许其中一个原因是由于巨石。曾经有一段时间，应用很小，表示逻辑通常与业务逻辑结合在一起。然后，领域模型变得复杂，出现了许多软件模式。他们中的大多数都关注一件事:关注点分离。

**分离** **关注点** ( **SoC** )是一种将软件分成不同部分的设计原则，这样每个部分只处理一个关注点。但是软件不是唯一需要分离的东西；架构也需要它。像 SoA 这样的东西就是为此而设计的，因为它允许我们将复杂性隐藏在黑盒后面，使我们的架构更加模块化，并且能够处理我们需要的复杂性。

我们可以基于详细的业务规则在大型机中创建一个复杂的数据存储，或者在一个具有深层模式、复杂存储过程、视图和关系的强大数据库上创建一个复杂的数据存储。我们可以选择框架和工具来轻松编排所有这些部分。我们可能还需要一个强大的**企业软件总线** ( **ESB** )。

ESB 是一个软件组件，负责服务的协调、映射和路由。总体想法是拥有一个非常强大的组件来轻松编排消息。为了创建复杂的应用，服务的设计使用了大部分这些元素，从而创建了复杂的关系。

从服务相互调用，到视图查询几个表，从不同的业务领域提取数据。最后，在我们的 ESB 中合并一些具有业务规则的元素，以产生新的服务。

![](img/00007.jpeg)

复杂的 SoA 应用

更改一个服务或模式中的一个表会在整个应用中产生连锁效应，导致需要更改那些关系和依赖关系，无论它们是服务、映射还是屏幕，因为它们都捆绑在一起。在许多情况下，这会导致长的发布周期，因为处理这种复杂程度并不是一件容易的事情。开发、配置、测试和部署也是如此。

甚至扩展应用都会受到影响，无论是更大的数据库、更多的服务服务器，还是更大的用于处理更多消息的 ESB。由于它们相互依赖，所以不容易单独对它们进行缩放。所有这些意味着我们的架构是耦合的，我们已经创建了一个整体的应用。

单一应用在 SoA 之前就存在了，事实上，这是 SoA 帮助处理的事情之一，将客户端从业务领域中分离出来。不幸的是，试图实现 SoA 将许多应用推回了它。

这是否意味着做 SoA 会产生一个庞然大物？不。事实上，在微服务概念出现之前，许多架构师和开发人员就开始采用模式和架构来处理这个问题。这就演变成了我们今天所说的微服务。

在那个名字存在之前就有人做微服务了；他们称之为 SoA。

# 微服务原则

定义微服务原则将允许我们构建可扩展、易于维护的企业应用。当我们回顾它们时，我们将把重点放在好处和坏处上。我们理解，有时在其中一些问题上可能会有一些分歧；但是，我们鼓励您全部阅读。最后，我们知道可能有几十个或更多的原则可以被包括在内，但是我们选择了在本书的上下文中最有意义的原则。

# 定义设计原则

我们在设计微服务的时候需要选择一套原则；它们每一个都有自己的优势，这将在本章的后面讨论，但是定义它们也将允许我们对不同类型的问题有一个一致的方法，并且将帮助其他人理解我们的架构。

我们将要定义的关键原则是:

*   围绕业务能力建模
*   松散耦合
*   单一责任
*   隐藏实现
*   隔离
*   可独立部署
*   为失败而建造
*   可量测性
*   自动化

# 围绕业务能力建模

设计良好的微服务应该围绕要实现的业务功能进行建模。设计软件有一个抽象的组成部分，我们习惯于获取需求并实现它们，但是我们必须考虑每个人，包括我们，现在和将来如何理解解决方案。

当我们需要更新甚至修改我们的微服务时，我们需要抽象回定义它的原始概念。在这个过程中，我们可以意识到有些事情并不像我们最初理解的那样，或者我们的设计无法进化。我们甚至可能会发现，我们必须打破业务领域的界限，我们不再实现原来的功能，或者实际上它是跨一组不同的不相关的微服务实现的。我们最终可能会将我们的微服务耦合在一起，这是我们希望避免的。

这些业务功能的领域专家清楚地了解它们是如何操作的，以及这些功能是如何组合和使用的。与他们合作可以使我们的微服务为每个人所理解，包括我们未来的自己，并将使我们的服务不仅仅成为一种抽象，而是原始业务能力的映射。

尽可能与你的领域专家紧密合作，这将永远使你受益。

我们将在本章的*领域驱动设计*部分深入探讨这个话题。

# 松散耦合

没有一个微服务是独立存在的，因为任何系统都需要与其他系统交互，包括其他微服务，但我们需要尽可能地松散耦合。假设我们正在设计一个微服务，它为一个给定的客户返回可用的报价，我们可能需要一个与客户的关系，例如，一个客户 ID，这应该是我们可以接受的最大耦合。

想象一个场景，对于使用我们产品的组件，微服务需要在显示这些产品时显示客户名称。我们可以修改我们的实现，使用客户微服务将该信息添加到我们的响应中，但是这样做，我们是在与客户微服务耦合。在这种情况下，如果客户姓名字段发生了变化，例如，不仅仅是一个姓名，而是被分为姓氏和名字，我们需要更改微服务的输出。需要避免这种类型的耦合；我们的微服务应该只返回真正属于它们的领域的信息。

记住，我们的领域专家可以帮助我们理解一个业务能力是否拥有一个功能；客户服务方面的专家可能知道客户名称是另一个业务功能中的句柄。

我们需要注意我们是如何耦合的，不仅仅是微服务之间的耦合，还包括我们架构中的一切，包括外部系统。这就是为什么每个微服务都应该拥有自己的数据的原因之一，这甚至包括保存数据的数据库。

# 单一责任

每个微服务应该只负责应用提供的功能的一个部分，而这个责任应该完全由微服务来承担。微服务的设计应该与这一职责紧密结合。

我们可以采用 Robert C. Martin 对应用于 OOP 的原则的定义:“一个类应该只有一个改变的理由”；对于这个原理，我们可以说:一个微服务应该只有一个改变的理由。

如果我们意识到，当我们需要更改应用中的业务功能时，它会修改几个微服务，或者一个更改会级联到不相关的微服务中，那么是时候重新考虑如何设计它们了。

这并不意味着我们可以制造只执行一种操作的微服务。也许让微服务来处理客户操作是个好主意，比如创建、查找、删除，但可能不应该处理向客户添加优惠等操作。

# 隐藏实现

微服务通常有一个清晰易懂的接口，必须隐藏实现细节。我们不应该公开内部细节，无论是技术实现还是驱动它的业务规则。

运用这一原则，我们减少了与他人的耦合，我们的任何细节变化都会影响到他们。我们将阻止影响整体架构的技术变更或改进。我们应该总是能够在需要的时候改变，从我们坚持我们的业务模型的地方，到我们使用的编程语言或框架。

但是我们还需要能够修改我们的逻辑和规则，以适应我们领域内的任何变化，而不影响整个应用。帮助处理变化是设计良好的微服务架构的好处之一。

# 隔离

微服务应该在物理上和/或逻辑上与使用它所依赖的系统的基础设施相隔离。如果我们使用数据库，它一定是我们的数据库，如果我们在服务器上运行，它应该在我们的服务器上，以此类推。有了这个，我们保证没有外部的东西影响我们，我们也不会影响任何外部的东西。

这将有助于从部署到性能或监控，甚至在建立我们的持续交付渠道。这将有助于我们独立控制和扩展，并帮助我们团队中的运营职能部门管理我们的微服务。

我们应该远离架构中某些部分的失败会影响到其他部分的日子。容器是有效实现这一原则的关键架构之一。我们将在本章的*云原生微服务*部分了解更多信息。

# 可独立部署

微服务应该是可独立部署的；如果没有，这可能意味着我们的架构中存在某种需要解决的耦合。如果我们可以满足其他原则，但我们在这一点上失败了，我们可能会减少这个架构的好处。

拥有持续交付的能力是微服务架构的优势之一；任何约束都应该被移除，就像我们从应用中移除 bug 一样。

我们应该从微服务和架构的设计开始就关注部署；在后期找到这个领域的约束可能会对整个应用产生很大的影响。

# 为失败而建造

我们在微服务中做了多少测试，实现了多少控制，触发了多少警报，这些都无关紧要；如果我们的微服务将要失败，我们需要为失败设计，尽可能优雅地处理它，并定义我们如何从中恢复。

“任何可能出错的事情都会出错。”

墨菲

当我们接近微服务的初始设计时，我们需要开始处理我们需要处理的更基本的错误。随着设计的发展，我们应该考虑所有的边缘场景，以及最终可能出现的问题。然后，我们需要评估我们将如何通知、监控和控制这些情况，我们如何恢复，以及我们是否有正确的信息和工具来解决这些问题。

设计微服务时，请考虑以下几个方面:

*   向上游
*   下游
*   记录
*   监视
*   发信号
*   恢复
*   后退

# 向上游

上游是理解我们将如何，或者如果我们不打算，通知错误给我们的消费者，但是记住总是避免耦合。

# 下游

下游指的是，如果我们依赖的某个东西出现故障，我们将如何处理，作为另一个微服务，甚至是一个系统，如数据库。

# 记录

日志记录是关于我们如何记录任何失败，考虑我们是否做得太频繁或太不频繁，信息量，以及如何访问这些信息。我们应该特别注意敏感信息和性能影响。

# 监视

监控需要精心设计。在监控系统中没有正确信息的情况下处理故障是一个非常成问题的情况；我们应该考虑应用的哪些元素具有有意义的信息。

# 发信号

警报是为了了解可能指示出问题的信号是什么，它与我们的监控以及可能与我们的日志记录有关，但是对于任何好的设计应用来说，仅仅对任何奇怪的事情发出警报是不够的。我们需要对这些信号以及它们之间的关系进行更深入的分析。

# 恢复

恢复就是设计我们如何应对这些失败，以恢复到正常状态。自动恢复应该是我们的目标，但是不应该避免手动恢复，因为自动恢复可能会失败。

# 后退

想想看，即使我们的微服务正在失败，我们仍然可以响应谁使用它们。例如，如果我们设计了一个微服务，它从客户那里获取报价，但是在访问数据层时遇到了问题，那么它可能会返回一组默认的报价，这使得应用至少可以获得一些有意义的信息。同样，如果我们使用一个外部服务，我们可能会有一个在该服务不可用时的回退机制。

回退是一种常见的模式，用于防止您的体系结构中的问题影响系统的其他部分。如果我们有一个好的后备，我们的应用可以工作，直到问题得到解决。

# 可量测性

微服务应该设计成可独立扩展的。如果我们需要增加我们可以处理的请求的数量或者我们可以保存的记录的数量，我们应该孤立地去做。由于架构上的耦合，我们应该避免这种情况；扩展我们的应用的唯一方法是将几个组件一起或通过整个系统进行扩展。

让我们回到最初的 SoA 应用示例，并处理一个需要扩展我们的产品功能的场景:

![](img/00008.jpeg)

扩展耦合 SoA 应用的示例

即使我们需要扩展的是我们的提供能力，由于系统的耦合，我们也需要作为一个整体来做。我们将增加我们拥有的表示层和业务层的实例数量，我们将通过更多实例或更大的数据库来增加我们的数据库。可能，我们还需要更新一些服务器，因为它们需要的资源会增加。在微服务架构中，我们可以只扩展所需的元素。让我们看看如何使用微服务扩展相同的应用:

![](img/00009.jpeg)

扩展微服务应用的示例

我们刚刚增加了对产品功能的要求，并保持架构的其余部分不变，我们需要考虑在微服务中，这些服务器较小，由于其范围有限，不需要太多资源。

In a well-designed microservice architecture, we could effectively have more capacity with less infrastructure since it could be optimized for more accurate use and be scaled independently.

我们将在本章的*云原生微服务*部分回顾更多关于这个主题的内容。

# 自动化

从构建或测试到部署和监控，我们的微服务在设计时应考虑自动化。由于我们的服务将会很小，而且是孤立的，因此自动化的成本应该很低，收益应该很高。

根据这一原则，我们可以提高应用的敏捷性，并防止不必要的手动任务对系统产生影响。由于这些原因，持续集成和持续交付应该从我们架构的开始就进行设计。

# 领域驱动设计

在我们的微服务中使用**领域驱动设计** ( **DDD** )将有助于我们满足我们的微服务原则，但 DDD 也将有助于以有利于我们从这种类型的架构中获得价值的方式组织我们的产品团队。但首先，我们需要了解 DDD 实际上是什么，以及我们如何应用它来创建一个干净的架构。

# 什么是领域驱动的设计

领域驱动设计是一种软件开发方法，它连接到一个不断发展的复杂模型，该模型绑定到一个核心领域。

术语**领域驱动设计**是 Eric Evans 在他的同名书中创造的。

当我们接近一个复杂的系统时，我们通常把它抽象成一个模型，这个模型描述了系统的不同方面，以及我们如何用它来解决问题。当使用多个模型时，不同模型的代码库组合在一起，软件就会变得错误、不可靠、难以理解。通常不清楚在什么情况下不应该应用模型。领域是我们系统的用户理解的知识领域，以及他们用来与我们的软件交互的东西；他们是领域专家。

在 DDD，我们定义模型适用的环境；根据团队组织、应用特定部分的使用以及物理表现(如代码库和数据库模式)明确设置界限，在这些界限内保持模型的严格一致性。

# 普遍存在的语言

在 DDD，我们应该在开发者和用户之间建立一种共同的、严谨的语言。这种语言应该基于领域模型，并且将帮助我们与领域专家进行无处不在和流畅的对话，并且在接近测试时将被证明是必不可少的。

由于我们的领域模型是我们软件的一部分，我们应该精确以避免任何歧义，并且随着领域的增长，随着我们知识的增长，发展模型和语言。但是在创建软件的时候，泛在语言的用法不应该只存在于我们的领域模型中，还应该存在于我们的领域逻辑甚至架构中。它将允许任何团队成员无处不在的理解。

创建使用领域语言的测试有助于任何团队成员理解我们的领域逻辑。

# 限界上下文

当一个领域模型增长时，拥有一个统一的领域模型就变得复杂了。有时，当我们看到一个概念的两种不同表示时，我们会面临一种情况，例如，让我们在一个大模型中考察家庭的概念。

在购物平台中，我们可能会有产品系列的概念，例如，我们出色的 32 英寸 LCD 屏幕和经典的 24 英寸 CRT 屏幕就是屏幕系列的一部分。另一方面，我们的速度优惠和最后一天优惠是我们有限的限时优惠系列的一部分。

我们可以看到，在产品和服务上，产品系列可能并不完全相同，可能它们在模型上都有一个独特的名称，但在每种情况下，它们可能有完全不同的模型和逻辑。

在 DDD，我们把它们分成有界的上下文，一个包围模型的边界。这使得边界内部的知识保持一致，忽略了外部世界，因此我们仍然可以为我们的领域模型使用无处不在的语言。

# 上下文映射

在为几个有限的上下文设计的大型应用中，我们可能会忽略全局视图。不可避免的是，各种有界的上下文需要在彼此之间共享或传递数据。上下文图是系统作为一个整体的全局视图，显示了我们的有界上下文应该如何相互通信。

![](img/00010.jpeg)

上下文映射示例

这是一个过于简单的例子，展示了三个有界的上下文以及它们是如何映射的。在产品上下文中，我们有我们的产品及其所属的系列。这里，我们将拥有这个域上下文的所有操作，并且它与任何其他上下文都没有直接的关系依赖。

我们的 offers bounded 上下文依赖于 product domain 上下文，但是这是一个弱关系，应该纯粹反映特定 offer 所属产品的 ID。该上下文将定义包含该上下文的域逻辑的操作。

在我们的购物绑定上下文中，我们与属于购物列表的产品有一个弱关系，并将对该上下文进行操作。最后，报价和购物概念都与客户有关系，这可能属于分离的边界上下文。

# 在微服务中使用 DDD

现在我们对 DDD 有了更清晰的了解，我们需要回顾一下如何将它应用到我们的微服务中。我们可以从以下几点着手:

*   **有界上下文**:我们不应该创建一个包含多个有界上下文的微服务:如果我们能够将整个上下文映射到单个微服务，这将更好，这表明我们的上下文确实是有界的
*   **无处不在的语言**:我们需要确保我们的微服务所使用的语言是无处不在的，所以暴露的操作和接口是用上下文域语言来表达的
*   上下文模型(Context Model):我们的微服务所使用的模型应该在有界限的上下文中定义，并且使用无处不在的语言，即使是对于没有在微服务提供的任何接口中公开的实体
*   **上下文映射**:最后，我们需要回顾整个系统的上下文映射，以了解我们的微服务的依赖性和耦合性

在回顾了这些要点之后，我们会注意到，我们实际上是在履行以前确定的主要原则。我们的微服务是围绕业务能力、我们的上下文域建模的，正如我们的上下文映射所示，它们是松散耦合的，并且具有绑定上下文应该具有的单一职责。实现有界上下文的微服务可以很容易地隐藏它们的实现，并且它们是自然隔离的，所以我们可以独立地部署它们。有了这些原则，就很容易为失败而构建，具有可伸缩性和自动化。最后，拥有一个遵循 DDD 的微服务架构将会交付一个任何团队成员都能理解的干净的架构。

The ubiquitous language of a well-designed bounded context will make many tasks easy in a microservice life cycle, from working with the domain experts to tests or any tasks for the ops function of our team.

# 反应式微服务

反应式编程是目前的一个趋势话题。这主要是因为使用这种新范式实现软件的好处。Spring Framework 5.0 包含了许多变化，以提供这种编程模型的优势，并且 Spring 家族的许多新组件已经发展到支持它。事实上，已经创建了新的 Spring 库，为对所谓的反应革命感兴趣的应用增加了额外的支持。此外，Spring 重写了框架的核心，使用了反应式技术，这将为使用它们的应用提供更好的技术。在本节中，我们将了解反应式编程的基础和原则，以及如何应用它来创建反应式微服务。

# 反应式编程

我们非常熟悉命令式编程:在我们的软件中，我们要求做一些事情并期待一个结果，同时，我们等待，我们的动作被阻止并期待一个结果。以这段小小的伪代码为例:

```java
var someVariable = getData()
print(someVariable)
```

在这两条指令中，我们将从返回数据的函数的输出中设置变量的内容；有了数据，我们会把它打印出来。这段代码中真正重要的部分是，我们的程序会停止，直到我们完全获得数据，这就是所谓的阻塞操作。

有一种方法可以绕过这种限制，这种方法在过去被广泛使用。例如，我们可以创建一个单独的线程来获取我们的数据，但实际上，该线程将被阻塞，直到完成，如果不同的请求需要处理这一点，我们最终会为每个请求创建一个线程，可能会使用一个池，但最终我们将达到我们可以处理的线程数量的限制。这是大多数传统应用的工作方式，但现在，这可以得到改善。

让我们来看看反应式编程中的一些伪代码:

```java
subscribe(::getData).whenDone(::print)
```

我们在这里尝试做的是订阅一个操作，当该操作完成时，将结果发送给另一个操作。在这个例子中，当我们得到数据时，我们将打印结果；重要的是，在那句话之后，我们的程序继续，所以它可以处理其他事情；这就是所谓的非阻塞操作。但这不仅仅适用于单个结果，我们可以订阅一个反应式数据流，当数据流开始流动时，它将调用我们的函数，逐步打印我们收到的数据。

一个反应流是一个数据集合，一旦它准备好了，它就会持续地流动，所以想象一下，不是向数据库查询一些结果，而是数据库在它准备好的时候就开始发送结果。许多现代数据库驱动程序支持这些概念。

这种新的编程模型允许我们用高性能的应用来处理比传统的阻塞模型多得多的请求。这种方法可以更有效地利用资源，并且可以减少我们的应用所需的基础设施数量。但是现在我们需要理解什么是反应式编程的真正原则。

# 反应宣言

2013 年，一个由来自世界上一些最大的软件公司的专家组成的工作组发布了《反应宣言》，该宣言为反应系统的理解和工作奠定了基础，该宣言可在[https://github.com/reactivemanifesto/reactivemanifesto](https://github.com/reactivemanifesto/reactivemanifesto)上获得。

让我们回顾一下宣言是怎么说的:

首先，宣言介绍了现代应用的现状，重点是这如何要求一种新的系统，这种系统需要比以前更快地响应更多的数据，并且必须具有可伸缩性、弹性和容错性。该宣言的目的是对这些问题有一个一致的方法，并定义反应系统以及我们从中获得什么好处。在我们的*微服务原则*章节中讨论了许多这些主题，因此回顾它们可能是一个好主意，但现在我们需要深入了解宣言中如何定义反应式系统。

如果你想签署舱单或有任何语言的 PDF 版本，你可以去 http://www.reactivemanifesto.org/。

# 应答的

现代的应用应该及时响应，但不仅仅是对系统的用户，而且是对我们的问题和错误的响应；我们已经远离了那些我们的应用会冻结的日子，那时有些东西要么需要更长的时间来回答，要么因为未知的原因而失败。

我们需要帮助用户获得无缝和可预测的体验，以便他们能够逐步在我们的系统中工作，并以一致的质量这样做，以便他们将被鼓励使用该系统，并通过随机的用户体验消除我们过去的耻辱。

# 弹回的

我们在“为失败和隔离而构建”的原则下讨论了这个话题的大部分内容，但宣言也指出，如果我们不能拥有弹性，我们就会影响我们的反应能力，这是我们应该处理的事情。

这些问题中的一些是可以处理的，并且正确地应用我们的可扩展性原则，因为我们可以通过复制和复制来存档恢复能力，这取决于我们的可扩展性。

# 弹性的

反应式系统应该是有弹性的，因此它们有效地应用可伸缩性原则来在变化的工作负载下保持响应，但是更内部地，系统本身可能具有增加或减少分配的资源的能力。

在旧的架构中，规划资源是我们架构的一部分；我们设计线程池来以一定的容量处理我们的请求，并且我们准备我们的服务器能够管理这一点。

在反应式系统中，如果需要，我们的服务可以动态地获取更多的资源，并在不需要时释放它们。

# 消息驱动的

反应式系统使用异步消息传递，通过非常松散耦合的不同组件传递信息，这允许我们隔离地互连这些系统。我们可以这样想，好像我们通过管道连接流，一个服务可以订阅另一个服务来获取一些信息，第二个服务可以订阅几个附加服务来组合数据并将其返回给原始服务。

![](img/00011.jpeg)

连接流

这些服务中的每一个都不知道为什么或如何使用这些信息，所以它们几乎没有关于依赖关系的信息。这使得我们可以很容易地替换这些部分，但是除了在失败的情况下处理错误之外，我们可以简单地用其他将处理和处理它们的接收器创建一个错误流。

但是宣言提到了施加反压力；我们需要进一步理解这个概念。

# 背压

当反应式系统以高于订户可以处理的速率发布时，会产生背压，换句话说，这就是反应式服务的消费者如何说:*请，我现在无法处理需求，停止发送数据，不要浪费资源*(例如，*缓冲存储器*)。

有一系列处理这种情况的机制，它们通常接近于反应式实现，从批处理消息到丢弃它们，但是现在，我们不需要进入细节，只需要理解任何反应式系统都必须处理背压。

# 反应式框架

我们可以使用几种反应式框架来创建反应式应用。

让我们列出更重要的框架:

*   反应式延伸(`ReactiveX`或`Rx`)
*   项目反应堆
*   Java 反应流
*   阿卡

# 反应性延伸

反应式扩展可能是创建反应式系统和支持更广泛的平台和编程语言的最流行的框架之一，从使用`RxJS`的 JavaScript 到使用`RxJava`的 Java，甚至在使用`Rx.Net`的`.Net`平台中。

它使用可观察的模式来执行无阻塞操作；大多数主要的反应系统都是使用`Rx`建造的。

更多详情请见:[http://reactivex.io/](http://reactivex.io/)。

# 项目反应堆

Project Reactor 是一个 JVM 反应式库，它遵循反应式流规范，并提供一个高级库来轻松创建反应式应用。Spring Framework 5.0 广泛使用 Project Reactor。

更多详情可在[https://projectreactor.io/.](https://projectreactor.io/)找到

反应式流是一种为具有非阻塞背压的异步流处理提供标准的倡议。可以参考[http://www.reactive-streams.org/](http://www.reactive-streams.org/)。

# Java 反应流

从 Java 9 开始，我们现在在 Java 平台上实现了反应流，一些项目正在将现有的 Rx 代码移植到新的 Java 9 库中。

更多详情请见:[https://community.oracle.com/docs/DOC-1006738](https://community.oracle.com/docs/DOC-1006738)。

# 阿卡

Akka 是由 Reactive Manifesto 的主要作者之一 Jonas Bonér 创建的，目的是在 JVM 中创建一个工具包，使用 Scala 创建并发和分布式应用。Akka 强调基于角色的模型，并已被证明支持高可伸缩的分布式应用。

更多详情请见:[https://akka.io/](https://akka.io/)。

# 反应式微服务

现在我们对反应式系统有了更好的理解，我们需要考虑为什么要创建反应式微服务。如果我们看看微服务，并记住是什么推动 SoA 进入微服务，我们就可以看到我们需要什么来创建更复杂的应用，并为驱动架构的用户生产更好的系统。有了新的反应式编程模型，我们可以创建快速、无阻塞的软件，更好地利用基础设施的资源。我们可以提供更好的响应，我们可以简化我们的开发来创建高度可重用的服务，这些服务可以松散地相互连接。考虑到反应式系统与我们的原则的一致性，以及它们对框架的广泛支持，我们得出结论，现代微服务的发展方向是变得反应式。

我们将在[第 4 章](04.html#5IAP60-005ba5e9819e4f499f11aaac5b7181c1) *，创建反应式微服务*中探讨这个主题的更多内容。

# 云原生微服务

云原生微服务是一种利用云计算模式的优势构建微服务的方法，专注于构建我们的微服务，并允许我们的云部署、管理和扩展它们。

云架构关注的是它将如何以及现在在哪里为我们提供不断为我们的产品提供价值的灵活性，但首先我们需要了解什么是云计算。

# 云计算

传统上，组织需要注意为其服务提供特定的基础设施。每当我们的应用需要扩展时，我们就需要为它们购买更多的服务器，很多时候需要使用由不同供应商提供的昂贵硬件，并花费大量时间在我们的系统中配置它们。

这种基础设施方法通常与静态容量相关，因此如果我们的应用出现负载高峰，我们需要购买更多的服务器，高峰过后，我们的部分基础设施未得到利用，有时会产生更多的成本来维护它或回收新服务，因为配置并不容易，我们可能会保持原样，直到下一个高峰到来。云计算就是使用普通而廉价的硬件来创建资源，这些资源可用于动态部署和运行多个应用，这些应用可以自动或手动扩展。

在传统架构中，我们可能有一个具有一定容量的数据库，并且运行在特定的服务器上；如果我们需要扩展，我们要么升级服务器资源，要么购买另一台服务器并进行配置。在云中，我们创建一个数据库服务器，并动态扩展实例的数量，如果不再需要，我们会删除未使用的实例。云上释放的资源可以用于创建或扩展其他应用，云的整体容量可以通过添加更多的传统服务器来增长。

这种方法允许组织对其基础架构采用随用随付的模式，而不是预先购买服务器，他们可以支付特定时间段内所需的任何资源。云应用被设计成易于配置，因为总体想法是拥有可以在短时间内容易产生的服务。云原生应用将使用某种系统，由云平台或应用本身提供，在创建新实例时进行配置。由于我们需要在云中运行容易滋生和破坏的服务，大多数云使用某种容器化的应用。

# 容器

容器是一种虚拟化方法，允许操作系统在隔离的用户空间中运行应用，控制和限制每个包含的应用的资源。对于运行在容器上的应用，它将像运行在自己的操作系统中一样工作。大多数容器不知道它们被托管在另一个操作系统上。这允许主机操作系统产生或破坏那些应用，而不影响系统的任何部分，并且防止一个容器对另一个容器的影响。

由于这些容器运行在托管系统上，当它们需要启动时，它们将比需要新操作系统启动的普通虚拟化更快。然而，这意味着我们不能用不同于运行主机的系统来生成容器，所以我们不能在 Linux 主机中将 Windows 应用作为进程运行。Docker 可能是云应用最常用的容器系统，但是不同的云提供商可能会选择不同的系统来运行他们的应用。我们将在第 7 章、*创建 Docker*中了解更多关于这个主题的内容。

# 部署模型

组织在创建云应用时可以选择不同的部署模型，让我们回顾一下最常见的模型:

*   私有云
*   公共云
*   混合云

# 私有云

私有云是针对单个组织的云基础架构，通常在自托管数据中心内部托管。它们通常是资本密集型的，需要分配空间、硬件和环境控制。他们的资产必须定期更新，这需要额外的成本。它们通常需要在内部构建和管理，因此它们不能从关注“如何做”而不是“在哪里做”的概念中充分受益。

# 公共云

公共云服务通过运营基础设施及其数据中心的服务提供商在对公众开放的网络中交付。提供商为使用这些服务的组织管理访问控制和安全性，通常允许通过 internet 连接，但是如果需要，组织可以选择使用直接连接。在现收现付模式中，它们可能被视为比私有云更昂贵，但是考虑到构建、升级和维护私有云的成本，这并不总是事实。

让您的服务器升级、安装安全补丁并保持弹性和可靠性既不容易也不便宜，想想公共云的整体优势吧。

# 混合云

混合云试图利用混合私有云和公共云的优势。一个组织可以选择拥有一个私有云，并连接到一个公共云来处理峰值容量或额外资源。一些组织可能会选择这种方法，因为其业务的关键部分需要在私有云内进行内部管理，而其他事务则需要公共云。

# 服务模式

不同的云提供商可以向组织提供多种服务模式，有时提供商的不同产品可以面向多个服务模式。

以下是最常见的:

*   **基础设施即服务** ( **IaaS** )
*   **平台即服务** ( **平台即服务**)
*   **软件即服务** ( **SaaS**

# 基础设施即服务

最基本的云服务模型将计算基础设施、虚拟机和其他资源作为服务提供给用户。他们通常提供一个高级 API 或前端来处理底层细节，如网络、数据分区、扩展、安全、备份等。所有这些通常作为原始元素交付，因此云用户需要维护、修补和配置平台创建的不同服务器。

这些平台的例子有:

*   亚马逊 AWS
*   谷歌计算引擎
*   微软 Azure 虚拟机
*   redhat openstack

# 平台即服务

在这种服务模式中，云平台提供的服务允许客户开发、运行和管理应用，而无需构建和维护复杂的基础架构。这通常是通过应用模板系统来实现的，它允许轻松地创建新服务。例如，为应用类型、框架甚至编程语言提供标准模板。

这样，我们可以降低复杂性，应用的整体开发可以更加有效，应用的维护和增强也更加容易。通常，云将提供修补和配置不同服务器的能力。

这些平台的例子有:

*   谷歌应用引擎
*   IBM Bluemix
*   微软 Azure 云服务
*   Pivotal 云铸造厂
*   红帽 OpenShift

# 软件即服务

在 SaaS 模型中，用户获得对应用软件的访问权，因此该模型有时被称为按需软件。该软件运行所需的所有元素都在平台内部进行管理。云用户不需要关注平台上的任何东西，也不需要关注云，因为一切都由提供商管理，通常是按用户付费的。

这些平台的例子有:

*   谷歌 G 套件
*   微软 Office 365
*   评论

# 云原生微服务

现在我们对云计算有了更好的理解，我们需要思考为什么要构建云原生微服务。如果我们一直遵循我们的微服务原则，我们可以轻松地在云中部署它们，并利用这些平台来进一步受益于微服务架构。我们的微服务很容易扩展和管理，因为它们的隔离是松散耦合的，所以它们很容易放入容器中。

当我们创建微服务时，我们可以让他们了解云，并尝试不仅从微服务中受益，而且成为云原生应用，这样他们就可以从云计算模式中充分受益。Spring Cloud 提供了一个易于使用的框架，使我们的云服务独立于托管它们的云平台，并充分利用该平台的优势。

我们将在[第 6 章](06.html#72V5S0-005ba5e9819e4f499f11aaac5b7181c1) *中进一步扩展这一点，创建云原生微服务。*

在写这本书的时候，Spring Boot 2 的当前快照版本是`Spring Boot 2.0.0 M7`。该版本的代码包和示例是最新的。最终，`Spring Boot 2.0.0`会最终发布，代码包也会相应更新。

# 摘要

在这一章中，我们清楚地了解了什么是微服务，它们的好处，以及它们是如何从 SoA 发展而来的。我们现在有了一套可以用来创建它们的原则，以及领域驱动的设计将如何允许我们根据需求发展我们的应用的概述。遵循这些设计，我们可以拥有一个干净的架构，这将有助于我们的微服务的生命周期，从开发到扩展或监控。我们应该熟悉反应式系统和云计算模式的优势，这将使我们能够提供符合下一级行业标准的微服务。

但接下来，我们需要从基础开始，所以在下一章，我们将重点关注如何使用 Spring Boot 2.0 开始使用 Kotlin 的微服务，同时，我们将学习我们将用来创建它们的工具。