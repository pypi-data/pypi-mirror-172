# 四、创建反应式微服务

反应式微服务是微服务发展的下一步。基于反应式范例，他们的目标是交付响应更快、更有弹性、更有弹性的消息驱动服务，这些服务将优于更传统的非反应式架构。

在这一章中，我们将学习如何使用 Spring Framework 5.0 轻松地创建它们，以及如何使用反应式编程来创建它们。

我们在[第 1 章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1) *中了解了反应式编程的好处，了解微服务*。您可以回顾一下关于反应式编程的部分，以进一步理解这个主题。

我们将在本章中创建的反应式微服务将基于我们之前创建的 RESTful API 示例，展示我们如何轻松适应这一新模型。

在本章中，您将了解:

*   Spring 网流量
*   路由器功能
*   单声道的
*   流量
*   函数式编程简介
*   被动错误处理

# 了解 Spring WebFlux

Spring WebFlux 是 Spring Framework 5.0 中引入的一个新组件，它允许使用 Netty 作为新的 web/应用服务器来创建反应式微服务。WebFlux 广泛使用 Reactor 框架来实现 reactive streams 模式。在本节中，我们将了解如何创建 Spring WebFlux 应用，以及如何使用它们将我们的非反应式微服务迁移到这个新的技术栈中。

# 创建 Spring WebFlux 应用

和以前一样，我们将使用 Spring Initializr 创建一个新的 Spring Boot 应用，但在本例中，是一个 WebFlux 应用。首先，导航到 https://start.spring.io/[的 Spring Initializr 站点。我们将选择用科特林和 Spring Boot 2.0.0 M7 创建一个 *Maven 项目*。对于项目元数据，我们将组设置为`com.microservices`，工件设置为`chapter4`，并且作为依赖项，我们将包括反应式 Web:](https://start.spring.io/)

![](img/00020.jpeg)

使用 Spring Initializr 创建 WebFlux 应用

然后，我们将点击 Generate Project 按钮下载一个名为`chapter4.zip`的 zip 文件；我们将解压缩它，并在 IntelliJ IDEA 中打开结果文件夹。一段时间后，我们的项目将准备好，我们可以打开 Maven 窗口来查看不同的生命周期阶段、Maven 插件及其目标。

我们将在《Spring Boot 2.0 入门第 2 章 *中介绍如何使用 Spring Initializr、Maven 和 IntelliJ IDEA。您可以访问本章以了解本节未涉及的主题。*

如果我们看一下我们新创建的应用并打开我们的`Chapter4Application.kt`文件，我们可以看到它是一个标准的 Spring Boot 应用:

```java
package com.microservices.chapter4

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class Chapter4Application

fun main(args: Array<String>) {
    runApplication<Chapter4Application>(*args)
}
```

现在，我们可以运行我们的微服务，看看它与其他章节中之前构建的微服务有何不同。我们可以使用 Maven 窗口双击 spring-boot 插件，运行 goal，或者只是从命令行这样做:

```java
mvnw spring-boot:run
```

几秒钟后，我们将看到几行日志，包括如下内容:

```java
INFO 12308 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
```

我们的微服务现在可以使用`Netty`处理请求了；这是我们需要理解的第一个变化，因为在前面的例子中，我们使用了 Tomcat。

有趣的是，当我们在 Spring Initializr 的依赖项中选择 Reactive Web 时，我们的 Maven `pom`将包含`spring-boot-starter-webflux`作为依赖项。如果我们在 Spring Initializr 中选择 Web 作为依赖，那么它将包含`spring-boot-starter-web`。为了清楚起见，我们在本章中将这个组件命名为 WebFlux，尽管 Spring Initializr 将其命名为 Reactive Web。

# 使用 Netty

Netty 最初是由 JBoss 开发的，目的是创建一个允许我们执行非阻塞 IO 操作的客户机-服务器框架。为了归档这种能力，我们使用 reactor 模式的消息驱动实现。如今，它得到了广泛的开源社区的支持。

Netty 包括对主要算法和协议的支持，如`HTTP`、`SSL` / `TSL`或`DNS`，但增加了对现代协议的支持，如`HTTP/2`、`WebSocket`或`Google Protocol Buffers`。这只是对 Netty 的一些能力的总结。

你可以在 Netty 的网站上找到更多关于 Netty 的信息，网址是[https://netty.io/](https://netty.io/)。

Spring Boot 1.x 使用 Apache Tomcat 作为默认的应用/web 服务器，但是 Tomcat 只执行阻塞操作。为了能够创建反应式服务，Spring Boot 2.0 选择了 Netty，因为它具有非阻塞 IO 功能。

当使用 Spring Boot 2.0 时，如果我们包括 Spring WebFlux 组件，当我们的应用启动时，它将创建一个新的 Netty 服务器，但如果我们使用标准的 Spring Web，一个新的 Tomcat 服务器将被启动。

正如我们在[第 1 章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1) *中所讨论的，了解微服务，*任何反应式系统的一个期望品质是响应迅速；事件驱动的软件，比如 Netty，将在剩余的 Reactive Manifesto 中满足这个需求。

我们在[第一章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1) *中分析了反应宣言，在*反应微服务*部分了解微服务*。

有了这项技术，我们的微服务可以处理更高的工作负载，并将比以往任何时候都更有效。

针对不同的技术还有其他非阻塞 IO 系统，如`NodeJS`、`Nginx`、`Apache Mina`、`Vert.X`或`Akka`。学习其中一些可能是个好主意，因为反应式系统将是未来几年最常用的技术之一。

# 服务静态上下文

正如在任何 Spring Boot 应用中一样，当我们使用 Netty 时，我们可以提供静态上下文，但这些内容将被动地提供给非阻塞 IO。让我们首先在 resource 文件夹下的项目中创建一个新文件夹；我们将它命名为`public`。然后，右键单击该文件夹，并在弹出菜单中选择新建| HTML 文件。

我们将编辑该文件，如下所示:

```java
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello World</title>
</head>
<body>
Reactive Static Content
</body>
</html>
```

如果我们再次启动我们的服务器:

```java
mvnw spring-boot:run
```

当访问`http://localhost:8080/index.html`时，我们应该得到一个简单的信息:

```java
Reactive Static Content
```

该内容像以前一样被提供，但是它不是一个阻塞操作，而是被反应性地处理。在某种程度上，我们可以这样理解，就好像我们的页面是我们系统中的一个文件。在阻塞 IO 方法中，当在服务器上请求页面时，它将读取所有页面内容，并开始将其发送回请求它的客户机。同时，当读取发生时，该操作被阻止。

在非阻塞 IO 系统中，我们的服务器一得到一些数据就开始读取页面并发送信息，然后最终我们会从文件中读取更多的数据并将更多的数据发送回客户端，等等。事实上，它可以从同一个页面或其他页面向请求数据的客户端发送数据，而无需阻止读取或发送所请求的页面。

这是一个非常复杂的架构的真正简化，如果你想了解更多，我推荐你阅读这篇文章:[https://techblog.bozho.net/why-non-blocking/](https://techblog.bozho.net/why-non-blocking/)。

现在，让我们像在前面的例子中一样添加一些 API 端点。

# 添加 RestController

使用 Spring WebFlux，我们可以像以前一样创建一个控制器，但是首先，我们需要我们的`Customer`类，所以让我们将它添加到我们的项目中。创建一个名为`Customer`的新类:

```java
package com.microservices.chapter4

data class Customer(var id: Int = 0, val name: String = "", val telephone: Telephone? = null) {
  data class Telephone(var countryCode: String = "", var telephoneNumber: String = "")
}
```

现在，我们可以创建一个简单的 rest 控制器；在我们的例子中，它将被命名为`CustomerController`:

```java
package com.microservices.chapter4

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RestController

@RestController
class CustomerController {
  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int) = Customer(id, "customer $id")
}
```

如果我们再次运行我们的服务器，在访问我们的`GET`客户 URL`http://localhost:8080/customer/1`之后，我们应该得到:

```java
{"id":1,"name":"customer 1"}
```

在这个新示例中，我们可能会得到一个`telephone = null`作为我们的`Customer`对象的属性，因为我们在创建客户时没有提供电话对象，但是请记住，您不能通过将值`spring.jackson.default-property-inclusion: NON_NULL`添加到我们的`application.yml`来序列化空值，正如我们在[第 3 章](03.html#44HU60-005ba5e9819e4f499f11aaac5b7181c1) *中讨论的，创建 RESTful 服务。*

但是我们可以像以前一样使用`ResponseEntity`来定制我们的 HTTP 状态消息，所以让我们为此修改我们的控制器:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RestController

@RestController
class CustomerController {
  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int): ResponseEntity<Customer> {
 return ResponseEntity(Customer(id, "customer $id"), HttpStatus.OK)
 }
}
```

# 创建客户服务

我们可以添加一个新的服务来处理我们的客户，所以让我们创建一个`CustomerService`接口:

```java
package com.microservices.chapter4

interface CustomerService {
  fun getCustomer(id: Int) : Customer?
  fun searchCustomers(nameFilter: String): List<Customer>
}
```

然后，我们可以创建实现接口的服务，`CustomerServiceImpl`:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id]

  override fun searchCustomers(nameFilter: String): List<Customer> =
      customers.filter {
        it.value.name.contains(nameFilter, true)
      }.map(Map.Entry<Int, Customer>::value).toList()
}
```

最后，我们可以修改控制器来使用服务:

```java
package com.microservices.chapter4

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
class CustomerController {
 @Autowired
 private lateinit var customerService: CustomerService

  @GetMapping(value = "/customer/{id}")
 fun getCustomer(@PathVariable id: Int): ResponseEntity<Customer?> {
 val customer = customerService.getCustomer(id)
 return ResponseEntity(customer, HttpStatus.OK)
 }

 @GetMapping(value = "/customers")
 fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
 customerService.searchCustomers(nameFilter)
}
```

然后，我们可以创建一个对我们客户的 URL`http://localhost:8080/customers`的`GET`请求，得到这个输出，以及一个 200 OK HTTP 状态:

```java
[
   {
      "id":1,
      "name":"Kotlin"
   },
   {
      "id":2,
      "name":"Spring"
   },
   {
      "id":3,
      "name":"Microservice",
      "telephone":{
         "countryCode":"+44",
         "telephoneNumber":"7123456789"
      }
   }
]
```

这与我们在第三章 *中创建的服务非常相似，创建 RESTful 服务。*在那里，我们解释了本章中使用的大多数概念。

# 阻断不是反应性的

我们可以看到，我们可以轻松地将我们更传统的非反应式微服务转换为反应式，但这种服务还不是完全反应式的。我们的控制器可能是，但如果执行的操作是阻塞操作，它将像任何其他非反应性系统一样执行阻塞操作。因此，正如我们所声明的，当客户端调用我们的 URL 时，我们将调用我们的服务来获取客户或搜索他们，当这个操作完成时，我们将结果序列化为 JSON 只有这样，我们才会将值返回给消费者，因为我们的操作是一个阻塞操作。我们可能需要修改我们的服务，使之成为一个反应式服务。

# 创建反应式服务

我们可能经历过创建非反应式服务，就像我们的`CustomerService`一样，但是现在我们需要创建我们自己的反应式服务。在本节中，我们将了解如何将我们的服务转变为响应式服务。

# 了解订阅者和发布者

首先，我们需要理解反应式编程中的一个核心组件，订阅和发布机制。反应式编程基于事件模型机制，在该机制中，一组事件被触发并被分派给任何需要它们的人。这个抽象的概念很容易理解，我们如何在几乎所有的 UI 框架中处理来自用户的动作。

假设我们想对一个 UI 动作做出反应，比如按下一个按钮，然后执行一个操作，比如关闭一个窗口。在普通的 UI 框架中，用户的动作，比如按按钮、选择菜单或者滚动窗口的内容，都可以被认为是事件。当我们选择监听这些事件时，我们定义的是一个订阅者，一个负责在事件产生时接收事件的对象。

另一方面，我们可能需要生成事件；例如，当我们用鼠标点击一个按钮时，需要触发一个关于按钮被点击的新事件。通过这样做，我们定义了一个发布者，一个负责发出事件的对象。我们的 UI 框架可能会将事物连接在一起，当我们单击按钮时，发布者将生成事件，订阅者将得到通知；然后，它可以通过执行所需的功能、关闭窗口来做出反应。

但是事件可以被链接和组合。在一个 UI 框架中，我们可能已经有了一个在屏幕上发送任何鼠标点击事件的发布者，我们也可能有了这些事件的订阅者。然后，当我们点击屏幕时，我们的发布者发出通用消息，更通用的订阅者将得到它，并发现鼠标的位置实际上是在某个按钮上。该通用订阅者将触发关于按钮被点击新事件，然而，订阅该事件的订阅者可以将该事件处理为执行所需逻辑的动作。

让我们用一点伪代码来形象化这一点:

```java
Framework Starts
Registering MouseClick as a subscriber for mouse.click events
Registering MouseHandler as a publisher of mouse.click events
Application Starts
Registering Action1 as a subscriber for button1.click event
Registering Button1Trigger as a publisher for button1.click event
User click on button1
MouseHandler publish a mouse.click event
MouseClick get a mouse.click event
MouseClick finds that is on button1
MouseClick delegate to Button1Trigger
Button1Trigger publish an event of button1.click
Action1 get the button1.click event and close the window
```

这可能不是 UI 事件系统的最佳实现，但它可以用来说明这个概念。在这些`subscriber`和`publisher`对象的每一个中，我们没有阻塞等待结果的操作；在某种程度上，它们是在需要时被调用的监听器。同时，UI 中的其他动作和事件也可能发生，甚至是同时发生，比如在我们按键的同时按下一个按钮。

发布和订阅机制不是一个新概念，事件驱动系统也不是；它们已经被使用了很长时间，从管理我们的硬件到更复杂的消息队列系统。然而，使用反应式编程方法，它们比以往任何时候都更有意义。

Spring 使用 Reactor 框架来创建反应式微服务。我们的控制器可以成为结果的发布者，Spring 将订阅产生更多的事件，这些事件将把数据发送回使用我们服务的任何人。该数据将按照反应流规范中的定义在反应流中发送，提供无阻塞背压。

在*无功编程*部分的[第 1 章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1) *了解微服务*中讨论了无功流和背压。另外，你可以在这里找到更多信息:[http://www.reactive-streams.org/](http://www.reactive-streams.org/)。

# 发布单个对象

Reactor 提供了一种通过名为`Mono`的类来定义反应式发布者的方法，但是那个发布者只能发送一个结果。

要创建一个`Mono`，我们可以简单地这样做:

```java
val customerMono : Mono<Customer> = Mono.just(Customer(1, "Mono"))
```

但是 reactor 为 Kotlin 提供了一个高级功能，我们可以使用它来利用更多的 Kotlin 特性:

```java
val customerMono : Mono<Customer> = Customer(1, "Mono").toMono()
```

但是由于科特林有类型推断，我们可以简单地把它写成:

```java
val customerMono = Customer(1, "Mono").toMono()
```

我们应该理解的是，`Mono`实际上并不是我们创建的`Customer`实例的值，它是对我们将要得到的东西的承诺。当我们声明某个东西为`Mono<Customer>`时，我们只是表明这是一个将来会发布客户的发布者。当有人订阅该发布服务器时，数据将被消费。

# 在服务中使用单声道

我们现在可以修改我们的服务，使用`Mono`返回单个客户的发布者。我们先来改一下我们的`CustomerService`界面:

```java
package com.microservices.chapter4

import reactor.core.publisher.Mono

interface CustomerService {
  fun getCustomer(id: Int) : Mono<Customer?>
  fun searchCustomers(nameFilter: String): List<Customer>
}
```

然后，我们将更改我们在`CustomerServiceImpl`类上的实现:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id].toMono()

  override fun searchCustomers(nameFilter: String): List<Customer> =
      customers.filter {
        it.value.name.contains(nameFilter, true)
      }.map(Map.Entry<Int, Customer>::value).toList()
}
```

最后，我们将修改我们的`CustomerController`:

```java
package com.microservices.chapter4

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Mono

@RestController
class CustomerController {
  @Autowired
  private lateinit var customerService: CustomerService

  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int): ResponseEntity<Mono<Customer?>> {
    val customer = customerService.getCustomer(id)
    return ResponseEntity(customer, HttpStatus.OK)
  }

  @GetMapping(value = "/customers")
  fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
      customerService.searchCustomers(nameFilter)
}
```

基本上，我们的控制器代码已经改变了，所以现在我们返回的不是包含我们的客户和相应 HTTP 状态的`ResponseEntity`，而是`Mono`。当新的请求到来时，Spring 将理解事情并订阅我们的发布者，以被动地返回结果。

我们可以对此进行测试——在再次运行我们的服务后，通过在`http://localhost:8080/customer/1`对我们的 URL 发出`GET`请求，请求获取客户 API，同时获得以下输出和 200 OK HTTP 状态:

```java
{
    "id":1,"name":"Kotlin"
}
```

# 发布多个对象

Reactor 提供了一个类来创建一个 publisher，该 publisher 将返回从 0 到不确定数量的元素；那个类被命名为`Flux`。

要创建一个简单的`Flux`，我们可以这样做:

```java
val customerFlux = Flux.fromIterable(listOf(Customer(1,"one"), Customer(2, "two")))
```

或者，我们可以使用适当的 Kotlin 版本:

```java
val customerFlux =  listOf(Customer(1,"one"), Customer(2, "two")).toFlux()
```

`Mono` can be used when we only need to return one result in our publisher, whereas `Flux` can be used for 0 to *N* including 1, but if we are going to return just 1, it is preferable to use `Mono` instead of `Flux` since it is more optimal for that usage.

# 在服务中使用 Flux

我们现在可以修改我们的服务，通过`Flux`返回客户列表的发布者。首先，我们需要修改我们的服务接口，`CustomerService`:

```java
package com.microservices.chapter4

import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

interface CustomerService {
  fun getCustomer(id: Int) : Mono<Customer?>
  fun searchCustomers(nameFilter: String): Flux<Customer>
}
```

然后，我们将修改我们的`CustomerServiceImpl`类:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.toFlux
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id].toMono()

  override fun searchCustomers(nameFilter: String) = customers.filter {
    it.value.name.contains(nameFilter, true)
  }.map(Map.Entry<Int, Customer>::value).toFlux()
}
```

我们不需要修改我们的控制器，因为我们的`getCustomer`函数将从`searchCustomers`方法中推断返回类型，现在将是一个`Flux`而不是一个`List`:

```java
@GetMapping(value = "/customers")
fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
    customerService.searchCustomers(nameFilter)
```

这是科特林式推理的好处之一；控制器将保持不变，因为我们的方法可以推断返回类型。要了解更多信息，我们推荐 Kotlin 文档中的这个部分:[https://kotlinlang.org/docs/reference/basic-syntax.html](https://kotlinlang.org/docs/reference/basic-syntax.html)。

然后，我们可以向客户 API 列表发出一个请求，向我们的`http://localhost:8080/customers` URL 发出一个`GET`请求，并获得这个输出以及一个 200 OK HTTP 状态:

```java
[
   {
      "id":1,
      "name":"Kotlin"
   },
   {
      "id":2,
      "name":"Spring"
   },
   {
      "id":3,
      "name":"Microservice",
      "telephone":{
         "countryCode":"+44",
         "telephoneNumber":"7123456789"
      }
   }
]
```

同样，就像之前的`Mono`例子一样，`Flux`是一个承诺，当被签署时就会被执行。在这种情况下，当我们的控制器返回`Flux`时，Spring 将被订阅一个新的请求。

# 被动接收对象

现在，我们知道如何反应性地返回对象，但是我们如何接受它们呢？
当我们创建一个反应式微服务时，Spring 可以向我们的`RequestMapping`发送一个`Mono` publisher，当我们订阅它时，它会在主体中包含该对象。但是我们需要让我们的服务接受一个承诺值的`Mono`，所以首先让我们修改我们的服务接口:

```java
package com.microservices.chapter4

import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

interface CustomerService {
  fun getCustomer(id: Int) : Mono<Customer?>
  fun searchCustomers(nameFilter: String): Flux<Customer>
 fun createCustomer(customerMono: Mono<Customer>) : Mono<*>
}
```

为什么我们将函数的结果设置为一个`Mono`？当我们创建一个反应式微服务时，我们可能需要反应式地获取数据，但是我们也需要反应式地响应，以便 Spring 理解我们需要创建一个 Spring 将订阅的发布者。因此，Spring 将发布来自请求的信息并订阅我们的响应；当我们的代码返回一个响应时，spring 会将它发送给发送原始请求的人。

让我们看看我们是如何用控制器中的代码做到这一点的:

```java
package com.microservices.chapter4

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import reactor.core.publisher.Mono

@RestController
class CustomerController {
  @Autowired
  private lateinit var customerService: CustomerService

  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int): ResponseEntity<Mono<Customer?>> {
    val customer = customerService.getCustomer(id)
    return ResponseEntity(customer, HttpStatus.OK)
  }

  @GetMapping(value = "/customers")
  fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
      customerService.searchCustomers(nameFilter)

 @PostMapping(value = "/customer/")
 fun createCustomer(@RequestBody customerMono: Mono<Customer>) =
 ResponseEntity(customerService.createCustomer(customerMono), HttpStatus.CREATED)
}
```

所以基本上，我们表示我们的响应将是通过另一个发布者创建客户的结果，该发布者将在我们的服务中创建，因为`createCustomer`返回一个`Mono`。

让我们在我们的`CustomerServiceImpl`类中创建服务的实现:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono
import reactor.core.publisher.toFlux
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id].toMono()

  override fun searchCustomers(nameFilter: String) = customers.filter {
    it.value.name.contains(nameFilter, true)
  }.map(Map.Entry<Int, Customer>::value).toFlux()

 override fun createCustomer(customerMono: Mono<Customer>): Mono<*> {
 return customerMono.subscribe {
      customers[it.id] = it
    }.toMono()
 }
}
```

我们将在新的`Mono`中返回我们的订阅结果。让我们以`POST`一个客户进入我们的 API 服务 URL`http://localhost:8080/customer/`为例，用这个`curl`请求:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 8,
 "name": "New Customer",
 "telephone": {
 "countryCode": "+44",
 "telephoneNumber": "7123456789"
 }
}
'
```

我们将得到以下输出:

```java
{
 "disposed": false,
 "scanAvailable": true
}
```

我们这样做的原因是,`subscribe`方法返回一个可处置的对象，它被序列化成 JSON。但是我们可能不希望这样；我们希望有一个空的结果作为 RESTful API 的例子。

我们在[第三章](03.html#44HU60-005ba5e9819e4f499f11aaac5b7181c1) *中讨论如何处理 HTTP 动词和状态，以及序列化响应，创建 RESTful 服务*；如果对你来说这是陌生的或新的，回顾这一章。

为了解决这个问题，我们将对我们的服务进行如下修改:

```java
override fun createCustomer(customerMono: Mono<Customer>): Mono<*> =
 customerMono.map {
      customers[it.id] = it
    }
```

如果我们用同样的`curl`请求`POST`这个对象，我们现在应该得到一个空对象，`{}`。这是因为我们在接收到的`Mono`上使用了映射器并对其进行了转换；由于我们还没有编写额外的对象，它将返回一个空对象。

例如，如果我们将服务更改如下:

```java
override fun createCustomer(customerMono: Mono<Customer>): Mono<*> =
    customerMono.map {
      customers[it.id] = it
 it    }

```

当我们再次执行我们的`curl`请求时，我们将获得我们发布的相同对象:

```java
{
    "id": 18,
    "name": "New Customer",
    "telephone": {
        "countryCode": "+44",
        "telephoneNumber": "7123456789"
    }
}
```

但是我们可以更改我们的服务来显式返回一个空对象:

```java
override fun createCustomer(customerMono: Mono<Customer>): Mono<*> =
    customerMono.map {
      customers[it.id] = it
 Mono.empty<Any>()
    }
```

这将返回一个空对象和一个结果，以及相应的 201 创建的 HTTP 状态；我们使用的是一个没有值的`Mono<Any>`；当在 JVM 中转换时，它将是一个`Mono<Object>`，因为`<Any>` Kotlin 类在 JVM 中被转换为 object 类。现在，我们知道如何让我们的微服务具有反应性——如果我们仔细看看我们控制器的语法，它看起来就像我们的非反应性实现。

然而，如果我们仔细观察我们的服务实现，我们会发现使用反应式发布者，无论是`Mono`还是`Flux`，看起来都非常像函数式编程。让我们在下一节进一步探讨这个概念。

# 使用函数式 web 编程

到目前为止，我们已经学习了如何使用与非反应式方法几乎相同的基于注释的语法来创建反应式微服务。然而，Spring Framework 5 提供了一种使用函数式编程来开发这些微服务的机制。在这一节中，我们将学习如何使用它来探索更灵活和现代的语法。

我们将使用在本章前一节中已经创建的示例，因此请按照步骤开始。

# 使用路由器功能

与带注释的基础系统一样，首先我们需要定义我们的微服务将如何处理传入的请求，但是我们将使用一个`RouterFunction`而不是创建一个控制器。

首先，我们将创建一个名为`CustomerRouter`的新类，带有一个`RouterFunction`:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter {
  @Bean
  fun customerRoutes(): RouterFunction<*> = router {
    "/functional".nest {
    }
  }
}
```

我们正在创建一个新的组件，因此它将被暴露`Bean`的组件扫描所拾取，这将创建一个新的绑定`RouterFunction`，允许我们为我们的 web 应用定义路由，并且当我们可以处理它们时，在这种情况下，我们的路由将处理对`/functional`路径的任何请求。

为了创建这个路由器功能，我们使用 Spring 为 web-flux 创建的 Kotlin DSL。要了解更多关于 DSL 的知识，可以在 Kotlin 文档中查看这篇文章:[https://kot linlang . org/docs/reference/type-safe-builders . html](https://kotlinlang.org/docs/reference/type-safe-builders.html)。

现在，我们需要向我们的`RouterFunction`添加一些东西来实际处理这条路径；让我们创建一些简单的东西:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.ServerResponse
import org.springframework.web.reactive.function.server.router
import reactor.core.publisher.toMono

@Component
class CustomerRouter {
  @Bean
  fun customerRoutes(): RouterFunction<*> = router {
 "/functional".nest {
      "/customer".nest {
        GET("/") {
          ServerResponse.ok().body("hello world".toMono(), String::class.java)
 }
      } }
  }
}
```

我们现在定义的是，嵌套到`/functional`路由，如果我们用`GET`请求请求`/customer`路由，我们将发送一个带有 200 OK，HTTP 状态的响应，主体将是一个简单的字符串，表示`"hello world"`。

如果我们访问`http://localhost:8080/functional/customer`，我们应该得到这个简单的消息:

```java
hello world
```

一个有趣的事实是，`ServerResponse.ok`是一个`ServerResponse.Builder`，一个构建响应的方法，最终将生成一个`Mono<ServerResponse>`。该响应将包含另一个`Mono`和我们的对象，一个`Mono<String>`。因此，我们将成为来自服务器的响应的发布者，该响应将具有承诺值的发布者，在本例中为字符串。

所以，我们的`Mono<ServerResponse>`对象包含`Mono<String>`，它将包含一个带有我们的值的字符串，这个值将是`"hello world"`。

请记住，`Mono`不是一个值，它是一个承诺，如果我们订阅它，当它准备好了，它会得到那个值。

我们可以通过删除不必要的类型来简化这个例子，比如 Kotlin 类型推断和几个静态导入:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.router
import reactor.core.publisher.toMono

@Component
class CustomerRouter {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/") {
          ok().body("hello world".toMono(), String::class.java)
        }
      }
    }
  }
}
```

最后，让我们使用我们的`Customer`类来返回值:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.router
import reactor.core.publisher.toMono

@Component
class CustomerRouter {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/") {
          ok().body(Customer(1, "functional web").toMono(),        
          Customer::class.java)
        }
      }
    }
  }
}
```

body 方法的最后一个参数表示 JVM 类，它将位于我们作为响应发送的`Mono`中。为此，我们将使用 Kotlin JVM 方法，`::class.java`。

现在，当我们访问我们的 URL，`http://localhost:8080/functional/customer`，我们应该得到我们的客户:

```java
{
    "id":1,
    "name":"functional web"
}
```

我们使用的体函数有不同的实现，但是我们将在本章的后面看更多的实现。

# 创建处理程序

在我们的路由器中，我们通过创建一个输出响应的 lambda 来定义我们需要如何对 HTTP `GET`请求采取行动。这段代码通常被称为处理程序。让我们扩展λ来更好地理解它:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.router
import reactor.core.publisher.toMono

@Component
class CustomerRouter {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/") { it: ServerRequest ->
          ok().body(Customer(1, "functional web").toMono(), 
          Customer::class.java)
        }
      }
    }
  }
}
```

我们的 lambda 有一个参数，它是一个`ServerRequest`类的对象。这个对象将包含发送到我们的句柄的请求的所有细节，包括参数甚至请求的主体。我们最初省略了它，因为我们的方法不需要处理来自请求的任何东西。拥有像 lambdas 这样的处理程序是可以的，但是我们可以为它们创建一个新的类，这样我们就可以有一个更容易理解的代码。

让我们创建一个名为`CustomerHandler`的新类:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import org.springframework.web.reactive.function.server.ServerResponse.ok
import reactor.core.publisher.Mono
import reactor.core.publisher.toMono

@Component
class CustomerHandler {
  fun get(severRequest: ServerRequest): Mono<ServerResponse> {
    return ok().body(Customer(1, "functional web").toMono(), 
    Customer::class.java)
  }
}
```

但是因为我们使用的是 Kotlin，所以让我们用类型推断在表达式体中转换这个函数:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import reactor.core.publisher.toMono

@Component
class CustomerHandler {
  fun get(severRequest: ServerRequest) =
      ok().body(Customer(1, "functional web").toMono(), 
      Customer::class.java)
}
```

现在，我们可以在路由器中连接这个类，并在 lambda:

```java
package com.microservices.chapter4

import org.springframework.beans.factory.annotation.Autowired import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter {
 @Autowired
  lateinit var customerHandler: CustomerHandler 
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/") { it: ServerRequest ->
          customerHandler.get(it)
        }
      }
    }
  }
}
```

但是因为我们的 lambda 已经把它的参数发送给了我们新的处理函数，我们可以只做一个方法引用来代替:

```java
package com.microservices.chapter4

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter {
  @Autowired
  lateinit var customerHandler: CustomerHandler
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/", customerHandler::get)
      }
    }
  }
}
```

最后，不使用`@Autowired`注释，只是注入我们的句柄作为我们的`CustomerRouter`构造函数的一部分:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/", customerHandler::get)
      }
    }
  }
}
```

任何用`@Component`标注的类都可以在构造中声明需要作为构造函数参数的 beans。当组件扫描找到该类时，它将检测到构造函数可以使用其他 beans 并注入它们。这让我们可以避免使用`@Autowired`；我们可以用`val`将这些 beans 声明为不可变的值，而不是自动绑定所需的可变的`var`。

# 使用响应式服务

现在我们有了一个处理程序，我们可以将它连接到我们之前创建的反应服务。让我们首先通过构造函数将它们绑定在我们的句柄中并使用它:

```java
@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
 ok().body(customerService.getCustomer(1), Customer::class.java)
}
```

如果我们现在尝试运行这个例子，我们将得到一个编译错误，这是因为我们的服务方法被定义为:

```java
fun getCustomer(id: Int): Mono<Customer?>
```

由于`Customer`是可空的，我们不能绑定到`Customer::class.java`，所以让我们修改我们的服务接口:

```java
package com.microservices.chapter4

import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

interface CustomerService {
  fun getCustomer(id: Int) : Mono<Customer>
  fun searchCustomers(nameFilter: String): Flux<Customer>
  fun createCustomer(customerMono: Mono<Customer>) : Mono<*>
}
```

但是现在我们需要修改我们的实现，使其不返回空值:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono
import reactor.core.publisher.toFlux
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id]?.toMono() ?: Mono.empty()

  override fun searchCustomers(nameFilter: String) = customers.filter {
    it.value.name.contains(nameFilter, true)
  }.map(Map.Entry<Int, Customer>::value).toFlux()

  override fun createCustomer(customerMono: Mono<Customer>): Mono<*> =
      customerMono.map {
        customers[it.id] = it
        Mono.empty<Any>()
      }
}
```

我们修改了我们的实现，现在如果没有找到我们的客户，这意味着它是空的，我们将返回一个空的`Mono`。因为我们不返回一个可空的对象，所以我们不需要在主体函数中指定我们的类，所以我们可以只改变我们的处理程序:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.body

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      ok().body(customerService.getCustomer(1))
}
```

还有一个步骤来获取我们的`GET`请求的参数——我们正在查询的客户；我们将把该参数作为路径的一部分传递，就像我们在 RESTful APIs 示例中所做的那样，放在一个 URL 中，比如`/customer/1`。

关于如何构建 RESTful APIs 的更多细节，你可以回顾[第 3 章](03.html#44HU60-005ba5e9819e4f499f11aaac5b7181c1)、*创建 RESTful 服务*。

让我们修改路由器，声明我们需要一个参数:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/{id}", customerHandler::get)
      }
    }
  }
}
```

这类似于我们在 RESTful APIs 示例中为`RequestMapping`声明路由的方式，但是我们需要在处理程序中获取参数，所以让我们修改它:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.body

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      ok().body(customerService.getCustomer(serverRequest.pathVariable("id").toInt()))
}
```

现在，如果我们访问我们的客户 URL，例如,`http://localhost:8080/functional/customer/2`,我们将得到以下输出，带有 200 OK HTTP 状态响应:

```java
{
    "id":2,
    "name":"Spring"
}
```

但是，如果我们请求一个不存在的客户，会发生什么呢？比如用`http://localhost:8080/functional/customer/9` URL。我们将得到一个空的主体，但是一个 200 OK 的 HTTP 状态响应。我们需要修改代码来返回 404 NOT FOUND，就像我们在 RESTful APIs 示例中已经做的那样，但是首先让我们改变方法，通过我们的`Mono`来处理响应的创建:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
}
```

现在我们调用我们的服务，首先获取`Mono`，我们将使用来自反应式发布者的`flatMap`方法将它转换成响应。这个方法将订阅`Mono`，当它有一个值时，它将使用`ok().body()`方法产生一个`Mono<ServerResponse>`。但是`ok().body()`功能需要一个`Mono`。在我们的例子中，我们将使用`fromObject`方法创建`Mono<Customer>`。

这将产生以下结果:

*   我们的方法将被我们的`Mono<Customer>`订阅，并由使用`flatMap`的`getCustomer`方法返回
*   当那个`Mono<Customer>`有一个值时，我们将在`it`参数中接收一个`Customer`对象
*   然后我们将使用`fromObject`方法转换新的`Mono<Customer>`中的值
*   最后，我们将使用刚刚创建的`Mono<Customer>`创建`Mono<ServerResponse>`

所以，我们的方法将返回我们的 final `Mono<ServerResponse>`，当有人订阅它时，我们将获得我们的`Customer`对象。

现在，让我们添加处理空`Mono`的代码:

```java
package com.microservices.chapter4

import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.notFound
import org.springframework.web.reactive.function.server.ServerResponse.ok

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
 .switchIfEmpty(notFound().build())
}
```

在这一步中，如果值为空，我们已经使用原始的`Mono`进行订阅，然后我们将使用`notFound`函数以 404 NOT FOUND HTTP 状态进行回答。由于我们没有这个答案的正文，我们将只使用`build`方法来完成我们的回答。

WebFlux 提供了几个`ServerResponse`助手函数来指定 HTTP 状态为`ok()`、`notFound()`、`badRequest()`、`deleted()`或`created()`，但是我们可以使用`status()`函数来代替:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.ServerResponse.status

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap{ ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())
}
```

不管怎样，我们认为应该使用更方便的助手函数，比如`NOT_FOUND`，以使我们的代码更具可读性。

# 处理多条路线

在我们的路由器中，我们可以创建多条路径来处理多个请求，例如，让我们创建一条查询客户列表的新路径:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/{id}", customerHandler::get)
      }
      "/customers".nest {
        GET("/", customerHandler::get)
      }
    }
  }
}
```

现在，我们有了一个新的路由器来获取客户列表，但是也可以定义多个 HTTP 动词来处理:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/{id}", customerHandler::get)
 POST("/", customerHandler::get)
      }
      "/customers".nest {
        GET("/", customerHandler::get)
      }
    }
  }
}
```

我们刚刚调用了现有的处理程序，但是我们应该创建新的处理程序。在此之前，让我们来谈谈我们的应用中的层。在创造新的之前，我们需要理解它们。

*   **路由器**:处理路径和动词，是反应式服务会回答
*   **处理程序**:执行将具体请求转换成响应的逻辑
*   **服务**:封装我们领域的业务逻辑

拥有这些独立的层将帮助我们在需要添加新功能的地方做出改变。我们的路由器可以为不同的功能调用相同的处理程序，我们的处理程序可以组合几个服务。更改一个层可能不会触发另一个层的更改。例如，如果我们在服务中改变我们的域逻辑，我们可能不需要改变我们的路由或处理程序。

同样，我们需要避免微服务架构中的耦合，我们也应该在创建层时尽量避免耦合。思考这些层以及它们在创建微服务时如何交互。记住应用单一责任原则；一个层应该只有一个改变的理由。

# 使用查询参数

我们将改变我们的`/customers`路线来搜索客户，就像我们的 RESTful APIs 示例那样。

首先，我们需要在我们的`CustomerHandler`类中为这个搜索创建一个新的处理程序:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.ServerResponse.status

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap{ ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

 fun search(serverRequest: ServerRequest) =
 ok().body(customerService.searchCustomers(""), Customer::class.java)
}
```

当我们调用我们的服务时，它将返回一个`Customer`对象的`Flux`,因此发布者承诺了这些值；然后，我们将把它添加到主体中，创建一个 HTTP 状态为 200 OK 的`Mono<ServerResponse>`。

现在，让我们更改我们的`CustomerRouter`来调用这个新的处理程序:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/{id}", customerHandler::get)
        POST("/", customerHandler::get)
      }
      "/customers".nest {
        GET("/", customerHandler::search)
      }
    }
  }
}
```

现在，当我们调用`http://localhost:8080/functional/customers`时，我们应该得到我们的客户列表:

```java
[
    {
        "id": 1,
        "name": "Kotlin"
    },
    {
        "id": 2,
        "name": "Spring"
    },
    {
        "id": 3,
        "name": "Microservice",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    }
]
```

我们的路由器会将请求发送给调用服务的处理程序。和以前一样，这个服务将返回一个`Flux`客户，我们将把它放入响应的正文中。

现在，我们只需要处理查询参数。查询参数可以通过`ServerRequest`对象的`queryParam`方法获得，但是这个方法返回一个`Optional`对象，因为我们可能有也可能没有在请求中搜索的参数。

Java 8 中引入了`Optional`类。它允许我们将一个对象封装在里面，并处理在 Optional 中没有有效对象的概念，命名为 absent object，这与`Mono.empty`非常相似。该对象的一个优点是我们不需要关心空对象。Kotlin 零安全是同类解决方案的不同方法。

最后，让我们修改我们的`search`函数来使用`Optional`值:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.ServerResponse.status

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap{ ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

  fun search(serverRequest: ServerRequest) =
      ok().body(customerService.searchCustomers(serverRequest.queryParam("nameFilter")
 .orElse("")), Customer::class.java)
}
```

现在，我们将从请求中获取`nameFilter`查询参数。如果它不存在，我们将向服务器发送一个空字符串。因为我们的服务是通过`receive`参数过滤的，如果我们发送一个空字符串，它将返回所有的客户。如果我们再次调用我们的客户 URL，`http://localhost:8080/functional/customers?nameFilter=in`，我们应该得到这样的输出:

```java
[
    {
        "id": 1,
        "name": "Kotlin"
    },
    {
        "id": 2,
        "name": "Spring"
    }
]
```

# 处理 JSON 主体

当我们需要实现其他方法时，我们可能需要能够处理请求体中的 JSON。一个明显的例子是创建客户的途径。在 RESTful APIs 的例子中，当我们在`/customer`路由上收到一个`POST` HTTP 请求时，就会发生这种情况。

首先，我们需要修改我们的`CustomerHandler`类来创建一个新方法，我们将其命名为`create`:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.ok
import org.springframework.web.reactive.function.server.ServerResponse.status
import org.springframework.web.reactive.function.server.bodyToMono

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

  fun search(serverRequest: ServerRequest) =
      ok().body(customerService.searchCustomers(serverRequest.queryParam("nameFilter")
          .orElse("")), Customer::class.java)

 fun create(serverRequest: ServerRequest) =
 customerService.createCustomer(serverRequest.bodyToMono()).flatMap {
        status(HttpStatus.CREATED).body(fromObject(it))
      }
}
```

这个新创建的方法将使用来自`ServerRequest`类的`bodyToMono`函数，该函数提供一个 Kotlin-rectified 函数，该函数将从请求体创建一个`Mono`。这种情况下会是`Mono<Customer>`。然后，我们可以在创建新的`ServerResponse`时使用它，就像我们以前做的那样。

现在，我们需要修改我们的`CustomerRouter`类来使用这个新方法:

```java
package com.microservices.chapter4

import org.springframework.context.annotation.Bean
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.router

@Component
class CustomerRouter(private val customerHandler: CustomerHandler) {
  @Bean
  fun customerRoutes() = router {
    "/functional".nest {
      "/customer".nest {
        GET("/{id}", customerHandler::get)
 POST("/", customerHandler::create)
      }
      "/customers".nest {
        GET("/", customerHandler::search)
      }
    }
  }
}
```

我们可以使用`curl`请求来测试这条新路由:

```java
curl -X POST \
 http://localhost:8080/functional/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 18,
 "name": "New Customer",
 "telephone": {
 "countryCode": "+44",
 "telephoneNumber": "7123456789"
 }
}'
```

最后，如果我们现在调用`http://localhost:8080/functional/customers`，我们应该得到新创建的客户以及 200 创建的 HTTP 状态:

```java
[
    {
        "id": 1,
        "name": "Kotlin"
    },
    {
        "id": 2,
        "name": "Spring"
    },
    {
        "id": 18,
        "name": "New Customer",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    },
    {
        "id": 3,
        "name": "Microservice",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    }
]
```

但是为什么我们现在使用`status()`而不是`created()` `ServerResponse`的方法呢？原因是`created()`需要我们刚刚创建的资源的 URL，遵循使用 201 创建的 HTTP 状态时的常见做法。

为了进行这样的更改，我们需要修改我们的`CustomerService.createCustomer`方法来返回新创建的客户。

让我们首先修改我们的`CustomerService`接口来改变方法签名:

```java
package com.microservices.chapter4

import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

interface CustomerService {
  fun getCustomer(id: Int) : Mono<Customer>
  fun searchCustomers(nameFilter: String): Flux<Customer>
  fun createCustomer(customerMono: Mono<Customer>) : Mono<Customer>
}
```

然后修改我们的实现以返回创建的对象:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono
import reactor.core.publisher.toFlux
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id]?.toMono() ?: Mono.empty()

  override fun searchCustomers(nameFilter: String) = customers.filter {
    it.value.name.contains(nameFilter, true)
  }.map(Map.Entry<Int, Customer>::value).toFlux()

  override fun createCustomer(customerMono: Mono<Customer>) = customerMono.map {
    customers[it.id] = it
 it
  }
}
```

最后，我们可以修改我们的处理程序来返回所创建资源的位置:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.*
import org.springframework.web.reactive.function.server.bodyToMono
import java.net.URI

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

  fun search(serverRequest: ServerRequest) =
      ok().body(customerService.searchCustomers(serverRequest.queryParam("nameFilter")
          .orElse("")), Customer::class.java)

  fun create(serverRequest: ServerRequest) =
      customerService.createCustomer(serverRequest.bodyToMono()).flatMap {
 created(URI.create("/functional/customer/${it.id}")).build()
      }
}
```

如果我们像以前一样调用这个函数，我们将再次得到 201 CREATED response 作为一个空的主体结果，但是另外，我们得到一个带有创建的资源位置的头:`/functional/customer/18`。

# 处理反应性错误

正如我们之前所做的那样，任何微服务都需要为失败而构建，因此当我们创建反应式微服务时，我们可以优雅地处理任何错误。Reactor 框架提供了我们需要理解的处理这些错误的机制。在本节中，我们将学习如何使用它们来使我们的反应式微服务像非反应式微服务一样善于处理错误。

# 捕获处理程序中的错误

当我们创建处理程序时，我们可能会遇到错误，这些错误可以用任何反应式发布器`onErrorResume`中的一种特殊方法来处理。让我们修改一下`CustomerHandler`类中的`create`方法，以了解它是如何工作的:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.*
import org.springframework.web.reactive.function.server.bodyToMono
import reactor.core.publisher.onErrorResume
import java.net.URI

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

  fun search(serverRequest: ServerRequest) =
      ok().body(customerService.searchCustomers(serverRequest.queryParam("nameFilter")
          .orElse("")), Customer::class.java)

  fun create(serverRequest: ServerRequest) =
      customerService.createCustomer(serverRequest.bodyToMono()).flatMap {
        created(URI.create("/functional/customer/${it.id}")).build()
      }.onErrorResume(Exception::class) {
        badRequest().body(fromObject("error"))
      }
}
```

使用`onErrorResume`，我们可以通知任何反应式发布者，如果我们得到一个错误，我们可以在我们的方法中处理它。我们已经创建了一个 lambda，它用一个简单的文本给出了一个 400 错误请求输出响应。

为了测试这一点，我们可以使用`curl`执行下面的 JSON 请求:

```java
curl -X POST \
  http://localhost:8080/functional/customer/ \
  -H 'content-type: application/json' \
  -d '{
  "id": 18,
  "name": "New Customer",
  "telephone": {
    "countryCode": "+44",
    "telephoneNumber": "7123456789"
  }
}
bad json'
```

这个请求将只产生一个 400 错误请求响应，其文本内容为:

```java
error
```

我们可以创建一个简单的 JSON 响应，就像我们在 RESTful APIs 示例中所做的那样，带来我们的`ErrorResponse`类:

```java
package com.microservices.chapter4

data class ErrorResponse(val error: String, val message: String)
```

现在，我们可以调整对错误的响应:

```java
package com.microservices.chapter4

import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.BodyInserters.fromObject
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse.*
import org.springframework.web.reactive.function.server.bodyToMono
import reactor.core.publisher.onErrorResume
import java.net.URI

@Component
class CustomerHandler(val customerService: CustomerService) {
  fun get(serverRequest: ServerRequest) =
      customerService.getCustomer(serverRequest.pathVariable("id").toInt())
          .flatMap { ok().body(fromObject(it)) }
          .switchIfEmpty(status(HttpStatus.NOT_FOUND).build())

  fun search(serverRequest: ServerRequest) =
      ok().body(customerService.searchCustomers(serverRequest.queryParam("nameFilter")
          .orElse("")), Customer::class.java)

  fun create(serverRequest: ServerRequest) =
      customerService.createCustomer(serverRequest.bodyToMono()).flatMap {
        created(URI.create("/functional/customer/${it.id}")).build()
      }.onErrorResume(Exception::class) {
        badRequest().body(fromObject(ErrorResponse("error creating customer",
            it.message ?: "error")))
      }
}
```

如果我们再次重复`curl`请求，我们应该得到类似于:

```java
{
    "error": "error creating customer",
    "message": "JSON decoding error: Unexpected character ('b' (code 98)): expected a valid value (number, String, array, object, 'true', 'false' or 'null'); nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected character ('b' (code 98)): expected a valid value (number, String, array, object, 'true', 'false' or 'null')\n at [Source: UNKNOWN; line: 9, column: 2]"
}
```

任何反应式发布者都可以使用`onErrorResume`方法，因此我们可以在我们的`CustomerService`以及应用的其他层中使用它；我们这样做是为了让我们的处理程序不会出错。

# 发布错误

我们知道如何处理错误，但有时我们需要制造错误。例如，如果我们试图创建一个已经创建的客户，那么让我们尝试创建一个错误。

为此，我们将创建一个简单的`Exception`类，`CustomerExistException`:

```java
package com.microservices.chapter4

class CustomerExistException(override val message: String) : Exception(message)
```

现在我们可以修改我们的`CustomerServiceImpl`类中的`create`方法来使用这个新的异常:

```java
package com.microservices.chapter4

import com.microservices.chapter4.Customer.Telephone
import org.springframework.stereotype.Component
import reactor.core.publisher.Mono
import reactor.core.publisher.toFlux
import reactor.core.publisher.toMono
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) = customers[id]?.toMono() ?: Mono.empty()

  override fun searchCustomers(nameFilter: String) = customers.filter {
    it.value.name.contains(nameFilter, true)
  }.map(Map.Entry<Int, Customer>::value).toFlux()

  override fun createCustomer(customerMono: Mono<Customer>) =
 customerMono.flatMap {
        if (customers[it.id] == null) {
 customers[it.id] = it
          it.toMono()
 } else {
 Mono.error(CustomerExistException("Customer ${it.id} already 
         exist"))
 }
      }
}

```

在这种情况下，我们必须首先检查客户是否存在，如果不存在，我们将只存储并返回一个`Mono`，如果不存在，我们将只创建一个`Mono.error`。与`Mono.empty`创建一个没有值的`Mono`一样，`Mono.error`将创建一个包含错误的`Mono`。

现在让我们试着发送这个`curl`请求两次:

```java
curl -X POST \
 http://localhost:8080/functional/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 18,
 "name": "New Customer",
 "telephone": {
 "countryCode": "+44",
 "telephoneNumber": "7123456789"
 }
}
'
```

第二次发送这个请求时，我们应该得到这个带有 400 错误请求响应的输出:

```java
{
    "error": "error creating customer",
    "message": "Customer 18 already exist"
}
```

完成这些之后，我们现在就可以在我们的反应式服务中有效地处理错误了。

# 摘要

在本章中，我们已经了解了如何创建反应式微服务来生产高质量的无阻塞 IO 微服务。我们学习了更多关于反应式编程模型以及发布者和订阅者模式的概念。现在，当我们创建反应式微服务时，我们有两个编程模型可供选择，一个是更传统的基于注释的模型，另一个是新的函数式模型。最后，我们学习了如何处理错误来创建为失败而构建的微服务。

但是，任何反应式系统都与其使用的后端一样具有反应性，因此，当我们的微服务需要查询数据时，例如从数据库查询数据，我们可以反应式地进行，因为我们仍然保留反应式微服务的全部功能。

在下一章中，我们将学习如何在创建反应式微服务时反应式地使用 MongoDB。我们将学习如何使用 Spring 数据对数据库执行反应式操作，以及如何在应用中轻松使用和配置 MongoDB。然后，我们将创建带有 CRUD 存储库的 RESTful APIs，以提供与 NoSQL 数据库完全集成的快速、无阻塞的反应式微服务。