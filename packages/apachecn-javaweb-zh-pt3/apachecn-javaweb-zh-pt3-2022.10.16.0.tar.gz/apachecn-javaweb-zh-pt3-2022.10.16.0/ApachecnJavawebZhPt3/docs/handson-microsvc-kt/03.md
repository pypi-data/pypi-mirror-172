# 三、创建 RESTful 服务

RESTful APIs 存在于我们每天使用的大多数现代应用中，从阅读 Twitter 消息或访问脸书页面到阅读我们的电子邮件或进行谷歌搜索。通过轻量级的通信协议和对资源、状态和动词的强调，它们已经成为通过 HTTP 协议交换信息的自然语言。

在本章中，我们将了解如何使用 Kotlin 和 Spring 框架创建我们自己的 RESTful APIs。我们将学习如何接收参数，以及 HTTP 动词和状态如何使我们的 API 定义它们无处不在的语言。我们在[第一章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1) *的*领域驱动设计*部分谈到了一种无处不在的语言，理解微服务*。

此外，我们将学习如何在我们的 API 中处理 JSON 请求和响应。最后，我们将回顾 Spring 如何允许我们处理微服务中的错误。

在本章中，您将了解:

*   rest 控制器
*   请求映射
*   路径变量
*   他们要求停止
*   响应实体和响应主体
*   控制器建议

# 了解 RestController

任何 RESTful API 都需要回答来自客户端的请求；这些请求在 Spring 中由一个控制器对象处理。在这一节中，我们将了解控制器实际上是什么，以及`RestController`如何帮助我们在 RESTful API 中创建第一个组件。

# 什么是控制器

每个到达 RESTful API 的请求都是一个无状态消息，主要将:

*   请求资源
*   更新资源
*   创建资源
*   删除资源

这些请求将使用 JSON 作为交换信息的机制。

**JavaScript Object Notation** (**JSON**) is a human-readable data format to transmit objects. It is a language-independent data format, but it was derived from JavaScript. Most programming languages include code to generate and parse JSON-format data.

Spring web 应用中的请求由控制器处理，控制器是一个专门的组件，其任务是处理来自客户端的请求并发回响应。控制器可以用于各种通信协议，但是因为我们要做一个 RESTful API，我们将使用一个`RestController`。

将指定我们的控制器将处理请求并输出一个主体；这将有助于我们做出回应。

# 创建 RestController

为了创建我们的控制器，我们将开始使用 Spring Initializr 生成一个新的 Spring Boot 应用，访问网站:[https://start.spring.io/](https://start.spring.io/)。

我们在《Spring Boot 2.0 入门第二章中学习了如何使用 Spring Initializr。您可以查看使用 Spring Initializr 一节来了解更多信息。

为了创建一个新的项目，我们将选择 Maven 项目与科特林和 Spring Boot 2.0.0 M7。在春天里。对于项目元数据，我们将设置一个组`com.microservices`和工件`chapter3`，作为依赖项，我们将包括 Web。

现在，我们将解压生成的项目，并用 IntelliJ IDEA 打开它。在项目窗口中，我们将右键单击我们的包 com.microservices，并在下拉菜单中选择 Kotlin File/Class。在新的对话框中，我们将选择创建一个名为`CustomerController`的类，我们将编写以下代码:

```java
package com.microservices.chapter3

import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.ResponseBody
import org.springframework.web.bind.annotation.RestController

@RestController
class CustomerController {
  @RequestMapping(value = "/customer", method = arrayOf(RequestMethod.GET))
  fun getCustomer() = "hello from a controller"
}
```

如果我们在浏览器中插入 URL `http://localhost:8080/customer`，我们将会得到一条消息`"hello from a controller"`。

因为 RESTful 服务是关于返回资源的，所以让我们创建一个表示资源的类，例如，一个客户创建一个名为`Customer`的类:

```java
package com.microservices.chapter3

data class Customer(var id: Int = 0, var name: String = "")
```

在 Kotlin 中，数据类是一个方便的类，它允许我们定义一个具有某些属性的类，这些属性在使用`val`创建后不能改变，或者可以使用`var`改变。

Kotlin 会自动为那些类提供`equals()`、`hashCode()`、`toString()`，甚至是复制或者赋值操作符。

数据类是传统 POJO 类(普通的旧 Java 对象)的非常有用的替代品。它们可以大大减少我们在课堂上需要的样板代码的数量。要了解更多，可以查看 Kotlin 文档中的条目:[https://kotlinlang.org/docs/reference/data-classes.html.](https://kotlinlang.org/docs/reference/data-classes.html)

然后，我们可以将控制器修改为:

```java
@RestController
class CustomerController {
  @RequestMapping(value = "/customer", method = arrayOf(RequestMethod.GET))
 fun getCustomer() = Customer(1, "Kotlin")
}
```

如果我们回到我们的 URL `http://localhost:8080/customer`，我们现在将得到一个 JSON 响应:

```java
{"id":1,"name":"Kotlin"}
```

# 了解我们的控制器

在我们的例子中，我们已经使用 Spring 注释`@RestController`创建了一个控制器。正如我们在[第 2 章](02.html#29DRA0-005ba5e9819e4f499f11aaac5b7181c1)、*Spring Boot 2.0 入门*中所理解的那样，这个控制器将在应用启动时被组件扫描获得，并将作为 bean 添加到我们的 Spring 上下文中。

在这个控制器中，我们使用`@RequestMapping`为 URL `/customer`设置了一个映射，以接受`GET`请求。由于是一个`RestController`，响应将作为 JSON 对象输出。

这个映射将由 Spring Boot 自动配置，并连接到我们的 web 应用中。如果我们在启动微服务时检查应用日志，我们可以看到以下消息:

```java
s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped "{[/customer],methods=[GET]}" onto public com.microservices.chapter3.Customer com.microservices.chapter3.CustomerController.getCustomer()
```

当对映射的 URL 的每个请求都启动并运行时，我们的方法将被执行，一个新的`Customer`对象实例将被创建并转换成 JSON，作为对请求的响应被发送回来。

如果你只看代码行，我们可以只写其中的几行，我们就有了一个全功能的 REST 服务。这也是很多开发者使用 Spring 和 Spring Boot 的原因之一；他们会变得非常有生产力。试着充分利用 Spring 的优势来最大化你的生产力。

# 路径和请求参数

现在我们已经了解了如何在控制器中返回数据，我们应该学习如何请求特定的资源，以便过滤信息并将其作为响应返回。在 RESTful APIs 中，当应用为特定资源调用我们的服务时，它将通过 URL 路径查询需要返回的信息。

例如，如果一个应用使用 URL `/customer/1`调用我们的 API，那么在这个例子中，它表明被查询的资源是一个特定的客户`1`。

但是 RESTful APIs 也允许我们扩展请求，通过参数进一步提供额外的信息。

应用可以使用 URL `/customers`调用我们的 API，表明需要接收客户列表。但是该 URL 可以提供一个额外的参数来指定一个过滤器，例如，通过给出 URL 的名称来搜索客户。

我们不应该过滤通过请求参数请求的资源。在 RESTful APIs 中，这总是通过路径变量来完成。

# 创建客户地图

但是在探索如何回答路径请求之前，我们需要有一组我们可以使用的客户，这样我们就可以在新请求中过滤他们。

首先，让我们修改我们的应用来创建一个代表我们客户的 bean:

```java
package com.microservices.chapter3

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.Bean
import java.util.concurrent.ConcurrentHashMap

@SpringBootApplication
class Chapter3Application {
 companion object {
 val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice"))
 } 
 @Bean
  fun customers() = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))
}
```

这段代码创建一个 hashmap，并将其作为 bean 添加到 Spring 上下文中；我们选择使用并发版本，因为我们不想修改这个映射，因为我们可能会以同步问题而告终，比如当不同的请求访问映射上的同一个元素时。现在我们的 bean 已经准备好了，我们可以将它自动连接到控制器中:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.RestController
import java.util.concurrent.ConcurrentHashMap

@RestController
class CustomerController {
 @Autowired
  lateinit var customers : ConcurrentHashMap<Int, Customer>

  @RequestMapping(value = "/customer/", method = arrayOf(RequestMethod.GET))
  fun getCustomer() = customers[2]
}
```

`@Autowired`注释将我们的 bean 放入我们的控制器，因此它可以用它来响应请求。在本例中，我们将只返回 id 为`2`的客户。

Beans、Spring 上下文和`@Autowired`注释在[第 2 章](01.html#K0RQ0-005ba5e9819e4f499f11aaac5b7181c1)、*Spring Boot 2.0 入门中进行了回顾。*

如果我们回到我们的 URL `http://localhost:8080/customer`，我们现在将得到一个 JSON 响应:

```java
{"id":2,"name":"Spring"}
```

# 获取路径变量

在 Spring 中，我们可以使用注释`@PathVariable`获得进入 URL 的值。让我们修改控制器来说明如何:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.RestController
import java.util.concurrent.ConcurrentHashMap

@RestController
class CustomerController {
  @Autowired
  lateinit var customers : ConcurrentHashMap<Int, Customer>

  @RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.GET))
  fun getCustomer(@PathVariable id : Int) = customers[id]
}
```

如果我们回到我们的 URL `http://localhost:8080/customer/2`，我们现在将得到这个 JSON 响应:

```java
{"id":2,"name":"Spring"}
```

# 了解路径变量

Spring 已经映射了我们的新 URL 来接收参数。我们在 URL 上用花括号指定了它的名字为`id`，在我们的例子中是`/customer/{id}`。
然后，我们将为我们的方法`getCustomer`创建一个名为`id`的参数，我们已经用注释`@PathVariable`注释了这个方法，并将它的类型指定为`Int`。

当 Spring 自动配置我们的控制器时，我们将理解这个注释，并将 URL 中传递的值映射到我们的方法所需的值，并将它转换为指定的正确数据类型。这是一个非常强大的特性，允许我们在方法中轻松地映射路径变量，而不需要任何类型的配置。

# 定义请求参数

现在，我们可以通过添加用于进一步理解请求的请求变量来改进我们的映射，但是首先，让我们在控制器中创建一个新方法来返回客户列表:

```java
@RequestMapping(value = "/customers", method = arrayOf(RequestMethod.GET))
fun getCustomers() = customers.map(Map.Entry<Int, Customer>::value).toList()
```

如果我们调用这个新的 URL `http://localhost:8080/customers`，在我们的微服务中，我们将得到这个结果:

```java
[{"id":1,"name":"Kotlin"},{"id":2,"name":"Spring"},{"id":3,"name":"Microservice"}]
```

我们刚刚将我们的客户地图转换成一个列表，并以一种新的方法输出。
但是现在如果我们需要过滤我们的客户列表，例如，通过客户名称的某个部分，我们可以修改我们的新方法:

```java
@RequestMapping(value = "/customers", method = arrayOf(RequestMethod.GET))
fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
 customers.filter {
      it.value.name.contains(nameFilter, true)
 }.map(Map.Entry<Int, Customer>::value).toList()
```

现在，当我们请求这个新的 URL `http://localhost:8080/customers?nameFilter=in`时，我们应该得到以下响应:

```java
[{"id":1,"name":"Kotlin"},{"id":2,"name":"Spring"}]
```

但是，如果我们请求没有参数的前一个 URL，我们将得到和以前一样的输出。

`String.contains` a powerful function. We use it to filter if the name of a customer contains a certain letter and the second parameter of the `String.contains` function is to set that we want to ignore upper/lower case differences.

# 了解请求参数

在 RequestMapping 中，我们不像在 path 变量中那样使用 URL 定义参数。我们在函数中将它们声明为参数，并用`@RequestParam`注释进行了注释。在注释中，我们可以指定参数是否是必需的参数，以及它是否有默认值，因此如果它不存在，该值将被注入到我们的映射方法中。

默认值必须始终是一个字符串，Spring 会自动将其转换回任何其他类型。我们可以定义尽可能多的参数，它们将在 URL 中用 and 分隔。有了这最后一项添加，我们可以开始创建更灵活的 API 来处理这些参数，以调整我们的功能。

要小心我们使用的参数数量，以及它们的用途。如果您因为参数中的某些东西而开始使一个 API 的行为真正不同，这可能表明可能需要一个不同的 API。

# HTTP 动词和状态

在 RESTful APIs 中，我们使用标准的 HTTP 动词来指示我们需要对特定资源做什么。这些动词定义了客户端需要做什么，但是我们需要在我们的微服务中回答我们返回什么响应。

例如，当一个客户使用带有 HTTP 动词`GET`的 URL `http://localhost:8080/customer/1`请求一个特定的客户时，我们可以用状态 200 OK 来回答，或者如果我们没有找到客户，就用 404 NOT FOUND 来回答。

这种双向交流成为客户机和 API 之间对话的一部分，并将形成我们无处不在的语言。

# 标准 HTTP 动词和状态

在 RESTful APIs 中，HTTP 动词和状态非常灵活，我们的应用可以决定如何使用它们，但是有一组标准和众所周知的模式来组合它们。

# 单一资源

考虑到我们正在使用通过 URL 提供资源的 API，例如`/customer`，我们可以使用:

| 统一资源定位器 | 动词 | 状态 | 意义 |
| `/customer/1` | `GET` | 200 好吧 | 我们询问了一个特定的客户，并得到了结果 |
| `/customer/1` | `GET` | 404 未找到 | 我们要求一个特定的客户，但他们无法找到 |
| `/customer` | `POST` | 201 已创建 | 我们请求创建一个新客户，它已经创建了 |
| `/customer` | `POST` | 400 错误请求 | 我们要求创建一个新客户，但是数据不正确 |
| `/customer/1` | `PUT` | 202 项被接受 | 我们请求更新一个客户，它被正确地更新了 |
| `/customer/1` | `PUT` | 404 未找到 | 我们请求更新一个客户，但是找不到该客户 |
| `/customer/1` | `DELETE` | 200 好吧 | 我们要求删除一个客户，我们做得很正确 |
| `/customer/1` | `DELETE` | 404 未找到 | 我们要求删除一个客户，但是找不到 |

# 收集

如果我们使用 API 来提供资源集合，例如，给出 URL/客户的客户列表，我们可以使用:

| 统一资源定位器 | 动词 | 状态 | 意义 |
| `/customers/` | `GET` | 200 好吧 | 我们索要了一份客户名单，并得到了结果 |
| `/customers/` | `GET` | 204 无内容 | 我们要了一份顾客名单，但是没有 |
| `/customers/?name=son` | `GET` | 200 好吧 | 我们要求过滤结果的客户名单 |
| `/customers/?name=son` | `GET` | 204 无内容 | 对客户的筛选没有返回任何结果 |
| `/customers/?name=#` | `GET` | 400 错误请求 | 对客户的筛选不正确 |

# 一般错误

有时 API 可能只返回一般性错误，在许多情况下，不管使用的是什么动词；比较常见的有:

| 状态 | 意义 |
| 400 错误请求 | 我们无法回答该请求，因为它不正确 |
| 401 未经授权 | 我们没有那个操作的凭证 |
| 403 禁止 | 我们可能有资格证书，但我们不允许这样做 |
| 422 无法处理的实体 | 我们无法处理该请求；它可能是正确的，但对于此操作无效 |
| 500 内部服务器错误 | 我们无法处理该请求 |

在我们的应用中，一个 500 错误确实是非常关键的，有时这意味着它甚至不能从中恢复，比如失去与数据库或另一个系统的连接。我们不应该返回任何具有功能意义的 5xx 范围错误，而应该使用 4xx 范围。

# 处理 HTTP 动词

Spring 允许我们定义控制器方法将处理的 HTTP 动词。我们在`@RequestMapping`中使用参数方法来实现这一点。

例如，在我们的控制器中:

```java
@RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.GET))
fun getCustomer(@PathVariable id: Int) = customers[id]
```

这个参数实际上是一个数组，如果需要的话，它可以被改变以接受多个方法。例如，作为:

```java
@RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.GET, RequestMethod.POST))
fun getCustomer(@PathVariable id: Int) = customers[id]
```

随着这一改变，我们设置我们将在该方法中接受`HTTP GET`或`HTTP POST`，但是，我们建议您在控制器中为每个函数保留一个方法。如果我们遵循我们的建议，`GET`将获得一个资源，而`POST`将创建一个资源，那么我们的方法将尝试做两件不同的事情，为此，我们应该有两个不同的方法。

在设计我们的方法时，我们应该永远记住单一责任原则。一个方法应该只有一个改变的理由。

我们已经在前面的例子中定义了如何处理 HTTP `GET`。让我们回顾一下如何处理其他 HTTP 动词。

# 处理 HTTP POST

当我们试图创建一个资源时，我们将使用`HTTP POST`，因此如果我们试图添加新客户，我们将向我们的客户 URL `/customer/`发布一个新资源。我们可以用这段代码简单地做到这一点:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*
import java.util.concurrent.ConcurrentHashMap

@RestController
class CustomerController {
  @Autowired
  lateinit var customers : ConcurrentHashMap<Int, Customer>

  @RequestMapping(value = "/customers", method = arrayOf(RequestMethod.GET))
  fun getCustomers() = customers.map(Map.Entry<Int, Customer>::value).toList()

  @RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.GET))
  fun getCustomer(@PathVariable id : Int) = customers[id]

 @RequestMapping(value = "/customer/", method = arrayOf(RequestMethod.POST))
 fun createCustomer(@RequestBody customer: Customer) {
 customers[customer.id] = customer
 }
}

```

这里，我们使用注释`@RequestBody`来指定我们正在发送一个对象。因为这是在一个`@RESTController`中，所以预期的对象应该是 JSON 格式的。对于这个例子，我们可以使用:

```java
{
 "id": 4,
 "name": "New Customer"
}
```

我们可以使用`cURL`简单地测试这个请求:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 4,
 "name": "New Customer"
}'
```

在这个命令中需要考虑的一件重要的事情是，我们已经将`content-type`头设置为`application/json`，这是因为我们需要让 Spring 明白我们发送的是一个 JSON 主体。执行该命令后，我们现在可以向 URL 为`http://localhost:8080/customers`的客户列表发出请求，得到以下输出:

```java
[{"id":1,"name":"Kotlin"},{"id":2,"name":"Spring"},{"id":3,"name":"Microservice"},{"id":4,"name":"New Customer"}]
```

在这个例子中，我们应该记住的一点是，客户的`id`是在对象中发送的，而不是在 URL 中出现的，这符合我们在本节开始时对 URL 和动词的建议。

# 处理 HTTP 删除

当我们使用`HTTP DELETE`时，我们要求我们的服务删除一个给定的资源，我们将以`/customer/id`的形式来完成。这指定了所有资源中需要删除的资源:

```java
@RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.DELETE))
fun deleteCustomer(@PathVariable id: Int) = customers.remove(id)
```

对于这个操作，我们刚刚在方法中设置了相应的 HTTP 动词，并作为路径变量，设置了要删除的资源的`id`。然后，我们只需将其从客户地图中删除。我们不需要任何客户作为主体参数，因为有了`id`，我们可以直接删除我们的资源。

我们可以使用`cURL`发送一个简单的请求来测试这个操作:

```java
curl -X DELETE http://localhost:8080/customer/4 
```

执行该命令后，我们现在可以向 URL `http://localhost:8080/customers`处的客户列表发出请求，以获得输出:

```java
[{"id":1,"name":"Kotlin"},{"id":2,"name":"Spring"},{"id":3,"name":"Microservice"}]
```

# 处理 HTTP PUT

当我们使用`HTTP PUT`时，我们要求我们的服务更新一个给定的资源，我们将以`/customer/id`的形式来完成。这指定了所有资源中哪个资源需要更新。但是我们也需要发送一个客户作为`JSON`主体，这样我们就可以准确地得到我们需要更新的内容。在 RESTful APIs 中，概念是资源保存在客户机中，并在需要时更新回服务器。然后，这个对象表示被查询的对象的状态。

但在实现之前，我们可能需要考虑一件事。如果我们请求更新的资源改变了`id`会发生什么，这是一个有效的场景吗？这取决于我们如何定义我们的 API 来工作，它实际上可能是我们喜欢做的事情，所以让我们在那个特定的场景中实现它:

```java
@RequestMapping(value = "/customer/{id}", method = arrayOf(RequestMethod.PUT))
fun updateCustomer(@PathVariable id: Int, @RequestBody customer: Customer) {
  customers.remove(id)
  customers[customer.id] = customer
}
```

对于这个方法的实现，我们只是选择做我们的删除和创建所做的。如果我们执行这个`cURL`请求:

```java
curl -X PUT \
 http://localhost:8080/customer/2 \
 -H 'cache-control: no-cache' \
 -H 'content-type: application/json' \
 -d '{
 "id": 4,
 "name": "Update Customer"
}'
```

执行完命令后，我们现在可以向 URL `http://localhost:8080/customers`处的客户列表发出请求，以获得输出:

```java
[{"id":1,"name":"Kotlin"},{"id":2,"name":"Spring"},{"id":4,"name":"Update Customer"}]
```

# 使用动词和映射注释

在我们的例子中，我们使用了`@RequestMapping`,将方法作为参数提供给注释，这是可以的，但是对于这么简单的事情来说，可能代码太多了；Spring 提供了助手来减少这种声明:

```java
@GetMapping(value = "/customer/{id}")
fun getCustomer(@PathVariable id : Int) = customers[id]

```

对于一个`GET`请求，我们可以使用`@GetMapping`，我们不需要指定方法；`POST`、`PUT`、`DELETE`、`@PostMapping`、`@PutMapping`、`@DeleteMapping`分别有对应的标注。

现在有了这个最后的改变，我们完成了我们的动词代码，但是我们可以在我们的`PUT`动词中看到一些看起来不正确的重复，所以我们可能需要探索如何更好地实现它的概念。

# 实现服务层

在我们的实现中，我们已经处理了几个不同的 HTTP 动词，这没问题，但是这样做，我们在代码中创造了一些可能需要删除的重复。例如，更新我们的客户结合了我们的删除和创建操作。

但是还有一点我们没有注意到。在某种程度上，我们正在耦合我们的 API 处理，我们的控制器，然而，我们的模型被存储，使得客户 bean 成为我们的控制器的一部分，从而创建了这种耦合。

现在，我们的客户列表是一个地图，明天，我们可能希望将它存储在数据库中，或者以不同的方式处理，从而影响我们的控制器，使其看起来不正确。我们将使用服务模式来处理这个问题。

# 创建服务接口

首先，我们将创建一个服务接口。在 IntelliJ 中，我们可以通过右键单击我们的包并选择一个新的 Kotlin File | Class，然后在下拉菜单中选择 Interface 来实现这一点。我们将命名它为`CustomerService`。

我们将定义我们的服务需要的方法:

```java
package com.microservices.chapter3

interface CustomerService {
  fun getCustomer(id: Int) : Customer?
  fun createCustomer(customer: Customer)
  fun deleteCustomer(id: Int)
  fun updateCustomer(id: Int, customer: Customer)
  fun searchCustomers(nameFilter: String): List<Customer>
}
```

这些操作并不公开客户是如何被存储/保存或搜索的，它们只是我们希望拥有的接口，并不公开实现中的任何内部内容。

我们已经将`getCustomer`的类型设置为客户。这意味着该值可能为空。Kotlin null-safety 是一个很好的特性，有时，像这样，当我们找不到客户时，我们可能会返回一个 null 值。但是，当然，我们可以使用 Java 可选对象来存档类似的结果。

# 创建实现

现在，在 IntelliJ 中，我们可以将光标放在`CustomerService`字上，点击 *Alt* + *Enter* 来显示动作，然后我们就可以选择实现接口了。一个新窗口将显示询问姓名。它已经填充了`CustomerServiceImpl`，所以我们让它保持原样并点击 OK。

现在，我们将看到我们想要实现的接口的方法。我们可以选择第一个然后按 *Shift* 最后一个全部选中。将出现一个新类，代码如下:

```java
package com.microservices.chapter3

class CustomerServiceImpl : CustomerService {
  override fun getCustomer(id: Int) : Customer? {
    TODO("not implemented")
  }

  override fun createCustomer(customer: Customer) {
    TODO("not implemented")
  }

  override fun deleteCustomer(id: Int) {
    TODO("not implemented")
  }

  override fun updateCustomer(id: Int, customer: Customer) {
    TODO("not implemented")
  }

  override fun searchCustomers(nameFilter: String): List<Customer> {
    TODO("not implemented")
  }
}
```

但是在实现这些方法之前，我们需要让我们的客户在那个类中。让我们像过去一样在 bean 上添加一个映射和初始化:

```java
package com.microservices.chapter3

import java.util.concurrent.ConcurrentHashMap

class CustomerServiceImpl : CustomerService {
 companion object {
 val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice"))
 }
 val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

  override fun getCustomer(id: Int) : Customer? {
    TODO("not implemented")
  }

  override fun createCustomer(customer: Customer) {
    TODO("not implemented")
  }

  override fun deleteCustomer(id: Int) {
    TODO("not implemented")
  }

  override fun updateCustomer(id: Int, customer: Customer) {
    TODO("not implemented")
  }

  override fun searchCustomers(nameFilter: String): List<Customer> {
    TODO("not implemented")
  }
}
```

然后，我们可以轻松地实现我们的方法:

```java
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
        Customer(2, "Spring"),
        Customer(3, "Microservice"))
  }

  val customers = ConcurrentHashMap<Int, Customer>(initialCustomers.associateBy(Customer::id))

 override fun getCustomer(id: Int) = customers[id]

 override fun deleteCustomer(id: Int) {
 customers.remove(id)
 }

 override fun createCustomer(customer: Customer) {
 customers[customer.id] = customer
 }

 override fun updateCustomer(id: Int, customer: Customer) {
 deleteCustomer(id)
 createCustomer(customer)
 }

 override fun searchCustomers(nameFilter: String): List<Customer> =
 customers.filter {
        it.value.name.contains(nameFilter, true)
 }.map(Map.Entry<Int, Customer>::value).toList()
}
```

# 绑定正确的 bean

现在，我们有了这个服务，我们可以更改我们的 Spring 上下文来为这个服务创建一个 bean，并删除原来的 customer bean。我们只需要修改我们的`Chapter3Application.kt`来删除 bean，并把它作为一个简单的类:

```java
package com.microservices.chapter3

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication@SpringBootApplication
class Chapter3Application 
fun main(args: Array<String>) {
    runApplication<Chapter3Application>(*args)
}

```

然后，我们将使用`@Component`注释来注释我们的服务实现:

```java
package com.microservices.chapter3

import org.springframework.stereotype.Component
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService 
........
}
```

但是，我们需要将控制器中使用的 bean 更改为服务:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*

@RestController
class CustomerController {
 @Autowired
  private lateinit var customerService: CustomerService
........

}
```

这将使组件扫描以将 bean 实现连接到该接口；因为我们的实现是用`@Component`注释的，所以它将连接这个实现。如果明天，我们改变我们的实现，那么控制器将得到新的实现而不受影响。

# 使用服务

现在，我们可以修改控制器本身来使用新的服务:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.web.bind.annotation.*

@RestController
class CustomerController {
  @Autowired
  private lateinit var customerService: CustomerService

  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int) = customerService.getCustomer(id)

  @PostMapping(value = "/customer/")
  fun createCustomer(@RequestBody customer: Customer) {
 customerService.createCustomer(customer)
  }

  @DeleteMapping(value = "/customer/{id}")
  fun deleteCustomer(@PathVariable id: Int) {
 customerService.deleteCustomer(id)
  }

  @PutMapping(value = "/customer/{id}")
  fun updateCustomer(@PathVariable id: Int, @RequestBody customer: Customer) {
 customerService.updateCustomer(id, customer)
  }

  @GetMapping(value = "/customers")
  fun getCustomers(@RequestParam(required = false, defaultValue = "") nameFilter: String) =
 customerService.searchCustomers(nameFilter)
}

```

如果我们再次运行我们的`cURL`请求，什么都不会改变，一切都会像以前一样工作，但这最终改变了我们的控制器，它与我们的客户服务的实现完全分离，为未来提供了更大的灵活性。

试着想办法用这样的模式从你的软件中分离元素。这将使您的应用更容易维护和发展。

# 处理 HTTP 状态

我们现在以精确的方式处理不同种类的动词，但是当我们响应我们的 API 服务的消费者时，我们需要同样精确。为此，我们可以使用 HTTP 状态，正如我们在本节开始时所描述的。

# 使用响应实体

到目前为止，Spring 已经处理了我们的响应状态，我们创建的每个方法都将以 200 OK 来回答，但是我们需要修改我们的响应，以便我们可以给出一系列不同的状态，正如我们在本节开始时所描述的。Spring 为此提供了一个名为`ResponseEntity`的通用类，当我们在控制器中回答时，我们可以用它来指定我们的状态。

为了更好地理解，我们可以修改我们的一个方法:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
class CustomerController {
  @Autowired
  private lateinit var customerService: CustomerService

  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int) =
 ResponseEntity(customerService.getCustomer(id), HttpStatus.OK)
......
}
```

这实际上是默认情况下`@GetMapping`正在做的事情，但是现在我们可以根据我们喜欢做的事情将状态修改为正确的值。

让我们更新我们的方法，使用正确的答案。

# 回答 GET 请求

根据我们的定义，最初，当我们收到一个对资源的`GET`请求时，我们应该用资源和 200 OK 来回答，或者如果没有找到资源，用 404 NOT FOUND 来回答。

所以，我们可以修改我们的方法:

```java
@GetMapping(value = "/customer/{id}")
fun getCustomer(@PathVariable id: Int): ResponseEntity<Customer?> {
  val customer = customerService.getCustomer(id)
 val status = if (customer == null) HttpStatus.NOT_FOUND else HttpStatus.OK
  return ResponseEntity(customer, status)
}
```

首先，我们得到客户；如果没有找到客户，服务将返回`null`，因此我们可以将我们的状态设置为 404 NOT FOUND 或 200 OK。

# 回复帖子请求

当我们定义如何回答`POST`请求时，我们指定不返回 200 OK，我们应该回答一个简单的 201 CREATED，我们真的不需要为我们的请求指定一个主体，因为我们没有返回任何对象。

我们可以将我们的方法修改为:

```java
@PostMapping(value = "/customer/")
fun createCustomer(@RequestBody customer: Customer): ResponseEntity<Unit> {
  customerService.createCustomer(customer)
  return ResponseEntity(Unit, HttpStatus.CREATED)
}
```

在这个场景中，我们将使用一个使用`Unit`的`ResponseEntity`，它相当于 Kotlin 中的一个 void 类型，因为我们不会输出任何人。

# 回复删除请求

在我们最初的定义中，我们说过如果我们要删除一个没有找到的资源，我们应该用 404 NOT FOUND 来回答，如果我们删除了它，我们应该回答 200 OK，而不管我们是否应该需要将一个主体发送回客户端。

因此，我们的方法看起来像这样:

```java
@DeleteMapping(value = "/customer/{id}")
fun deleteCustomer(@PathVariable id: Int): ResponseEntity<Unit> {
  var status = HttpStatus.NOT_FOUND
  if (customerService.getCustomer(id) != null) {
    customerService.deleteCustomer(id)
 status = HttpStatus.OK
  }
 return ResponseEntity(Unit, status)
}
```

首先，我们将设置我们没有找到客户，我们将检查我们的服务是否实际存在。如果是这样，我们删除并将状态设置为 200 OK，最终返回`Unit`，因为我们不需要 body 和期望的状态。

我们可以争论这个逻辑是应该在我们的`CustomerService`中还是在控制器中，但是实际上是控制器要求以不同的方式删除一个不存在的客户，所以我们保留这个逻辑。

# 回答更新请求

与`DELETE`请求非常相似，当我们更新一个客户时，我们应该注意资源是否存在，同样，我们不需要为这个请求返回任何人；但是，如果我们修改了资源，我们应该返回 202 ACCEPTED。

让我们修改一下`update`方法:

```java
@PutMapping(value = "/customer/{id}")
fun updateCustomer(@PathVariable id: Int, @RequestBody customer: Customer): ResponseEntity<Unit> {
 var status = HttpStatus.NOT_FOUND
  if (customerService.getCustomer(id) != null) {
    customerService.updateCustomer(id, customer)
 status = HttpStatus.ACCEPTED
  }
 return ResponseEntity(Unit, status)
}
```

使用这种方法，我们必须完成我们的状态响应，但是还有一件事我们需要澄清。

# 空响应

在我们所有的方法中，我们被设置为返回一个`JSON`响应，这是因为我们使用了一个`RESTController`。然而，有趣的是，如果我们要返回一个对象，而返回的对象是`null`，那么主体将是空的，所以我们的响应中将没有内容，只有状态。当我们用一个不存在的 ID 调用 get 服务时，就会发生这种情况；返回一个空响应。

在我们之前声明的返回`Unit`的方法中，将返回一个空的 JSON 对象。如果我们调用它们，我们只会得到`{}`；这就是当我们用一个不存在的 ID 调用 delete 或 update 方法时得到的结果，返回一个空对象。

但是我们可以修改代码，即使对于`Unit`方法也不返回任何内容。如果需要，只需像这样修改它们:

```java
@PostMapping(value = "/customer/")
fun createCustomer(@RequestBody customer: Customer): ResponseEntity<Unit?> {
  customerService.createCustomer(customer)
  return ResponseEntity(null, HttpStatus.CREATED)
}
```

但是，我们应该回报什么呢？空对象还是空响应？由我们来决定什么对我们的 API 更好，但是我们更喜欢空响应而不是空对象，因为对于 API 的用户来说，简单地没有内容比空对象更容易混淆。

在 Rest API 方法中，总是返回一个值是一个好习惯，在之前描述的操作中，我们可以返回一个简单的 JSON，表示一切正常，类似于`{ "result" : "ok" }`。这将防止消费者误解响应，但是，无论响应主体是什么，消费者都应该始终信任`HttpStatus`。

# 使用 JSON

到目前为止，我们的 API 一直使用`JSON,`从返回`JSON`对象作为结果，到在请求体中接受 JSON 对象。但是我们需要理解这是如何工作的，以及我们如何创建和使用更复杂的 JSON 对象。在这一节中，我们将回顾 Spring 提供的处理 JSON 请求和响应的不同机制。

# 理解序列化

在我们的例子中，我们已经创建了`Customer`类，并且我们已经看到，在我们的控制器中返回该类的一个对象，无论是直接还是通过一个响应实体，它都会被转换成 JSON。这种机制被称为序列化，将一个对象转换成一个表示，在我们的例子中，是一个 JSON 对象。

Spring 用于归档这个`Jackson`，这是一个众所周知的处理 Java 中 JSON 对象的库。你可以在他们的网站上找到更多关于那个图书馆的信息:[https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)。

当我们输出一个 Java 对象时，Spring 将在内部使用一个由 Jackson 提供的类`ObjectMapper`来创建 JSON 表示。这个对象映射器将检查提供的对象，并使用 Java 反射 API，发现任何公共属性并创建表示。

# 使用简单的对象

例如，让我们创建一个名为`SimpleObject`的简单类，其结构如下:

```java
package com.microservices.chapter3

class SimpleObject {
  public val name = "hello"
  private val place = "world"
}
```

现在，让我们创建一个新的控制器来测试这个，我们将它命名为`JsonExamplesController`；它将是一个具有一个`GetMapping`的 RestController:

```java
package com.microservices.chapter3

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class JsonExamplesController {
  @GetMapping(value = "/json")
  fun getJson() = SimpleObject()
}
```

然后，如果我们执行微服务并向这个 URL `http://localhost:8080/json`发出请求，我们应该得到:

```java
{"name":"hello"}
```

我们可以看到值位还没有在`JSON`中被创建，但是如果我们修改我们的类如下:

```java
package com.microservices.chapter3

class SimpleObject {
  public val name = "hello"
  private val place = "world"
 public fun getPlace() = place }
```

然后，如果我们再次请求 URL `http://localhost:8080/json`，我们应该得到:

```java
{"name":"hello","place":"world"}
```

现在发生的是，`ObjectMapper`正在寻找一个公共方法名`getPlace`，任何名为 get 的公共方法，然后一个大写字母将作为一个属性序列化到 JSON 对象中，该属性的名称在 get 之后。因此，`getPlace`会将该函数的值序列化为一个名为`place`的属性。

事实上，如果我们像这样修改这个类:

```java
class SimpleObject {
  public val name = "hello"
  private val zone = "world"
  public fun getPlace() = zone
}
```

我们将得到完全相同的结果，因为`ObjectMapper`正在序列化方法，而不是属性。但是我们可以使用 Kotlin `data classes`更简单地归档相同的结果:

```java
data class SimpleObject(var name: String = "hello", var place: String = "world")
```

Kotlin 编译成 JVM 类的`data class`将生成比`ObjectMapper`更好的方法，所以我们将像前面的例子一样被序列化。但是更多的特性，比如为对象提供一个构造函数，如果我们修改我们的控制器，我们会从中受益:

```java
package com.microservices.chapter3

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class JsonExamplesController {
  @GetMapping(value = "/json")
 fun getJson() = SimpleObject("hi", "kotlin")
}
```

然后，如果我们再次请求 URL `http://localhost:8080/json`，我们应该得到:

```java
{"name":"hi","place":"kotlin"}
```

# 处理复杂对象

序列化也适用于复杂对象。例如，我们可以创建一个名为`ComplexObject`的新类:

```java
package com.microservices.chapter3

data class ComplexObject(var object1 : SimpleObject? = null)
```

然后，修改我们的控制器来使用它:

```java
package com.microservices.chapter3

import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class JsonExamplesController {
  @GetMapping(value = "/json")
  fun getJson() = ComplexObject(object1 = SimpleObject("more", "complex"))
}
```

然后，如果我们再次请求 URL `http://localhost:8080/json`，我们应该得到:

```java
{"object1":{"name":"more","place":"complex"}}
```

由于我们的`ComplexObject`是一个数据类，它将有一个`getObject`方法。当我们反序列化时，`ObjectMapper`也会将值或对象反序列化为名为`object1`的属性。

我们可以根据需要创建任意多的级别，如果需要的话还可以使用嵌套类。

# 为我们的客户添加电话

现在我们对序列化有了更多的了解，我们可以修改 customer 类来创建一个内部类。

您可以删除之前创建的`SimpleObject`和`JSonExamplesController`，因为我们将使用我们的 API 服务来进一步解释这些概念:

```java
package com.microservices.chapter3

data class Customer(var id: Int = 0, var name: String = "", var telephone: Telephone) {
  data class Telephone(var countryCode: String = "", var telephoneNumber: String = "")
}
```

如果我们现在运行我们的代码，我们会得到一个编译错误。我们有一批没有电话的客户，让我们给他们增加一些:

```java
package com.microservices.chapter3

import com.microservices.chapter3.Customer.Telephone
import org.springframework.stereotype.Component
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin", Telephone("+44", "7123456789")),
        Customer(2, "Spring", Telephone("+44", "7123456789")),
        Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }
.............
}
```

在这次修改中，当我们调用构造函数时，我们可以写`Customer.Telephone`，因为我们需要引用`Customer`中的内部类，但是如果我们在类的开头做静态导入的话，我们可以只写`Telephone`:`import com.microservices.chapter3.Customer.Telephone`

如果我们向 get customer URL `http://localhost:8080/customers`发出请求，我们现在应该得到:

```java
[
    {
        "id": 1,
        "name": "Kotlin",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    },
    {
        "id": 2,
        "name": "Spring",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    },
    {
        "id": 3,
        "name": "Microservice",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    }
]
```

我们的客户列表得到正确序列化，我们看到每个客户的电话号码。

# 处理空值

我们已经学会了如何处理复杂的对象，但是当事情是可选的时，我们如何处理它们呢？让我们考虑在前面的例子中，我们可以设置客户的电话是我们可能有的，但是是可选的。

首先，我们需要修改我们的`Customer`类，使电话可空:

```java
package com.microservices.chapter3

data class Customer(var id: Int = 0, var name: String = "", var telephone: Telephone? = null) {
  data class Telephone(var countryCode: String = "", var telephoneNumber: String = "")
}
```

我们已经将电话的默认值设置为`null`，所以让我们修改我们的服务:

```java
package com.microservices.chapter3

import com.microservices.chapter3.Customer.Telephone
import org.springframework.stereotype.Component
import java.util.concurrent.ConcurrentHashMap

@Component
class CustomerServiceImpl : CustomerService {
  companion object {
    val initialCustomers = arrayOf(Customer(1, "Kotlin"),
 Customer(2, "Spring"),
 Customer(3, "Microservice", Telephone("+44", "7123456789")))
  }
...............
}
```

现在，如果我们向我们的 get customer URL `http://localhost:8080/customers`发送另一个请求，我们应该得到:

```java
[
    {
        "id": 1,
        "name": "Kotlin",
        "telephone": null
    },
    {
        "id": 2,
        "name": "Spring",
        "telephone": null
    },
    {
        "id": 3,
        "name": "Microservice",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    }
]
```

现在，我们得到用空值序列化的对象，但它可能不是我们要找的；我们不想序列化可选字段。

我们可以在数据类中使用`Jackson`注释来实现这一点:

```java
package com.microservices.chapter3

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.annotation.JsonInclude.Include

@JsonInclude(Include.NON_NULL)
data class Customer(var id: Int = 0, var name: String = "", var telephone: Telephone? = null) {
  data class Telephone(var countryCode: String = "", var telephoneNumber: String = "")
}
```

通过对我们的 get customer URL `http://localhost:8080/customers`的最后一个请求，我们现在应该得到:

```java
[
    {
        "id": 1,
        "name": "Kotlin",
    },
    {
        "id": 2,
        "name": "Spring",
    },
    {
        "id": 3,
        "name": "Microservice",
        "telephone": {
            "countryCode": "+44",
            "telephoneNumber": "7123456789"
        }
    }
]
```

`@JsonInclude`注释在我们的类中表明我们将只序列化非空值，并且我们可以在任何我们需要的数据类中包含，然而，我们可以全局配置 Spring 以不序列化空对象，在我们的 Spring 配置中设置这个值，因此编辑我们的`application.yaml`:

```java
spring.jackson.default-property-inclusion: NON_NULL
```

有了这个值，我们不再需要在数据类对象中设置注释。

在我们的[第 2 章](02.html#29DRA0-005ba5e9819e4f499f11aaac5b7181c1)*《Spring Boot 2.0 入门》中，我们将更详细地回顾 Spring 配置工作。*你可以看看它，了解我们改变 Spring 配置的不同方式。

# 理解反序列化

当我们向我们的 API 发送请求时，我们可以发送一个`JSON`对象，如果我们已经将我们的`@RequestMapper`或变量设置为具有主体，我们可以将其转换为对象。这被称为反序列化。Spring 也使用 Jackson 将`JSON`对象反序列化为 JVM 类，并使用`ObjectMapper`类进行序列化。

让我们理解这是如何工作的。

# 从请求到对象

当我们定义我们的`POST`方法来创建客户时，我们以如下方式定义它:

```java
@PostMapping(value = "/customer/")
fun createCustomer(@RequestBody customer: Customer): ResponseEntity<Unit?> {
  customerService.createCustomer(customer)
  return ResponseEntity(null, HttpStatus.CREATED)
}
```

然后，当一个请求被发送时，例如这个`cURL`请求:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 4,
 "name": "New Customer"
}'
```

Spring 将获得请求的主体，并使用`ObjectMapper`来构造指定类的 JVM 对象。使用反射的对象映射器将为 JSON 对象中的每个属性找到所有公共属性或 setter 方法，并更改它们或调用它们。

例如，对于我们的`Customer`类，它会找到一个`setId`函数，并将对象中属性`id`的值传递给它。这是因为数据类将为每个属性生成 setters。

# 反序列化复杂对象

这是它在发送复杂对象时的工作方式，例如，使用以下请求:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d ' {
 "id": 4,
 "name": "New Customer",
 "telephone": {
 "countryCode": "+44",
 "telephoneNumber": "7123456789"
 }
 }'
```

当`ObjectMapper`探索我们要求从`JSON`反序列化为 java 对象的类时，它也会探索它使用的任何其他类。JSON 在分析`Customer`类并找到属性 phone 时，将获得`Telephone`类并探索该类的 getters 和 setters。

因此，当读取 JSON 并找到属性 telephone 时，它将使用`Telephone`类创建所需的对象，然后使用`Customer`类提供的 setter 赋值。

在某种程度上，我们可以用这样的伪代码来定义这个过程，它读取 JSON:

```java
Reading class Customer
Create a Customer Object
Attribute "id" found in JSON
searching for a setter for id
calling Customer::setId with the value 4
Attribute "name" found in JSON
searching for a setter for name
calling Customer::setName with the value "New Customer"
Attribute "telephone" found in JSON
searching for a setter for telephone
Reading class Telephone
Creating a Telephone Object
Attribute "countryCode" found in JSON
searching for a setter for countryCode
calling Telephone::setCountryCode with the value "+44"
Attribute "telephoneNumber" found in JSON
searching for a setter for telephoneNumber
calling Telephone::telephoneNumber with the value "7123456789"
calling Customer::setTelephone with the object telephone created
end
```

这个伪代码可能不完全正确，`Jackson`的实现可能会因此而有所不同，但从概念上讲，应该是类似的。

# 验证对象

当我们发送一个 JSON 对象时，只处理可以设置的属性值；如果 JSON 对象有额外的数据，它将被忽略。如果不指定更多，即使我们不发送请求中实际需要的值，对象也会以某种方式被反序列化。

例如，让我们将这个请求发送给我们的 API:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 4,
 "customerName": "New Customer"
}'
```

我们将在 API 中得到一个 400 错误请求错误。如果我们发送一个无法处理的 JSON，也不会创建一个对象，也会发生这种情况。例如，对于此请求，缺少一个括号:

```java
curl -X POST \
 http://localhost:8080/customer/ \
 -H 'content-type: application/json' \
 -d '{
 "id": 4,
 "name": "New Customer"
}'
```

Spring 会自动生成另一个 400 BAD 请求响应。

如果两种情况都出现，我们也会得到一些`JSON`响应，比如:

```java
{
 "timestamp": 1505233267030,
 "status": 400,
 "error": "Bad Request",
 "message": "JSON parse error: Unexpected end-of-input within/between Object entries; nested exception is com.fasterxml.jackson.core.JsonParseException: Unexpected end-of-input within/between Object entries\n at [Source: (PushbackInputStream); line: 8, column: 169]",
 "path": "/customer/"
}
```

我们将在本章的最后一节学习如何处理这些错误，并定制它们的消息。

# 处理错误

任何软件都需要处理错误，这些错误要么是由定义的业务规则触发的，要么只是为了处理可能出现的特殊情况。在 RESTful APIs 中，当错误发生时，我们使用状态代码来告诉我们的消费者，但是在我们的代码中，我们需要处理那些场景，并确保它们被优雅地处理。在本节中，我们将回顾一些可以用来处理这些情况的技术。

# 使用控制器建议

在我们的上一个例子中，当我们的 JSON 格式不正确时，我们得到了一个异常。那个异常是`JsonParseException`，没有在我们代码的任何部分被处理，所以 Spring 自动为我们处理它并返回一个错误消息。

但是我们可能希望自己处理异常，这样我们就可以定制错误，并返回消息体。为此，Spring 提供了一种机制，使用`ControllerAdvice`和`ExceptionHandler`注释来处理我们的应用代码中没有捕捉到的任何异常。

首先，让我们创建一个新的 Kotlin 类，并将其命名为`ErrorHandler`:

```java
package com.microservices.chapter3

import com.fasterxml.jackson.core.JsonParseException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import javax.servlet.http.HttpServletRequest

@ControllerAdvice
class ErrorHandler {
  @ExceptionHandler(JsonParseException::class)
  fun JsonParseExceptionHandler(servletRequest: HttpServletRequest,
                                exception: Exception): ResponseEntity<String> {
    return ResponseEntity("JSON Error", HttpStatus.BAD_REQUEST)
  }
}
```

这个类用`@ControllerAdvice`进行了注释，并将通过上下文扫描添加到 Spring 上下文中。然后，它声明了一个用`@ExceptionHandler`注释标注的方法，该方法还指示了我们将处理什么类型的异常，引用异常的类。当抛出`JsonParseException`并且没有处理它的 catch 子句时，Spring 将搜索该类可用的任何异常处理程序，并将错误发送给它。

如果我们将错误的`JSON`请求发送到 URL `http://localhost:8080/customer/`:

```java
{
    "id": 8,
    "customerName": "New Customer",
    "telephone": {
        "countryCode": "+44",
        "telephoneNumber": "7123456789"
    }
```

我们将收到一个 400 错误请求，响应正文中有一个错误:

```java
JSON Error
```

然而，我们要创建一个 RESTful API，所以我们需要使用 JSON 来回答。因此，让我们创建一个新的简单数据类来保存我们的错误响应:

```java
package com.microservices.chapter3

data class ErrorResponse(val error: String, val message: String)
```

现在，我们可以修改我们的错误处理程序来使用这个新类:

```java
package com.microservices.chapter3

import com.fasterxml.jackson.core.JsonParseException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import javax.servlet.http.HttpServletRequest

@ControllerAdvice
class ErrorHandler {
  @ExceptionHandler(JsonParseException::class)
  fun JsonParseExceptionHandler(servletRequest: HttpServletRequest,
                                exception: Exception): ResponseEntity<ErrorResponse> {
    return ResponseEntity(ErrorResponse("JSON Error", exception.message ?: "invalid json"),
        HttpStatus.BAD_REQUEST)
  }
}
```

如果我们重复我们的错误请求，我们现在将得到同样的 400 个错误请求，但是有一个`JSON`结果:

```java
{
 "error": "JSON Error",
 "message": "JSON parse error: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (PushbackInputStream); line: 1, column: 5]); nested exception is com.fasterxml.jackson.core.io.JsonEOFException: Unexpected end-of-input: expected close marker for Object (start marker at [Source: (PushbackInputStream); line: 1, column: 5])\n at [Source: (PushbackInputStream); line: 8, column: 175]"
}
```

此外，我们可以在控制器建议中记录异常，这样我们就可以跟踪可能要处理的问题。

在我们的错误处理程序中，我们刚刚得到了`JsonParseException`，但是如果我们得到任何其他错误，例如，一些非常关键的错误，我们将没有定制的消息。为此，在我们的控制器建议中为`Throwable`类留下一个通用句柄，至少根据我们的 API 定义提供一条消息，这可能是一个好主意。

# 创建业务例外

我们知道如何处理一般的异常，但是如果我们需要响应我们的业务逻辑，我们该如何处理它们呢？

让我们假设我们正在请求一个不存在的客户；到目前为止，如果要求一个不存在的客户，我们的`UserService`将返回一个`null`客户。然后，我们只是输出一个 404 未找到状态代码，因为它是我们的客户，我们不会发送一个机构。但是让我们使用一个定制的业务异常来处理这个问题。

首先，我们将创建一个名为`CustomerNotFoundException`的新类，它将继承自`Exception`:

```java
package com.microservices.chapter3

class CustomerNotFoundException(message: String) : Exception(message)
```

然后，我们可以修改我们的`CustomerController`代码来抛出这个异常:

```java
package com.microservices.chapter3

import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestControllerclass CustomerController {
.....
  @GetMapping(value = "/customer/{id}")
  fun getCustomer(@PathVariable id: Int): ResponseEntity<Customer> {
    val customer = customerService.getCustomer(id) ?:
 throw CustomerNotFoundException("customer '$id' not found")
 return ResponseEntity(customer, HttpStatus.OK)
  }
.....
}
```

然后，我们可以将它添加到我们的`ErrorHandler`类中:

```java
@ExceptionHandler(CustomerNotFoundException::class)
fun CustomerNotFoundExceptionHandler(servletRequest: HttpServletRequest,
                                     exception: Exception) : ResponseEntity<ErrorResponse>{
  return ResponseEntity(ErrorResponse("Customer Not Found", exception.message!! ),
      HttpStatus.NOT_FOUND)
}
```

如果我们现在调用 URL `http://localhost:8080/customer/11`，我们应该得到 404 NOT FOUND 响应:

```java
{
    "error": "Customer Not Found",
    "message": "customer '11' not found"
}
```

# 避免控制器建议

控制器建议是一个很好的工具，但是有时候，我们可能会把它当作一个`GO-TO`指令的等价物来使用。我们失去了对心流的控制，让一些事情发生在我们的主要逻辑之外。

控制器建议应该只用于处理非常情况，当我们需要回答错误时，我们可以通过添加我们的业务逻辑来避免它。

例如，我们可以像这样简单地修改我们的控制器方法:

```java
@GetMapping(value = "/customer/{id}")
fun getCustomer(@PathVariable id: Int): ResponseEntity<Any> {
  val customer = customerService.getCustomer(id)
 return if (customer != null)
 ResponseEntity(customer, HttpStatus.OK)
 else
    ResponseEntity(ErrorResponse("Customer Not Found", "customer '$id' not found"), HttpStatus.NOT_FOUND)
}
```

这将输出完全相同的结果，但我们需要避免创建异常，控制器建议，与我们的控制器一起获取错误的逻辑。

当我们分析生产应用中的故障时，最令人困惑的一次是在应用日志中遇到大量的异常，但实际上发现这些并不是真正的异常错误，它们只是业务逻辑错误。避免创建不必要的异常将有助于发现应用中的真正问题。

# 摘要

现在，我们可以使用 Spring 框架有效地编写 RESTful APIs。我们学习了如何使用 JSON 创建复杂的对象，以及如何在 API 中创建请求和响应时处理它们。我们知道如何使用 HTTP 动词和状态来定义 API 的通用语言，以便向 API 消费者提供清晰的通信。最后，我们学习了如何处理错误并向 RESTful 微服务的用户反馈。

当你构建你的 API 时，记住我们的微服务原则，域驱动设计是按照你的域映射分离你的 API 服务的完美方式。但是这些 API 遵循大多数微服务的标准方法，使用传统的阻塞操作。在下一章中，我们将学习如何使用非阻塞技术来产生更多的响应和可伸缩的微服务，并且我们将学习新的 Spring 组件 WebFlux 和 Reactor 框架如何允许我们轻松地创建反应式微服务。