# 五、数据建模——设计应用的基础

数据模型是应用的基础。一开始就把它们做好比以后改变基础要容易得多，因为在设计阶段，你需要做的所有改变都可以用纸和铅笔来完成。另一方面，在应用的实现过程中对数据模型进行更改通常涉及到修改应用每一层的所有代码，正如我们之前提到的，更改是不可避免的，构建良好的数据模型可以帮助您更轻松地进行这些更改。

在本章中，我们将设计 TaskAgile 应用的数据模型，您将了解以下内容:

*   数据建模的基础
*   进行数据建模的目标
*   用 ER 图进行概念数据建模
*   逻辑数据建模
*   RDBMS 的物理数据建模
*   MongoDB 的物理数据建模

# 数据建模简介

在创建像 TaskAgile 这样的应用时，数据建模是必不可少的一步。通过数据建模，我们发现基于应用需求的数据需求，然后分析和确定这些数据需求的范围，并将它们转换为定义如何存储、检索和更新应用数据的数据模型。此外，应用的其余部分将建立在这些数据模型之上。

在本节中，我们将讨论数据建模的基础知识，包括阶段和每个阶段的可交付成果，以及数据建模中使用的术语。之后，我们将开始 TaskAgile 应用的数据建模。

# 数据建模阶段和可交付成果

数据建模通常包括三个阶段:

*   概念数据建模
*   逻辑数据建模
*   物理数据建模

在接下来的几节中，我们将详细了解每个阶段。

# 概念数据建模

概念数据建模是我们通过检查应用的需求来发现数据需求的阶段。我们使用 **E** **实体关系** ( **ER** )图将这些数据需求记录为概念数据模型，这是记录数据模型的非正式标准。

让我们看一个例子。基于在[第 4 章](04.html)、 *TaskAgile -一个类似 Trello 的任务管理工具*中创建的注册用户故事和在 TaskAgile 应用中登录用户故事，在*用户*部分，我们可以发现我们需要在注册时存储用户的数据，并且在登录时提供基于用户名或电子邮件地址查询每个用户数据的能力。

让我们使用在[第 4 章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的创建团队用户故事，作为另一个例子，在*团队*部分。作为注册用户，我想创建团队，这样我就可以组织不同团队的任务。我们会发现，我们将需要存储团队，以及用户和团队之间的关系，即谁创建了哪些团队，仔细观察，您会发现，我们还需要存储任务的数据，可能还需要存储任务和团队之间的关系。这个数据需求没有进一步的细节，但是一旦我们完成对所有其他用户故事的分析，我们会对它有更好的理解。

# 逻辑数据建模

一旦我们有了概念数据模型，我们就进入下一个阶段，即逻辑数据建模。在这一阶段，我们对数据需求做进一步的分析和范围界定。我们将通过提问或与业务专家讨论来构建数据模型的细节。例如，您可能对用户和团队之间的关系有如下疑问:

*   一个用户可以创建多少个团队？
*   用户必须创建团队吗？
*   除了创建团队，用户还可以加入其他用户创建的团队吗？
*   如果有，一个用户可以加入多少个团队？
*   用户可以创建一个名称已经被另一个团队使用的团队吗？
*   我们如何通过名字来识别一个团队？

有了这些问题的答案，我们开始对数据需求和逻辑有了更深的理解，这些在概念数据建模过程中还没有揭示出来。

并且，在逻辑数据建模期间，我们将需要进行规范化，通常是反规范化。规范化是在数据插入、更新和删除过程中消除数据冗余和异常并确保数据依赖关系有意义的过程。反规范化与规范化相反，主要用于提高性能。稍后我们还会看到一个这样的例子。

在概念数据建模阶段和逻辑数据建模阶段，我们通常会使用子类型和超类型进行归纳，以调整数据模型。稍后我们将看到一个这样的例子。

# 物理数据建模

一旦我们有了逻辑数据模型，我们就可以创建物理数据模型了。在这个阶段，您将逻辑数据模型转换为针对特定的 RDBMS 的数据库设计，比如 MySQL 或 PostgreSQL，或者 NoSQL 数据库，比如 MongoDB。物理数据建模过程中的一个重要考虑因素是性能。大多数数据库系统都支持索引、集群、分区和数据压缩等工具，以便在不影响逻辑数据模型设计的情况下提高归档性能。我们还将在本书中讨论索引。但是我们不会讨论聚类、划分或数据压缩。它们超出了本书的范围。

这个阶段的输出是物理数据模型，由于我们使用 MySQL (5.7.21)作为我们的数据库，我们将使用 MySQL work bench([https://www.mysql.com/products/workbench](https://www.mysql.com/products/workbench))进行物理数据建模。MySQL Workbench 支持的一个很好的特性是能够将物理数据模型导出为 SQL，我们可以用它来设置数据库。

下面是一个活动图，显示了不同的数据建模阶段和每个阶段的可交付成果。圆角矩形表示动作，如创建**概念数据模型**，而方形矩形表示动作之间的对象流，如**应用需求**节点是创建**概念数据模型**的输入:

![](img/f3837952-b4b5-4e93-9383-6546c85be5f0.png)

图 5.1 数据建模阶段和可交付成果

# 数据建模中使用的术语

现在，让我们介绍一下我们将在数据建模中使用的术语。

# 实体

在数据建模中，我们使用术语**实体**来表示我们想要存储在数据库中的东西，这些东西或者以物理方式存在，或者以逻辑方式存在，并且可以被唯一地标识。实体是你正在建模的事物、领域的复杂性的抽象。通常，它们只包含您正在开发的应用感兴趣的那些特征。例如，在 TaskAgile 应用中，用户实体代表其数据需要存储在数据库中的应用用户。在物理数据建模过程中，如果您的目标是 RDBMS，比如 MySQL，这些用户实体将存储在一个表中，每个用户实体将是该表的一条记录。或者，如果您的目标是 NoSQL 数据库，比如 MongoDB，它们将存储在一个集合中，每个用户实体将作为一个文档存储在该集合中。

# 属性

我们使用术语**属性**来表示一个实体的特征。例如，名字、姓氏和电子邮件地址是用户实体的属性。对于 RDBMS，属性将被转换成表的列，或者对于 NoSQL，比如 MongoDB，属性将被转换成文档的字段。在一个实体的属性中，至少需要有一个属性可以用来唯一地标识该实体。以用户实体为例；用户的电子邮件地址可用于识别该用户。通常，可以有几个这样的属性。

# 关系

我们使用术语**关系**来表示两个实体之间的关系。通常，一种关系有一个名称，例如，创作者和团队之间的关系是一种**创作**关系。而且，关系通常与基数一起被提及，例如，创建关系是一个**一对多**关系。也就是说，一个团队创建者可以创建零个或多个团队，一个团队可以由一个团队创建者创建。其他基数包括一对一和多对多。

# 主键

当我们设计实体时，我们选择一个属性或多个属性的组合来唯一地标识一个实体，作为该类型实体的**主键**。

从本质上讲，主键是唯一的。例如，由于两个用户不能有相同的电子邮件地址，我们可以使用它作为用户实体的主键。然而，这在允许用户更改电子邮件地址的应用中不起作用。用作主键的属性或属性组合必须稳定。也就是说，主键的值在该实体的整个生命周期中不得更改，原因与使用属性 username 作为用户实体的主键不是一个好主意相同。尽管电子邮件地址和用户名属性不能用作主键，但它们仍然可以用来标识用户，例如，您仍然可以使用用户的电子邮件地址或用户名来查找该用户。我们称这些类型的属性为候选键。

实际上，通常使用系统生成的唯一值作为某类实体的主键。例如，我们可以让 MySQL 为表的`id`列生成整数值，并将该列用作主键。使用 MongoDB，数据库将为每个文档的`_id`属性自动生成一个惟一的值，该值可以用作主键。或者，我们可以在应用中生成一个**通用唯一标识符** ( **UUID** )，比如`e7f71282-37c6-41fe-a413-8fc0d4d32eed`，并将其作为主键的值。所有这些系统生成的主键都称为代理键。

# 外键

**外键**是在不同类型的实体之间建立关系的方式。例如，在团队创建者和团队之间的一对多关系中，团队实体将有一个属性创建者 ID，它保存团队创建者的主键的值。我们将在构建逻辑数据模型时详细讨论这一点。

# 数据建模的目标

正如我们在本章开始时提到的，数据建模是创建应用的重要步骤。这是你不想跳过的一步。即使在您不想创建任何其他文档的项目中，数据模型仍然是值得您投入时间和精力的。

那么，我们想通过数据建模归档什么呢？在开始 TaskAgile 应用的数据建模之前，我们先来讨论一下这个问题。

# 完全

数据建模的第一个目标是在覆盖应用的需求时达到完整性。然而，这并不意味着当我们开始数据建模时，我们需要预先满足应用的所有需求，数据建模更多地采用瀑布方式。我们设计的数据模型应该能够支持当前可用的需求中指定的特性的实现。

而且，这还意味着在数据建模期间，我们应该包括那些需要应用到数据库级别的业务规则，以便我们可以对存储的数据有信心。

# 最小冗余

数据建模的第二个目标是在我们的数据库中实现**最小冗余**。当我们多次存储相同的数据或者存储一段可以从其他数据派生的数据时，我们给数据库带来了冗余。很多时候，冗余是不好的。存储冗余数据所需的额外空间并不是我们消除冗余的主要原因。正是额外的努力和数据中潜在的不一致性要求我们努力在数据模型中实现最小的冗余。

例如，对于我们的用户实体，我们将有一个名字属性和一个姓氏属性。而且，如果我们添加另一个属性，比如首字母，它可以根据名字和姓氏来计算，我们会引入冗余数据，每次我们更改名字时，我们也必须更新首字母，如果我们忘记这样做，我们的数据库就会出现不一致。并且在我们设计数据模型时应该避免它。

另一方面，有时我们需要添加冗余数据，主要是为了提高性能。然而，在概念数据建模期间，我们应该首先去除冗余，然后，显式地只添加那些在逻辑数据建模期间可以提高性能的数据。

# 展开性

我们希望在数据建模过程中实现的另一个目标是可扩展性。也就是说，我们构建的数据模型应该能够在对现有数据结构影响最小的情况下进行扩展以适应新的需求，并且进行这些更改所需的工作量应该很小。可扩展并不意味着数据模型应该能够适应各种变化，这是不可能的，并且通常会导致模型过度设计。我们应该实现的可扩展性是基于对应用需求的深刻理解，并且通过与业务专家的讨论来预见不久的将来可能的需求。例如，在 TaskAgile 应用中，我们不需要在团队之上创建组织，也不需要提供邀请人们加入团队的能力(在当前的用户案例中，我们只允许向董事会添加人员)。这些是我们可能需要在下一版本中实现的特性的例子。而且，当我们设计数据模型时，我们肯定需要记住这些，并确保我们的数据模型具有可扩展性。

# 一致性

我们在这里谈论的一致性主要是关于我们的数据模型的实体和属性的命名的一致性，以及我们用来讨论和交流应用层需求的语言的一致性。例如，如果业务专家使用 team creator 来指代创建团队的用户，那么在数据模型中，我们也应该使用 team creator，而不是其他术语，例如团队所有者。我们应该有一个命名约定来加强一致性。稍后我们将讨论数据建模的命名约定。

# 用 ER 图进行概念数据建模

现在，让我们开始 TaskAgile 应用的概念数据建模。首先，让我们回顾一下我们将用来创建 er 图的符号。

# 鱼尾纹符号

我们在本书中使用的符号是乌鸦脚符号。我们用矩形来代表实体。例如，下面代表**用户**实体和**团队**实体:

![](img/485242cb-2514-47c5-96f0-1c7e08841852.png)

图 5.2:实体

并且，我们用一条线连接矩形来表示一种关系。例如，*图 5.3* 表示**用户**实体和**团队**实体之间的关系:

![](img/1f9f9b29-247b-4636-9f78-db75761388a5.png)

图 5.3:用户和团队之间的关系

在这个关系中，左边有双垂直线的符号表示*一个且只有一个*，右边类似于鱼尾纹的符号表示*零个或多个*。从左到右是这样写的— *每个用户可以创建零个或多个团队*。并且，从右向左阅读时是这样的— *每个团队必须由一个且只有一个用户*创建。

以下是鱼尾纹符号中的关系符号:

![](img/5e7b42f2-fe44-4663-992c-04e768c160ce.png)

图 5.4:鱼尾纹符号中的关系符号

用来创建 ER 图的工具是 draw . io([https://www . draw . io](https://www.draw.io))。这是一个伟大的工具，它是免费的，有在线版本和桌面版本。此外，除了 er 图之外，您还可以使用它来创建许多其他类型的图。

# 命名约定

为了实现数据模型的一致性，我们需要为 er 图建立一个命名约定。以下是本书使用的。你可以选择一个你认为合适的。这里的目标是保持一致:

*   实体名称必须是单数且非集合名称。例如，**用户**和**团队**但不是用户、团队，也不是用户表。一个例外是**卡片列表**，实际上是需求中的名称。
*   实体名称必须是大写字母。比如**董事会成员**而不是董事会成员，也不是董事会成员。
*   关系名必须是不定式。例如，**创建**而不是创建，**被**创建而不是被创建。
*   属性名必须是大写字母。

# TaskAgile 概念数据模型

我们通过浏览用户故事并找到实体和实体之间的关系来开始概念数据建模。我们将把属性留给逻辑数据建模阶段，这样我们就可以专注于数据需求的高层视图，避免被细节所困扰。现在，让我们开始浏览用户故事。

如前所述，用户实体和团队实体是一对多的关系，这涵盖了用户故事中的用户和团队主题。

并且，基于用户故事，创建个人板，即在[第四章](04.html)、 *TaskAgile -一个类似 Trello 的任务管理工具*中创建的，我们可以看到会有**板**实体，并且**用户**实体和**板**实体之间的关系也是一对多的关系，如图*图 5.5* 所示:

![](img/2f4da129-a0c1-43ec-a2a4-8ce0321035d8.png)

图 5.5:用户和董事会之间的关系

并且，基于用户故事，创建团队板，这是在[第四章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的，我们可以发现在**板**实体和**团队**实体之间有一个关系，这是一个一对多的关系，如图*图 5.6* 所示:

![](img/13f559e6-33d5-440a-a83e-c622498bd4ee.png)

图 5.6:团队和董事会之间的关系

在*图 5.6* 中，关系是这样的——*一个团队可能包含零个或多个董事会，当一个董事会是个人董事会时，它可能属于零个团队，当它是团队董事会时，它可能属于一个团队*。等等，这种关系似乎隐藏了区分个人董事会和团队董事会的信息。我们最好通过创建**板**实体的两个子类型:**个人板**和**团队板**，在图中明确区分，如图*图 5.7* 所示:

![](img/19c21053-a4a8-4588-80e1-bdf546eada28.png)

图 5.7:用户和个人板，团队和团队板之间的关系

如你所见，我们将团队端的基数从零或一更新为一且只有一个，因为一个**团队板**必须属于一且只有一个**团队**。

这仍然不准确，因为根据这个图，**用户**实体和**团队板**实体之间的关系是*每个用户可以创建零个或多个团队板*。也就是说，任何注册用户都可以将板添加到任何团队中，即使这些团队不是由该用户创建的。这是不对的。正确的逻辑应该是，只有团队创建者才能向团队添加董事会。而且在创建团队板用户故事里也是错的，说*是注册用户。*应该是*作为团队创造者*。让我们将创建团队委员会用户的情况更正如下:

*   **Title** — **创建团队板**:作为团队创建者，我可以给我的团队添加一个板，这样我就可以组织那个团队的任务，我们也应该使用**团队创建者**作为**用户**的子类型。*图 5.8* 是使用**用户**和**板卡**子类型的修改图:

![](img/6b073b27-5cd7-417c-b2e5-ed95eb47718d.png)

图 5.8:用户和板的子类型

根据图表，一个**团队创建者**也可以创建零个或多个**个人板**，这是有意义的，因为一个**团队创建者**也是一个**用户**。还是真的有意义？我们稍后将回到这一点。现在，让我们继续。

基于用户故事，添加在[第四章](04.html)、 *TaskAgile -一个类似 Trello 的任务管理工具*中创建的董事会成员，我们可以看到**用户**和**董事会**之间还有一种关系，这是一种多对多的关系，如图*图 5.9* 所示。事实上，当一个用户创建了一个板，该用户应该成为该板的第一个成员。因此，一个**板**必须有一个或多个**用户**作为其成员:

![](img/e54bc503-7db0-4661-85ae-b7966014d982.png)

图 5.9:用户和董事会之间的另一种关系

基于用户故事，查看在[第四章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的板活动，我们可以看到有一种新类型的实体，**板活动**。**板**和**板活动**是一对多关系，**板成员**和**板活动**是一对多关系，如图*图 5.10* 所示:

![](img/ce1a55ab-bc92-479f-99f7-0d9e654c3400.png)

图 5.10:董事会成员和董事会活动、董事会和董事会活动

在**板**和**板活动**之间的关系中，**板活动**端的基数是一个或多个基数，因为当板被创建时，将有一个**板创建活动**生成。因此，每个**板**必须至少有一个**板活动**

基于在[第四章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的用户故事，创建卡片列表，我们可以发现**卡片列表**实体和**董事会成员**和**卡片列表**之间的关系是一对多的关系。并且**板**和**卡片列表**的关系也是一对多的关系，如图*图 5.11* 所示:

![](img/14184e97-41ba-4de1-b4d4-677762712b60.png)

图 5.11:卡片列表

这里，**董事会成员**是**用户**的子类型。我们使用**板成员**而不是**用户**，因为不是每个用户都可以在一个板中添加卡片列表。只有那些董事会成员才能做这件事。如果我们将**董事会成员**替换为**用户**，这个业务规则将会丢失。

卡片列表主题中的其他用户故事中没有新的实体或关系。让我们继续讨论卡片主题中的用户故事。

基于[第四章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的用户故事 Add card，我们可以找到一个新的实体 **Card** ，它与**董事会成员**的关系是一对多关系，它与**卡片列表**的关系也是一对多关系，如图*图 5.12* :

![](img/b0c6f67f-052b-436b-8ca6-3bd5269b0dc2.png)

图 5.12:卡片。

基于用户故事，分配成员到卡片，我们可以找到**董事会成员**和**卡片**之间的另一种关系，这是一种多对多的关系，如图*图 5.13* 所示:

![](img/2dcfecd0-1f1d-41ed-86d0-8e3002d7c0ca.png)

图 5.13:董事会成员和卡

基于用户故事，添加卡片附件，从 [第四章](04.html)，*Task agile——一个类似 Trello 的任务管理工具*，我们可以看到一个新的实体附件。**板卡成员**和**附件**之间是一对多的关系。**卡片**和**附件**是一对多的关系，如图*图 5.14* 所示:

![](img/5c0718c8-af97-44ed-92a8-235710e55f29.png)

图 5.14:板件和附件，以及卡和附件

基于用户故事，添加在第四章[中创建的卡片注释，*Task agile——一个类似 Trello 的任务管理工具*我们可以看到还有另一种类型的实体，**注释**。**董事会成员**和**评论**的关系是一对多的关系。并且**卡片**和**注释**的关系也是一对多关系，如图*图 5.15* 所示:](04.html)

![](img/04c64d73-5aa9-4f7f-bb6a-847d0a9bdca3.png)

图 5.15:董事会成员和评论，以及卡片和评论

基于在[第 4 章](04.html)、*Task agile——一个类似 Trello 的任务管理工具*中创建的用户故事，查看卡活动，我们可以找到一种新的实体类型，**卡活动**。并且**板成员**和**卡活动**的关系是一对多关系，**卡**和**卡活动**的关系也是一对多关系，如图*图 5.16* 所示:

![](img/dad6e4fe-9abd-4e61-8411-2cbd9129e92b.png)

图 5.16:董事会成员和卡活动，以及卡和卡活动

*图 5.17* 是我们发现的所有实体和关系的 ER 图:

![](img/4ed78d79-01c3-4f13-a81b-b94e425caf8b.png)

图 5.17:task agile 的概念数据模型

如果你仔细观察，你会发现**用户**实体和**董事会**实体之间的关系是一种成员关系。但是，我们也有**董事会成员**实体作为**用户**实体的子类型。如你所见，这里有些味道。当我们只在图表中有那些相关时，这将变得更加明显，如图*图 5.18* 所示:

![](img/b7835d23-a62e-4ac9-8d81-1c1322749979.png)

图 5.18:有气味的部分

让我们根据这个图来测试一下**板成员**和**板**之间的关系。既然我们让**董事会成员**成为**用户**的子类型，那么它应该继承其父类型的关系。所以关系从左到右是这样读的:*一个董事会成员可能是很多董事会的零个成员*。这不可能是正确的，因为一个**板成员**必须属于且仅属于一个**板**。这就是为什么它被称为**董事会成员**。要解决此问题，我们必须更改“作为成员”关系。但是，如果我们改变它，**用户**和**板**的关系将会是错误的。

所以，这部分有问题。如果不是关系，那一定是实体。而且，根据我们刚刚做的测试，**董事会成员**实体不会继承**用户**实体的成员关系。这意味着它们不是子类型和超类型，即使当你说**董事会成员**是**用户**的子类型时，这听起来是真的。实际上，当他们在应用中拥有**董事会成员**角色和**用户**角色时，情况确实如此。

# 子类型和超类型

在数据建模中，子类型及其超类型共享公共属性，超类型和其他实体之间的关系也可以应用于子类型。您可以使用这个规则来测试两种类型的实体，看它们是否是子类型和超类型。如果你用**个人棋盘**和**团队棋盘**试一下，你可以看到它们是**棋盘**的子类型。如果您用这个规则测试**团队创建者**，您可以看到它不是**用户**的子类型。*图 5.19* 显示了 TaskAgile 的修正数据模型:

![](img/6fd8e110-c438-4ea0-8645-7da88a160b2f.png)

图 5.19:修改后的 TaskAgile 概念数据模型

# 逻辑数据建模

现在，让我们创建 TaskAgile 的逻辑数据模型。在这个阶段，我们将通过按主题浏览用户故事和实现实体之间的关系，以及我们使用的子类型，向概念数据模型中的每种类型的实体添加属性。

基于用户主题和团队主题，我们创建了以下逻辑数据模型:

![](img/2f6f59b6-a623-4e9f-814c-3de5a24ec8c6.png)

图 5.20:用户和团队实体的逻辑数据模型

正如您在*图 5.20* 中所看到的，对于**用户**实体，我们使用代理关键字 **ID** 作为其主键，因为即使**电子邮件地址**和**用户名**可以用来标识用户，它们也可以被更改。系统生成的 **ID** 将始终保持不变。对于**团队**实体也是如此。并且**团队创建者**实体中的**用户 ID** 属性是一个外键。图中， **PK** 是**主键**的简称， **FK** 是**外键**的简称。并且，在**团队创建者**实体中，**团队 ID** 和**用户 ID** 属性形成一个组合键，可以用来唯一地标识一个**团队创建者**。

基于 Boards 主题中的用户故事，我们更新了逻辑数据模型，如图*图 5.21* 所示:

![](img/0d184e15-23d8-4ed7-a58e-741f0f133b8a.png)

图 5.21:带有电路板实体的逻辑数据模型

在概念数据模型中，我们有**个人板**和**团队板**作为**板**的子类型。在这里，我们只有**板**。在**板**实体中，我们添加了一个属性 **Type** ，用来区分**个人板**和**团队板**，以及一个外键**用户 ID** ，用来建立**用户**实体和**板**实体之间的创建关系。而外键，**团队 ID** ，是建立**团队**实体和**板**实体之间的一对多关系。

如您所见， **Board** 实体和**团队创建者**实体都有外键**团队 ID** 和外键**用户 ID** ，可以用来标识创建团队的用户。然而，基于这个逻辑数据模型，添加板的用户不一定必须是团队创建者。可能是任何人。如果您想要强制限制只有团队创建者可以在数据库级别添加板，您可以更改设计，如图*图 5.22* 所示:

![](img/990da8ce-61c1-416f-9273-657ccc2a41fd.png)

图 5.22:强制团队创建者约束

如你所见，我们将属性 **ID** 添加到**团队创建者**实体，并将外键**团队创建者** **ID** 添加到**板**实体。这将确保所有的板子都是由团队创建者**创建的。然而，当我们需要允许其他团队成员创建电路板时，这可能是返工的根源。*图 5.21* 中的设计提供了可扩展性，从这个角度来看，这是一个更好的设计。作为折衷，我们可以在应用的代码中实现约束。我们不应该在**板**实体中使用**团队创建者 ID** 的另一个原因是，将有一个额外的表连接来通过**用户 ID** 查询板。**

你可能已经注意到在*图 5.21* 中，对于个人的板卡，属性**团队 ID** 的值将为空，这是允许的。外键可以有空值。

下面的*图 5.23* 是带有**板**、**板成员**、**板活动**、**用户**实体的逻辑数据模型。为了简单起见，我们将**团队创建者**排除在图表之外:

![](img/996f8086-93df-4043-830f-b9e41c3074a4.png)

图 5.23:带有董事会、董事会成员、董事会活动和团队的逻辑数据模型

在**板卡成员**中，外键**板卡 ID** 和外键**用户 ID** 组成一个组合键，可以用来唯一标识一个板卡成员。我们在**板活动**实体中使用这个组合键。并且，在**板活动**实体和**用户**实体之间，是一对多的关系。这与它在概念数据模型中的情况不同，在概念数据模型中，**董事会活动**实体和**董事会成员**实体具有一对多关系。我们做出这一调整的原因是，我们不想给**板成员**添加主键 **ID** 并在**板活动**中使用该主键，因为**板活动**已经有了**板 ID** 属性和**用户 ID** 属性，这是一个可以用来标识板成员的组合键。

并且，在概念数据模型中，**董事会成员**与**卡片列表**、**卡片**、**评论**、**附件**和**卡片活动**有关系。出于同样的原因，我们将使用组合键`<Board ID and User ID>`来构建这些关系。

下面的*图 5.24* 是带有**卡片**、**卡片列表**以及其他相关实体的逻辑数据模型:

![](img/ac526189-5747-47c6-9ab9-f0e9360cb2d3.png)

图 5.24:带有卡片、卡片列表和相关实体的逻辑数据模型

在这个图中，你可以看到，我们使用了**卡片列表**、**卡片**、**附件**、**卡片活动**、**分配**和**注释**实体中的**板成员**。但这造成了数据冗余，主要是**板卡 ID** 。板 ID 是多余的，因为它可以从其他属性中导出。例如**卡**实体中的**板卡 ID** 可以通过**卡**实体中的**卡列表 ID** 从**卡列表**实体中派生出来。这种设计的另一个问题是，当我们将来需要实现一个功能时，例如，在板之间移动卡，我们将不得不更新所有这些实体中的所有**板 ID** ，这不仅会导致性能问题，还会导致数据不一致。未来解决这些问题的努力意义重大。

那么，让我们从**卡**、**附件**、**卡活动**、**赋值**、**注释**中去掉**板卡 ID** 。这将把用户 ID**留在这些实体中。并且**董事会成员**与这些实体之间的关系将转移到**用户**实体中。正因为如此，我们将需要加强约束，即只有董事会成员才能在应用代码中执行这些相关的操作。通过这一调整，我们的数据模型将没有冗余的**板 ID** ，并且还将是可扩展的。**

并且，如图 5.24 中的*所示，我们为需要支持删除后恢复的实体添加了**存档**属性。也就是说，当一张卡片被归档后， **Archived** 属性的值将为`true`，卡片将不会出现在 UI 中。董事会成员可以从该董事会的活动列表中恢复它。*

在我们移除 ID 为的**板之前，还有一件事。让我们再来看看板活动，**卡活动**，以及用户故事，查看板活动，如下所示:**

作为一名董事会成员，我可以查看该董事会中的所有活动，以便了解该董事会中发生了什么。

这种描述是模糊的。一切都包括什么？需要具体说明。这正是数据建模师需要与业务专家进行深入讨论的时候。

对于此版本的 TaskAgile，让我们添加对跟踪以下活动的支持:

| 

*   Create card
*   Add member to card
*   Create card list
*   Rename card list
*   Archive card list
*   Add card
*   Editorial card title
*   Member assigned to card

 | 

*   Move the card
*   Archive card
*   Delete card
*   Add card attachment
*   Delete card attachment
*   Add card comments
*   Editorial card annotation
*   Delete card comment

 |

而且，如果我们使用 Board Activity 来引用前面列表中的前两个活动，*创建 board* 和*向 board* 添加成员，我们还需要另一个新类型的实体，Card List Activity，来将这些活动引用到 Card List。这样，我们将有三种类型的实体:棋盘活动、卡片列表活动和卡片活动。

当我们需要从三个实体中提取数据来呈现一个列表，以便委员会成员可以查看该委员会中所有内容的活动时，这种分离会带来问题。例如，如果默认情况下董事会成员可以查看最近的 15 个活动，我们将需要从每个实体中提取 15 个活动，并将它们合并到一个单独的排序列表中，然后只返回最近的 15 个项目作为结果。这似乎还是可以控制的。但是，如何从 16 日到 30 日进行活动？实现的复杂性和性能问题是糟糕的数据模型设计的标志。

下图是修改后的逻辑数据模型:

![](img/b1995691-c417-4220-b7eb-7cb5e8b5e852.png)

图 5.25:带有卡片、卡片列表和相关实体的修改后的逻辑数据模型

如你所见，我们引入了 **Activity** 实体，它将存储我们列出的所有动作的活动，以及卡片注释。通过这种方式，我们可以用简单得多的查询在同一时间线中呈现卡片活动和卡片评论。**活动**实体的**类型**属性用于指示一条记录是活动日志，还是卡片备注。并且， **Card ID** 属性是一个外键，如果一个活动与一个卡无关，这个属性的值将为空。 **Detail** 属性将包含以 JSON 格式存储的详细数据。因为我们使用这些通用的**活动**实体来存储所有的活动以及卡片评论，所以我们不需要**评论**实体。

让我们把所有的实体放在一个图中，如图*图 5.26* 所示。并且，在这个版本中，我们将外键**用户 ID** 添加到**团队**实体中，并删除**团队创建者**实体。原因是因为**团队**实体和**团队创建者**实体是一一对应的关系，除了**用户** **ID** 之外没有其他附加属性。我们从这个变化中得到的一个好处是，我们可以避免通过**用户 ID** 将表连接到查询团队。

正如您所看到的，概念数据模型和逻辑数据模型之间有许多不同之处。我们在概念数据模型中的一些约束必须转移到应用的代码中，以便我们在设计中具有更好的可扩展性，并且通过更少的表连接来提高性能:

![](img/48d2767a-a598-448c-9eeb-0b2a33392aca.png)

图 5.26:完整的逻辑数据模型

到目前为止，我们已经采用自顶向下的方法完成了概念数据建模和逻辑数据建模，即首先建立高层概念数据模型，然后在此基础上建立逻辑数据模型。现在，让我们基于逻辑数据模型创建物理数据模型。

# RDBMS 的物理数据建模

在这个阶段，我们将把逻辑数据模型转换成目标 RDBMS 的物理数据模型。如前所述，我们将使用 MySQL，并将使用 MySQL Workbench 创建物理数据模型。

我们要做的是:

*   为每个实体创建一个表。
*   为每个属性创建一列。除了名称之外，我们还将定义列类型、长度、为空性和默认值。
*   使主键自动递增。
*   创建索引。

# 命名约定

物理数据模型的命名约定与逻辑数据模型的命名约定有一些不同:

*   我们将对表、列和索引使用小写，例如,`user`表。我们将使用下划线连接多个单词，例如,`card_list`表。
*   对于外键定义，键的名称以`fk_`开始。外键的命名约定是`fk_<referencing table name>_<referenced table name>_<referencing field name>`。例如，`activity`表中`user_id`字段的外键是`fk_activity_user_user_id`。
*   对于索引定义，索引名称将以`_idx`结尾，如果是唯一索引，则以`_uidx`结尾。

我们使用小写的原因是 MySQL 在 Linux/Unix 中区分大小写，在 Windows 中不区分大小写。将所有内容都写成小写可以避免混合使用不同大小写所导致的问题。

下图是 TaskAgile 应用的物理数据模型:

![](img/2a7f3bba-2067-4738-96f9-5ff15fa839a7.png)

图 5.27:task agile 应用的物理数据模型

用 MySQL Workbench 创建的图是一个**增强实体关系** ( **EER** )图。它用实线表示识别关系，用虚线表示非识别关系。

标识关系意味着如果没有父表，子表就不能被唯一标识。例如，在`board_member`表中，`board_id`列和`user_id`列是主键。而且，如果没有董事会 ID 或用户 ID，董事会成员记录就无法被唯一识别。换句话说，当外键是子表主键的一部分时，关系就是一种标识关系。

而且，通过 MySQL Workbench，我们可以将物理数据模型导出为 DDL 脚本，用于设置数据库。

您可以在本章的源代码中找到导出的数据库设置 SQL 文件`database-setup.sql`和 MySQL Workbench 数据模型文件`TaskAgilePhysicalDataModel.mwb`。

# MongoDB 的物理数据建模

存储在 MongoDB 中的数据具有非常灵活的模式。当我们为 MongoDB 进行物理数据建模时，我们没有定义模式的结构，而是编写验证器来强制执行数据模型中的字段规则。这样，我们可以确保集合中的每个文档都有我们在验证器中指定的那些必需字段，并且它们都是我们需要的数据类型。而且，作为 MongoDB 的命名约定，所有集合的名称都是复数，例如，用户实体将存储在集合 users 中。

我们来看一个例子；下面是一个用于创建`teams`集合的 MongoDB 脚本(用于 MongoDB 3.6 版和更高版本)。如您所见，该脚本的大部分内容是定义验证规则:

```java
db.createCollection( "teams",{
    "storageEngine": {"wiredTiger": {}},
    "capped": false,
    "validator": {
        "$jsonSchema": {
            "bsonType": "object",
            "additionalProperties": false,
            "properties": {
                "_id": {"bsonType": "objectId"},
                "name": {"bsonType": "string"},
                "user_id": {"bsonType": "objectId"},
                "archived": {"bsonType": "bool"},
                "created_date": {"bsonType": "timestamp"}
            },
            "required": [
                "_id",
                "name",
                "user_id",
                "archived",
                "created_date"
            ]
        }
    },
    "validationLevel": "strict",
    "validationAction": "error"
});
```

由于这本书的范围，我们不会通过这个脚本。您可以在本章的源代码中找到用于创建逻辑数据模型中定义的所有实体的所有 MongoDB 脚本。

# 摘要

在本章中，您已经学习了什么是数据建模，数据建模的三个阶段——概念数据建模、逻辑数据建模和物理数据建模，以及每个阶段的交付内容。

您还学习了执行数据建模的目标，以及如何使用 ER 图进行概念数据建模和逻辑数据建模。您还了解了如何使用 MySQL Workbench 为 MySQL 创建物理数据模型，并且看到了用于定义 scheme 规则的 MongoDB 脚本。

在下一章，我们将讨论应用的代码设计。