# 一、现代 Web 应用开发——这是一个新时代

现代 web 应用开发生态系统的多样性正以惊人的速度增长。几乎每天都可以看到新的框架和库出现。人们似乎乐于不断地重新发明轮子。这对新的学习者来说可能是令人畏惧的，因为掌握一项新技能需要时间，有时很难跟上技术发展的速度。这导致了经常抱怨 web 开发变得不必要的复杂，因为要学习许多新的库和框架，要熟悉大量的新工具。

一旦你学会了如何创建一个完整的现代 web 应用，并掌握了构建这样一个应用所需的技能，与你可能跟不上主流的感觉相关的焦虑就可以释放了。而且，通过这本书，你将学习这些技能，并意识到成为一名全栈开发人员不仅仅是知道如何编写前端和后端代码。在本书中，我们将创建一个真实的全栈 web 应用，并涵盖全栈开发人员所需的大部分技能。而一旦你看完了，你就会明白，语言和框架只是你工具箱里的工具。您可以用其他语言和框架替换它们，也可以构建伟大的全栈应用。

为了开始我们的旅程，我们将从基础开始。一旦你记住了这些基础知识，你就可以更有效地学习框架。在本章中，我们将讨论以下主题:

*   对我们将在本书中构建的全栈 web 应用的介绍
*   从 Java 开发人员的角度学习 JavaScript
*   了解我们将在本书中使用的 ECMAScript 2015 的功能

# 介绍

如果你正在为你的个人网站创建一个简历页面，用普通的 JavaScript、HTML 5 和一些有创意的 CSS 样式表就足够了，让它看起来特别而独特。如果你正在创建公司官方网站的招聘页面，徒手操作可能会有效。但是如果你使用一些框架来设计页面风格，处理逻辑和动画，你会发现自己处于一个更好的位置，你仍然可以比平时更早下班回家，在周末和朋友一起喝咖啡。如果你正在构建像 Monster([https://www.monster.com/](https://www.monster.com/))这样的东西，我希望你不要只是带着那些最喜欢的框架去战场，如果你赤手空拳去，你甚至不能到达那里。鉴于这种应用的复杂程度，以及由于永无止境的不断变化的需求，您将需要不断改进或改变特性，您需要随身携带用于现代 web 应用开发的工具。

有时，人们使用术语 vanilla JavaScript 来指代使用没有任何附加库的普通 JavaScript，例如 jQuery、Lodash 等等。这意味着您只使用 JavaScript 语言本身提供的 API 来编写代码。

在本书中，我们将创建一个名为`TaskAgile`的现代 web 应用，这是一个类似 Trello 的任务管理应用。让我们首先了解一下我们将用来构建它的技术。

对于前端，我们会用 **Vue.js 2** 作为我们的前端应用框架，Bootstrap 4 作为 UI 框架，我们会用 ES6 写我们的前端，也叫 ECMAScript 2015，或者 ES 2015，然后用 **Babel** 编译成 ES5 代码。我们将使用 ESLint 来检查我们的 JS 代码，以确保它遵循我们定义的所有规则，并使用 Flow([https://flow.org](https://flow.org))进行静态类型检查。我们将使用 **Jest** 来编写我们的前端单元测试，并使用 **Nightwatch.js** 来运行我们的端到端测试用例。我们将使用 webpack 4 来捆绑所有的依赖项，并使用`npm`来负责包的管理。

对于后端，我们将使用 Spring Boot 2 创建一个 Spring 5 应用。我们将使用 Hibernate 5 作为我们的**对象关系映射** ( **ORM** )框架，使用 MySQL 作为我们的数据库。我们将使用 Spring Security 进行认证和授权，并且我们将使用 **Spring WebSocket** 实现实时更新特性。我们将使用 **Spring AMPQ** 异步处理后台任务，使用 **Spring Session** 进行服务器端会话管理。

现在，在我们介绍 Vue.js 2 和 Spring 5 之前，对于不熟悉 JavaScript 的读者，让我们先学习一下它的基础知识，从 Java 开发人员容易混淆的部分开始。

# 从 Java 开发人员的角度看 JavaScript

对于不熟悉 JavaScript 但熟悉 Java 语言的读者来说，这两种语言之间的一些差异可能会让您感到困惑。尽管这一节是从 Java 开发人员的角度来写的，但是如果您是 JavaScript 新手，您也会发现它很有启发性。

# 功能和方法

JavaScript 中的函数与 Java 中的方法非常不同，因为它实际上是由`Function`构造函数创建的对象，而构造函数是语言的内置对象。是的，没错。`Function`本身也是一个对象。那么 JavaScript 中的方法是什么呢？当一个函数是一个对象的属性时，它就是一个方法。所以，在 JavaScript 中，方法是函数，但不是所有的函数都是方法。

因为函数是对象，所以它也可以有属性和方法。要确定一个对象是否是一个函数，可以使用`instanceof`，如下所示:

```java
var workout = function () {};
console.log(workout instanceof Function); // true
```

JavaScript 中的函数和其他对象的区别是什么，除了它是由`Function`构造函数创建的？首先，一个函数是可调用的，而其他对象不是。另一个区别是函数有一个`prototype`属性，而其他对象没有。我们稍后会谈到`prototype`。

在 JavaScript 中，你可以使用一个函数来创建带有`new`的对象。在这种情况下，该函数充当构造函数。按照惯例，当函数作为构造函数时，应该大写。下面是一个使用函数作为`User`构造函数的简单例子。稍后我们将构建包含更多细节的`User`构造函数:

```java
function User () {
}
var user = new User();
```

在我们继续之前，让我们看看在 JavaScript 中创建函数的不同方法。函数声明和函数表达式是创建函数最常见的方式。除此之外，你可以使用`new Function()`来创建一个函数。但是，由于其较差的性能和可读性，不建议这样做。前面代码片段中的`User`函数是一个函数声明。而`workout`是一个函数表达式。创建和调用函数的方式会影响函数体指向的执行上下文。我们以后再谈。

# 对象和类

在 Java 中，你创建一个类来表示一个概念，例如一个`User`类。`User`类有一个构造函数、一些字段和方法。并且使用它的构造函数实例化一个`User`对象。Java 中的每个对象都是相关类的一个实例，该类在其实例之间提供代码共享。例如，您可以扩展`User`类来创建一个`TeamMember`类。

在 JavaScript 中，有几种方法可以创建对象:

*   `Object()`构造函数方法
*   对象文字方法
*   构造函数方法
*   `Object.create()`法
*   创建者函数方法
*   ES6 类方法

让我们一次看一种方法。

`Object`构造函数方法看起来像这样:

```java
// Call the Object constructor with new
var user = new Object();
user.name = 'Sunny';
user.interests = ['Traveling', 'Swimming'];
user.greeting = function () {
  console.log('Hi, I\'m ' + this.name + '.');
};
user.greeting(); // Hi, I'm Sunny.
```

`Object`构造函数创建一个对象包装器。这不是推荐的方法，尽管它在 JavaScript 中是有效的。实际上，最好使用对象文字，这样可以使代码更紧凑。

对象文字方法如下所示:

```java
// Create a user with object literal
var user = {
  name: 'Sunny',
  interests: ['Traveling', 'Swimming'],
  greeting: function () {
    console.log('Hi, I\'m ' + this.name + '.');
  }
}
user.greeting();  // Hi, I'm Sunny.
```

object literal 是一种在 JavaScript 中创建对象的紧凑语法，也是通过`new Object()`创建对象的推荐方式。从 ES5 开始，对象文字也支持 getter 和 setter 访问器，如下所示:

```java
var user = {
  get role() {
    return 'Engineer';
  }
} 
user.role;  // Engineer
```

如果您试图给`role`赋值，它将保持不变，因为没有为`role`属性定义 setter 访问器。

构造函数方法如下所示:

```java
// Create a constructor function
function User (name, interests) {
  this.name = name;
  this.interests = interests;
  this.greeting = function () {
    console.log('Hi, I\'m ' + this.name + '.');
  }
}
// Call the constructor with new to create a user object
var user = new User('Sunny', ['Traveling', 'Swimming']);
user.greeting(); // Hi, I'm Sunny.
```

这种语法非常接近 Java 中的语法。JavaScript 非常宽容，调用构造函数时可以省略括号。但是，这不会将任何参数传递给构造函数，如下所示:

```java
var user = new User;
console.log(user.name); // undefined
```

同样，即使这在 JavaScript 中是有效的，也不建议省略括号。

`Object.create()`方法如下所示:

```java
// Use Object.create() method with the prototype of
// User constructor function created above
var user = Object.create(User.prototype, {
  name: { value: 'Sunny' },
  interests: { value: ['Traveling', 'Swimming']}
}); 
user.greeting(); // Uncaught TypeError: user.greeting() is not a //function
```

这里的原因是`greeting()`不是`user`对象的函数，因为`Object.create()`方法用构造函数的原型对象创建了一个新对象。并且`greeting`函数没有在`User.prototype`中定义，或者在`Object.create()`的第二个参数中传递。为了让用户能够打招呼，我们可以在第二个参数中传递`greeting`函数，或者将它添加到`User`构造函数的原型对象中。不同之处在于，第一种方法只将`greeting`函数添加到当前的`user`对象中。如果您在没有传入`greeting`函数的情况下创建了另一个用户，该用户将没有`greeting`函数。另一方面，将函数添加到原型对象会将`greeting`函数添加到由该构造函数创建的所有对象中。让我们将它添加到`User`原型对象中:

```java
// Add greeting to prototype object
User.prototype.greeting = function () {
  console.log('Hi, I\'m ' + this.name + '.');
}
user.greeting(); // Hi, I'm Sunny.
```

实际上，在 JavaScript 中，使用原型就是超类如何为子类提供继承方法。我们稍后将详细讨论这一点。

creator 函数方法如下所示:

```java
// Use a creator function with an object as its return value
function createUser (name, interests) {
  var user = {};
  user.name = name;
  user.interests = interests;
  user.greeting = function () {
    console.log('Hi, I\'m ' + this.name + '.');
  };
  return user;
}
// Call the creator function with parameters
var user = createUser('Sunny', ['Traveling', 'Swimming']);
user.greeting(); // Hi, I'm Sunny.
```

这里的 creator 函数是一个工厂方法，类似于 Java 中用来实例化对象的静态工厂方法。它仅仅是一个模式，因为它将对象创建的细节包装在 creator 函数中。

ES6 类方法如下所示:

```java
// Create User class
class User {
  // Equivalent to User constructor function
  constructor (name, interests) {
    this.name = name;
    this.interests = interests;
  }
  // Equivalent to User.prototype.greeting
  greeting () {
    console.log('Hi, I\'m ' + this.name + '.')
  }
}
let user = new User('Sunny', ['Traveling', 'Swimming']);
user.greeting(); // Hi, I'm Sunny.
```

这非常接近 Java 中的语法。除了使用类声明，还可以使用类表达式来创建类，如下所示:

```java
// Use class expression
let User = class {
  constructor (name, interests) {
    this.name = name;
    this.interests = interests;
  }
  greeting () {
    console.log('Hi, I\'m ' + this.name + '.')
  } 
}
```

尽管使用了相同的关键字`class`，JavaScript 中的`class`与 Java 中的`class`有很大的不同。比如 JavaScript 中没有静态类，也没有私有类。我们将在 ES6 部分详细讨论`class`。

# 对象、属性和属性特性

在 Java 中，一旦创建了一个对象，就(几乎)没有办法在运行时修改它的方法。Java 不是一种动态语言。在 JavaScript 中，事情完全不同。您可以创建一个对象，并在运行时轻松修改它，例如添加新属性和替换方法。这就是动态语言所能做到的。事实上，那不是特别的部分。特殊之处在于`Object`是 JavaScript 中的一种语言类型，和 JavaScript 拥有的其他语言类型一样，包括`Undefined`、`Null`、`Boolean`、`String`、`Symbol`、`Number`。JavaScript 中的任何值都是这些类型的值。

未定义的类型只有一个值`undefined`。空类型只有一个值`null`。一个布尔值有两个值:`true`和`false`。

在 Java 中，对象有字段和方法。在 JavaScript 中，对象在逻辑上是属性的集合。属性具有字符串类型的名称和属性列表。JavaScript 中的属性用于定义和解释属性的状态。有两种类型的属性—数据属性和访问属性。

数据属性有四个属性:

*   `value`，可以是任何 JavaScript 语言类型
*   `writable`，定义数据属性是否可以改变
*   `enumerable`，定义是否可以使用`for-in`语句枚举属性
*   `configurable`，定义了一个属性是否可以被删除、更改为访问属性、更改为不可写，或者是否可以修改其`enumerable`属性

访问属性也有四个属性:

*   `get accessor`，可以是一个`Function`对象，也可以是未定义的
*   `set accessor`，可以是一个`Function`对象，也可以是未定义的
*   `enumerable`，定义是否可以使用`for-in`语句枚举属性

*   `configurable`，定义一个属性是否可以删除，是否可以变成数据属性，或者是否可以修改它的其他属性。

要访问对象的属性，可以使用点符号或括号符号。点符号的作用与它在 Java 中的作用相同。另一方面，括号符号非常有趣。在 JavaScript 中，属性名必须是字符串。如果您尝试使用一个非字符串对象作为带有括号符号的属性名，该对象将通过它的`toString()`方法被转换成一个字符串，正如我们在这里看到的:

```java
var obj = {};
obj['100'] = 'one hundred';
// Number 100 will be casted to '100'
console.log(obj[100]);  // 'one hundred'
// Both foo and bar will be casted to string '[object Object]'
var foo = {prop: 'f'}, bar = {prop: 'b'};
obj[foo] = 'Foo'
console.log(obj[bar])  // 'Foo'
```

简而言之，逻辑上，**对象**是这样出现的:

![](img/603ed726-5ed7-41e8-b311-d1a7a977ae8e.png)

图 1.1:对象、属性和属性属性

在 JavaScript 中，可以使用`Object.defineProperty`或`Object.defineProperties`来修改对象的属性。它是这样工作的:

```java
1\.  function User (name, department) {
2\.    var _department = department;
3\.    var _name = name;
4\.    Object.defineProperty(this, 'name', {
5\.      value: _name,
6\.      writable: true,
7\.      enumerable: true,
8\.      configurable: false
9\.    }); 
10\.   Object.defineProperty(this, 'department', {
11\.     get: function () {
12\.       console.log('Retrieving department');
13\.       return _department;
14\.     },
15\.     set: function (newValue) {
16\.       console.log('Updating department value to "' + newValue + '"');
17\.       _department = newValue;
18\.     },
19\.     enumerable: true,
20\.     configurable: true
21\.   });
24\.   Object.defineProperty(this, 'greeting', {
25\.     value: function () {
26\.       console.log('Hi, I\'m ' + _name + '.');
27\.     },
28\.     enumerable: false,
29\.     configurable: false
30\.   }); 
31\. } 
```

从第`4`到`9`行可以看到，我们使用`Object.defineProperty`将`name`定义为一个数据属性，它的实际数据存储在内部属性`_name`中。在第`10`到`21`行中，我们将`department`定义为一个具有`get accessor`和`set accessor`的访问属性，实际值保存在`_department`中。在第`24`到`30`行中，我们将`greeting`属性定义为一个数据属性，其值是一个`Function`对象:

```java
32\. var user = new User('Sunny', 'Engineering');      
33\. console.log(user.department);  
34\. user.department = 'Marketing'; 
35\. user.greeting();  
36\. Object.defineProperty(user, 'name', { 
37\.   enumerable: false
38\. });
39\. delete user.name;
40\. delete user.department;
41\. for (var prop in user) {
42\.   console.log(prop);
43\. }
```

在第`32`行，我们使用`User`构造函数创建了一个`user`对象。在第`33`行中，我们访问`department`属性。因为它是一个 get 访问器，所以 getter 函数将被调用，消息`Retrieving department`将在实际的 department 值之前显示在控制台中。在第`34`行，我们给`department`属性分配了一个新值。因为我们已经定义了 set 访问器，所以将调用 setter 函数。在第`35`行，由于`user`对象的 greeting 属性被定义为一个函数，我们需要调用它。在第`36`到`38`行，我们尝试重新定义`name`属性。然而，由于它是不可配置的，JavaScript 将抛出一个错误。对于第`39`行也是如此，我们试图删除这个属性。删除第`40`行的`department`属性将有效，因为它是可配置的。在第`41`到`43`行中，控制台中唯一会显示的属性是`name`属性，因为`department`已经被删除，并且`greeting`属性不可枚举。

# 原型和继承

如前所述，JavaScript 中的继承是通过使用构造函数的原型来实现的。在 JavaScript 中，原型是为其他对象提供共享属性的对象。而且只有函数对象有原型，因为只有函数对象是可调用的，可以创建其他对象。在 ES6 中，箭头函数没有原型。我们稍后将讨论这一点。

你可以把一个功能想象成一个工厂，它的原型是工厂生产的产品的规格。每次您用关键字`new`调用一个函数，您就为它的产品下了一个订单。而且工厂会根据它在原型中是怎么规定的来生产。

现在，让我们看看代码中的继承是如何工作的。我们将创建另一个名为`TeamMember`的构造函数，它将从`User`继承属性，并覆盖`greeting()`方法，提供一个名为`work()`的新方法。稍后，我们将为`User`添加`eat()`方法，为`Object`添加`move()`方法。

下面是它在 ES5 中的实现方式:

```java
1\. function User (name, interests) {
2\.   this.name = name;
3\.   this.interests = interests;
4\. }
5\. User.prototype.greeting = function () {
6\.    console.log('Hi, I\'m ' + this.name + '.');
7\. }
```

在第`1`到`4`行，我们创建了一个`User`构造函数。它真正做的是使用`Function`构造函数创建一个`function`对象。在 JavaScript 中，您可以通过使用对象的`constructor`属性来检查对象的创建者，该属性引用回其创建者，如下所示:

```java
console.log(User.constructor === Function);  // true
```

一旦创建了`User`构造函数，它就有了一个原型对象。一个`User`原型对象本身是由`User`构造函数创建的，如下所示:

```java
console.log(User.prototype.constructor === User); // true 
```

在 JavaScript 中，使用`User`构造函数创建一个`user`对象后，该对象将拥有一个引用`User`原型对象的`__proto__`属性。你可以看到这样的链接:

```java
var user = new User();
console.log(user.__proto__ === User.prototype); // true 
```

这个`__proto__`引用作为原型链中的一个环节。稍后你会看到这意味着什么。

现在回到代码。在第`5`到`7`行，我们在`User`原型上创建了一个`greeting`属性。这将创建一个可以被`User`子类**继承**的方法。而且，正如我们之前提到的，如果你在`User`构造函数中定义了`greeting`方法，子类将看不到这个`greeting`方法。我们将很快看到这样做的原因:

```java
8\.  function TeamMember (name, interests, tasks) {
9\.     User.call(this, name, interests);
10\.    this.tasks = tasks;
11\. }
12\. TeamMember.prototype = Object.create(User.prototype);
13\. TeamMember.prototype.greeting = function () {
14\.   console.log('I\'m ' + this.name + '. Welcome to the team!');
15\. };
16\. TeamMember.prototype.work = function () {
17\.   console.log('I\'m working on ' + this.tasks.length + ' tasks');
18\. };
```

在第`8`到`13`行中，我们创建了一个`TeamMember`构造函数，在它内部，我们调用了`User`构造函数的`call()`方法，该方法继承自`Function`对象来链接构造函数，类似于在 Java 类的构造函数中调用`super()`。一个区别是`call()`方法的第一个参数必须是一个对象，它充当执行上下文。在我们的例子中，我们使用`this`作为执行上下文。在`call()`方法中，`name`和`interests`属性被初始化。然后，我们向`TeamMember`添加一个额外的属性`tasks`。

在第`12`行，我们使用`Object.create()`创建一个使用`User`原型对象的`TeamMember`原型对象。这样，由`TeamMember`构造函数创建的对象将具有`User`原型对象的属性，并且每个团队成员对象将具有链接到这个`TeamMember`原型的`__proto__`属性。

在第`13`到`15`行中，我们覆盖了`User`原型的最初的`greeting()`方法，这样由`TeamMember`构造函数创建的对象将具有不同的行为。这不会影响`User`原型对象，因为它们本质上是两个不同的对象，即使这两个原型对象有相同的构造函数，如下所示:

```java
console.log(User.prototype === TeamMember.prototype);  // false
console.log(User.prototype.constructor === TeamMember.prototype.constructor); // true
```

在第`16`到`18`行，我们向`TeamMember`原型对象添加了一个新方法`work()`。通过这种方式，由`TeamMember`构造函数创建的对象将具有这种额外的行为:

```java
19\. var member = new TeamMember('Sunny', ['Traveling'],
20\.                             ['Buy three tickets','Book a hotel']);
21\. member.greeting();  // I'm Sunny. Welcome to the team!
22\. member.work();      // I'm working on 2 tasks
23
24\. console.log(member instanceof TeamMember); // true
25\. console.log(member instanceof User);       // true
26\. console.log(member instanceof Object);     // true
27
28\. User.prototype.eat = function () {
29\.   console.log('What will I have for lunch?');
30\. };
31\. member.eat();     // What will I have for lunch?         
32
33\. // Add a method to the top
34\. Object.prototype.move = function () {
35\.   console.log('Every object can move now');
36\. };
37\. member.move();    // Every object can move now
38\. var alien = {};
39\. alien.move();     // Every object can move now
40\. User.move();      // Even the constructor function
```

在第`19`行，我们使用`TeamMember`构造函数创建了一个`member`对象。第`21`行显示了`member`对象可以用不同的方式问候由`User`构造函数创建的对象。而线`22`表示`member`对象可以工作。

第`24`到`26`行显示了`member`对象是其所有超类的一个实例。

在第`28`到`30`行中，我们将`eat()`方法添加到了`User`原型中，尽管`member`对象是在此之前创建的，但是从第`31`行可以看出，它也继承了那个方法。

在第`34`行中，我们将`move()`方法添加到了`Object`原型中，这可能会被证明是一个非常糟糕的想法，因为正如你在第`37`到`40`行中看到的，现在每个对象都可以移动，甚至那些构造函数对象。

我们只是创建一个从`Object` | `User` | `TeamMember`开始的继承链。原型环节是这个链条的关键。下面是它的样子:

![](img/701fa56a-94ed-4552-a19a-f5bd2b9f4812.png)

图 1.2:基于原型的继承

左边是构造函数，右边是它们对应的原型。底部是`member`物体。如您所见，`member`对象的`__proto__`属性引用了`TeamMember`的原型对象。并且`TeamMember`原型对象本身的`__proto__`属性引用了`User`的原型对象。而`User`原型对象的`__proto__`属性引用了顶层，也就是`Object`的原型对象。要验证链接，您可以执行如下操作:

```java
console.log(member.__proto__ === TeamMember.prototype);         // true
console.log(TeamMember.prototype.__proto__ === User.prototype); // true
console.log(User.prototype.__proto__ === Object.prototype);     // true
```

因此，要非常小心使用`__proto__`属性。如果你，比如说，不小心把这个属性改成了别的东西，继承就断了:

```java
User.prototype.__proto__ = null;
member.move(); // Uncaught TypeError: member.move is not a function 
console.log(member instanceof Object); // false (Oops!)
```

建议使用`Object.prototype.isPrototypeof()`检查原型链:

```java
TeamMember.prototype.isPrototypeOf(member);   // true
```

通过上图中显示的继承关系图，您可以很容易地看到 JavaScript 如何通过原型链解析属性。例如，当你访问一个`member`对象的`name`属性时，JavaScript 发现它在对象本身上，不会沿着链向上。当你访问`move()`方法时，JavaScript 将沿着链向上，检查`TeamMember`原型是否有它，如果没有，JavaScript 将继续向上，直到在`Object`原型中找到该方法。您可以使用对象的`hasOwnProperty()`方法来检查该对象是否拥有自己的属性，而不是通过原型链继承的属性:

```java
member.hasOwnProperty('name');   // true
member.hasOwnProperty('move');   // false
```

# 范围和结束

作用域是关于变量的可访问性。在 Java 中，基本上一组花括号`{}`定义了一个作用域，包括类级作用域、方法级作用域和块级作用域。

让我们看看下面这个 Java 示例:

```java
1\.  public class User { 
2\.    private String name; 
3\.    private List<String> interests; 
4\.   
5\.    public User (String name, List<String> interests) {
6\.      this.name = name;
7\.      this.interests = interests;
8\.    }
9\. 
10\.   // Check if a user is interested in something
11\.   public boolean isInterestedIn(String something) {
12\.     boolean interested = false;
13\.     for (int i = 0; i < interests.size(); i++) {
14\.       if (interests.get(i).equals(something)) {
15\.         interested = true;
16\.         break;
17\.       } 
18\.     } 
19\.     return interested;
20\.   }
21\. }
```

`name`和`interests`属性在类级别的范围内，它们可以在类内的任何地方访问。第`12`行中定义的`interested`变量在方法级范围内，并且只能在该方法内访问。第`13`行的`i`变量在`for`循环中定义，它是块级范围，只能在`for`循环块中访问。在 Java 中，变量的范围是静态的，可以由编译器决定。

在 JavaScript 中，变量的范围要灵活得多。还有全局作用域和函数作用域，以及带有`let`和`const`关键字的块作用域，这些在 ES6 中已经介绍过了，我们后面会讲到。

我们来看下面这个 JavaScript 例子:

```java
1\.  function bookHotel (city) {
2\.    var availableHotel = 'None';
3\.    for (var i=0; i<hotels.length; i++) {
4\.      var hotel = hotels[i];
5\.      if (hotel.city === city && hotel.hasRoom) {
6\.        availableHotel = hotel.name;
7\.        break;
8\.      }
9\.    }
10\.   // i and hotel still accessible here
11\.   console.log('Checked ' + (i+1) + ' hotels');// Checked 2 hotels
12\.   console.log('Last checked ' + hotel.name);  // Last checked Hotel B
13\.   {
14\.     function placeOrder() {
15\.       var totalAmount = 200;
16\.       console.log('Order placed to ' + availableHotel);
17\.     }
18\.   } 
19\.   placeOrder();
20\.   // Not accessible
21\.   // console.log(totalAmount);
22\.   return availableHotel;
23\. }
24\. var hotels = [{name: 'Hotel A', hasRoom: false, city: 'Sanya'},
                  {name: 'Hotel B', hasRoom: true, city: 'Sanya'}];
25\. console.log(bookHotel('Sanya')); // Hotel B
26\. // Not accessible
27\. // console.log(availableHotel);
```

第`24`行中声明的`hotels`变量是全局变量，可以在任何地方访问，比如在`bookHotel()`函数内部，即使该变量是在函数之后定义的。

第`2`行声明的`availableHotel`变量在`bookHotel()`函数的范围内。它是一个局部变量，在函数之外是不可访问的，正如您从第`27`行看到的。在它的封闭函数中，`availableHotel`变量可以在任何地方访问，甚至是嵌套的`placeOrder()`函数，正如你在第`16`行看到的。这被称为**关闭**。当一个函数嵌套在另一个函数中时，就形成了闭包。无论函数嵌套得有多深，它仍然可以访问其父函数的作用域，并且一直到顶层作用域，也就是全局作用域。第`15`行定义的`totalAmount`变量是`placeOrder()`函数的局部变量。

在第`3`和`4`行，我们用`var`关键字定义了`i`和`hotel`变量。即使它在`for`循环块中，它仍然可以在块外访问，如第`11`和`12`行所示。在 ES6 中，可以使用`let`关键字定义`i`和`hotel`，这将把这两个变量放在`for`循环块范围内。我们稍后会详细讨论这一点。

# this 关键字

在 Java 中，`this`总是指当前对象。它是实心的。在 JavaScript 中，`this`的行为有所不同。简而言之，`this`指的是当前执行的上下文，是一个对象。JavaScript 运行时确定当前执行上下文的方式比 Java 复杂得多。

在 JavaScript 中，有一个执行上下文栈，从逻辑上由活动的执行上下文形成。当控制从一个可执行代码转移到另一个可执行代码时，控制进入新的可执行代码的执行上下文，该执行上下文成为当前执行上下文，或者被称为正在运行的执行上下文。栈底是全局上下文，一切从这里开始，就像 Java 中的`main`方法一样。当前的执行上下文总是在栈顶。

可执行代码是什么？JavaScript 中有三种类型:

*   **全局代码**，这是从 JavaScript 程序开始的地方运行的代码。在浏览器中，它是`window`所在的位置。当你打开一个浏览器控制台并输入`var user = new User()`时，你正在编写全局代码。
*   **Eval 代码**，这是作为内置`eval()`函数的参数传入的字符串值(除非您确实知道自己在做什么，否则不要使用`eval()`函数)。
*   **函数代码**，解析为函数体的代码。然而，这并不意味着写在函数内部的所有代码都是函数代码。

现在，为了更好地理解这一点，让我们看下面的例子:

```java
1\.  function User (name) {
2\.    console.log('I\'m in "' + this.constructor.name + '" context.');
3\.    this.name = name;
4\.    this.speak = function () {
5\.      console.log(this.name + ' is speaking from "' +
6\.        this.constructor.name + '" context.');
7\.      var drink = function () {
8\.        console.log('Drinking in "' + this.constructor.name + '"');
9\.      } 
10\.     drink(); 
11\.   }; 
12\.   function ask() {
13\.     console.log('Asking from "' + 
14\.       this.constructor.name + '"   context.');
15\.     console.log('Who am I? "'  + this.name + '"');
16\.   }
17\.   ask();
18\. }
19\. var name = 'Unknown';
20\. var user = new User('Ted');
21\. user.speak();
```

因为执行上下文实际上是一个对象，这里我们使用它的`.constructor.name`来查看上下文是什么。如果您在节点命令行中运行前面的代码，它将是`Object`而不是`Window`。

如果从 Chrome 控制台运行代码，输出将如下:

```java
// I'm in "User" context.
// Asking from "Window" context.
// Who am I? "Unknown"
// Ted is speaking from "User" context.
// Drinking in "Window"
```

首先，我们来看看哪部分是全局代码，哪部分是函数代码。`User`函数声明和`19`到`21`行是全局代码。第`2`至`17`行是`User`功能的功能代码。不完全是。第`5`到`10`行，除了第`8`行，都是`speak()`方法的功能代码。第`8`行是`drink()`功能的功能代码。行`13`和`14`是`ask()`功能的功能代码。

在我们回顾输出之前，让我们回顾一下创建函数的两种常用方法——函数声明和函数表达式。当 JavaScript 引擎看到一个函数声明时，它将创建一个`function`对象，该对象在声明该函数的范围内可见。例如，第`1`行声明了`User`函数，该函数在全局范围内可见。第`12`行声明了`ask()`函数，它在`User`函数的范围内可见。第`4`行是创建`speak()`方法的函数表达式。另一方面，在第`7`行，我们使用一个函数表达式来创建一个`drink`变量。它不同于在`4`行创建的`speak()`方法。尽管它也是一个函数表达式，但`drink`变量不是对象的属性。它在`speak()`方法中是可见的。

在 JavaScript 中，范围和执行上下文是两个不同的概念。范围是关于可访问性的，而执行上下文是关于运行可执行代码的**所有权**。`speak()`方法和`ask()`函数在同一个范围内，但是它们有不同的执行上下文。当执行`ask()`函数时，正如您从输出中看到的，它具有全局上下文，并且`name`属性解析为值`Unknown`，该值在全局范围内声明。并且当执行`speak()`方法时，它具有`user`上下文。从输出中可以看到，它对`name`属性的访问解析为`Ted`。这对 Java 开发人员来说是相当困惑的。那么幕后发生了什么？

让我们从 JavaScript 引擎的角度回顾一下前面的例子。当 JavaScript 引擎执行第`20`行时，它通过调用`User`构造函数创建一个`user`对象。它将进入函数体来实例化对象。当控制从全局代码流向函数代码时，执行上下文被更改为`user`对象。这就是你在输出中看到`I'm in "User" context.`的原因。在实例化过程中，JavaScript 引擎不会执行`speak()`方法中的代码，因为还没有调用。当它到达第`17`行时，它执行`ask()`功能。此时，控制从`User`构造函数的函数代码流向`ask()`函数。因为`ask()`函数不是一个对象的属性，也不是由`Function.call()`方法调用的，我们将在后面讨论，全局上下文成为执行上下文。这就是为什么您会在输出中看到`Asking from "Window" context.`和`Where am I? "Unknown"`。在`user`对象实例化之后，JavaScript 引擎返回执行行`21`并调用`user`对象上的`speak()`方法。现在，控制流入`speak()`方法，`user`对象成为执行上下文。这就是你在输出中看到`Ted is speaking from "User" context.`的原因。当引擎执行`drink()`函数时，它解析回全局上下文作为执行上下文。这就是为什么您会在输出中看到`Drinking in "Window" context.`。

如前所述，执行上下文受函数创建方式和调用方式的影响。那是什么意思？让我们把第`16`行从`ask()`改为`ask.call(this)`。如果您从 Chrome 的控制台再次运行上述示例，您可以看到以下输出:

```java
...
Asking from "User" context.
Who am I? "Ted"
...
```

如果你在控制台中输入`user.speak.apply({name: 'Jack'})`，你会看到一些有趣的东西，就像这样:

```java
Jack is speaking from "Object" context.
Drinking in "Window" context.
```

或者，如果你把线`17`换成`ask.bind(this)()`，你可以看到问题的答案`"Who am I?"`现在也是`"Ted"`。

那么，这些`call()`、`apply()`、`bind()`方法是什么呢？在前面的例子中似乎没有对它们的定义。您可能还记得，每个函数都是由`Function`对象创建的对象。在控制台中键入以下代码后，可以看到`speak()`函数继承了`Function`原型的属性，包括`call()`、`apply()`和`bind()`方法:

```java
console.log(Function.prototype.isPrototypeOf(user.speak)); // true
user.speak.hasOwnProperty('apply');                        // false
user.speak.__proto__.hasOwnProperty('apply');              // true
```

`call()`方法和`apply()`方法类似。这两种方法的区别在于，`call()`方法接受一个参数列表，而`apply()`方法接受一个参数数组。这两种方法都将第一个参数作为函数代码的执行上下文。比如在`user.speak.apply({name: 'Jack'})`中，`{name: 'Jack'}`对象将是`user`的`speak()`方法的执行上下文。您可以将`call()`和`apply()`方法视为切换执行上下文的一种方式。

而`bind()`方法的行为与其他两种不同。`bind()`方法所做的是创建一个新函数，该函数将绑定到作为新函数的执行上下文传入的第一个参数。即使您使用`call()`或`apply()`切换执行上下文，新函数也不会改变其执行上下文。因此，`ask.bind(this)()`所做的就是创建一个函数，然后立即执行它。除了立即执行之外，您还可以将新函数赋给一个变量或作为一个对象的方法。

总结一下，有四种方法可以调用函数:

*   构造函数调用:`new User()`
*   直接函数调用:`ask()`
*   方法调用:`user.speak()`
*   切换上下文调用:`ask.call(this)`或`ask.apply(this)`

当我们谈论构造函数调用时，函数体中`this`的存在，除了那些被其他三种类型调用的函数包装的实例，指的是构造函数创建的对象。

当我们谈论直接函数调用时，函数体内`this`的存在，除了那些被其他三种类型调用的函数包装的实例，指的是全局上下文。

当我们讨论方法调用时，函数体中出现的`this`，除了那些被其他三种调用类型的函数包装的实例，都是指方法所属的对象。

当我们讨论切换上下文调用时，除了被其他三种类型调用的函数包装的那些实例之外，函数体中存在的`this`是指作为`call()`方法的第一个参数传入的对象。

# 提升

这是 Java 开发人员通常容易混淆的另一件事。提升是对 JavaScript 解释器将**将**函数声明和变量声明提升到其包含范围顶部的方式的隐喻。所以，在 JavaScript 中，你可以看到一些明显错误的东西，如果你用 Java 写，肯定会破坏编译，但在 JavaScript 中是完全有效的。

让我们看一个例子:

```java
1\. travel = 'No plan';
2\. var travel;
3\. console.log(travel); // Is the output: undefined? 
4.
5\. function travel() {
6\.     console.log('Traveling');
7\. }
8\. travel(); // Is the output: Traveling? 
```

当 JavaScript 引擎执行第`3`和`8`行时，输出会是什么？它不是`undefined`，也不是`Traveling`。线`3`为`"No plan"`，线`8`为`"Uncaught TypeError"`。

以下是 JavaScript 解释器在处理前面的代码时看到的内容:

```java
1\.  // Function declaration moved to the top of the scope
2\.  function travel() {
3\.    console.log('Traveling');
4\.  }
5\.  // Variable declaration moved under function declaration
6\.  var travel;
7\.  travel = 'No plan';
8.
9\.  console.log(travel);  // No plan
10\. travel();  // Uncaught TypeError: travel is not a function
```

JavaScript 解释器将函数声明移到顶部，后面是变量声明。函数表达式，例如`var travel = function(){}`，并没有作为函数声明提升到顶部，因为它们也是变量声明。

再来看另一个例子:

```java
1\.  function workout() { 
2\.    goToGym();    // What will the output be?
3\.    var goToGym = function () {
4\.      console.log('Workout in Gym A');
5\.    }
6\.    return;    
7\.    function goToGym() {
8\.      console.log('Workout in Gym B');
9\.    }
10\. }
11\. workout();
```

当执行第`2`行时，输出会是什么？就是`"Workout in Gym B."`。下面是解释器在处理代码时看到的内容:

```java
1\.  function workout() {
2\.    function goToGym() {
3\.      console.log('Workout in Gym B');
4\.    }
5\.    var goToGym;
6\.    goToGym();
7\.    goToGym = function () {
8\.      console.log('Workout in Gym A');
9\.    }
10\.   return;
11\. }
12\. workout();
```

解释器将函数声明移到作用域的顶部，然后是变量声明，但不是赋值。所以当执行`goToGym()`时，新函数的赋值表达式还没有发生。

总结一下，在执行之前，JavaScript 解释器会将函数声明，然后是变量声明(没有赋值表达式)移动到包含作用域的顶部。并且将函数声明放在`return`语句之后是有效的。

# ES6 基础知识

**ES6**(**ECMAScript 2015**的简称)，是 ECMAScript 的第六个版本，是一种通用、跨平台、厂商中立的编程语言。ECMAScript 是由 Ecma International 在 ECMA 标准(ECMA-262)中定义的。大多数时候，ECMAScript 通常被称为 JavaScript。

理解 ES6 是使用现代 JavaScript 编写 web 应用的关键。由于这本书的范围，我们将只涵盖 ES6 中引入的新特性的基础，因为你将在本书的其余部分看到它们。

# 块范围、let 和 const

如前所述，在 ES6 中，你可以使用`let`定义变量或者使用`const`定义常量，它们会有块级的作用域。在同样的范围内，你不能使用`let`来重定义一个变量。同样，你不能访问在声明前用`let`或`const`定义的变量或常量，因为没有用`let`或`const`提升的变量。

让我们看下面的`workout`例子:

```java
1\.  function workout() {
2\.    let gym = 'Gym A';
3\. 
4\.    const gymStatuses = {'Gym A': 'open', 'Gym B': 'closed'};
5\.    for (let gym in gymStatuses) {
6\.      console.log(gym + ' is ' + gymStatuses[gym]);
7\.    }
8.
9\.    {
10\.     const gym = 'Gym B';
11\.     console.log('Workout in ' + gym);
12\.     // The following will throw TypeError
13\.     // gym = 'Gym C'; 
14\.   }
15\. 
16\.   console.log('Workout in ' + gym);
17\. 
18\.   {
19\.     function gym () {
20\.       console.log('Workout in a separate gym');
21\.     }
22\.     gym();
23\.   }
24\. 
25\.   if (gymStatuses[gym] == 'open') {
26\.     let exercises = ['Treadmill', 'Pushup', 'Spinning'];
27\.   }
28\.   // exercises are no longer accessible here
29\.   // console.log(exercises);
30\. 
31\.   try {
32\.     let gym = 'Gym C'; 
33\.     console.log('Workout in ' + gym);   
34\.     throw new Error('Gym is closed');
35\.   } catch (err) {
36\.     console.log(err);
37\.     let gym = 'Gym D';
38\.     console.log('Workout in ' + gym);   
39\.   }
40\. }
41\. workout();
```

在第`2`行，我们声明了`gym`变量，它在`workout()`函数体中是可见的。在第`5`行，我们在`for`循环块中声明了`gym`变量。它隐藏了第`2`行中声明的`gym`变量，并且只能在那个`for`循环块中访问。

在第`9`到`14`行，我们使用 block 语句声明了一个新的作用域。第`10`行中声明的`gym`常量只能在该范围内访问。正如你在`13`行看到的，给一个常量赋值会导致`TypeError`。

在第`16`行，`gym`变量回到第`2`行声明的变量。在第`18`到`23`行中，我们声明了`gym`函数，它只能在那个块中访问。

在第`26`行，我们在`if`块中定义了`exercises`变量。正如你从线路`29`中看到的，在`if`街区之外不再可以到达。

在第`31`到`39`行，我们声明了一个`try` - `catch`块。从第`32`和`37`行可以看到，`try`块和`catch`块在不同的范围内。

最后，使用`let`和`const`，我们可以用`for`循环块、`if`块、`try-catch`块和块语句以及`switch`块来归档块级范围。

# 班级

ES2015 引入了类，这主要是基于原型继承的语法糖。使用类语法，您可以创建构造函数、从超类扩展、创建静态方法以及 getters 和 setters。

让我们看看下面的例子，它使用类语法来实现`User`和`TeamMember`:

```java
1\.  class User {
2\.    constructor(name, interests) {
3\.      this.name = name;
4\.      this.interests = interests;
5\.    }
6\.    greeting () {
7\.      console.log('Hi, I\'m ' + this.name + '.');
8\.    }
9\.    get interestsCount () {
10\.     return this.interests ? this.interests.length : 0;
11\.   }
12\. }
```

在第`1`到`12`行，我们定义了类`User`，它通过构造函数接受两个参数。它有一个`greeting()`方法和一个`interestsCount`获取器:

```java
13\. class TeamMember extends User {
14\.   constructor(name, interests) {
15\.     super(name, interests);
16\.     this._tasks = [];
17\.     this._welcomeText = 'Welcome to the team!';
18\.   }
19\.   greeting () {
20\.     console.log('I\' m ' + this.name + '. ' + this._welcomeText);
21\.   }
22\.   work () {
23\.     console.log('I\' m working on ' + this._tasks.length + ' 
        tasks.')
24\.   }
25\.   set tasks (tasks) {
26\.     let acceptedTasks = [];
27\.     if (tasks.length > TeamMember.maxTasksCapacity()) {
28\.       acceptedTasks = tasks.slice(0, 
          TeamMember.maxTasksCapacity());
29\.       console.log('It\'s over max capacity. Can only take two.');
30\.     } else {
31\.       acceptedTasks = tasks;
32\.     }    
33\.     this._tasks = this._tasks.concat(acceptedTasks);
34\.   }
35\.   static maxTasksCapacity () {
36\.     return 2;
37\.   }
38\. }
```

在第`13`到`38`行，我们创建了一个从`User`扩展而来的`TeamMember`类。在其构造函数中，用`super`调用`User`的构造函数，实例化`name`和`interests`的属性。我们还定义了两个附加属性，`_tasks`和`_welcomeText`。前面的下划线表明它们被视为私有属性，不应从外部直接更改。然而，在 JavaScript 中没有什么是私有的。您仍然可以访问这些属性，例如，`member._tasks`和`member._welcomeText`。

我们在`20`行覆盖了`user`的`greeting()`方法，并在`22`行添加了一个新的`work()`方法。在第`25`到`34`行，我们定义了一个 setter `tasks`，在里面我们访问`TeamMember`的`maxTasksCapacity()`静态方法:

```java
39\. let member = new TeamMember('Sunny', ['Traveling']);
40\. member.greeting();   // I' m Sunny. Welcome to the team!
41\. member.tasks = ['Buy three tickets', 'Book a hotel', 'Rent a car'];                         
    // It's over max capacity. Can only take two.
42\. member.work();       // I' m working on 2 tasks.
43\. console.log(member.interestsCount); // 1
44\. member.interestsCount = 2;          // This won’t save the change
45\. console.log(member.interestsCount); // 1
46\. console.log(member.tasks);          // undefined
```

正如你所看到的，在第`39`到`43`行中，`member`对象拥有`User`类和`TeamMember`的所有特性，工作正常。在第`44`到`45`行中，我们试图对`member.interestsCount`进行修改，但是不会成功，因为没有定义 setter。第`46`行显示访问`member.tasks`会导致`undefined`，因为我们没有为它定义一个 getter。

您不能使用`member.constructor`来访问`14`行中定义的`TeamMember`的构造函数。它用于访问`member`对象的构造函数，在这里是`TeamMember`。

现在让我们看看如何向`User`类添加一个新方法`eat()`:

```java
User.prototype.eat = function () {
  console.log('What will I have for lunch?');
};
member.eat();  // What will I have for lunch?
```

你还需要把它添加到`User`的 prototype 对象中。如果按如下方式直接加到`User`上，就会得到`TypeError`:

```java
User.sleep = function () {
  console.log('Go to sleep');
};
member.sleep();  // Uncaught TypeError: member.sleep is not a function
User.sleep();    // Go to sleep
```

这是因为以这种方式编写的结果是，你添加了`sleep`作为`User`类本身的属性，或者更准确地说，作为`User`构造函数本身的属性。您可能已经注意到了，`sleep`变成了`User`类的静态方法。当使用类语法时，当您定义一个方法时，在后台，JavaScript 将其添加到其原型对象中，当您定义一个静态方法时，JavaScript 将其添加到构造函数中:

```java
console.log(User.prototype.hasOwnProperty('eat'));  // true
console.log(User.hasOwnProperty('sleep'));          // true
```

# 增强的对象文字

在 ES6 中，对象文字支持设置原型、速记赋值、定义方法、进行超级调用以及用表达式计算属性。

让我们来看看下面的例子，它创建了一个以`TeamMember`对象为原型的`advisor`对象:

```java
1\.  const advice = 'Stay hungry. Stay foolish.';
2\. 
3\.  let advisor = {
4\.    __proto__: new TeamMember('Adam', ['Consulting']), 
5\.    advice,
6\.    greeting () {
7\.      super.greeting();
8\.      console.log(this.advice); 
9\.    },
10\.  [advice.split('.')[0]]: 'Always learn more'
11\. };
```

第`4`行，将`TeamMember`的对象赋给`advisor`对象的`__proto__`属性，使`advisor`成为`TeamMember`的实例:

```java
console.log(TeamMember.prototype.isPrototypeOf(advisor));  // true
console.log(advisor instanceof TeamMember);                // true
```

行`5`是`advice:advice`的简写赋值。行`7`正在创建`TeamMember`的`greeting()`方法，在其中它将调用`TeamMember`的`greeting`方法:

```java
advisor.greeting();   // I' m Adam. Welcome to the team!
                      // Stay hungry. Stay foolish.
```

在第`10`行中，`Stay hungry`属性是用括号符号计算的。要访问这个属性，在这种情况下，因为属性名包含一个空格，所以需要使用括号符号，就像这样— `advisor['Stay hungry']`。

# 箭头功能

ES6 引入了箭头函数作为函数简写，使用`=>`语法。箭头函数支持语句块体和表达式体。使用表达式体时，表达式的结果是函数返回的值。

箭头语法以函数参数开始，然后是箭头`=>`，最后是函数体。让我们看看箭头函数的以下不同变体。这些示例是用 ES5 语法和 ES6 箭头函数语法编写的:

```java
const fruits = [{name: 'apple', price: 100}, {name: 'orange', price: 80}, {name: 'banana', price: 120}];

// Variation 1
// When no arguments, an empty set of parentheses is required
var countFruits = () => fruits.length;
// equivalent to ES5
var countFruits = function () {
  return fruits.length;
}; 

// Variation 2
// When there is one argument, parentheses can be omitted.
// The expression value is the return value of the function.
fruits.filter(fruit => fruit.price > 100);
// equivalent to ES5
fruits.filter(function(fruit) {
  return fruit.price > 100;
});

// Variation 3
// The function returns an object literal, it needs to be wrapped
// by parentheses.
var inventory = fruits.map(fruit => ({name: fruit.name, storage: 1}));
// equivalent to ES5
var inventory = fruits.map(function (fruit) {
  return {name: fruit.name, storage: 1};
});

// Variation 4
// When the function has statements body and it needs to return a 
// result, the return statement is required
var inventory = fruits.map(fruit => {
  console.log('Checking ' + fruit.name + ' storage');
  return {name: fruit.name, storage: 1};
});
// equivalent to ES5
var inventory = fruits.map(function (fruit) {
  console.log('Checking ' + fruit.name + ' storage');
  return {name: fruit.name, storage: 1};
});
```

关于变体 3 有一个额外的注释。当箭头函数使用花括号时，它的函数体需要是一个或多个语句:

```java
var sum = (a, b) => { return a + b };
sum(1, 2);     // 3
```

当`sum`函数被写成这样时，它不会像预期的那样工作:

```java
var sum = (a, b) => { a + b };
sum(1, 2);    // undefined
// Using expression will work
var sum = (a, b) => a + b;
sum(1, 2);    // 3
```

与 ES5 函数相比，Arrow 函数具有更短的语法和许多其他重要的区别。让我们一个接一个地看看这些不同之处。

# 没有词汇

箭头函数没有自己的`this`。与 ES5 函数不同，它会创建自己单独的执行上下文，arrow 函数使用周围的执行上下文。让我们看看下面的购物车示例:

```java
1\.  var shoppingCart = {
2\.    items: ['Apple', 'Orange'],
3\.    inventory: {Apple: 1, Orange: 0},
4\.    checkout () {
5\.      this.items.forEach(item => {
6\.        if (!this.inventory[item]) {
7\.          console.log('Item ' + item + ' has sold out.');
8\.        }      
9\.      })    
10\.   }
11\. }
12\. shoppingCart.checkout();
13\. 
14\. // equivalent to ES5
15\. var shoppingCart = {
16\.   items: ['Apple', 'Orange'],
17\.   inventory: {Apple: 1, Orange: 0},
18\.   checkout: function () {
19\.     // Reassign context and use closure to make it 
20\.     // visible to the callback passed to forEach
21\.     var that = this
22\.     this.items.forEach(function(item){
23\.       if (!that.inventory[item]) {
24\.         console.log('Item ' + item + ' has sold out.');
25\.       }      
26\.     })    
27\.   }
28\. }
29\. shoppingCart.checkout();
```

在第`6`行中，`this`指的是`shoppingCart`对象本身，甚至是在`Array.prototype.forEach()`方法的回调里面。正如您在`21`行中看到的，在 ES5 版本中，您需要使用闭包来保持回调函数可以使用执行上下文。

因为箭头函数没有单独的执行上下文，所以当用`Function.prototype.call()`、`Function.prototype.apply()`或`Function.prototype.bind()`方法调用它时，作为第一个参数传入的执行上下文将被忽略。让我们来看一个例子:

```java
1\. var name = 'Unknown';
2\. var greeting = () => {
3\.   console.log('Hi, I\'m ' + this.name); 
4\. };
5\. greeting.call({name: 'Sunny'});    // I'm Unknown
6\. greeting.apply({name: 'Tod'});     // I'm Unknown
7\. var newGreeting = greeting.bind({name: 'James'});
8\. newGreeting();                     // I'm Unknown
```

从第`3`行可以看出，在箭头函数中，`this`总是解析到它周围的执行上下文。`call()`、`apply()`或`bind()`方法对其执行上下文没有影响。

与 ES5 函数不同，箭头函数没有自己的`arguments`对象。`arguments`对象是对周围函数的`arguments`对象的引用。

因为箭头函数使用其周围的执行上下文，所以它们不适合定义对象的方法。

让我们看看下面的购物车示例，它使用了一个箭头函数来结帐:

```java
1\.  var shoppingCart = {
2\.    items: ['Apple', 'Orange'],
3\.    inventory: {Apple: 1, Orange: 0},
4\.    checkout: () => {
5\.      this.items.forEach(item => {
6\.        if (!this.inventory[item]) {
7\.          console.log('Item ' + item + ' has sold out.');
8\.        }      
9\.      })    
10\.   }
11\. }
12\. shoppingCart.checkout();
```

在第`4`行，我们将`checkout`改为一个箭头函数。因为箭头函数使用了它周围的执行上下文，所以第`5`行中的`this`不再引用`shoppingCart`对象，它将抛出`Uncaught TypeError: Cannot read property 'forEach' of undefined`。

前面的购物车示例是用对象文字编写的。当使用原型对象定义对象方法时，箭头函数也不能很好地工作。让我们看下面的例子:

```java
1\.  class User {
2\.    constructor(name) {
3\.      this.name = name;
4\.    }
5\.  }
6\.  User.prototype.swim = () => {
7\.    console.log(this.name + ' is swimming');
8\.  };
9\.  var user = new User();
10\. console.log(user.swim());   //  is swimming
```

从输出中可以看到，在第`7`行中，`this`没有引用`user`对象。在本例中，它引用全局上下文。

# 没有原型对象

箭头函数没有原型对象，因此，它们不是构造函数。并且不能用`new`操作符调用它们。如果您尝试这样做，将会抛出一个错误。这里有一个例子:

```java
const WorkoutPlan = () => {};
// Uncaught TypeError: WorkoutPlan is not a constructor
let workoutPlan = new WorkoutPlan(); 
console.log(WorkoutPlan.prototype);  // undefined
```

# 默认参数值

在 ES6 中，您可以定义函数参数的默认值。这是一个非常有用的改进，因为 ES5 中的等效实现不仅乏味，而且降低了代码的可读性。

让我们来看一个例子:

```java
const shoppingCart = [];
function addToCart(item, size = 1) {
  shoppingCart.push({item: item, count: size});
}
addToCart('Apple');     // size is 1
addToCart('Orange', 2); // size is 2
```

在这个例子中，我们给参数`size`一个默认值`1`。让我们看看如何在 ES5 中归档同样的东西。下面是 ES5 中`addToCart`函数的一个等价函数:

```java
function addToCart(item, size) {
  size = (typeof size !== 'undefined') ? size : 1;
  shoppingCart.push({item: item, count: size});
}
```

如您所见，使用 ES6 默认参数可以提高代码的可读性，并使代码更易于维护。

# 休息参数

在 ES5 中，在函数体内，可以使用`arguments`对象来迭代函数的参数。在 ES6 中，您可以使用 rest parameters 语法将无限数量的参数定义为一个数组。

让我们看下面的例子:

```java
1\.  // Using arguments in ES5
2\.  function workout(exercise1) {
3\.    var todos = Array.prototype.slice.call(arguments, 
      workout.length);
4\.    console.log('Start from ' + exercise1);
5\.    console.log(todos.length + ' more to do');
6\.  }
7\.  // equivalent to rest parameters in ES6
8\.  function workout(exercise1, ...todos) {
9\.    console.log('Start from ' + exercise1);    // Start from 
    //Treadmill
10\.   console.log(todos.length + ' more to do'); // 2 more to do
11\.   console.log('Args length: ' + workout.length); // Args length: 1
11\. }
12\. workout('Treadmill', 'Pushup', 'Spinning');
```

在第`8`行，我们定义了一个 rest 参数`todos`。它以三个点为前缀，是`workout()`函数的最后一个命名参数。为了在 ES5 中存档，正如你在第`3`行看到的，我们需要切片`arguments`对象。在第`11`行，你可以看到 rest 参数`todos`并不影响`workout ()`函数中参数的长度。

# 扩展语法

在 ES6 中，当在函数声明中使用三点符号(`...`)时，它定义了一个 rest 参数；当它与数组一起使用时，它会分布数组的元素。可以用这种方式将数组的每个元素传递给一个函数。您也可以在数组文本中使用它。

让我们看下面的例子:

```java
1\. let urgentTasks = ['Buy three tickets'];
2\. let normalTasks = ['Book a hotel', 'Rent a car'];
3\. let allTasks = [...urgentTasks, ...normalTasks];
4\. 
5\. ((first, second) => {
6\.   console.log('Working on ' + first + ' and ' + second)
7\. })(...allTasks);
```

在第`3`行，我们使用 spread 语法来扩展`urgentTasks`数组和`normalTasks`数组。在第`7`行，我们使用 spread 语法来扩展`allTasks`数组，并将其中的每个元素作为函数的参数传递。并且`first`自变量具有值`Buy three tickets`，而`second`自变量具有值`Book a hotel`。

# 解构分配

在 ES6 中，可以使用析构赋值来解包数组中的元素、字符串中的字符或对象中的属性，并使用类似于数组文字和对象文字的语法将它们赋给不同的变量。在声明变量、分配变量或分配函数参数时，可以这样做。

# 对象析构

首先，我们来看一个对象析构的例子:

```java
1\. let user = {name:'Sunny', interests:['Traveling', 'Swimming']};
2\. let {name, interests, tasks} = user;
3\. console.log(name);       // Sunny
4\. console.log(interests);  // ["Traveling", "Swimming"]
5\. console.log(tasks);      // undefined
```

正如您所看到的，在第`2`行中定义的`name`和`interests`变量在`user`对象中选择了具有相同名称的属性值。并且`tasks`变量在`user`对象中没有匹配的属性。其值保持为`undefined`。您可以通过给它一个默认值来避免这种情况，如下所示:

```java
let {name, interests, tasks=[]} = user;
console.log(tasks)  // []
```

对象析构的另一个好处是你可以选择不同的变量名。在下面的例子中，我们选取了`user`对象的`name`属性的值，并将其赋给了`firstName`变量:

```java
let {name: firstName} = user;
console.log(firstName)  // Sunny
```

# 数组析构

数组析构类似于对象析构。数组析构不使用花括号，而是使用括号来进行析构。下面是一个数组析构的例子:

```java
let [first, second] = ['Traveling', 'Swimming', 'Shopping'];
console.log(first);   // Traveling
console.log(second);  // Swimming
```

您也可以跳过变量，只选择您需要的变量，如下所示:

```java
let [,,third, fourth] = ['Traveling', 'Swimming', 'Shopping'];
console.log(third);   // Shopping
console.log(fourth);  // undefined
```

如您所见，我们跳过了前两个变量，只需要第三个和第四个变量。然而，在我们的例子中，`fourth`变量不匹配数组中的任何元素，它的值仍然是`undefined`。此外，您可以给它一个默认值，如下所示:

```java
let [,,third, fourth = ''] = ['Traveling', 'Swimming', 'Shopping'];
console.log(fourth);  // an empty string
```

# 嵌套解构

类似于使用对象文字和数组文字以简洁的语法创建复杂的嵌套数据结构，您可以使用析构赋值来选取深度嵌套数据结构中的变量。

让我们看看下面的例子，在这个例子中，我们只需要用户的第二个兴趣:

```java
1\. let user = {name:'Sunny', interests:['Traveling', 'Swimming']};
2\. let {interests:[,second]} = user;
3\. console.log(second);    // Swimming
4\. console.log(interests); // ReferenceError
```

在第`2`行，即使我们将`interests`放在析构赋值中，JavaScript 并没有真正声明它。正如您在第`4`行中看到的，访问它将引发`ReferenceError`。这里发生的事情是，JavaScript 使用冒号左边的部分(`:`)，在本例中是`interests`，提取同名属性的值，并使用右边的部分做进一步的析构赋值。如果您想要提取`interests`属性，如前所述，您需要像这样写:`let {interests} = user;`。

下面是另一个数组中第二个元素的`name`属性被析构的例子:

```java
const fruits = [{name:'Apple', price:100},{name:'Orange', price:80}];
let [,{name:secondFruitName}] = fruits;
console.log(secondFruitName); // Orange
```

# 其余元素

您可以在析构赋值中使用与 rest 参数相同的语法，将一个数组的剩余元素放入另一个数组中。这里有一个例子:

```java
let [first, ...others] = ['Traveling', 'Swimming', 'Shopping'];
console.log(others);   // ["Swimming", "Shopping"]
```

如您所见，数组的第二项和第三项被复制到了`others`变量中。我们可以使用这个语法来复制一个数组。然而，这只是一个肤浅的克隆。当数组的元素是对象时，对复制的数组的对象属性的更改将在原始数组中看到，因为本质上，两个数组的元素引用同一个对象。这里有一个例子:

```java
1\. const fruits = [{name:'Apple', price:100},{name:'Orange', price:80}];
2\. let [...myFruits] = fruits;
3\. console.log(myFruits[0].name);            // Apple
4\. myFruits.push({name:'Banana', price:90});
5\. console.log(myFruits.length);             // 3
6\. console.log(fruits.length);               // 2
7\. myFruits[0].price = 110;
8\. console.log(fruits[0].price);             // 110
```

正如你在第`2`行看到的，我们使用析构赋值语法将`fruits`数组复制到`myFruits`数组中。向复制的数组中添加一个新项不会影响原始数组，正如您在第`4`到`6`行中看到的。但是，从复制的数组中更改`price`属性的值也会在原始数组中看到。

# 函数参数析构

您也可以对函数参数应用析构赋值。让我们看下面的例子:

```java
1\. function workout({gym}, times) {
2\.   console.log('Workout in ' + gym + ' for ' + times + ' times');
3\. }
4\. let thisWeek = {gym: 'Gym A'};
5\. workout(thisWeek, 2);   // Workout in Gym A for 2 times
```

如你所见，在第`1`行，我们使用对象析构语法从`workout()`函数的第一个参数中提取`gym`变量。这样，传递给`workout()`函数的参数不能是`null`或`undefined`。否则会抛出`TypeError`。您可以将一个数字、一个字符串、一个数组或一个函数传递给`workout()`函数，JavaScript 不会对此有所抱怨，尽管您将获得`undefined`作为`gym`变量的值。

让我们看另一个例子，我们将对一个被析构的变量进行进一步的析构:

```java
1\. function workout({gym, todos}) {
2\.   let [first] = todos;
3\.   console.log('Start ' + first + ' in ' + gym);
4\. }
5\. let today = {gym: 'Gym A', todos: ['Treadmill']};
6\. workout(today);         // Start Treadmill in Gym A
7\. workout({gym: 'Gym B'}) // throw TypeError
```

在第`1`行，我们对第一个参数进行了参数析构，在第`2`行，我们对`todos`变量进行了进一步的析构。这样，传递给`workout()`函数的参数必须有一个`todos`属性，并且它的值是一个数组。否则，`TypeError`将被抛出，如第`7`行所示。这是因为，在第`2`行，JavaScript 不能对`undefined`或`null`进行析构。我们可以通过给`todos`一个默认值来改善这一点，如下所示:

```java
1\. function workout({gym, todos=['Treadmill']}) {
2\.   let [first] = todos;
3\.   console.log('Start ' + first + ' in ' + gym);
4\. }
5\. workout({gym: 'Gym A'});  // Start Treadmill in Gym A
6\. workout();                // throw TypeError
```

正如你所看到的，在第`1`行，我们只给了`todos`一个默认值，我们必须调用带有参数的`workout()`函数。不带任何参数调用它，如第`6`行，仍然会抛出一个错误。这是因为 JavaScript 仍然不能对`undefined`进行析构来获取`gym`变量的值。而如果你试图给`gym`本身赋一个默认值，比如`workout({gym='', ...)`，那就不行。您需要将整个参数析构赋值为默认值，如下所示:

```java
function workout({gym='', todos=['Treadmill']} = {}) {
  ...
}
```

# 模板文字

模板文字提供了在字符串文字中嵌入表达式的能力，并支持多行。语法是使用反勾(```java)字符来括住字符串，而不是单引号或双引号。这里有一个例子:

```
let user = {
  name: 'Ted',
  greeting () {
    console.log(`Hello, I'm ${this.name}.`);
  }
};
user.greeting();  // Hello, I'm Ted.
```java

如您所见，在模板文字中，您可以通过使用语法`${...}`经由`this`访问执行上下文。这是另一个多行的例子:

```
let greeting = `Hello, I'm ${user.name}.
Welcome to the team!`;
console.log(greeting);  // Hello, I'm Ted.
                        // Welcome to the team!
```java

需要注意的是，反勾字符中的所有空格都是输出的一部分。因此，如果您按如下方式缩进第二行，输出看起来不会很好:

```
let greeting = `Hello, I'm ${user.name}.
 Welcome to the team!`;
console.log(greeting); // Hello, I'm Ted.
                       //                Welcome to the team! 
```java

# 模块

在 ES6 中，JavaScript 为模块提供了语言级别的支持。它使用`export`和`import`来组织模块并创建静态模块结构。这意味着您可以在编译时确定导入和导出。ES6 的模块的另一个重要特性是导入和导出必须在顶层。你不能将它们嵌套在像`if`和`try/catch`这样的区块中。

除了导入和导出的静态声明，还有一个建议是使用`import()`操作符以编程方式加载模块。在撰写本报告时，该提案正处于 TC39 流程的第 3 阶段。你可以在 https://github.com/tc39/proposal-dynamic-import 的[查看详情。](https://github.com/tc39/proposal-dynamic-import)

要创建一个模块，你需要做的就是把你的 JavaScript 代码放到一个`.js`文件中。可以选择使用 Babel ( [http://babeljs.io](http://babeljs.io) )等工具将 ES6 代码编译成 ES5，再配合 web pack([https://webpack.js.org](https://webpack.js.org))等工具将代码捆绑在一起。或者，使用模块文件的另一种方式是使用`<script type="module">`将它们加载到浏览器中。

# 出口

在模块内部，您可以选择不导出任何内容。或者，您可以导出原始值、函数、类和对象。有两种类型的导出—命名导出和默认导出。同一模块中可以有多个命名导出，但该模块中只能有一个默认导出。

在下面的例子中，我们将创建一个导出`User`类的`user.js`模块，一个跟踪已完成任务总数的`tasks.js`模块，以及一个导出角色常量的`roles.js`模块。

让我们看看`user.js`文件:

```
1\. export default class User {
2\.   constructor (name, role) {
3\.     this.name = name;
4\.     this.role = role;
5\.   }
6\. };
```java

在这个模块中，我们通过将关键字`export`和`default`放在前面，将`User`类内联导出为默认导出。您可以先声明`User`类，然后在底部导出它，或者在模块的顶层导出，甚至在`User`类之前，而不是在内联中声明`export`。

让我们看看`roles.js`文件:

```
1\. const DEFAULT_ROLE = 'User';
2\. const ADMIN = 'Admin';
3\. export {DEFAULT_ROLE as USER, ADMIN};
```java

在这个模块中，我们创建了两个常量，然后通过将它们放在花括号中，在一个列表中使用命名导出来`export`它们。是的，在大括号里。不要认为它们是导出一个对象。正如你在第`3`行看到的，我们可以在`export`期间重命名东西。我们也可以用`import`来重命名。我们很快会谈到这一点。

让我们看看`tasks.js`文件:

```
1\. console.log('Inside tasks module');
2\. export default function completeTask(user) {
2\.   console.log(`${user.name} completed a task`);
3\.   completedCount++;
4\. }
5\. // Keep track of the count of completed task
6\. export let completedCount = 0;
```java

在这个模块中，在第`2`行，我们有一个`completeTask`函数的默认导出和第`6`行的一个`completedCount`变量的命名导出。

# 导入

现在，让我们创建一个模块`app.js`来导入我们刚刚创建的模块。

让我们看看`app.js`文件:

```
1\.  import User from './user.js';    
2\.  import * as Roles from './roles.js';
3\.  import completeTask from './tasks.js';
4\.  import {completedCount} from './tasks.js';
5\. 
6\.  let user = new User('Ted', Roles.USER);     
7\.  completeTask(user);    
8\.  console.log(`Total completed ${completedCount}`);
9\.  // completedCount++; 
10\. // Only to show that you can change imported object.
11\. // NOT a good practice to do it though.
12\. User.prototype.walk = function () {
13\.   console.log(`${this.name} walks`);
14\. };
15\. user.walk();
```java

在第`1`行，我们使用`default import`从`user.js`模块导入`User`类。您可以在这里使用不同于`User`的名称，例如`import AppUser from './user.js'`。`default import`不必与默认导出中使用的名称匹配。

在`2`行中，我们使用`namespace import`来导入`roles.js`模块，并将其命名为`Roles`。正如你从第`6`行看到的，我们使用点符号访问`roles.js`模块的命名导出。

在第`3`行，我们使用`default import`从`tasks.js`模块导入`completeTask`函数。在第`4`行，我们使用`named import`再次从同一个模块导入`completedCount`。因为 ES6 模块是单例的，所以即使我们在这里导入两次，`tasks.js`模块的代码也只求值一次。当我们运行它时，您将在输出中只看到一个`Inside tasks module`。可以把`default import`和`named import`放在一起。以下等同于前面的行`3`和`4`:

```
import completeTask, {completedCount} from './tasks.js';
```java

您可以重命名一个`named import`，以防它与模块中的其他本地名称冲突。例如，您可以像这样将`completedCount`重命名为`totalCompletedTasks`:

```
import {completedCount as totalCompletedTasks} from './tasks.js';
```java

就像函数声明一样，导入是被吊起来的。所以，如果我们像这样把第`1`行放在第`6`行之后，它仍然有效。但是，这不是组织导入的推荐方式。最好将所有的导入放在模块的顶部，这样就可以一眼看到依赖关系:

```
let user = new User('Ted', Roles.USER);        
import User from './user.js';    
```java

继续使用`app.js`模块。在第`7`行，我们调用了`completeTask()`函数，它增加了`tasks.js`模块中的`completedCount`。由于它被导出，您可以在另一个模块中看到`completedCount`的更新值，如第`8`行所示。

第`9`行被注释掉。我们试图直接改变`completedCount`，但没有成功。如果你取消注释，当我们稍后运行这个例子时，你会看到`TypeError`，说你不能修改一个常量。等等。`completedCount`由`tasks.js`模块内的`let`定义；它不是一个常数。这里发生了什么？

进口申报有两个目的。一个是很明显的，告诉 JavaScript 引擎需要导入什么模块。第二个是告诉 JavaScript 其他模块的导出应该是什么名字。JavaScript 将用这些名称创建常量，这意味着您不能重新分配它们。

然而，这并不意味着您不能更改导入的内容。从第`12`行到第`15`行可以看到，我们将`walk()`方法添加到了`User`类原型中。您可以从稍后将展示的输出中看到，在第`6`行中创建的`user`对象立即拥有了`walk()`方法。

现在，让我们在 HTML 页面中加载`app.js`模块，并在 Chrome 中运行它。

下面是`index.html`文件:

```
1\. <!DOCTYPE html>
2\. <html>
3\. <body>
4\.   <script type="module" src="./app.js"></script>
5\.   <script>console.log('A embedded script');</script>
6\. </body>
7\. </html>
```java

在第`4`行中，我们用`<script type="module">`将`app.js`作为一个模块加载到浏览器中，这是在 HTML 中指定的，默认情况下具有`defer`属性，这意味着浏览器将在解析完 DOM 后执行该模块。您将在输出中看到，脚本代码行`5`将在`app.js`内的代码之前执行。

以下是本示例中的所有文件:

```
/app.js
/index.html
/roles.js
/tasks.js
/user.js
```java

您需要从 HTTP 服务器(如 NGINX)运行它。在 Chrome 中直接以文件形式打开`index.html`是行不通的，因为有 **CORS** (简称**跨源资源共享**)政策，我们将在另一章中讨论。

如果您需要快速启动一个简单的 HTTP 服务器，您可以使用`http-server`，它不需要任何配置，只需一个命令就可以启动。首先你需要安装 Node.js，然后运行`npm install http-server -g`。一旦安装完成，切换到包含示例代码的文件夹，运行`http-server -p 3000`，然后在 Chrome 中打开`http://localhost:3000`。

您需要进入 Chrome 的开发者工具来查看输出，类似于以下内容:

```
A embedded script
Inside tasks module
Ted completed a task
Total completed 1
Ted walks
```java

从输出中可以看到，浏览器推迟了模块代码的执行，而脚本代码立即执行，`tasks.js`模块只求值一次。

从 ES6 开始，JavaScript 有两种类型——脚本和模块。与脚本代码不同，在脚本代码中，您需要将`'use strict';`放在文件的顶部，以严格模式呈现代码，而模块代码自动处于严格模式。并且一个模块的顶层变量对于该模块来说是局部的，除非你使用`export`使它们对外部可用。并且，在模块的顶层，`this`指的是`undefined`。在浏览器中，你仍然可以访问一个模块中的`window`对象。

# 承诺

承诺是 JavaScript 中除回调、异步编程事件之外的另一种选择。在 ES6 之前，像`bluebird`([http://bluebirdjs.com](http://bluebirdjs.com))这样的库提供了与 promises/A+规范兼容的 Promises。

承诺表示异步操作的最终结果，如承诺/A+规范中所述。结果可能是成功完成，也可能是失败。它还提供了像`.then()`和`.catch()`这样的方法，将多个异步操作链接在一起，使代码类似于同步代码，易于理解。

ES6 promises 的特性是`bluebird`等库提供的特性的子集。在本书中，我们使用的承诺是 ES6 语言规范中定义的，除非另有说明。

让我们看一个例子，在这个例子中，我们将从服务器获取一个项目列表，然后在一个单独的 API 调用中从服务器获取这些项目的任务。然后我们会渲染它。这里的实现是一个简化版本，用于演示使用回调和承诺之间的区别。我们使用`setTimeout`来模拟异步操作。

首先，我们来看看使用回调的版本:

```
1\.  function getProjects(callback) {
2\.    // Use setTimeout to stimulate calling server API
3\.    setTimeout(() => {
4\.      callback([{id:1, name:'Project A'},{id:2, name:'Project B'}]);
5\.    }, 100);
6\.  }
7\.  function getTasks(projects, callback) { 
8\.    // Use setTimeout to stimulate calling server API
9\.    setTimeout(() => {
10\.     // Return tasks of specified projects
11\.     callback([{id: 1, projectId: 1, title: 'Task A'}, 
12\.               {id: 2, projectId: 2, title: 'Task B'}]);
13\.   }, 100);    
14\. }
15\. function render({projects, tasks}) {
16\.   console.log(`Render ${projects.length} projects and 
      ${tasks.length} tasks`);
17\. }
18\. getProjects((projects) => {
19\.   getTasks(projects, (tasks) => {
20\.     render({projects, tasks});
21\.   });
22\. });
```java

正如您在第`18`到`22`行中看到的，我们使用回调来组织异步调用。尽管这里的代码被大大简化了，但您仍然可以看到`getProjects()`、`getTasks()`和`render()`方法是嵌套的，创建了一个厄运金字塔或回调地狱。

现在，让我们看看使用承诺的版本:

```
1\.  function getProjects() {
2\.    return new Promise((resolve, reject) => {
3\.      setTimeout(() => {
4\.        resolve([{id:1, name:'Project A'},{id:2, name:'Project B'}]);
5\.      }, 100);
6\.    }); 
7\.  }
8\.  function getTasks(projects) {
9\.    return new Promise((resolve, reject) => {
10\.     setTimeout(() => {
11\.       resolve({projects, 
12\.                tasks:['Buy three tickets', 'Book a hotel']});
13\.     }, 100);
14\.   });
15\. }
16\. function render({projects, tasks}) { 
17\.   console.log(`Render ${projects.length} projects and ${tasks.length} tasks`);
18\. }
19\. getProjects()
20\. .then(getTasks)
21\. .then(render)
22\. .catch((error) => {
23\.   // handle error
24\. });
```

在第`1`到`15`行中，在`getProjects()`和`getTasks()`方法中，我们将异步操作包装在一个立即返回的`Promise`对象中。`Promise`构造函数将一个函数作为其参数。这个函数被称为 executor 函数，它使用两个参数立即执行，一个`resolve`函数和一个`reject`函数。这两个功能由`Promise`实现提供。当异步操作完成时，您调用带有操作结果的`resolve`函数，或者根本没有结果。并且当操作失败时，可以使用`reject`功能拒绝承诺。在 executor 函数中，如果抛出任何错误，承诺也会被拒绝。

承诺处于以下三种状态之一:

*   **待定**:承诺的初始状态
*   **完成**:操作成功完成的状态
*   **拒绝**:由于错误或其他原因，操作没有成功完成的状态

您不能以编程方式获得承诺的状态。相反，您可以使用 promise 的`.then()`方法在状态变为 fulfilled 时采取行动，并使用`.catch()`方法在状态变为 rejected 或在操作过程中抛出错误时做出反应。

一个`promise`对象的`.then()`方法将两个函数作为它的参数。当承诺实现时，调用参数中的第一个函数。所以通常引用为`onFulfilled`，第二个在拒绝承诺时调用，通常引用为`onRejected`。这个`.then()`方法也将返回一个`promise`对象。正如您在第`19`到`21`行中看到的，我们可以使用`.then()`来链接所有的操作。第`22`行的`.catch()`方法其实是`.then(undefined, onRejected)`的一个语法糖。在这里，我们把它作为捕捉所有拒绝和错误的最后一个环节。您也可以在`.catch()`后添加`.then()`进行进一步的操作。

ES6 `Promise`还提供了`.all(iterable)`方法来聚合多个承诺的结果，并提供了`.race(iterable)`方法来返回一个承诺，该承诺在 iterable 中的一个承诺履行或拒绝时立即履行或拒绝。

ES6 `Promise`提供的另外两个方法是`.resolve(value)`方法和`.reject(reason)`方法。`.resolve(value)`方法返回一个`Promise`对象。当`value`是一个承诺时，返回的承诺将采用它的最终状态。也就是你调用返回承诺的`.then()`方法的时候；`onFulfilled`处理程序将获得价值承诺的结果。当值不是承诺时，返回的承诺处于已履行状态，其结果是一个值。`.reject(reason)`方法返回一个处于被拒绝状态的承诺，并传入`reason`来指示它被拒绝的原因。

您可能已经注意到，承诺并不能帮助您编写更少的代码，但是它们确实可以通过提供一种更好的组织代码流的方式来帮助您提高代码的可读性。

# 摘要

在这一章中，你学习了 JavaScript 语言和 Java 语言之间的区别。请记住这些差异。它们可以帮助您在编写 JavaScript 代码时避免陷阱。

您还学习了 ES6 的基础知识。精通 ES6 被认为是 web 开发人员应该具备的基本技能之一。使用 ES6，您可以编写更少的代码，也可以编写更好的代码。

下一章，你将学习 Vue.js 2 的基本概念，你将能够理解 Vue.js 2 内部是如何工作的，成为 Vue.js 的大师。