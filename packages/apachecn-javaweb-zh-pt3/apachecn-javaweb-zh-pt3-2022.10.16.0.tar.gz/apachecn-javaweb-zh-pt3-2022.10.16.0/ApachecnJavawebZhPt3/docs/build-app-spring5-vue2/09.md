# 九、表单和验证——从注册页面开始

表单是 web 应用的基本元素，数据验证是 web 应用中最基本的安全机制。在处理用户输入之前，必须对其进行验证。我们将从注册页面开始执行 **TaskAgile** 。在这一章中，我们将着重于构建注册表单，并在前端和后端验证输入。在这个过程中，我们将在构建注册页面时练习 TDD，并不断记录代码提交，以便您可以轻松地检查每个步骤的细节。

在本章中，您将学习以下内容:

*   如何用 Bootstrap 4 构建 UI
*   如何用 Vue.js 构建表单
*   如何使用 Vuelidate 在前端进行验证
*   如何使用 Bean 验证在后端进行验证
*   如何在域模型中实现注册
*   如何进行全套单元测试

在这一章中，我们有许多事情要完成。让我们开始吧。

# 用 Bootstrap 4 构建 UI

bootstrap([http://getbootstrap.com](http://getbootstrap.com))很流行也很有用。它改变了为 web 应用构建 ui 的方式。正如您将在我们实现 UI 时看到的，Bootstrap 可以通过提供覆盖 UI 开发大部分部分的特性来提高我们的生产率。它是高度可定制的，允许我们创建不同的主题。在本节中，我们将学习如何将 Bootstrap 导入到 Vue 应用中，并使用它来构建注册页面。我们还将更改 webpack 的配置，以在单独的`.css`文件中保存引导程序的样式。

# 安装和使用引导程序

首先，让我们通过运行以下命令将引导及其依赖项安装到我们的`frontend`目录中:

```java
npm install jquery popper.js bootstrap --save
```

一旦安装完毕，我们需要将 Bootstrap 编译好的 CSS 导入到我们的应用中。有许多方法可以使用 webpack 导入 Bootstrap。这里我们将使用的方法是在 webpack 中创建一个新条目，将所有第三方样式分组到一个单独的`.css`文件中。以下是对`frontend/vue.config.js`的改动:

```java
module.exports = {
  ...
  configureWebpack: {
 entry: {
 app: './src/main.js',
 style: [
 'bootstrap/dist/css/bootstrap.min.css'
 ]
 }
 }
}
```

如您所见，我们在新条目`style`中列出了`bootstrap.min.css`文件。需要的时候我们会在这里添加其他第三方库的样式。现在，如果您执行`npm run serve`并在`http://localhost:3000/login`打开登录页面，您可以看到文本 TaskAgile 的字体和大小已经更改为 Bootstrap 默认主题定义的样式。

# 实现注册页面的用户界面

现在，我们已经准备好引导。让我们使用它来创建注册页面，它看起来像下图所示的 UI 设计:

![](img/d897a33b-1349-43ce-bde2-e8221b09b942.png)

图 9.1:注册页面的用户界面

如您所见，在这个页面上，我们有一个徽标、一个标语、三个字段和一个提交按钮。还有一些文本、链接和一个简单的页脚。该页面的主要部分是注册表，位于屏幕的中间。在我们写任何代码之前，让我们看看我们将如何构造这个页面的布局。

首先，我们将把页面上的所有内容包装在一个容器中。在 Bootstrap 中，容器是最基本的布局元素，当我们需要使用 Bootstrap 的默认网格系统时，容器是必需的，它是基于 flexbox 的和移动友好的。基本上，网格系统是一种使用行来垂直划分页面的系统，在每行内部，它使用一个*十二列系统*来水平划分该行。在我们的 UI 中，徽标、标语和注册表单在页面中央对齐。因此，我们将它们放在同一个包装器中，这将是一个`<div>`标签。我们将把页脚放在一个`<footer>`标签中。这是布局的高级概述。让我们潜入更深的地方。

# 创建布局图

为了更好地理解页面的布局和元素，让我们画一个布局图来分解结构。在这个图中，我们不需要包括将出现在页面上的每个元素。我们只需要那些对我们来说足够好的来验证我们如何构造 UI 的计划。我们将为图中的每个元素命名，这将是我们将在代码中使用的它们的类名。这种绘制布局图的实践可以被看作是代码编写的一种预演。对于那些不熟悉前端开发的开发人员是有帮助的。有时候，有经验的前端工程师也会发现它在构建复杂 UI 时很有用。一旦你完成了图表，你将能够更自信更快速地编写你的代码。

*图 9.2* 是注册页面的布局图:

![](img/4326f685-5484-4eaa-a986-b618e007a207.png)

图 9.2:注册页面的布局

正如您所看到的，在这个图中，我们只包括高级结构元素，除了底部的`.copyright`。一切都包裹在`.container`里面。我们将页面的主体放在`.row`中，页脚单独放在`.footer`中。`.register-form`用于将徽标、标语和表单组合在一起。它也有助于保持固定的宽度，并被定位在中心水平。现在，这看起来足够好了，所以让我们写代码。

# 寄存器页面的 TDD

我们将首先编写的代码是单元测试代码。如果你以前没有做过，实践 TDD 可能会很难。如果你与它抗争，它会变得更难，更烦人，更浪费时间。然而，通过简单的心态改变和几轮实践，你可能会认为这是一种非常有价值的技术，尤其是对于敏捷项目。我们不会在这里详细讨论实践 TDD 的好处，因为我们正在这本书里实践它，希望在旅程结束时，你能自己看到这些好处。现在，只要把所有这些单元测试方法想象成迷你 QA 机器人，它将在我们每次运行`mvn clean install`命令时帮助我们检查应用的健康状况。

我们将在`frontend/src/views/RegisterPage.vue`文件中创建注册页面，在`frontend/test/unit/RegisterPage.spec.js` 文件中创建单元测试代码。在这个单元测试中，在这个阶段，我们只需要验证注册表单元素的存在，包括徽标、标语、三个字段和提交按钮。下面是`RegisterPage.spec.js`的样子:

```java
import Vue from 'vue'
import RegisterPage from '@/views/RegisterPage'

describe('RegisterPage.vue', () => {
  it('should render correct contents', () => {
    const Constructor = Vue.extend(RegisterPage)
    const vm = new Constructor().$mount()
    expect(vm.$el.querySelector('.logo').getAttribute('src'))
      .toEqual('/statimg/logo.png')
    expect(vm.$el.querySelector('.tagline').textContent)
      .toEqual('Open source task management tool')
    expect(vm.$el.querySelector('#username').value).toEqual('')
    expect(vm.$el.querySelector('#emailAddress').value).toEqual('')
    expect(vm.$el.querySelector('#password').value).toEqual('')
    expect(vm.$el.querySelector('form 
    button[type="submit"]').textContent)
      .toEqual('Create account')
  })
})
```

正如你所看到的，类似于如何在`LoginPage.spec.js`中编写测试，我们用`RegisterPage.vue`创建一个 Vue 子类并挂载它，然后使用`querySelector()` API 验证元素的存在。这对于一个简单的测试来说很好，就像我们现在做的一样。在本章的后面，我们将使用`vue-test-utils`提供的 API 来创建更复杂的测试。

# 实现用户界面

现在，如果您运行`npm test`命令，您可以看到我们有一个失败的测试。让我们写`RegisterPage.vue`让测试通过。

下面这段代码是`RegisterPage.vue`的`<template>`段。为了简洁起见，这里排除了一些细节:

```java
<template>
  <div class="container">
    <div class="row justify-content-center">
      <div class="register-form">
        <div class="logo-wrapper">...</div>
        <form>
          <div class="form-group"></div>
          <div class="form-group"></div>
          <div class="form-group"></div>
          <button type="submit" class="btn btn-primary btn-block">
          </button>
          ... 
        </form>
      </div>
    </div>
    <footer class="footer">
      <span class="copyright">...</span>
      <ul class="footer-links list-inline float-right">...</ul>
    </footer>
  </div>
</template>
```

如您所见，为了将`.row`元素中的内容保持在中间，我们使用了`.justify-content-center`类，这是 Bootstrap 的另一个实用程序类。在`<form>`内部，我们将`.form-group`类添加到每个字段的包装器中。这样，Bootstrap 将为我们很好地组织这些字段的填充和边距。在页脚，我们将`span`和`.copyright`类一起使用。`<span>`非常适合这里，因为版权信息只是内联显示的文本，这是`<span>`标签的默认样式。我们使用`<ul>`作为页脚链接，因为它们本质上是水平显示的无序条目列表。Bootstrap 的`.list-inline`非常适合这个场景。在`.float-right`类的帮助下，我们可以轻松的将列表拉到右边。

下面是我们需要添加到`RegisterPage.vue`的`<style>`部分的自定义样式。下面的列表只包括那些与结构相关的样式，每个类都被重新格式化为一行:

```java
<style lang="scss" scoped>
.container {max-width: 900px;}
.register-form {margin-top: 50px; max-width: 320px;}
.logo-wrapper {margin-bottom: 40px;}
.footer {width: 100%; line-height: 40px; margin-top: 50px; }
</style>
```

如你所见，我们将容器的最大宽度设置为 900 像素，将`.register-form`设置为 320 像素。我们在这些结构类中使用边距来保持元素之间的距离。现在，让我们运行`npm test`，正如你将看到的，我们有一个绿色的结果。我们需要做的最后一件事是将`RegisterPage.vue`添加到`/register`路径的路由器中。这一步的细节不会在本书中涉及。您可以在代码提交记录中找到它们，以及我们跳过的注册页面的其他细节。

到目前为止，我们已经完成了注册页面 UI 的大部分创建工作。如您所见，我们利用了许多 Bootstrap 的内置类，这提高了我们的生产率。让我们运行`mvn clean install`命令来确保在提交代码之前没有意外引入代码中断。如你所见，我们已经成功构建了。*图 9.3* 是提交记录:

![](img/bc6c6c02-1665-4913-b0c5-293deb2569c5.png)

图 9.3:实现注册页面提交的用户界面

# 用 Vue.js 构建注册表单

当我们创建注册页面的 UI 时，我们没有添加任何行为。在本节中，我们将添加获取表单中字段值的功能、处理 Create account 按钮上的 click 操作的功能以及将注册数据发送到后端的功能。

以下是我们需要做的细节。首先，我们将在 Vue 实例的`data`属性中创建一个具有这三个属性的`form`对象:`username`、`emailAddress`和`password`。这些属性的初始值将是空字符串。我们将它们绑定到表单的输入字段。之后，我们将创建一个`submitForm()`方法来处理表单的提交事件。在`submitForm()`方法内部，我们将调用注册服务的`register()`方法，该方法将被写入`frontend/src/services/registration/index.js`文件。在该服务中，我们将使用`axios`将注册细节发送到后端。

# 为表单编写测试代码

现在是 TDD 时间。让我们将更多的测试写入`RegisterPage.spec.js`。我们需要创建的测试包括以下内容:

*   测试数据模型的初始值
*   测试表单输入字段和数据模型之间的绑定
*   测试窗体的事件处理程序是否存在

包括前面用来验证表单呈现的测试，在本规范中我们将有四个测试。是时候对测试规范本身做一些重构了。如前所述，我们还将使用 Vue.js 的官方单元测试实用程序库`vue-test-utils`。在开始重构之前，让我们使用下面的命令来安装这个库:

```java
npm install @vue/test-utils --save-dev
```

完成后，让我们将`RegisterPage.spec.js`重构如下:

```java
1\.  import { mount } from '@vue/test-utils'
2\.  import RegisterPage from '@/views/RegisterPage'
3\. 
4\.  describe('RegisterPage.vue', () => {
5\.    let wrapper
6\.    let fieldUsername
7\.    let fieldEmailAddress
8\.    let fieldPassword
9\.    let buttonSubmit
10.
11\.   beforeEach(() => {
12\.     wrapper = mount(RegisterPage)
13\.     fieldUsername = wrapper.find('#username')
14\.     fieldEmailAddress = wrapper.find('#emailAddress')
15\.     fieldPassword = wrapper.find('#password')
16\.     buttonSubmit = wrapper.find('form button[type="submit"]')
17\.   })
18.
19\.   it('should render registration form', () => {
20\.     expect(wrapper.find('.logo').attributes().src)
21\.       .toEqual('/statimg/logo.png')
22\.     expect(wrapper.find('.tagline').text())
23\.       .toEqual('Open source task management tool')
24\.     expect(fieldUsername.element.value).toEqual('')
25\.     expect(fieldEmailAddress.element.value).toEqual('')
26\.     expect(fieldPassword.element.value).toEqual('')
27\.     expect(buttonSubmit.text()).toEqual('Create account')
28\.   })
29.})
```

如你所见，在第`1`行，我们从`vue-test-utils`导入了`mount`函数。这个`mount`函数将创建一个`Wrapper`对象，其中包含已安装和渲染的`RegisterPage.vue`组件，正如您将在第`12`行中看到的。从第`5`行到第`9`行，我们创建需要初始化并在测试中使用的变量。从第`11`行到第`17`行，我们添加了`beforeEach()`来初始化`RegisterPage.spec.js`中每次测试前的变量。这样，我们可以确保这些变量不会受到本规范文件中其他测试的影响。`wrapper.find()`是`vue-test-utils`的 API，用于查找与选择器匹配的 HTML 元素。这个 API 的结果也是一个`Wrapper`对象，可以用来从它包装的 HTML 元素中检索我们需要的内容。在第`20`行到第`27`行之间，我们用`Wrapper`对象的 API 替换旧的`vm.$el.querySelector`。我们可以使用`wrapper.element`来访问这个包装器的根`HTMLElement`，我们可以使用`wrapper.text()`来返回一个包装器的文本内容，并使用`wrapper.attributes()`来获取 DOM 节点的属性。

现在，让我们使用`npm run test:unit`命令再次运行测试，以确保重构后我们仍然有一个绿色的结果。正如你应该看到的，一切看起来都很好。让我们开始添加另外三个新的测试。

第一个是测试数据模型的初始值，如下所示:

```java
it('should contain data model with initial values', () => {
  expect(wrapper.vm.form.username).toEqual('')
  expect(wrapper.vm.form.emailAddress).toEqual('')
  expect(wrapper.vm.form.password).toEqual('')
})
```

如您所见，我们通过`wrapper.vm`访问 Vue 实例，从那里我们可以访问被包装的`vm`的所有方法和属性。如您所见，我们通过`wrapper.vm.form`访问`username`、`emailAddress`和`password`属性，以验证它们都是用空字符串初始化的。

下一个测试是验证数据模型与表单输入的绑定。下面是测试的样子:

```java
it('should have form inputs bound with data model', () => {
  const username = 'sunny'
  const emailAddress = 'sunny@local'
  const password = 'VueJsRocks!'

  wrapper.vm.form.username = username
  wrapper.vm.form.emailAddress = emailAddress
  wrapper.vm.form.password = password
  expect(fieldUsername.element.value).toEqual(username)
  expect(fieldEmailAddress.element.value).toEqual(emailAddress)
  expect(fieldPassword.element.value).toEqual(password)
})
```

正如您所看到的，在测试的开始，我们为数据模型中的这三个字段分配了新的值。通过绑定，这些字段应该分别得到更新。我们可以通过检查这些输入字段的值来验证这一点，看看它们是否与我们分配给数据模型的值相匹配。

我们需要添加的最后一个测试是检查提交处理程序是否存在。测试看起来像这样:

```java
it('should have form submit event handler `submitForm`', () => {
  const stub = jest.fn()
  wrapper.setMethods({submitForm: stub})
  buttonSubmit.trigger('submit')
  expect(stub).toBeCalled()
})
```

如您所见，我们使用 Jest 创建了`stub`，然后通过使用包装器的`setMethods()` API，用这个存根替换原来的提交处理程序`submitForm`。然后，我们使用`buttonSubmit`来触发提交事件，然后验证`stub`已经被调用。

现在，我们的测试准备好了。让我们实现已经在`RegisterPage.vue`中测试过的特性，以使测试通过。

# 实现表单绑定

首先，让我们将三个字段添加到数据模型中，如下所示:

```java
export default {
  name: 'RegisterPage',
  data: function () {
    return {
      form: {
 username: '',
 emailAddress: '',
 password: ''
 }
    }
  }
}
```

有了这个改变，我们刚刚添加的第一个测试现在应该可以通过了。让我们运行`npm run test:unit`命令来验证一下。结果，您应该会看到如下所示的内容:

```java
Tests:       2 failed, 3 passed, 5 total
```

我们在这方面取得了一些进展。现在，让我们将数据模型绑定到表单中的输入，并添加`submitForm()`方法来处理表单提交事件。以下是对`RegisterPage.vue`的改动:

```java
<template>
  ...
  <form @submit.prevent="submitForm">
    <div class="form-group">
      <input type="text" class="form-control" 
        id="username" v-model="form.username">
    </div>
    <div class="form-group">
      <input type="email" class="form-control" 
        id="emailAddress" v-model="form.emailAddress">
    </div>
    <div class="form-group"> 
      <input type="password" class="form-control" 
        id="password" v-model="form.password">
    </div> 
  </form>
  ...
</template>
<script>
export default {
  ...
  methods: {
    submitForm () {
    }
  }
}
</script>
```

在前面的清单中，为了简洁起见，我们排除了表单中不必要的细节。如您所见，我们使用`@submit.prevent`指令将提交事件绑定到`submitForm()`方法。目前，处理程序的实现是空白的。我们使用`v-model`指令将输入字段与数据模型绑定在一起。有了所有这些改变，`RegisterPage.spec.js`中的所有四个测试都应该能够通过。现在，让我们运行单元测试，您应该会看到所有的测试都通过了。

# 处理表单提交

此时，我们的注册表单已经准备好接收输入并处理提交。我们可以继续实现向后端发送数据的逻辑，这从`submitForm()`方法开始。在这个方法中，我们可以使用 HTTP 客户端`axios`直接完成繁重的工作，正如我们在[第 3 章](03.html)、 *Spring 5 -手头工作的正确栈*中已经介绍的那样。这一次，我们将用不同的方式使用它。我们将在`frontend/src/services/registration/index.js`文件中创建一个名为`registrationService`的服务，来包装如何使用`axios`发送 HTTP 请求的细节。这样做的好处是，我们对`RegisterPage.vue`隐藏了与服务器通信的实现，这样，一旦我们需要改变一些与发送 HTTP 请求相关的事情，而`RegisterPage.vue`不需要知道，我们可以将这些改变隔离在`registrationService`内部，防止它们脱离服务。

在`submitForm()`方法中，我们将使用`vm.form`对象调用`registrationService.register()`方法。注册成功后，我们会将用户重定向到登录页面。当它失败时，我们将在 UI 中的表单上方显示一条错误消息。

现在，我们清楚了需要实现什么。让我们想想我们需要测试什么。主要有两部分:`submitForm()`方法和`registrationService.register()`方法。先说第一个。

# 测试 submitForm()方法

我们需要在测试中涵盖两种场景。一个是注册成功，一个是注册失败。我们的应用在这两种情况下表现不同。我们最好对每个场景使用单独的测试。

在对`submitForm()`方法的测试中，我们将通过创建一个服务的模拟来将方法本身从它的依赖项`registrationService`中分离出来。这样，我们可以定义依赖的行为，并确保它不会影响测试结果。使用 Jest，我们需要将模拟放在与依赖项相同的目录下的一个名为`__mocks__`的文件夹中。以下是`registrationService`及其模仿的路径:

```java
frontend/src/services/registration/index.js
frontend/src/services/registration/__mocks__/index.js
```

下面是模拟的样子:

```java
export default {
  register (detail) {
    return new Promise((resolve, reject) => {
      detail.emailAddress === 'sunny@local'
        ? resolve({result: 'success'})
        : reject(new Error('User already exist'))
    })
  }
}
```

如您所见，mock 拥有与`registrationService`完全相同的 API。`register()`方法是基于承诺的，它的实现非常简单。当邮件地址为`sunny@local`时，我们将注册成功；否则，我们将注册失败，并显示错误消息“用户已经存在”。

现在，让我们将`RegisterPage.spec.js`改为测试规格如下:

```java
import { mount, createLocalVue } from '@vue/test-utils'
import VueRouter from 'vue-router'

// Adding Vue Router to the test so that
// we can access vm.$router
const localVue = createLocalVue()
localVue.use(VueRouter)
const router = new VueRouter()

// Mock dependency registratioService
jest.mock('@/services/registration')

describe('RegisterPage.vue', () => {
  ...
  beforeEach(() => {
    wrapper = mount(RegisterPage, {
      localVue,
      router
    })
    ...
  })

  afterAll(() => {
    jest.restoreAllMocks()
  })
  ...
})
```

如您所见，我们从`vue-test-utils`导入了`createLocalVue`函数。顾名思义，这个函数创建一个本地 Vue 类，这样我们对这个本地`Vue`类所做的更改就不会影响实际的全局`Vue`类。我们也进口`VueRouter`。在`beforeEach()`方法中，我们为`mount`函数提供了本地`Vue`实例和`router`实例来创建`wrapper`。这里我们需要`router`实例的原因是，我们将使用它来检查是否发生了到登录页面的重定向。

我们使用`jest.mock('@/services/registration')`来准备我们之前创建的`registrationService`的模拟。我们通过调用`afterAll()`中的`jest.restoreAllMocks()`来恢复`registrationService`，一旦这个文件中的所有测试都执行完毕，就会调用这个函数。

现在，让我们实现用于验证成功注册的测试。测试方法如下所示:

```java
it('should register when it is a new user', () => {
  const stub = jest.fn()
  wrapper.vm.$router.push = stub
  wrapper.vm.form.username = 'sunny'
  wrapper.vm.form.emailAddress = 'sunny@local'
  wrapper.vm.form.password = 'Jest!'
  wrapper.vm.submitForm()
  wrapper.vm.$nextTick(() => {
    expect(stub).toHaveBeenCalledWith({name: 'LoginPage'})
  })
})
```

如您所见，我们存根了`vm.$router`的`push()`方法，以便我们可以检查重定向是否发生。在向数据模型提供值之后，我们调用`wrapper.vm.submitForm()`方法来触发表单提交。由于`registrationService.register()`方法是基于承诺的，我们需要将 expect 断言包装在`vm.$nextTick()`中，否则断言总是会失败。

以下是验证注册失败的测试:

```java
it('should fail it is not a new user', () => {
  // In the mock, only sunny@local is new user
  wrapper.vm.form.emailAddress = 'ted@local'
  expect(wrapper.find('.failed').isVisible()).toBe(false)
  wrapper.vm.submitForm()
  wrapper.vm.$nextTick(null, () => {
    expect(wrapper.find('.failed').isVisible()).toBe(true)
  })
})
```

如上所述，当注册失败时，我们会显示一条错误消息。因此，在这个测试中，在开始时，我们验证在调用`submitForm()`方法之前错误消息是不可见的。在`vm.$nextTick()`中，我们验证错误消息是可见的。

到目前为止，我们已经完成了`submitForm()`方法的测试。现在让我们实现`submitForm()`方法本身。

# 实现 submitForm()方法

如前所述，`submitForm()`方法的实现依赖于`registrationService`，这不是我们现在关注的重点；我们将简单地创建一个服务的空白实现。以下是`frontend/src/services/registration/index.js`的长相:

```java
export default {
  register (detail) {
    return new Promise((resolve, reject) => {
      resolve()
    })
  }
}
```

如您所见，它只是一个占位符，这已经足够让我们实现`submitForm()`方法并通过那些测试了。

以下是我们对`RegisterPage.vue`所做的更改:

```java
<template>
  ...
  <form @submit.prevent="submit">
    <div v-show="errorMessage" class="alert alert-danger failed">{{ 
    errorMessage }}</div>
    ...
  </form>
  ...
</template>

<script>
import registrationService from '@/services/registration'

export default {
  name: 'RegisterPage',
  data: function () {
    return {
      ...
      errorMessage: ''
    }
  },
  methods: {
    submitForm () {
      // TODO: Validate the data
      registrationService.register(this.form).then(() => {
        this.$router.push({name: 'LoginPage'})
      }).catch((error) => {
        this.errorMessage = 'Failed to register user. Reason: ' +
          (error.message ? error.message : 'Unknown') + '.'
      })
    }
  }
}
</script>
```

正如你所看到的，在`<form>`标签中，我们添加了一个`<div>`标签来显示错误消息，它将被 Bootstrap 的`.alert-danger`类高亮显示。错误消息的可见性由我们在数据模型中定义的`vm.errorMessage`控制。

在`submitForm()`方法中，现在，我们将注册细节`vm.form`传递给`registrationService`。注册成功后，我们会重定向用户。当它失败时，我们将显示错误消息。这就是我们通过测试所需要写的全部内容。运行`npm run test:unit`命令后，您应该看到所有的测试都通过了。

通常，当我们进行 TDD 时，会有几轮尝试和修正来使测试通过。我们跳过本书中的这些步骤，向您展示最终结果，我们将对本书中的其余测试进行同样的操作。如果你对学习如何一步一步地实践 TDD 感兴趣，强烈推荐 Kent Beck 的书，*Test-Driven Development by Example*。

让我们转到在前端实现注册过程的下一部分，即实现`registrationService.register()`方法。

# 与后端通信

在 TaskAgile 中，前端和后端之间的所有通信都将由我们放在`frontend/src/services`目录中的服务来处理。这些服务的所有方法都是基于承诺的，正如您在我们之前创建的`registrationService`的空白实现中看到的。

# 测试注册()方法

在写测试代码之前，让我们先讨论一下`registrationService.register()`方法的行为，这样我们就可以决定测试什么。本质上，这个方法将向后端发送一个 HTTP `POST`请求，然后将结果返回给调用者。该方法的依赖项是`axios`，需要对其进行模拟，以便我们可以隔离`register()`方法并测试其逻辑，而不受依赖项的影响。

让我们用以下命令安装模拟`axios`请求的`axios`和`moxios`:

```java
npm install axios --save 
npm install moxios --save-dev
```

完成后，让我们创建`frontend/test/unit/services.registration.spec.js`，如下所示:

```java
1\.  import moxios from 'moxios'
2\.  import registrationService from '@/services/registration'
3\. 
4\.  describe('services/registration', () => {
5\.    beforeEach(() => {
6\.      moxios.install()
7\.    })
8\. 
9\.    afterEach(() => {
10\.    moxios.uninstall()
11\.  })
12.
13\.  it('should pass the response to caller when request succeeded', 
    ()=>{
14\.    expect.assertions(2)
15\.    moxios.wait(() => {
16\.      let request = moxios.requests.mostRecent()
17\.      expect(request).toBeTruthy()
18\.      request.respondWith({
19\.        status: 200,
20\.        response: {result: 'success'}
21\.      })
22\.    })
23\.    return registrationService.register().then(data => {
24. expect(data.result).toEqual('success')
25. })
26\.  })
27.})
```

如你所见，在第`1`行到第`2`行，我们导入了`moxios`和`registrationService`。从第`4`行到第`11`行，我们调用`moxios.install()`为每个测试创建模拟，然后使用`moxios.uninstall()`销毁它。

在测试方法中，我们验证服务是否会将服务器的响应返回给调用者。在第`14`行中，我们使用 Jest 的 API`expect.assertions()`来确保断言的确切数量，这在我们测试的方法返回承诺时非常有用。

从第`15`行到第`22`行，`moxios.wait()`方法是等待请求发出后再继续。其实现基于`setTimeout()`。当等待结束时，正如您在`16`行中看到的，我们获得最近的请求，并通过使用 Jest 的`toBeTruthy()` API 验证它的存在。这是为了确保实际上已经发出了一个`axios`请求。之后，我们使用`respondWith()` `moxios`方法指定请求的响应。这样，我们就可以确定`register()`方法会得到成功的响应。

在第`23`行，我们调用`register()`方法，然后进行验证，以确保由`register()`方法返回的`result`属性的值是成功的。因为我们在这里使用承诺，我们需要返回一个承诺作为测试方法本身的结果，这样 Jest 就可以等待它解决。当承诺被拒绝时，测试将自动失败。

`Promise.prototype.then(onFulfilled[, onRejected])`方法也返回一个承诺。这就是为什么你可以在它后面链接其他的`then()`方法或者`catch()`方法。

现在，让我们为 HTTP 请求失败的场景创建一个测试。这是它的样子:

```java
it('should propagate the error to caller when request failed', () => {
 expect.assertions(2)
  moxios.wait(() => {
    let request = moxios.requests.mostRecent()
    expect(request).toBeTruthy()
    request.reject({
      status: 400,
      response: {message: 'Bad request'}
    })
  })
  return registrationService.register().catch(error => {
    expect(error.response.message).toEqual('Bad request')
  })
})
```

正如您所看到的，这个测试与前一个非常相似，只是我们没有使用`respondWith()`，而是使用`request.reject()` `moxios` API 来发送失败的响应，并且我们将`register()`方法与`catch(onRejected)`方法链接起来。在这个`onRejected`处理程序中，我们断言错误响应，以确保错误传播到调用者。

# 实现 register()方法

现在，让我们实现`register()`方法本身，从如下配置`axios`开始。

让我们来看看`frontend/src/main.js`文件:

```java
import router from './router'
import axios from 'axios'

// Bootstrap axios
axios.defaults.baseURL = '/api'
axios.defaults.headers.common.Accept = 'application/json'
axios.interceptors.response.use(
 response => response,
 (error) => {
 return Promise.reject(error)
 }
)
```

如你所见，在`main.js`文件中，我们配置了`baseURL`,这样我们就不必为每个请求添加`/api`。我们明确表示，我们只接受 JSON 格式的响应，我们还在响应中添加了一个拦截器来传播错误。

现在，让我们将`registrationService`的`register()`方法改为如下:

```java
import axios from 'axios'

export default {
  register (detail) {
    return new Promise((resolve, reject) => {
      axios.post('/registrations', detail).then(({data}) => {
        resolve(data)
      }).catch((error) => {
        reject(error)
      })
    })
  }
}
```

如您所见，我们向后端发送了一个 HTTP POST 请求，并将注册细节作为请求体。当请求成功时，我们将响应返回给调用者。当它失败时，我们拒绝错误。

现在，如果我们运行`npm run test:unit`命令，我们应该看到所有测试都通过了。

到目前为止，我们已经完成了本节的计划。如果您使用`npm run serve`命令启动前端并进入注册页面，然后点击创建帐户按钮，您将看到类似于*图 9.4* 所示的错误。如果您检查终端中打印的日志，您可以看到有一个代理错误。这是因为我们还没有为`/api/registrations`构建 API 处理程序:

![](img/e54f5208-7560-42ad-a5ce-389e4d21011d.png)

图 9.4:实现的寄存器页面

让我们在提交代码之前运行`mvn clean install`命令。正如您应该看到的，所有测试都通过了，下面是提交历史:

![](img/64b5483e-033b-4ca2-8c33-aa6dcd81b4ad.png)

图 9.5:构建注册表单提交

# 前端验证

正如本章开始时提到的，我们必须始终验证用户输入，以确保我们收到的数据是有效的。在本节中，我们将使用**vue lidate**(【https://monterail.github.io/vuelidate】T2)在前端实现验证，这是 Vue.js 的一个基于模型的验证库

首先，让我们用下面的命令安装`Vuelidate`:

```java
npm install vuelidate --save
```

一旦完成，让我们编写数据验证的单元测试代码。

# 测试数据验证

我们需要测试数据验证的原因是为了确保有适当的验证，并且用户输入在被发送到后端之前已经得到了正确的验证。让我们将下面的测试添加到`RegisterPage.spec.js`中，以验证当电子邮件地址的值无效时，不会调用`registrationService.register()`方法:

```java
...
import Vuelidate from 'vuelidate'
import registrationService from '@/services/registration'
...
localVue.use(Vuelidate)
...
// Mock dependency registratioService
jest.mock('@/services/registration')

describe('RegisterPage.vue', () => {
  ...
  it('should fail when the email address is invalid', () => {
    const spy = jest.spyOn(registrationService, 'register')
    wrapper.vm.form.emailAddress = 'bad-email-address'
    wrapper.vm.submitForm()
    expect(spy).not.toHaveBeenCalled()
    spy.mockReset()
    spy.mockRestore()
  })
})
```

如你所见，我们导入`Vuelidate`，然后将其应用到`localVue`。我们也进口`registrationService`。即使导入`registrationService`被放置在`jest.mock('@/services/registration')`之上，但是`jest.mock()`方法仍然会在导入之前执行，因为 Jest 会在任何导入之前自动将`jest.mock()`调用提升到模块的最顶端。这样，导入的`registrationService`实际上是我们之前在`__mock__`文件夹中创建的模拟。

在`test`方法中，我们使用`jest.spyOn()`来创建一个`register()`方法的间谍。这个 spy 也是一个模拟函数。作为一个间谍，它有能力跟踪对方法的调用。如您所见，我们使用`expect(spy).not.toHaveBeenCalled()`来验证`register()`方法没有被调用。在测试结束时，我们使用`mockReset()`清除存储在 mock 中的所有调用，然后使用`mockRestore()`恢复`register()`方法的原始行为。

现在，如果您使用`npm run test:unit`命令运行单元测试，您应该会看到测试失败了，这是意料之中的。让我们实现验证以使测试通过。

# 用 Vuelidate 验证表单数据

本质上，Vuelidate 是一个 Vue mixin。我们需要先把它应用到 Vue 上。为此，我们对`frontend/src/main.js`文件进行了如下修改:

```java
import Vuelidate from 'vuelidate'
...
Vue.use(Vuelidate)
```

以下是我们对`RegisterPage.vue`所做的更改:

```java
<script>
import { required, email, minLength, maxLength, alphaNum } from 'vuelidate/lib/validators'
...
export default {
  ...
  validations: {
    form: {
      username: {
        required,
        minLength: minLength(2),
        maxLength: maxLength(50),
        alphaNum
      },
      emailAddress: {
        required,
        email,
        maxLength: maxLength(100)
      },
      password: {
        required,
        minLength: minLength(6),
        maxLength: maxLength(30)
      }
    }
  },
  methods: {
    submitForm () {
      this.$v.$touch()
      if (this.$v.$invalid) {
        return
      }
      ...
    }
  }
}
</script>
```

如您所见，我们导入了 Vuelidate 的几个内置验证器，然后添加了`validations` options 对象，它与我们的数据模型具有相同的结构。在这个`validations`对象的每个字段中，我们指定每个字段需要的规则。一旦完成，在`submitForm()`方法中，我们通过 Vuelidate 创建并添加到 Vue 实例的`$v`对象访问 Vuelidate 的 API。这个`$v`对象保存了当前的验证状态。我们调用它的`$v.$touch()`方法来触发数据验证。然后，我们通过检查`$v.$invalid`属性来验证结果。如果验证失败，它的值是`true`，我们简单地中止注册过程。

现在，让我们运行测试，看看事情是如何工作的。您应该看到结果显示所有测试都已通过。然而，Vue.js 发出了许多警告，内容如下:

```java
Expected mock function to have been called with:
  [{"name": "LoginPage"}]
But it was not called.
```

仔细查看警告消息，我们可以发现该警告源自以下测试方法:

```java
it('should register when it is a new user', () => {
  const stub = jest.fn()
  wrapper.vm.$router.push = stub
  wrapper.vm.form.username = 'sunny'
  wrapper.vm.form.emailAddress = 'sunny@local'
  wrapper.vm.form.password = 'Jest!'
  wrapper.vm.submitForm()
  wrapper.vm.$nextTick(() => {
    expect(stub).toHaveBeenCalledWith({name: 'LoginPage'})
  })
})
```

根据警告消息，未调用`vm.$router.push`。事实上，这不应该被视为一个警告，因为在这个测试方法中，我们验证了用户在成功注册后将被重定向到登录页面。当方法没有被调用时，测试应该会失败。为什么 Jest 仍然让测试通过？一定有什么严重的问题。我们需要深入挖掘，找出测试过程中发生了什么。

让我们想想这个。在我们实现数据验证之前，这个测试通过了。所以，这一定与我们刚刚添加的验证规则有关。仔细查看我们在测试中使用的数据，我们可以看到电子邮件地址是无效的，密码也少于 6 个字符。看起来我们应该通过测试的测试数据实际上导致了一个验证问题。但尽管如此，Vue.js 为什么抛出那个警告？Jest 不应该是负责测试的人吗？

让我们浏览一下测试和代码流，看看发生了什么。从测试方法开始，我们使用无效数据，在调用了`submitForm()`方法之后，Vuelidate 在`submitForm()`方法内部执行数据验证。验证失败，调用立即返回到测试方法。因此，`register()`方法没有被调用。这意味着没有发生异步执行，并且在测试完成之前，Jest 没有评估`$nextTick()`内部的验证。这就是 Jest 让测试通过的原因。随后，不管在`submitForm()`方法中是否有异步执行，下一个滴答最终都会开始。这时`$nextTick()`内部的验证得到评估，失败了。由于 Jest 已经完成了测试方法的执行，它唯一能做的就是将验证失败作为错误抛出。这个错误被 Vue.js 检测到，因为验证发生在 Vue.js 的`$nextTick()`方法内部。由于我们没有向`$nextTick()`提供错误处理程序，Vue.js 不知道如何处理这个错误，它向我们抛出了警告，基本上是说:*嘿，这是一个您忽略的错误。做点什么*。

现在，一切都说得通了。这显然是测试方法的缺陷。要解决这个问题，首先让我们解决规范中使用的所有测试数据以及注册服务的模拟数据。然后，我们可以使用 promise-chain 将一个`catch()`方法链接到`$nextTick()`。或者，我们可以使用`async` / `await`进行异步调用，如下所示:

```java
  it('should fail it is not a new user', async () => { 
    // In the mock, only sunny@taskagile.com is new user 
    wrapper.vm.form.username = 'ted'
    wrapper.vm.form.emailAddress = 'ted@taskagile.com'
    wrapper.vm.form.password = 'JestRocks!'
    ...
    await wrapper.vm.$nextTick()
    expect(wrapper.find('.failed').isVisible()).toBe(true)
  })
```

要使用`async` / `await`，我们需要在包含异步调用的函数前添加`async`，然后在异步调用前放置 await。通过这种方式，JavaScript 将一直等待，直到承诺完成并返回结果。

# 改进测试

事实上，我们使用的无效数据并不是测试中的主要问题。实际的问题是，Jest 没有及时评估我们在测试中添加的验证/断言。因此，基于 Jest 的结果，我们认为已经通过的测试实际上可能在我们没有注意到的情况下失败了。这些测试变成了出故障的迷你 QA 机器人，并将影响我们应用的健康。您可能已经注意到，这种问题只在涉及异步执行时才会发生。

我们测试中的另一个问题是，我们跳过了对是否调用了`registrationService.register()`方法的验证，从而跳转到验证到登录页面的重定向，这是`submitForm()`方法的两个可能的最终结果之一。为了编写一个更强大的测试，而不是急于检查最终结果，我们应该相应地验证`submitForm()`方法依赖项的行为，这样我们就可以确定`submitMethod()`方法的实现是正确的。我们的`submitForm()`方法的实现相对简单。假设有一个非常复杂的实现，并且有可能在没有调用`register()`方法的情况下仍然会发生重定向。在我们旧的测试方法中，迷你 QA 机器人仍然会天真地认为注册已经成功，从而在应用交付生产时留下了一个重大的 bug。

现在，我们已经在测试中发现了问题。让我们通过对`RegisterPage.spec.js`进行以下更改来修复它们:

```java
...
describe('RegisterPage.vue', () => {
  ...
  let registerSpy

  beforeEach(() => {
    ...
    // Create spy for registration service
    registerSpy = jest.spyOn(registrationService, 'register')
  })

  afterEach(() => {
    registerSpy.mockReset()
 registerSpy.mockRestore()
  })
  ...
})
```

正如你所看到的，我们将`registerSpy`移到了测试套件级别，这样本规范中的所有测试都可以使用它。我们使用`beforeEach()`和`afterEach()`来实例化它，并为每个测试方法重置它。这样，我们可以在下面两个测试中加入期望值:

```java
it('should register when it is a new user', async () => {
  expect.assertions(2)
  ... 
  wrapper.vm.submitForm()
  expect(registerSpy).toBeCalled()
  await wrapper.vm.$nextTick()
  expect(stub).toHaveBeenCalledWith({name: 'LoginPage'})
})

it('should fail it is not a new user', async () => {
  expect.assertions(3)
 expect(wrapper.find('.failed').isVisible()).toBe(false)
  ...
  wrapper.vm.submitForm()
  expect(registerSpy).toBeCalled()
  await wrapper.vm.$nextTick()
 expect(wrapper.find('.failed').isVisible()).toBe(true)
})
```

通过这种重构和改进，我们的测试更加强大，因为它验证了`register()`方法的行为。

除了测试之外，*当电子邮件地址无效时应该会失败*，让我们也添加以下两个测试来确保无效数据不会通过验证:

*   当用户名无效时，它应该会失败
*   当密码无效时，它应该会失败

现在，让我们用`npm run test:unit`运行单元测试，看看事情是如何工作的。您应该会看到如下结果:

```java
Test Suites: 3 passed, 3 total
Tests:       12 passed, 12 total
```

我们需要对注册页面进行最后一个与数据验证相关的更改，即在 UI 中显示每个字段的验证错误。我们不会深入细节。如果您感兴趣，请查看 GitHub 上提交的代码以了解详细信息。

现在，我们已经完成了注册页面的前端。让我们运行`mvn clean install`命令。正如您将看到的，所有测试都已通过，下面是提交记录:

![](img/17229629-d4ed-48fc-a098-cd912f0b9847.png)

图 9.6:在前端提交时添加验证

# 后端验证

后端收到的请求可以从 UI 发送，也可以通过 cURL 和 Postman 等工具发送。当请求不是来自 UI 时，我们在前端添加的验证可以被完全绕过。因此，在处理数据之前，我们还必须在后端执行数据验证。

正如在[第五章](05.html)、*数据建模-设计应用基础*中提到的，我们在 **TaskAgile** 应用中使用六边形架构风格。所以，当一个 HTTP 请求到达服务器端时，一个适配器会处理它。在我们的应用中，适配器是**控制器**中的一个处理程序。我们将在那里进行验证。另一件事是，我们应该将业务逻辑排除在验证之外。我们应该只根据不涉及任何业务逻辑的规则来检查数据是否有效。例如，我们可能想要反转应用中的用户名列表，在创建用户之前，我们需要检查请求中的用户名值是否被允许。这个验证涉及到一个业务规则，不应该在适配器中执行。相反，它应该是**应用核心**中的服务的责任。下图显示了我们在本部分中构建的后端数据验证流程:

![](img/bc0fcd7c-9cb6-498f-ae51-578e564dcfb2.png)

图 9.7:数据验证流程

如您所见，我们需要确保我们传递给**应用核心**的数据总是有效的。

# 正在创建注册有效负载

我们将在后端创建`com.taskagile.web.apis.RegistrationApiController`类来处理`/api/registrations`请求。我们将创建`com.taskagile.web.payload.RegistrationPayload`类来映射请求体中发送的字段。Spring MVC 将为我们实例化这个`RegistrationPayload`类，并用请求体中的数据填充它。

# 创建注册有效负载测试

首先，让我们创建`com.taskagile.web.payload.RegistrationPayloadTests`单元测试类。在这个测试类中，我们将创建一个`javax.validation.Validator`实例来执行数据验证。我们仍然会遵循`[UnitOfWork_StateUnderTest_ExpectedBehavior]`惯例来命名测试方法。下面是`RegistrationPayloadTests`的样子:

```java
...
public class RegistrationPayloadTests {

  private Validator validator;

  @Before
  public void setup () {
    ValidatorFactory factory = 
    Validation.buildDefaultValidatorFactory();
    validator = factory.getValidator();
  }

  @Test
  public void validate_blankPayload_shouldFail() {
    RegistrationPayload payload = new RegistrationPayload();
    Set<ConstraintViolation<RegistrationPayload>> violations = 
    validator.validate(payload);
    assertEquals(3, violations.size());
  }
}
```

正如你所看到的，我们在`setup()`方法中创建了一个`javax.validation.Validator`的实例，并用`@Before`注释对其进行了注释，这样它将在运行每个测试方法之前被执行。这就像是`beforeEach()`在开玩笑。我们这里的第一个测试方法非常简单。它测试一个空白的注册表单，我们期望看到三个约束违反。

# 创建注册有效负载

现在，让我们继续创建`RegistrationPayload`类本身。这是它的样子:

```java
...
public class RegistrationPayload {

  @Size(min = 2, max = 50, message = "Username must be between 2 and 50 characters")
  @NotNull
  private String username;

  @Email(message = "Email address should be valid")
  @Size(max = 100, message = "Email address must not be more than 100 characters")
  @NotNull
  private String emailAddress;

  @Size(min = 6, max = 30, message = "Password must be between 6 and 30 characters")
  @NotNull
  private String password;

  // getters and setters
}
```

如您所见，这个`RegistrationPayload`类有三个字段，我们应用于它们的约束与我们在前端添加的相匹配。一个区别是,`@Size`注释认为`null`值是有效的。这就是为什么我们也必须为每个字段添加`@NotNull`注释。

我们还需要在`RegistrationPayloadTests`中添加以下测试方法，以涵盖应用于每个字段的每个约束:

*   `validate_payloadWithInvalidEmail_shouldFail()`
*   `validate_payloadWithEmailAddressLongerThan100_shouldFail()`
*   `validate_payloadWithUsernameShorterThan2_shouldFail()`
*   `validate_payloadWithUsernameLongerThan50_shouldFail()`
*   `validate_payloadWithPasswordShorterThan6_shouldFail()`
*   `validate_payloadWithPasswordLongerThan30_shouldFail()`

我们不会在这里讨论每一种测试方法。如果您对这些方法的实现感兴趣，可以在 GitHub 上的提交历史中找到它们。

# 创建注册控制器

现在，让我们创建 API 处理程序来接受注册请求。下图*图 9.8* 显示了`RegistrationApiController`与其从属关系之间的关系:

![](img/88a95bff-d2fd-4e53-b7ca-7557fd917e22.png)

图 9.8:registrationpicontroller 类图

如您所见，`RegistrationApiController`类有一个名为`service`的`UserService`类型的字段，它提供了一个用于注册用户的 API`register(RegistrationCommand)`。这个服务 API 成功时不返回任何东西，失败时抛出`RegistrationException`。在控制器中，`register(RegistrationPayload)`方法是我们需要创建的方法。这个方法的输入是一个`RegistrationPayload`的实例，Spring MVC 将从请求体中创建这个实例，并在传递它之前自动验证它的数据。这个方法的返回值是一个`ResponseEntity`的实例，Spring MVC 将使用它来生成 HTTP 响应。

现在，让我们从单元测试开始实现。

# 创建 RegistrationApiControllerTests

在[第七章](07.html)、 *RESTful API 设计——前端和后端之间的构建语言*中，我们创建了单元测试类`MessageControllerTest`。在本节中，我们将使用相同的方法来创建`RegistrationApiControllerTests`类。为了测试`register(RegistrationPayload)`方法，我们需要通过 Spring 的`MockMvc`提供输入，并模拟它的依赖项`UserService`。这样，我们可以验证这个 API 处理程序的行为。

现在我们清楚了需要做什么，让我们添加以下测试方法，它们将涵盖四种不同的场景:

*   `register_blankPayload_shouldFailAndReturn400()`
*   `register_existedUsername_shouldFailAndReturn400()`
*   `register_existedEmailAddress_shouldFailAndReturn400()`
*   `register_validPayload_shouldSucceedAndReturn201()`

以下是第一种测试方法下`RegistrationApiControllerTests`的样子:

```java
...
@RunWith(SpringRunner.class)
@WebMvcTest(RegistrationApiController.class)
public class RegistrationApiControllerTests {

  @Autowired
  private MockMvc mvc;

  @Test
  public void register_blankPayload_shouldFailAndReturn400() throws Exception {
    mvc.perform(post("/api/registrations"))
      .andExpect(status().is(400));
  }
}
```

正如您所看到的，在这个测试中，我们执行一个带有空请求体的 HTTP `POST`请求，并期望 API 处理程序返回一个带有 HTTP status `400`的响应，这意味着一个错误的请求。

第二种测试方法`register_existedUsername_shouldFailAndReturn400()`，如下所示:

```java
...
@MockBean
private UserService serviceMock;
...
@Test
public void register_existedUsername_shouldFailAndReturn400() throws Exception {
  RegistrationPayload payload = new RegistrationPayload();
  payload.setUsername("exist");
  payload.setEmailAddress("test@taskagile.com");
  payload.setPassword("MyPassword!");

  doThrow(UsernameExistsException.class)
 .when(serviceMock)
 .register(payload.toCommand());

  mvc.perform(
    post("/api/registrations")
      .contentType(MediaType.APPLICATION_JSON)
      .content(JsonUtils.toJson(payload)))
    .andExpect(status().is(400))
    .andExpect(jsonPath("$.message").value("Username already exists"));
}
```

如您所见，我们在这里添加了`UserService`依赖项作为模拟 bean。在测试方法内部，我们指定了`serviceMock`的行为，当`register(RegistrationCommand)`方法被调用时，它抛出`RegistrationExcpetion`。`doThrow()`和`when()`方法是 Mockito 的 API。一旦输入和模拟准备就绪，我们就调用`/api/registrations` API，将注册数据作为请求参数传入。然后，我们预计结果是 HTTP `400`失败。

第三种测试方法与第二种类似。唯一不同的是，在这个测试中，抛出的异常是`EmailAddressExistException`。

第四种测试方法也与第二种类似。不同之处在于，我们以不同的方式定义了`serviceMock`的行为，如下面的代码所示。这是因为服务的方法的返回值是`void`，注册成功时不会抛出异常:

```java
doNothing().when(serviceMock).register(form.toCommand());
```

正如这个 Mockito API 的名字`doNothing()`所暗示的，在`register()`方法完成之后，什么都不会发生，这是所期望的行为。

为了简洁起见，省略了`RegistrationApiControllerTests`类的许多细节。你可以在 GitHub 的提交历史中查看它们。

# 实现 RegistrationApiController 及其依赖项

现在，让我们继续实现`RegistrationApiControler`及其依赖项。控制器的全称是`com.taskagile.web.apis.RegistrationApiController`，看起来是这样的:

```java
...
@Controller
public class RegistrationApiController {

  private UserService service;

  public RegistrationApiController(UserService service) {
    this.service = service;
  }

 @PostMapping("/api/registrations")
  public ResponseEntity<ApiResult> register(
      @Valid @RequestBody RegistrationPayload payload) {
    try {
      service.register(payload.toCommand());
      return Result.created();
    } catch (RegistrationException e) {
    String errorMessage = "Registration failed";
      if (e instanceof UsernameExistsException) {
      errorMessage = "Username already exists";
      } else if (e instanceof EmailAddressExistsException) {
      errorMessage = "Email address already exists";
      }
      return Result.failure(errorMessage);
    }
  }
}
```

如您所见，我们将`@Valid`注释应用于`RegistrationPayload`。有了这个注释，Spring MVC 将对`RegistrationPayload`执行数据验证，以确保它的数据在传递给`register()`方法之前是有效的。在处理程序内部，我们用从`RegistrationPayload`实例转换而来的`RegistrationCommand`类的实例调用服务 API。如果一切正常，我们调用`Result.created()`返回一个带有 HTTP 状态`201`的响应。否则，我们捕获`RegistrationException`并返回一个带有消息的`400`响应。

下面是`RegistrationCommand`的样子。它是只读的。一旦创建，就不能改变它的状态，因为它只提供 getters，不提供 setters:

```java
public class RegistrationCommand {
  private String username;
  private String emailAddress;
  private String password;

  public RegistrationCommand(String username, String emailAddress, String password) {
    this.username = username;
    this.emailAddress = emailAddress;
    this.password = password;
  }

  // getters

  @Override
  public boolean equals(Object o) {
    ...
  }

  @Override
  public int hashCode() {
    ....
  }
}
```

如您所见，它还有`equals()`和`hashCode()`方法。这是因为，当 Mockito 在测试中比较两个`RegistrationCommand`实例的相等性时，它将使用这两种方法来进行比较。否则，它将使用对象的内存地址来进行相等性的比较，这将是不同的，测试将失败。

下面是`com.taskagile.domain.application.UserService`界面的样子:

```java
public interface UserService {
  void register(RegistrationCommand command) throws RegistrationException;
}
```

我们将这个**应用服务**放在`com.taskagile.domain.model.user`包中。我们不会使用分层架构打包样式，它通常如下所示:

*   `com.taskagile.web`
*   `com.taskagile.service`
*   `com.taskagile.domain`
*   `com.taskagile.dao`

尽管这种结构由于其简单性而非常适合 CRUD 应用，但是这种方法的最大问题是它将相同领域的类划分到不同的包中。当您查看应用的结构时，您不知道它提供了什么。

在 **TaskAgile** 中，我们采用了不同的方法。也就是说，我们将一个领域的所有类放在同一个包中，所有的领域知识都在这个包中。下面是我们的用户域的结构:

*   `com.taskagile.domain.application.UserService`
*   `com.taskagile.domain.application.commands`
*   `com.taskagile.domain.application.commands.RegistrationCommand`
*   `com.taskagile.domain.model.user.User`
*   `com.taskagile.domain.model.user.UserRepository`
*   `com.taskagile.domain.model.user.events.UserRegisteredEvent`
*   `com.taskagile.domain.model.user.RegistrationManagement`
*   `com.taskagile.domain.model.user.AuthenticationManagement`

如您所见，`com.taskagile.domain.aplication`包包含了控制器所依赖的应用服务。`com.taskagile.domain.model.user`包包含域模型、存储库接口和域事件，以及域服务、`RegistrationManagement`和`AuthenticationManagement`。我们将在本章后面详细讨论这些。

回到让我们的测试通过；我们仍然需要完成这些依赖/更改:

*   将一个`RegistrationPayload`实例转换成一个`RegistrationCommand`实例
*   创建一个`com.taskagile.domain.model.user.RegistrationException`异常，以及`UsernameExistsException`和`EmailAddressExistsException`
*   添加一个空白的`com.taskagile.domain.application.UserService`实现
*   添加`com.taskagile.web.results.ApiResult`和`com.taskagile.web.results.Result`

因为这些实现和改变中的大多数都非常简单，所以我们不会在本书中列出它们。您可以在*图 9.10* 中显示的提交历史中找到详细信息。

现在，让我们通过点击 Run Test 链接从 VS 代码中运行`RegistrationApiControllerTests`中的测试，如图 9.9 中的*所示，您将看到所有测试都通过了:*

![](img/966ab022-3457-4534-a930-6af5a31e13eb.png)

图 9.9:运行 RegistrationApiControllerTests

在运行`mvn clean install`命令之后，您应该看到在提交更改之前我们已经成功安装了。*图 9.10* 显示了提交历史:

![](img/4a4a2c9e-0a1e-4090-b55b-3897d67e8b34.png)

图 9.10:实现注册 API 处理程序提交

# 在域模型中实现注册

`RegistrationApiController`所依赖的`UserService`非常单薄，因为它的职责只包括以下几项:

*   协调模型上的任务
*   用安全约束保护域模型
*   控制交易

最重要的是，它的责任不应该涉及任何商业逻辑。业务逻辑应该只存在于领域模型中。*图 9.11* 显示了`UserService`与其依赖关系:

![](img/ec274508-f4ae-48a6-bef9-965bc61e9e69.png)

图 9.11:用户服务类图

如你所见，`UserService`的实现，也就是`UserServiceImpl`，依赖于`RegistrationService`，这是一个域服务来处理实际的注册。它还依赖`MailManager`发送电子邮件和`DomainEventPublisher`发布`UserRegisteredEvent`域事件。

# 实现用户服务应用服务

如前所述，应用服务应该保持精简。它们可以保存对它们的依赖项的引用，比如存储库、域服务和基础设施服务，以帮助 it 完成它的角色。

# 创建 UserServiceImplTests

首先:让我们创建单元测试类`UserServiceImplTests`。为了测试`UserServiceImpl`，我们需要模拟它的依赖项— `RegistrationManagement`、`MailManager`和`DomainEventPublisher`。至少有以下测试方法来涵盖不同的场景:

*   `register_nullCommand_shouldFail()`
*   ``register_existingUsername_shouldFail()``
*   `register_existingEmailAddress_shouldFail()`
*   `register_validCommand_shouldSucceed()`

下面是第一个测试方法的样子:

```java
...
public class UserServiceImplTests {
  private RegistrationManagement registrationManagementMock;
  private DomainEventPublisher eventPublisherMock;
  private MailManager mailManagerMock;
 private UserServiceImpl instance;

  @Before
  public void setUp() {
    registrationManagementMock = mock(RegistrationManagement.class);
    eventPublisherMock = mock(DomainEventPublisher.class);
    mailManagerMock = mock(MailManager.class);
    instance = new UserServiceImpl(registrationServiceMock, 
    eventPublisherMock, mailerMock);
  }

 @Test(expected = IllegalArgumentException.class)
  public void register_nullCommand_shouldFail() throws 
  RegistrationException {
    instance.register(null);
  }
}
```

如您所见，我们使用`setUp()`方法来创建模拟并实例化`UserServiceImpl`。在我们的第一个测试方法`register_nullCommand_shouldFail()`中，我们将一个`null`值传递给`register()`方法，让它显式地失败。我们使用`@Test(expected = IllegalArgumentException.class)`来告诉 JUnit 我们期望这个方法抛出一个`IllegalArgumentException`错误。如果没有抛出这个异常，那么这个测试应该被认为是失败的。

由于其余的测试方法与`RegistrationApiControllerTests`中的类似，这里就不一一列举了。有关详细信息，请查看 GitHub 上的提交历史。

# 创建邮件管理器

现在，我们将只创建`MailManager`接口和一个空的实现`DefaultMailManager`。我们将在下一章的后面完成实现。下面是`MailManager`界面的样子:

```java
public interface MailManager {
  void send(String emailAddress, String subject, String template, MessageVariable... variables);
}
```

如您所见，API 非常简单。它需要收件人的电子邮件地址、邮件主题、邮件消息的模板以及模板中使用的变量。

# 构建域事件

我们基于 Spring 的`ApplicationEvent`构建领域事件。这使得我们可以轻松地发布和收听领域事件。下面是`DomainEvent`类的样子:

```java
...
public abstract class DomainEvent extends ApplicationEvent {
  public DomainEvent(Object source) {
    super(source);
  }
  public long occurredAt() {
    // Return the underlying implementation's timestamp
    return getTimestamp();
  }
}
```

正如你所看到的，它从`ApplicationEvent`扩展而来，并提供了自己的 API，即`occurredAt()`方法，这样我们就不太依赖`ApplicationEvent`来获得事件发生的时间。

以下是`DomainEventPublisher`界面的外观:

```java
public interface DomainEventPublisher {
  void publish(DomainEvent event);
}
```

如您所见，它只有一个 API，即`publish()`方法。它基于 Spring 的实现如下所示:

```java
@Component
public class DefaultDomainEventPublisher implements DomainEventPublisher {
  @Autowired
  private ApplicationEventPublisher actualPublisher;

  @Override
  public void publish(DomainEvent event) {
    actualPublisher.publishEvent(event);
  }
}
```

如您所见，我们注入了实际的发布者，这里是`ApplicationEventPublisher`实例，然后将发布委托给它。有了这个实现，我们可以在同一个 JVM 中发布和监听域事件。将来，我们可以创建基于 AMQP 或 Redis 发布/订阅的实现，以提供分布式域事件处理。目前，这个基于 Spring 的实现已经足够好了。

`DomainEvent`、`DomainEventPublisher`、`DefaultDomainEventPublisher`都住在`com.taskagile.domain.common.event`包里。它们可以在多个模型之间共享。

尽管在`User`模块中我们不需要处理`UserRegisteredEvent`，让我们创建一个处理程序来看看如何接收这个域事件。

以下是`com.taskagile.domain.model.user`包内的`UserRegisteredEventHandler`:

```java
...
@Component
public class UserRegisteredEventHandler {
  ...
  @EventListener(UserRegisteredEvent.class)
  public void handleEvent(UserRegisteredEvent event) {
    log.debug("Handling `{}` registration event", 
    event.getUser().getEmailAddress());
    // This is only a demonstration of the domain event listener
  }
}
```

正如您所看到的，事件处理程序是一个标准组件，它有一个用`@EventListener`注释的方法，这个方法只对`UserRegisteredEvent`感兴趣。方法体本身只是将调试信息写入日志。为了查看该日志，您需要在`src/main/resources/application.properties`中添加以下日志级别:

```java
logging.level.com.taskagile=DEBUG
```

使用此设置，应用本身的所有调试信息都将显示在输出中。

# 实现 UserServiceImpl 类

现在，我们已经准备好了测试。让我们实现`UserServiceImpl`类本身。这是它的样子:

```java
...
@Service
@Transactional
public class UserServiceImpl implements UserService {

  private RegistrationManagement registrationManagement;
  private DomainEventPublisher domainEventPublisher;
  private MailManager mailManager;

  public UserServiceImpl(RegistrationManagement registrationManagement,
                         DomainEventPublisher domainEventPublisher,
                         MailManager mailManager) {
    this.registrationManagement = registrationManagement;
    this.domainEventPublisher = domainEventPublisher;
    this.mailManager = mailManager;
  }

  @Override
  public void register(RegistrationCommand command) throws 
  RegistrationException {
    Assert.notNull(command, "Parameter `command` must not be null");
    User newUser = registrationManagement.register(
      command.getUsername(),
      command.getEmailAddress(),
      command.getPassword());

    sendWelcomeMessage(newUser);
    domainEventPublisher.publish(new UserRegisteredEvent(newUser));
  }

  private void sendWelcomeMessage(User user) {
    mailManager.send(
      user.getEmailAddress(),
      "Welcome to TaskAgile",
      "welcome.ftl",
      MessageVariable.from("user", user)
    );
  }
}
```

如您所见，我们对这个类应用了`@Service`注释和`@Transactional`注释。注释的名字`@Service`最初是在 Eric Evans 的书*中定义的，域驱动设计*。这意味着应用了该注释的类只为其客户端提供操作。`UserServiceImpl`类是无状态的。它不包含任何内部状态。在 DDD 应用中，服务分为三种类型—应用服务、域服务和基础设施服务。

让我们再多谈谈这些服务。

首先，对于应用服务，以下内容适用:

*   他们只协调模型上的任务
*   它们不包含任何业务逻辑
*   它们有时被设计成屏蔽客户端访问域模型
*   它们控制事务，在我们的例子中是通过使用`@Transactional`注释

一个例子是我们的`UserServiceImpl`班。如你所见，它并不关心如何注册一个用户。它在域服务`RegistrationManagement`上回复，来处理这个问题。在 Spring 中，`@Service`注释通常应用于应用服务。

对于域服务，以下内容适用:

*   它们封装了不适合领域对象的业务逻辑，也不是属于存储库的典型 CRUD 操作

一个例子是我们的`RegistrationManagement`类，我们将很快讨论它。

对于基础设施服务，以下内容适用:

*   它们通常与外部资源对话，例如邮件服务器、数据库、消息队列、缓存服务器或第三方 RESTful APIs
*   它们不是领域模型的主要问题的一部分

一个例子是`UserRepository`和邮件服务的实现，我们将在下一章创建它，并且`DefaultMailManager`依赖于它。

回到代码；在这个服务中，我们要求 Spring 通过构造函数注入它的三个依赖项。在`register()`方法中，我们做的第一件事是添加一个断言，以确保命令参数永远不会是`null`。如果为空，将从`Assert.notNull()`方法中抛出一个`IllegalArgumentException`。一旦参数被检查，我们调用`RegistrationManagement`的`register()`方法来注册用户。这里，我们不再将`RegistrationCommand`实例作为参数传递，因为`RegistrationCommand`是供应用服务的客户端使用的，比如`Controller`。在应用核心内部，我们避免使用`RegistrationCommand`，这样应用核心的内部就不会与外部耦合。

用户注册后，我们会发送一封欢迎电子邮件并发布`UserRegisteredEvent`域事件，以便其他对此事件感兴趣(订阅)的人可以采取相应的行动。我们现在将跳过`sendWelcomeMessage()`方法的细节。您可以检查提交的详细信息。我们将在本章的后面部分讨论发送电子邮件。

现在，我们仍然不能通过测试，因为我们还没有创建`RegistrationManagement`类。

# 实现注册管理

域服务是注册的业务逻辑所在。业务逻辑包括以下内容:

*   现有用户名/电子邮件地址无法注册
*   加密密码
*   将用户保存到存储库中

下图显示了`RegistrationManagement`与其依赖项之间的关系:

![](img/af6bc1e1-816e-453e-88aa-e188fdaf6f17.png)

图 9.12:注册管理类图

可以看到，`RegistrationManagement`使用`UserRepository`来查找用户。当已经存在另一个具有相同用户名或电子邮件地址的用户时，它抛出`UsernameExistsException`或`EmailAddressExistsException`。否则，它会要求`PasswordEncryptor`加密密码，然后要求`UserRepository`保存该用户。

在我们创建单元测试之前，让我们先创建`User`实体，因为它是在`RegistrationManagement`内部创建的，`UserRepository`也依赖于它。它看起来像下面这样:

```java
...
@Entity
@Table(name = "user")
public class User extends AbstractBaseEntity {
  @Id
 @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name="username", nullable=false, length=50, unique=true)
  private String username;

  @Column(name="email_address", nullable=false, length=100, 
  unique=true)
  private String emailAddress;

  @Column(name="password", nullable=false, length=30)
  private String password;

  @Column(name="first_name", nullable=false, length=45)
  private String firstName;

  @Column(name="last_name", nullable=false, length=45)
  private String lastName;

  @Temporal(TemporalType.TIMESTAMP)
  @Column(name = "created_date", nullable=false)
  private Date createdDate;

  public User() {}

  public static User create(String username, String emailAddress, 
        String password) {
    User user = new User();
    user.username = username;
    user.emailAddress = emailAddress;
    user.password = password;
    user.firstName = "";
    user.lastName = "";
    user.createdDate = new Date();
    return user;
  }
  ...
}
```

如您所见，这个实体的字段映射到我们在数据建模过程中创建的列。对于`id`字段，我们使用`GenerationType.IDENTITY`策略告诉 Hibernate】字段的值是由数据库生成的。对于其他字段，我们使用`@Column`注释指定长度、可空性和惟一性。这是必需的，因为当我们测试存储库时，我们将使用 Hibernate 的`hbm2ddl`特性在 H2 内部创建数据库，这是我们将在测试中使用的嵌入式数据库。利用`@Column`注释中的这些设置，自动生成的表格也将具有这些约束。在这个实体中，我们还覆盖了`equals()`和`hashCode()`方法，只比较两个`User`对象的`username`和`emailAddress`；只要这两个场是相同的，我们就认为这两个对象是相等的。

# 创建注册管理测试

现在，我们知道了`RegistrationManagement`做什么，并且我们已经准备好了`User`实体，所以让我们创建`RegistrationManagementTests`单元测试。我们将重点关注以下内容:

*   确保使用现有用户名注册用户失败
*   确保使用现有电子邮件地址注册用户失败
*   确保使用有效数据注册用户成功，并且密码已加密
*   确保所有用户的电子邮件地址都以小写形式保存在存储库中

以下是我们将创建的测试方法，以涵盖前面列出的情况:

*   `register_existedUsername_shouldFail()`
*   `register_existedEmailAddress_shouldFail()`
*   `register_uppercaseEmailAddress_shouldSucceedAndBecomeLowercase()`
*   `register_newUser_shouldSucceed()`

下面是`RegistrationManagementTests`类中第一个测试方法的样子:

```java
...
public class RegistrationServiceTests {
  ...
  @Test(expected = UsernameExistsException.class)
  public void register_existedUsername_shouldFail() throws RegistrationException {
    String username = "existUsername";
    String emailAddress = "sunny@taskagile.com";
    String password = "MyPassword!";
    // We just return an empty user object to indicate an existing user
    when(repositoryMock.findByUsername(username)).thenReturn(new User());
    instance.register(username, emailAddress, password);
  }
}
```

与`UserServiceImplTests`相同，在这个测试中我们也需要创建模拟，并在`setUp()`方法中实例化`RegistrationManagement`实例。

正如您所看到的，在这个测试方法中，我们定义了`repositoryMock`的行为来返回一个用户作为`findByUsername()`方法的结果。有了这个设置，我们期望`RegistrationManagement`抛出`UsernameExistsException`。如果没有抛出这个异常，那么`RegistrationManagement`的实现就是不正确的。

`register_existedEmailAddress_shouldFail()`方法和第一种方法类似，这里就不列举了。唯一的区别是我们为`findByEmailAddress()`方法定义了 mock 的行为，并期望`EmailAddressExistsException`被抛出。

下面是第三种方法的样子:

```java
@Test
public void register_uppercaseEmailAddress_shouldSucceedAndBecomeLowercase() 
  throws RegistrationException {
  String username = "sunny";
  String emailAddress = "Sunny@TaskAgile.com";
  String password = "MyPassword!";
 instance.register(username, emailAddress, password);
  User userToSave = User.create(username, emailAddress.toLowerCase(), password);
  verify(repositoryMock).save(userToSave);
}
```

正如你所看到的，在这个测试方法中，我们用大小写混合的电子邮件地址调用了`register()`方法，我们期望`register()`方法确保`repository`保存了用户，并且电子邮件地址是小写的。

下面是最后一个测试方法的样子:

```java
@Test
public void register_newUser_shouldSucceed() throws RegistrationException {
  String username = "sunny";
  String emailAddress = "sunny@taskagile.com";
  String password = "MyPassword!";
  String encryptedPassword = "EncryptedPassword";
  User newUser = User.create(username, emailAddress, encryptedPassword);

  // Setup repository mock
  // Return null to indicate no user exists
  when(repositoryMock.findByUsername(username)).thenReturn(null);
  when(repositoryMock.findByEmailAddress(emailAddress)).thenReturn(null);
  doNothing().when(repositoryMock).save(newUser);
  // Setup passwordEncryptor mock
 when(passwordEncryptorMock.encrypt(password))
 .thenReturn("EncryptedPassword");

  User savedUser = instance.register(username, emailAddress, password);
  InOrder inOrder = inOrder(repositoryMock);
  inOrder.verify(repositoryMock).findByUsername(username);
  inOrder.verify(repositoryMock).findByEmailAddress(emailAddress);
  inOrder.verify(repositoryMock).save(newUser);
  verify(passwordEncryptorMock).encrypt(password);
  assertEquals("Saved user's password should be encrypted", 
    encryptedPassword, savedUser.getPassword());
}
```

正如你所看到的，在这个测试方法的开始，我们准备了所有的测试数据。然后，我们定义模仿的行为。事实上，我们不必在这里定义`repositoryMock`的行为，因为默认情况下它的`findByUsername()`方法的行为，`findByEmailAddress()`方法返回`null`，它的`save()`方法什么也不做。我们在这里添加了这些行为定义，以使其更加明确，这将使我们的测试更加强大。`passwordEncryptorMock`的`encrypt()`方法将返回我们指定的加密密码。

在这个测试中，我们使用 Mockito 的`InOrder` API 来验证`repositoryMock`的方法调用是以特定的顺序发生的。然后，我们验证`passwordEncryptor`的`encrypt()`方法已经被调用，保存的用户中存储的密码是加密版本，而不是明文版本。

# 实现 RegistrationManagement 类

有了我们在上一节中创建的所有测试方法，您可能已经对`RegistrationManagement`的外观有了一个概念，如下所示:

```java
...
@Component
public class RegistrationService {

  private UserRepository repository;
  private PasswordEncryptor passwordEncryptor;

  public RegistrationManagement(UserRepository repository, PasswordEncryptor passwordEncryptor) {
    this.repository = repository;
    this.passwordEncryptor = passwordEncryptor;
  }

  public User register(String username, String emailAddress, String password) throws RegistrationException {
      User existingUser = repository.findByUsername(username);
      if (existingUser != null) {
        throw new UsernameExistsException();
      }

      existingUser = 
        repository.findByEmailAddress(emailAddress.toLowerCase());
      if (existingUser != null) {
        throw new EmailAddressExistsException();
      }

      String encryptedPassword = passwordEncryptor.encrypt(password);
      User newUser = User.create(
        username, emailAddress.toLowerCase(), encryptedPassword);
      repository.save(newUser);
      return newUser;
  }
}
```

正如您所看到的，这个域服务非常简单。有些人可能会怀疑这个`RegistrationManagement`类的存在，并认为这是过度设计，因为这个注册逻辑可以放在`UserServiceImpl`的`register()`方法中，这样就可以节省创建`RegistrationManagement`的工作量。其他人甚至可能更喜欢将这个注册逻辑移到`RegistrationController`内部，这样代码会简单得多。如果我们从简单的角度来看这两种选择，毫无疑问，它们都更简单。然而，如果我们从可扩展性和可维护性的角度来看，使用`RegistrationManagement`更好，因为它封装了必要的业务规则，这样调用其`register()`方法的客户就不需要关心这些规则。并且，将来当我们需要在注册过程中添加更多规则时，我们只需要修改`RegistrationManagement`。

例如，有些人可能更喜欢将`RegistrationManagement`声明为接口，然后使用`RegistrationManagementImpl`来实现实际的逻辑。对于应用服务，它在应用核心和它的客户端之间建立了边界，使用接口是首选的，因为我们不希望`Controller`直接引用实际的实现，这给了我们一个狭窄的空间来发展实现。对于`RegistrationManagement`这样的域服务，不需要在应用核心内部声明边界。只有当您需要应用策略设计模式时，使用域服务的接口才有意义，在这种情况下，同一接口将有多个实现，实现的选择取决于所需的策略。

# 实现注册管理依赖项

这里简单介绍一下`RegistrationManagement`的依赖关系。在这个阶段，我们的重点是获得`RegistrationManagementTests`通行证。在测试中，我们使用模拟来定义依赖关系的行为。因此，我们只需要创建一个依赖项的空白实现，实际的实现留到本章后面的部分。

下面是`PasswordEncryptor`接口的空白实现:

```java
@Component
public class PasswordEncryptorDelegator implements PasswordEncryptor {
  @Override
  public String encrypt(String rawPassword) {
    // TODO implement this
    return rawPassword;
  }
}
```

正如你所看到的，我们将其命名为`PasswordEncryptorDelegator`，表示实际的密码加密逻辑被委托给了其他人，在我们的例子中，就是 Spring Security 的`PasswordEncoder`，这一点我们将在后面讨论。

这里是`MailManager`接口的空白实现:

```java
@Component
public class DefaultMailManager implements MailManager {

  @Override
  public void send(String emailAddress, String subject, String template, MessageVariable... variables) {
    // TODO implement this
  }
}
```

这个邮件管理器负责从模板和变量创建邮件消息，然后调用邮件服务 API 将消息发送出去。

下面是`UserRepository`界面的样子:

```java
...
public interface UserRepository {
  User findByUsername(String username);
  User findByEmailAddress(String emailAddress);
  void save(User user);
}
```

如你所见，这个界面很干净，很容易理解。我们稍后将讨论它的实现。

现在，如果您从 VS 代码运行`RegistrationManagementTests`，您应该看到所有的测试都通过了。

至此，我们已经完成了域模型内部注册的实现。是时候在数据库中保存用户了。

# 实现用户存储库

如前所述，我们将使用 Hibernate 将数据保存到 MySQL 数据库中。Spring 数据 JPA 的 JPA 实现基于 Hibernate。

Spring Data JPA 的特别之处在于，它只需要开发人员编写存储库接口，从而大大减少了编写存储库的工作量，并且它会为我们自动生成实现，这听起来很完美，非常高效。

为了使用 Spring Data JPA 提供的实现特性的自动生成，我们需要将`UserRepository`接口更改如下:

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
  User findByUsername(String username);
  User findByEmailAddress(String emailAddress);
}
```

如你所见，我们需要将`@Repository`注释应用到接口上，并使其从 Spring 的`JpaRepository`或`CurdRepository`中扩展出来。我们不再需要原始接口中的`save()`方法，因为`JpaRepository`已经有了一个。除了`save()`方法，我们还继承了一堆其他方法，比如`saveAll()`、`getOne()`和`findAll()`。

如果我们需要找到昨天注册的用户，我们可以在`UserRepository`接口中声明一个 API，如下所示:

```java
List<User> findByCreatedDateBetween(Date, Date);
```

或者，我们可以创建以下方法，按姓氏查找用户，并按名字降序排序:

```java
List<User> findByLastNameOrderByFirstNameDesc(String lastName);
```

Spring Data JPA 也支持开箱即用的分页，例如，以下方法可以按姓氏查找用户并返回分页结果:

```java
List<User> findByLastName(String lastName, Pageable pageable);
```

Spring Data JPA 提供了一个查询关键字列表，您可以将这些关键字放入方法名称中。除此之外，您可以将`@Query`注释应用于一个方法来创建一个定制查询，如下所示:

```java
@Query("select u from User u where u.emailAddress = ?1")
User findByEmailAddress(String emailAddress);
```

或者，使用本机查询，如下所示:

```java

@Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)
User findByEmailAddress(String emailAddress);
```

如果这仍然不能满足您的需求，您可以创建一个带有自定义实现的自定义存储库接口。

但是，这真的是一个好方法吗？这个问题的答案取决于你希望`Repository`界面是什么样子。如果您习惯于将方法命名选项缩小到这些关键字，使用`@Query`在接口中指定查询，或者为自定义查询创建另一个`Repository`接口，那么实现的自动生成会非常高效。您也不需要担心对`Repository`接口进行单元测试，因为 Spring Data JPA 为此提供了一个很好的解决方案。

另一方面，如果您希望您的存储库接口干净并且实现中立，以便您可以自由地从 Hibernate 切换到其他实现，比如 MyBatis 或 Spring JDBC，您可能不希望以前面描述的方式使用 Spring Data JPA。

在 **TaskAgile** 中，我们希望保持`Repository`接口的整洁，并保持基础设施相关的实现在我们的领域模型之外。所以，我们要做的是:

*   保持`UserRespository`界面不变
*   在`com.taskagile.infrastructure.repository`包中创建一个`HibernateUserRepository`实现
*   让 Spring Data JPA 为我们创建`DataSource`实例和`EntityManager`实例，以及设置连接池；从那里，我们将自己实现这些方法

让我们开始吧。

# 创建 HibernateUserRepositoryTests

在`HibernateUserRepositoryTests`中，我们将创建以下测试方法来涵盖不同的场景:

*   `save_nullUsernameUser_shouldFail()`
*   `save_nullEmailAddressUser_shouldFail()`
*   `save_nullPasswordUser_shouldFail()`
*   `save_validUser_shouldSuccess()`
*   `save_usernameAlreadyExist_shouldFail()`
*   `save_emailAddressAlreadyExist_shouldFail()`
*   `findByEmailAddress_notExist_shouldReturnEmptyResult()`
*   `findByEmailAddress_exist_shouldReturnResult()`
*   `findByUsername_notExist_shouldReturnEmptyResult()`
*   `findByUsername_exist_shouldReturnResult()`

首先，让我们添加一个 H2 依赖到 Maven 的`pom.xml`中，如下所示，这样当 Spring Boot 开始测试时，它知道我们需要 H2 而不是 MySQL:

```java
<dependency>
  <groupId>com.h2database</groupId>
  <artifactId>h2</artifactId>
  <scope>test</scope>
</dependency>
```

由于 H2 需要的数据源配置不同于 MySQL 在`src/main/resources/application.properties`中使用的数据源配置，让我们在`src/test/resources/`目录中为 H2 创建`application.properties`,设置如下:

```java
spring.datasource.url=jdbc:h2:mem:taskagile;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE 
spring.datasource.username=sa
spring.datasource.password=sa
spring.datasource.driver-class-name=org.h2.Driver

spring.jpa.open-in-view=false
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
```

如您所见，我们通过指定数据源的`url`和`driver-class-name`来使用 H2 数据库，并通过将`ddl-auto`指定为`create-drop`来让 Hibernate 自动生成和删除数据库。我们还关闭了 Hibernate 的 Open Session In View 特性，然后我们通过 Hibernate 的`H2Dialect`的类名让 JPA 知道我们正在使用的数据库平台。

因为我们已经在`src/**test**/resources/application.properties`中添加了`spring.jpa.*`设置，所以让我们也将以下设置添加到`src/**main**/resources.application.properties`中，以明确我们需要这些设置用于测试以外的环境:

```java
spring.jpa.open-in-view=false
spring.jpa.hibernate.ddl-auto=none
spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect
```

只有当 Spring 在`test`概要文件中运行时，它才会读取`src/**test**/resources/application.properties`文件中的设置。默认情况下，当您启动 Sprint Boot 应用时，它在`dev`配置文件中运行。我们将需要改变活动配置文件，以便 Spring 可以知道我们正在进行测试。我们可以将`@ActiveProfiles`注释应用到测试中，比如下面的`TaskAgileApplicationTests`，它最初是由 Spring Initializr 生成的:

```java
...
@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("test")
public class TaskAgileApplicationTests {
  @Test
  public void contextLoads() {
  }
}
```

如你所见，我们在这里使用了`@SpringBootTest`注释，这样 Spring Boot 将寻找一个主类，在我们的例子中是用`@SpringBootApplication`注释的`TaskAgileApplication`类，然后启动一个 Spring 应用上下文，将应用中定义的所有 Spring beans 加载到上下文中。如果没有使用`@ActiveProfiles`注释来指定概要文件，当我们运行`mvn clean install`命令或`mvn test`时，Spring 将读取`dev`概要文件的`src/main/resources/application.properties`，并且不能初始化 H2 数据库。

我们需要添加的另一个属性文件是`src/test/resources/hibernate.properties`，如下所示:

```java
hibernate.hbm2ddl.auto=create-drop
hibernate.dialect=org.hibernate.dialect.H2Dialect
hibernate.show_sql=true
hibernate.format_sql=true
```

在测试过程中，Hibernate 将从这个文件中获取设置。

现在，让我们回到`HibernateUserRepositoryTests`。以下是第一种测试方法:

```java
...
@RunWith(SpringRunner.class)
@ActiveProfiles("test")
@DataJpaTest
public class HibernateUserRepositoryTests {

  @TestConfiguration
  public static class UserRepositoryTestContextConfiguration {
    @Bean
 public UserRepository userRepository(EntityManager entityManager) {
 return new HibernateUserRepository(entityManager);
 }
  }

  @Autowired
  private UserRepository repository;

  @Test(expected = PersistenceException.class)
  public void save_nullUsernameUser_shouldFail() {
User inavlidUser = User.create(
  null, "sunny@taskagile.com", "MyPassword!");
    repository.save(inavlidUser);
  }
}
```

如您所见，我们对它应用了`@ActiveProfiles`注释和`@DataJpaTest`注释。与`@SpringBootTest`注释不同，`@DataJpaTest`注释仅用于测试 JPA 组件。由于它的存在，默认情况下，测试将使用嵌入式内存数据库，在我们的例子中，是 H2 数据库。我们创建一个内部配置类来创建一个`HibernateUserRepository`的实例，这样它就可以自动连接到测试类中。

事实上，如果我们使用 Spring 数据 JPA 方式的`UserRepository`,我们就不需要像这样使用测试配置来实例化`UserRepository`,因为 Spring 会生成存储库实现，并在出现`@DataJpaTest`注释的情况下自动为我们实例化它。

在这个测试中，我们不需要创建任何模拟。所有的数据库交互都将在内存数据库中执行。

在`save_nullUsernameUser_shouldFail()`方法中，我们试图保存一个没有`username`的用户，它应该会失败，因为在`User`实体中，我们将`nullable=false`放在应用于`username`字段的`@Column`注释中。

我们不会在这里讨论其余的测试方法，因为这个`HibernateUserRepositoryeTests`与我们之前创建的所有测试的唯一主要区别是如何初始化嵌入式数据库。您可以在 GitHub 上的提交历史中找到这个测试类的详细信息。

# 实现 HibernateUserRepository

如前所述，Spring Data JPA 将为我们实例化`EntityManager`。`EntityManager`是 JPA 的一个接口。在我们的应用中，Hibernate 是底层实现。Hibernate 提供了比 JPA 更强大的 API。例如，`org.hibernate.query.Query`接口支持`Generics`，而`javax.persistence.Query`接口不支持。在本书中，我们大部分时间将在我们的存储库实现中使用 Hibernate 的 API。

为了简单起见，我们先创建一个抽象基类`HibernateSupport`，从`EntityManager`中检索`org.hibernate.Session`的一个实例。这是它的样子:

```java
...
abstract class HibernateSupport {

  EntityManager entityManager;

  HibernateSupport(EntityManager entityManager) {
    this.entityManager = entityManager;
  }

  Session getSession() {
    return entityManager.unwrap(Session.class);
  }
}
```

正如你所看到的，我们要求 Spring 在这里注入`EntityManager`实例，然后在`getSession()`方法中，返回`org.hibernate.Session`的实例，我们使用`EntityManager`的`unwrap()`方法获得 Hibernate `session`的实例。

下面是`HibernateUserRepository`的样子:

```java
...
@Repository
public class HibernateUserRepository extends HibernateSupport 
    implements UserRepository {

  public HibernateUserRepository(EntityManager entityManager) {
    super(entityManager);
  }

  @Override
  public User findByUsername(String username) {
Query<User> query = getSession().createQuery(
  "from User where username = :username", User.class);
    query.setParameter("username", username);
    return query.uniqueResult();
  }

  @Override
  public User findByEmailAddress(String emailAddress) {
Query<User> query = getSession().createQuery(
  "from User where emailAddress = :emailAddress", User.class);
    query.setParameter("emailAddress", emailAddress);
    return query.uniqueResult();
  }

  @Override
  public void save(User user) {
    entityManager.persist(user);
    entityManager.flush();
  }
}
```

如你所见，除了直接使用`EntityManager` API 的`save()`方法，对于另外两个`find*`方法，我们使用 Hibernate 的 API。这里确实有样板代码。代价是我们将基础设施实现细节排除在我们的领域模型之外。

现在，让我们运行`mvn clean install`命令，以确保在提交代码之前一切正常。正如您应该看到的，这是一个成功的构建。以下是 GitHub 上的提交记录:

![](img/c08c9489-64b7-4e06-9c2a-022a3c6b4706.png)

图 9.13:在域模型和存储库提交中实现注册

# 最后的修正

以下是本章中的修复:

*   **修复** — **添加/注册请求映射** : 如果您在全新安装后运行`mvn spring-boot:run`命令，然后在`https://localhost:8080/register,`打开页面，您将会看到一个`404`错误页面。这是因为我们还没有在`MainController`里面给`@GetMapping`加上`/register`。让我们现在修理它。修复后，尝试从注册页面执行注册。注册后，您应该会看到`UserRegisteredEventHandler`创建的调试信息。

没有将`/register`添加到映射中揭示了我们端到端测试中的缺陷。端到端测试应该在构建过程中捕获这类问题。可惜没有。我们将在下一章改进我们的端到端测试。以下是提交记录:

![](img/7e71c359-11aa-4abf-bebf-ebeb9011704a.png)

图 9.14:修复—添加/注册到请求映射提交

*   **修复**—**`encrypt()`方法** : 无效返回值在我们的`PasswordEncryptor`、`PasswordEncryptorDelegator`实现中，`encrypt()`方法返回一个`null`值，导致注册失败。现在让我们将它改为返回原始密码，这样我们就可以成功注册了。我们将在下一章使用 Spring Security 的`PasswordEncoder`来加密密码。

以下是提交记录:

![](img/0035d076-d50f-4194-bdc9-8f095368d9e4.png)

图 9.15:修复—加密方法提交的无效返回值

# 摘要

在这一章中，我们已经介绍了整个全栈开发，从注册页面的 UI 创建到注册的逻辑和数据验证，然后我们转到后端实现。我们还展示了 TDD 实践，并且研究了如何编写更强大的单元测试。

由于本书的范围，没有涵盖注册页面实现的每个细节。你可以用 GitHub 上的 commit 记录来看看应用是如何一步一步创建的。

在下一章中，我们将介绍 Spring 安全并实现登录页面。我们还将重构我们的端到端测试，使其真正有用。