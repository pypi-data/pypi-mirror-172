# 三、Spring5——手头工作的正确技术栈

Spring 框架是创建 Java EE 应用的事实上的标准。与其早期的竞争对手**EJB**(**Enterprise JavaBean s**的简称)相比，它是轻量级的。Spring Framework 的创始人 Rod Johnson 在他的书《没有 EJB 的一对一 J2EE 开发专家》中写道:

控件容器的轻量级反转对于实现 J2EE 应用有巨大的好处。我相信控制反转和 AOP 一起为下一代 J2EE 架构提供了基础。

那是在 2004 年。他是对的。在过去的 16 年中，自 2002 年框架的最初发布以来，Spring 已经成为人们用来构建 Java EE 应用的首选框架。而且，有了 Spring Boot，构建 Spring 应用变得比以往任何时候都更加容易和高效。

在这一章中，我们将介绍 Spring Framework 5 的基本概念。您将执行以下操作:

*   了解什么是**控制反转** ( **IoC** )和**依赖注入** ( **DI** )
*   学习 Spring MVC
*   学习 Spring JDBC 和 JAP 进行数据访问
*   学习面向方面编程、Spring AOP 及其好处
*   了解 Spring 如何管理事务
*   学习 Spring Boot

在这个过程中，我们将使用 Spring 提供的这些技术来创建 Messages 应用的后端。最后，我们将把本章中创建的 Messages 应用的前端与后端集成起来。

# Spring IoC 和依赖注入

按照惯例，在 Spring 中，由 Spring 容器管理的对象通常被称为**bean**。它们构成了我们应用的主干。在 Java 中，有两种方法来管理对象的依赖关系。第一种方式是对象本身或者通过调用其依赖项的构造函数来实例化其依赖项(例如，在其构造函数内部),或者通过使用查找模式来定位其依赖项。下面是`RegistrationService`的例子，注册成功后给用户发邮件。为了简单起见，我们将集中在依赖部分，跳过注册和发送电子邮件的细节。

以下代码清单显示了`RegistrationService`如何在其构造函数中实例化`MailSender`:

```java
public class RegistrationService {
  private MailSender mailSender;
  public RegistrationService() {
    // Instantiate dependencies itself
    this.mailSender = new MailSender();
  }
  // ... other logics
}
```

如您所见，通过实例化`MailSender` , `RegistrationService`控制对其依赖项的管理。这是管理依赖关系的第一种方式。

让我们看看第二种方式，它依赖于一个容器，在我们的例子中是 Spring，通过它的构造函数或设置函数来注入它的依赖项。例如，我们可以将`RegistrationService`改为如下:

```java
public class RegistrationService {
  private MailSender mailSender;
  public RegistrationService(MailSender mailSender) {
    this.mailSender = mailSender;
  }
  // ... other logics
} 
```

如您所见，我们添加了一个`MailSender`实例作为`RegistrationService`构造函数的参数。这样，`RegistrationService`对其附属国没有控制权。Spring 现在负责实例化`MailSender`实例。依赖性的控制是颠倒的。这也是**控制反转** ( **IoC** )这个名字的由来。

那么，Spring 是如何知道一个类需要哪些依赖的呢？它使用我们提供的配置元数据。在配置中，我们指定需要创建什么对象以及它们的依赖关系是什么。要设置一个 Spring 容器，传统的方法是将配置元数据放在一个 XML 文件中，通常命名为`applicationContext.xml`。从 Spring 2.5 开始，我们可以使用基于注释的配置来提升容器。从 Spring 3.0 开始，我们可以使用基于 Java 的配置来定义零 XML 配置。如今，基于 XML 的配置被认为是过时的，应该在遗留代码中使用。在我们的例子中，我们将使用基于 Java 的配置。

# 旋转 Spring 容器

在 Spring 中，`org.springframework.context.ApplicationContext`接口代表 Spring IoC 容器。在独立应用中，设置容器的典型方式是使用`ClassPathXmlApplicationContext`或`AnnotationConfigApplicationContext`。两者都是`ApplicationContext`接口的实现。顾名思义，`ClassPathXmlApplicationContext`用于基于 XML 的配置，而`AnnotationConfigApplicationContext`用于基于 Java 的配置，这就是我们将要使用的。

让我们开始构建 Messages 应用的后端。在介绍 Spring 的特性时，我们将把它一点一点地构建成一个可行的 Spring Boot web 应用。

本书中的所有代码都是用 Visual Studio 代码([https://code.visualstudio.com/](https://code.visualstudio.com/))编写的，并且为前端代码编写安装了以下扩展:

*   **ESLint** ( `dbaeumer.vscode-eslint` )

*   **韦图尔** ( `octref.vetur`)

为后端代码编写安装了以下扩展:

*   **针对 Visual Studio 代码的 Java**语言支持(`redhat.java`
*   Java 扩展包 ( `vscjava.vscode-java-pack`)
*   【Java 调试器 ( `vscjava.vscode-java-debug`)
*   **Spring Boot 支持** ( `Pivotal.vscode-spring-boot`)
*   **Maven 项目总管** ( `vscjava.vscode-maven`)

我们将使用 Maven([https://maven.apache.org](https://maven.apache.org))创建这个应用。对于不熟悉 Maven 的读者来说，你可以把它想象成 Java 世界里的`npm`。典型的 Maven 项目目录结构如下所示:

```java
/src
/src/main/java 
/src/main/resources
/src/main/webapp
/src/test/java 
/src/test/resources
/pom.xml
```

`/src/main`文件夹是应用源代码的根目录。`/src/main/webapp`用于 web 应用放置视图——静态资产。但是，因为我们正在构建一个 Spring Boot web 应用，所以我们不需要这个文件夹。`/src/test`文件夹是应用测试代码的根。`pom.xml`文件是 Maven 的配置文件；你可以把它想象成 Maven 中的`package.json`。

**项目对象模型** ( **POM** )是 Maven 中的工作单元。更多详情请参考[https://maven . Apache . org/guides/introduction/introduction-to-the-POM . html](https://maven.apache.org/guides/introduction/introduction-to-the-pom.html)。

要启动一个 Maven 项目，第一步是创建`pom.xml`文件。我们的`pom.xml`文件是这样的:

```java
1\. <?xml version="1.0" encoding="UTF-8"?>
2\. <project 
3\.          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
4\.          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
            http://maven.apache.org/xsd/maven-4.0.0.xsd">
5\.   <modelVersion>4.0.0</modelVersion>
6\. 
7\.   <groupId>app.sample</groupId>
8\.   <artifactId>messages</artifactId>
9\.   <version>1.0-SNAPSHOT</version>
10\.   
11\.  <properties>
12\.    <spring.version>5.0.3.RELEASE</spring.version>
13\.    <log4j.version>2.10.0</log4j.version>
14\.  </properties>
15.
16\.  <dependencies>
17\.    <dependency>
18\.      <groupId>org.springframework</groupId>
19\.      <artifactId>spring-context</artifactId>
20\.      <version>${spring.version}</version>
21\.    </dependency>
22\.    <dependency>
23\.      <groupId>org.apache.logging.log4j</groupId>
24\.      <artifactId>log4j-api</artifactId>
25\.      <version>${log4j.version}</version>
26\.    </dependency>
27\.    <dependency>
28\.      <groupId>org.apache.logging.log4j</groupId>
29\.      <artifactId>log4j-core</artifactId>
30\.      <version>${log4j.version}</version>
31\.    </dependency>
32\.  </dependencies>
33\. 
34\. </project>
```

`pom.xml`的根是`<project>`元素。在`5`行中，`modelVersion`是 POM 本身的版本；通常，你不需要改变它。在第`7`到`9`行，我们定义了应用工件的细节。如果您的应用/库已经发布，那么工件将由`groupId`、`artifactId`和`version`的组合来标识。在第`11`到`14`行，我们添加了这个 POM 的属性来指定我们使用的依赖项的版本。在第`16`到`32`行，我们添加了 Spring Framework 和 Apache Log4j 作为这个应用的依赖项。

现在，让我们编写位于`app.messages`包中的源代码。我们将创建以下四个 Java 类:

```java
/src/main/java/app/messages/AppConfig.java
/src/main/java/app/messages/Application.java
/src/main/java/app/messages/Message.java
/src/main/java/app/messages/MessageRepository.java
/src/main/java/app/messages/MessageService.java
```

`AppConfig.java`是 Spring 将用来实例化容器的配置元数据。`Application.java`是应用的入口点。这是`main()`方法存在的地方。`Message.java`定义消息模型，结构非常简单。`MessageRepository.java`是一个负责保存消息的仓库的演示。`MessageService.java`是为客户提供 API 的应用服务。

在我们的 Messages 应用中，为了简单起见，我们将使用具体的类而不是接口来定义存储库和服务。而且，在这一点上，我们没有可用于基于 HTTP 的访问的 API。此外，我们为 Messages 应用使用的代码结构是扁平的。所有东西都住在同一个包里，不实用。在本章结束时，您将看到软件包是如何增长的。

让我们来创造`Message.java`。它看起来是这样的:

```java
1\. package app.messages;
2.
3\. public class Message {
4\.   private String text;
5\.   public Message(String text){this.text = text;}
6\.   public String getText(){return text;}
7\. }
```

行`1`定义了`Message`类所在的包。在`4`行中，我们定义了一个`String`类型的`private`字段`text`。在第`5`行，我们定义了一个`Message`类构造函数。它接受一个参数`text`，该参数被分配给私有字段`text`。在 Java 中，参数名可以和类字段名相同。你可以使用`this`关键字来区分它们。在第`6`行，我们为其他人定义了一个 getter 方法来访问`private text`字段。

这里的代码已经被重新格式化，所以它需要更少的行。在实践中，你应该遵循 Java 风格指南的惯例，例如，[https://github.com/google/styleguide](https://github.com/google/styleguide)。

`MessageRepository.java`看起来是这样的:

```java
1\. package app.messages;
2\. 
3\. import org.apache.commons.logging.Log;
4\. import org.apache.commons.logging.LogFactory;
5\. 
6\. public class MessageRepository {
7.
8\.   private final static Log log = 
     LogFactory.getLog(MessageRepository.class);
9.
10\.  public void saveMessage(Message message) {
11\.    // Save message to a database
12\.    log.info("Saved message: " + message.getText());
13\.  }
14.}
```

如您所见，在第`8`行，我们创建了一个`Log`的实例。在第`10`到`13`行中，我们创建了`saveMessage()`方法，该方法将一个`Message`对象作为其参数。我们将把消息保存到数据库的实现留到后面的小节。这里，我们将简单地在日志中打印出一条消息。

`MessageService.java`看起来是这样的:

```java
1\. package app.messages;
2.
3\. public class MessageService {
4\.   private MessageRepository repository;
5.
6\.   public MessageService(MessageRepository repository) {
7\.     this.repository = repository;
8\.   }
9\.   public void save(String text) {
10\.    this.repository.saveMessage(new Message(text));
11\.  }
12.}
```

如你所见，在第`4`行，我们将`MessageRepository`定义为`MessageService`的依赖项。在第`6`到`8`行，我们创建了一个构造函数，它将`MessageRepository`的一个实例作为它的参数。Spring 将通过这个构造函数为我们连接依赖关系。在第`9`到`11`行中，我们定义了一个简单的 API `save(String)`方法，它允许它的客户端传递一个`String`类型的文本并保存到存储库中。

既然`MessageService`类和`MessageRepository`类已经准备好了，让我们创建配置`AppConfig.java`，如下所示:

```java
1\. package app.messages;
2\. 
3\. import org.springframework.context.annotation.Bean;
4\. import org.springframework.context.annotation.ComponentScan;
5\. import org.springframework.context.annotation.Configuration;
6\. 
7\. @Configuration
8\. @ComponentScan("app.messages")
9\. public class AppConfig {
10.
11\.  @Bean
12\.  public MessageRepository messageRepository() {
13\.    return new MessageRepository();
14\.  }
15.
16\.  @Bean
17\.  MessageService messageService() {
18\.    return new MessageService(messageRepository());
19\.  }
20.}
```

如您所见，在第`7`行，我们应用了`@Configuration`注释来告诉 Spring 这个`AppConfig.java`是用于定义 beans 的。第`8`行的`@ComponentScan`注释与`@Configuration`一起使用，告诉 Spring 扫描带注释组件的基础包。我们使用`@Bean`注释来注释`messageRepository()`方法和`messageService()`方法。这些方法负责生成 beans。方法名将是 bean 的名称；换句话说，`MessageRepository` bean 的名称将是`messageRepository`。对于`MessageService`也是一样。在第`18`行，我们将`MessageRepository`实例传递给`MessageService`构造函数。

现在，是时候在`Application.java`中旋转容器了。它看起来像下面这样:

```java
1\. package app.messages;
2\. 
3\. import org.springframework.context.ApplicationContext;
4\. import org.springframework.context.annotation.
   AnnotationConfigApplicationContext;
5\. 
6\. public class Application {
7\.   public static void main(String[] args) {
8\.     ApplicationContext context = new 
       AnnotationConfigApplicationContext(AppConfig.class);
9\.     MessageService messageService = 
       context.getBean(MessageService.class);
10\.    messageService.save("Hello, Spring!");
11\.  }
12.}
```

在第`7`行中，我们使用`static` - `void` - `main`方法定义了应用的入口点，该方法将一组`String`对象作为其参数。在第`8`行，我们通过将`AppConfig`类传递给`AnnotationConfigApplicationContext`类的构造函数来创建 Spring 容器。在第`9`行中，我们通过调用在`org.springframework.beans.factory.BeanFactory`接口中定义的`getBean(Class<T>)`方法来检索`MessageService` bean 的实例，该方法由`ApplicationContext`接口扩展。此时，我们从 Spring 容器中获得的`messageService` bean 已经被完全实例化，值得注意的是,`MessageRepository`的一个实例已经被注入其中。在第`10`行，我们请求服务保存消息。

现在，让我们运行代码。我们将使用 Maven 生成一个`.jar`文件，并从命令行运行它。为了做到这一点，我们需要更新`pom.xml`文件，并在`<dependencies>`部分下面添加下面的`<build>`部分。

它看起来是这样的:

```java
</dependencies>
<build>
  <finalName>messages</finalName>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-assembly-plugin</artifactId>
      <executions>
        <execution>
          <phase>package</phase>
          <goals><goal>single</goal></goals>
          <configuration>
            <archiveBaseDirectory>${project.basedir}
            </archiveBaseDirectory>
            <archive>
              <manifest>
                <mainClass>app.messages.Application</mainClass>
              </manifest>
            </archive>
            <descriptorRefs>
              <descriptorRef>jar-with-dependencies</descriptorRef>
            </descriptorRefs>
          </configuration>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
</project>
```

基本上，这将 Maven 插件`maven-assembly-plugin`添加到构建过程中。这个插件需要`.jar`文件的`main`类的信息。我们在`mainClass`标签中提供了它。为了从命令行执行`.jar`文件，我们还需要将应用的依赖项(在我们的例子中是`spring-context-5.0.3.RELEASE.jar`)包含到`.jar`文件中。那就是`<descriptorRef>`的目的。

在构建应用之前，我们需要在`src/main/resources/log4j2.xml`添加 Log4j 配置，如下所示:

```java
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level 
       %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="app.messages" level="INFO">
      <AppenderRef ref="Console"/>
    </Logger>
    <Root level="ERROR"/>
  </Loggers>
</Configuration>
```

如您所见，在这个配置中，我们为我们的应用定义了一个控制台 appender 和一个 logger。并且日志的根级别被设置为`ERROR`。如果你对 Log4j 的配置细节感兴趣，可以在这里查看它的手册:[https://logging . Apache . org/Log4j/2 . x/manual/configuration . html](https://logging.apache.org/log4j/2.x/manual/configuration.html)。

现在，在 macOS 中打开一个终端，或者在 Windows 中打开一个命令行，切换到应用的根文件夹，在那里保存`pom.xml`文件并执行`mvn install`，这将从公共 Maven 资源库下载所有需要的依赖项，然后构建`.jar`文件。输出将放在应用根文件夹下的`target`文件夹下。构建完成后，执行以下命令:

```java
java -jar target/messages-jar-with-dependencies.jar
```

您应该会看到类似如下的输出:

```java
13:07:55.381 [main] INFO  app.messages.MessageRepository - Saved message: Hello, Spring!
```

到目前为止，您已经成功创建了一个非常简单的 Spring 应用。

# 基于注释的配置

在我们刚刚创建的`AppConfig.java`中，我们使用了`messageRepository()`方法和`messageService()`方法来实例化`MessageRepository`和`MessageService`，并将它们合并到 Spring 容器中。当您只有少量的 beans 需要初始化时，这种方法非常有效。然而，当应用中有很多 beans 时，通过构造函数或 setters 手动传递依赖关系需要太多的样板代码和太多的注意力。

Spring 提供了基于注释的配置，这使得依赖性管理更加容易。Spring 主要提供两种类型的注释。第一种类型用于声明 beans，第二种类型用于连接依赖项。

# Bean 声明

首先，我们来看看如何使用 Spring 注释来声明 beans。

Spring 提供了一组用于声明 beans 的原型注释，包括`@Component`、`@Service`、`@Controller`和`@Repository`。我们可以将这些注释应用到需要 Spring 管理的类中。Spring 将通过扫描包来挑选它们，从我们提供给`@ComponentScan`注释的基础包开始。

`@Component`注释是一个通用的原型。当用这个注释对一个类进行注释时，Spring 将实例化该类的一个实例。`@Service`注释是`@Component`的一个专门化，它表明被注释的类是一个服务，一个在*领域驱动设计* (Evan，2003)中使用的术语，或者一个业务服务外观，一个核心 J2EE 中的模式。`@Repository`注释表明一个组件是一个存储库，也是一个在*域驱动设计*或**数据访问对象** ( **DAO** )中使用的术语，一个传统的 Java EE 模式。`@Controller`注释表明组件是一个可以接受 HTTP 请求的 web 控制器。关于`@Service`、`@Repository`、`@Controller`我们后面会讲的更多。现在，让我们简单地使用`@Component`注释。以下是对`MessageService`的更改:

```java
...
import org.springframework.stereotype.Component;
@Component
public class MessageService {
...
```

如您所见，为了让 Spring 管理我们的 beans，我们需要做的就是在类级别应用`@Component`注释。以下是对`MessageRepository`的更改:

```java
...
import org.springframework.stereotype.Component;
@Component
public class MessageRepository {
...
```

既然我们已经使用了`@Component`来声明`MessageService`和`MessageRepository`的 beans，让我们从`AppConfig`中删除`messageRepository()`和`messageService()`方法，因为不再需要它们了。

事实上，如果我们将这两个方法留在`AppConfig`中，Spring 仍然会使用它们来创建`MessageRepository`和`MessageService`的实例，应用于这两个类的`@Component`注释不会生效。它们被`AppConfig`内的`@Bean`注释覆盖。

# 依赖注入

为了连接依赖关系，我们可以使用 Spring 提供的这两个注释——`@Required`注释和`@Autowired`注释。我们可以将`@Required`注释应用于 setter 方法，将`@Autowired`注释应用于构造函数、方法和字段。

综上所述，在 Spring 中，注入依赖有三种方式:

*   基于构造函数的注入
*   基于设置器/基于方法的注入
*   基于场的注射。

# 基于构造函数的注入

顾名思义，这种类型的注入是通过构造函数完成的。并且，在我们的 Messages 应用中，通过构造函数将一个`MessageRepository` bean 注入到一个`MessageService` bean 中。我们可以将`@Autowired`注释应用于构造函数，如下所示:

```java
@Autowired
public MessageService (MessageRepository repository) {
  this.repository = repository;
}
```

我们也可以省略这里的`@Autowired`注释，Spring 仍然知道它需要注入一个`MessageRepository` bean，从而检查`MessageService`构造函数并找出参数的类型。

# 基于设置器/基于方法的注入

第二种方法是声明一个方法，通常是一个 setter，并对其应用`@Autowired`注释或`@Required`注释。例如，我们可以移除`MessageService`构造函数并添加一个`setRepository(MessageRepository)`方法，如下所示:

```java
public class MessageService {
   ...
   @Required
   public void setRepository(MessageRepository repository) {
     this.repository = repository;
   }
   ...
}
```

或者，您可以将其命名为其他名称，例如:

```java
@Autowired
public void prepare (MessageRepository repository) {
  this.repository = repository;
}
```

# 基于场的注射

使用`@Autowired`注释，您可以将它直接应用于一个字段。这样，您不需要为它声明一个 setter 方法，如下所示:

```java
@Autowired
private MessageRepository repository;
```

**其他注解** : 除了内置注解、`@Required`和`@Autowired`之外，Spring 还支持 JSR-250 中规定的`@javax.annotation.Resource`注解和 JSR-330 中的`@javax.inject.Inject`注解。

**Java Specification Request** (**JSR**): JSR 250 is for common annotations for the Java<sup>TM</sup> platform. JSR 330 is about dependency injection for Java. You can find more details at: [https://jcp.org/en/jsr/detail?id=250](https://jcp.org/en/jsr/detail?id=250) and [https://jcp.org/en/jsr/detail?id=330](https://jcp.org/en/jsr/detail?id=330).

# 依赖注入的最佳实践

对于那些强制依赖，我们应该总是通过构造函数注入它们。这样，在创建之后，实例将被完全初始化，并且依赖项将是只读的。没有人能再用依赖来诱惑你了。

对于那些可选的依赖项，我们可以通过 setter/methods 注入它们。

至于场基注入，要避免使用。Spring 利用 Java 反射进行字段注入，使用字段注入被认为是有害的。事实上，应该避免使用它，原因如下:

*   它隐藏了依赖关系的信息，比如它们是如何初始化和管理的，以及这些依赖关系依赖于什么。
*   字段注入非常容易，因为您只需要定义一个字段并对其应用`@Autowired`或`@Resource`注释。开发者可以让**对此上瘾**并添加过多的依赖项，违反**单一责任原则** ( **SRP** )，我们将在[第 6 章](06.html)、*代码设计——为稳定性和可扩展性而设计*中讨论。

# 的实现

Spring MVC 提供了构建 web 应用的技术。它基于 Java EE Servlet API。在我们深入研究 Spring MVC 之前，让我们来看看 Java EE web 应用是如何与 servlet 一起工作的。这将有助于你更容易理解 Spring MVC 的作用。

# Java EE Servlet

Java EE servlet，简称 Servlet，存在于一个 Servlet 容器中，这个容器通常是一个应用服务器，例如 Tomcat([https://tomcat.apache.org](https://tomcat.apache.org))。当一个 HTTP 请求到达一个服务器时，通常它会通过一个执行过滤任务的过滤器列表，例如身份验证、日志记录和审计。如果请求没有被任何过滤器返回，应用服务器将把它交给一个注册的 servlet 来处理那些包含与特定模式匹配的 URI 的请求。一旦 servlet 处理完请求，HTTP 响应将在通过处理相应 HTTP 请求的同一组过滤器后被发送回客户机。

在这些过滤器中，您可以执行额外的过滤任务，比如向响应添加某些 HTTP 头。下图显示了这一流程:

![](img/3f07190d-b68a-48e8-822f-10d547fcf0fd.png)

图 3.1: Java EE web 应用请求/响应流

在 Java EE 中，对于每个 HTTP 请求，都会创建一个`HttpServletRequest`实例。对于每个 HTTP 响应，都会创建一个`HttpServletResponse`实例。为了在多个请求中识别一个用户，应用服务器将在收到第一个请求时创建一个`HttpSession`的实例。每个`HttpSession`实例都有一个 ID，称为**会话 ID** 。会话 id 将在 HTTP 响应头中作为 cookie 发送给客户端。客户端将存储 cookie，并在下一个请求中将其发送回服务器。这样，服务器可以通过使用 cookie 中的会话 ID 查找`HttpSession`实例来识别用户。

在 Java EE 中，您可以创建监听器，通过实现`HttpSessionListener`接口来监听`HttpSession`生命周期变更的事件，或者通过实现`ServletRequestListener`接口来监听生命周期请求。

要创建一个 servlet，您可以扩展`javax.servlet.http.HttpServlet`，或者用`@WebServlet`注释对其进行注释，或者将其注册到传统的`web.xml`文件中，该文件是一个 Java EE web 应用的配置文件。无论哪种方式，您都需要将这个 servlet 映射到一个或多个 URI 模式，以便服务器可以将匹配 URIs 的请求路由到它。

此外，在 servlet 中，您可以覆盖以下方法:

*   `doGet`，用于处理 HTTP `GET`请求
*   `doPost`，用于处理 HTTP `POST`请求
*   `doPut`，用于处理 HTTP `PUT`请求
*   `doDelete`，用于处理 HTTP `DELETE`请求

这些方法内部是应用逻辑开始的地方。当使用 servlet 时，如果您需要访问共享资源，比如内存中的数据或执行 I/O，您需要记住的是，您的 servlet 通常处理并发请求，一个请求所做的更改可能会影响其他请求。

# 前端控制器

使用 Spring MVC，您不必创建 servlets。您可以创建一个类，用`@Controller`注释对其进行注释，并使用`@RequestMapping`注释将其映射到某个 URI 模式。按照惯例，这个类的名字通常以`Controller`结尾。

Spring 使用一个中央 servlet`DispatcherServlet`来接受请求。这个`DispatcherServlet`需要被配置为处理所有请求，并且基于在`@RequestMapping`注释中指定的 URI 模式，Spring 将找到一个匹配的控制器来处理请求。

下图显示了使用 Spring MVC 时的请求/响应流:

![](img/dcc8d982-c18c-4a33-b4a0-77ba5db68cd9.png)

图 3.2: Spring DispatcherServlet 和控制器

现在，让我们将 Messages 应用转换成一个 web 应用，并添加一个控制器来接受 HTTP 请求。为此，让我们将 Spring Boot 依赖项添加到`pom.xml`文件中。

在本书中，我们构建的所有 web 应用都将基于 Spring Boot。默认情况下，我们在嵌入式模式下使用 Tomcat 应用服务器，这不需要手动安装 Tomcat。Spring Boot 将处理所有的重物。

下面是对`pom.xml`文件所做的更改:

```java
...
<parent>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-parent</artifactId>
  <version>2.0.0.RELEASE</version>
</parent>

<dependencies>
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>
</dependencies>
...
```

标签从 Spring Boot 的父启动器继承了项目工件。并且`spring-boot-starter-web`依赖项包括我们之前使用的`spring-context`模块。在撰写本文时，Spring Boot 2.0 仍在发布候选中，但我们需要指定 Spring 自己的 Maven 库来下载它。

现在，如果你运行`mvn install`，你可以看到 Maven 也将下载一堆 Spring Boot 需要的依赖项。如果您运行`java -jar target/messages-jar-with-dependencies.jar`命令，您将看到调试信息被打印出来，在输出的最后是我们的消息`"Saved message: Hello, Spring!"`。

到目前为止，我们的应用仍然没有作为 web 应用运行。让我们改变我们的`Application.java`使它成为一个 Spring Boot 网络应用。

它看起来是这样的:

```java
1\. package app.messages;
2\. import org.springframework.boot.SpringApplication;
3\. import org.springframework.boot.autoconfigure.SpringBootApplication;
4\. @SpringBootApplication
5\. public class Application {
6\.   public static void main(String[] args) {
7\.     SpringApplication.run(Application.class, args);
8\.   }
9\. }
```

在第`4`行，我们将`@SpringBootApplication`注释应用于`Application`类，这样 Spring 将执行**神奇的**自动配置。在第`7`行，我们使用`SpringApplication.run()`引导我们的应用，这将启动 Spring 容器。我们删除了`MessageService`保存消息代码，因为我们将使用控制器来处理 HTTP 请求。

现在，让我们创建一个控制器来接受 HTTP 请求。我们将它命名为`MessageController`,因为我们希望在这个控制器中处理所有与消息相关的请求。现在，让我们只添加一个 API 来显示 hello 消息。

下面是`MessageController`出现的方式:

```java
1\. package app.messages;
2\. import org.springframework.stereotype.Controller;
3\. import org.springframework.web.bind.annotation.GetMapping;
4\. import org.springframework.web.bind.annotation.RequestMapping;
5\. import org.springframework.web.bind.annotation.ResponseBody;
6\. @Controller
7\. @RequestMapping("/messages")
8\. public class MessageController {
9\.    @GetMapping("/welcome")
10\.   public String welcome() {
11\.     return "Hello, Welcome to Spring Boot!";
12\.   }
13\. }
```

在第`6`行，我们应用了`@Controller`注释来使`MessageController`类成为一个实际的 Spring MVC 控制器。在第`7`行中，我们使用`@RequestMapping`注释来映射控制器，以处理与 URI 模式`"/messages"`匹配的请求。在第`9`行，我们使用`@GetMapping`注释映射`welcome()`处理程序方法来处理与 URI 模式匹配的请求；`"/messages/welcome"`。`@GetMapping`注释是`@RequestMapping`的一个快捷变体，用于映射 HTTP `GET`请求。可以用`@RequestMapping(value = "/welcome", method = RequestMethod.GET)`代替。但是`@GetMapping`更简洁。在第`10`到`12`行中，`welcome()`处理程序方法返回一个简单的消息，该消息应该在`HttpServletResponse`中被发回。

现在，如果您运行`mvn install`然后运行`java -jar target/messages-jar-with-dependencies.jar`命令，您可以看到它不起作用。您将在输出中看到一个错误，显示为`Application run failed`。这是因为`maven-assembly-plugin`无法运行 Spring Boot 应用。让我们将它从`<build>`部分删除，并添加`spring-boot-maven-plugin`，它是用于使用 Maven 运行 Spring Boot 应用的。下面是更新后的`<build>`部分的外观:

```java
<build>
  <finalName>messages</finalName>
  <plugins>
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
  </plugins>
</build>
```

现在，让我们运行下面的命令来启动应用。使用这个命令，您不需要运行`mvn install`:

```java
mvn spring-boot:run
```

一旦应用启动，您可以在输出中看到以下消息:

```java
...
Mapped "{[/messages/welcome],methods=[GET]}" onto public java.lang.String app.messages.MessageController.welcome()
...
Tomcat started on port(s): 8080 (http) with context path ''
...
```

这意味着 Spring 已经用 HTTP `GET`请求的`"/messages/welcome"`路径注册了我们的`welcome()`处理程序。Tomcat 服务器已经启动，正在监听来自端口`8080`的 HTTP 请求。

让我们在 Chrome 浏览器中打开`http://localhost:8080/messages/welcome`网址进行测试。等等，是错误页面，写着`HTTP 404 Not Found`，像下面这样:

![](img/da461825-1d2d-4086-ad06-ae38c3519ebb.png)

图 3.3:白色标签 HTTP 404 错误页面

那不应该是对的。我们已经正确注册了我们的`welcome()`处理程序，如启动输出所示。嗯，我们还遗漏了一些东西。我们还没有告诉 Spring 如何处理我们的返回值，`"Hello, Welcome to Spring Boot!"`。默认情况下，在没有任何其他配置的情况下，Spring 认为一个`String`类型的返回值是请求应该在内部转发的路径。在我们的例子中，它试图为不存在的`"/Hello, Welcome to Spring Boot!"`路径找到一个处理程序。这就是为什么错误信息是`HTTP 404`。

为了解决这个问题，让我们将`@ResponseBody`注释添加到处理程序方法中，如下所示:

```java
@GetMapping("/welcome")
@ResponseBody
public String welcome() {
  return "Hello, Welcome to Spring Boot!";
}
```

有了`@ResponseBody`注释，Spring 会将返回值作为 HTTP 响应的主体，它会找到相应的`HttpMessageConverter`将值写入响应。您还可以将注释应用于`MessageController`类，这与将注释应用于该类中的所有方法具有相同的效果。

现在，如果您终止应用并再次运行`mvn spring-boot:run`，您应该会在刷新后在浏览器中看到 hello 消息。

要构建 RESTful API，您还可以将`@RestController`注释应用于控制器。`@RestController`注释是`@Controller`和`@ResponseBody`的组合。当我们讨论 RESTful APIs 时，我们将更多地讨论这一点。

# 视图

在`welcome()`处理程序中，我们向客户端返回了一个非常简单的`String`,这不是我们想要的，因为对于一个 web 应用，我们通常需要向浏览器发送一段 HTML 代码来呈现一个 web 页面或者发送 JSON 数据作为 API 调用的结果。事实上，HTML 代码和 JSON 数据都是在 HTTP 响应中传递的`String`对象。举例来说，您确实可以将返回值更改为类似下面的内容，这样浏览器就会以粗体显示文本:

```java
public String welcome() {
  return "<strong>Hello, Welcome to Spring Boot!</strong>";
}
```

然而，将 HTML 标记放在 Java 代码中并不是创建 web 应用的实用方法。我们需要遵循 MVC 模式。

在 MVC 模式中， **C** 是我们的**控制器**， **V** 是我们放置 HTML 标记的**视图**，而 **M** 是包含控制器创建的数据的**模态**，视图可以使用它来呈现将在 HTTP 响应中发送给客户机的最终输出。

让我们将应用改为使用模板引擎百里香叶([http://www.thymeleaf.org/](http://www.thymeleaf.org/))，根据我们定义的 HTML 模板生成 HTML 代码。要做的第一件事是添加依赖项。下面是我们对`pom.xml`文件所做的更改:

```java
<dependencies>
  ...
  <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-thymeleaf</artifactId>
  </dependency>
</dependencies>
```

如你所见，我们没有直接添加百里香库。相反，我们添加了`spring-boot-starter-thymeleaf`启动模块，这样 Spring Boot 将为我们自动配置这个视图技术。

默认情况下，百里香要查找的 HTML 模板文件需要放在`/src/main/resources/templates`目录下。让我们将`welcome.html`文件添加到这个文件夹中。

下面是`welcome.html`的样子:

```java
<strong th:text="${message}"></strong>
```

我们保持这个模板非常简单，只显示粗体显示的 hello 消息。`th:text`是用于渲染文本的百里香语法，`${message}`用于从模型中获取`message`值，我们将从`MessageController`传递该值。

现在，让我们从处理程序方法中移除`@ResponseBody`注释，因为`welcome()`处理程序不再需要它了。Spring 将处理程序的返回值作为视图的名称，并使用百里香叶来生成响应。

下面是对`welcome()`处理程序的更改:

```java
...
import org.springframework.ui.Model;
...
  @GetMapping("/welcome")
  public String welcome(Model model) {
    model.addAttribute("message", "Hello, Welcome to Spring Boot!");
    return "welcome";
  }
```

如您所见，我们将 Spring 为我们创建的`Model`实例传递给`welcome()`方法，并将消息作为`model`的属性添加，其中的键`"message"`与我们在模板`${message}`中使用的键相匹配。现在，如果您重新启动应用，您将在页面上看到一条粗体欢迎消息。到目前为止，我们已经在应用中添加了视图技术。

在 Spring MVC 中利用模型和视图的另一种方式是从处理程序返回一个`org.springframework.web.servlet.ModelAndView`的实例。下面是使用`ModelAndView`时`welcome()`方法的样子:

```java
@GetMapping("/welcome")
public ModelAndView welcome() {
  ModelAndView mv = new ModelAndView("welcome");
  mv.addObject("message", "Hello, Welcome to Spring Boot!");
  return mv;
}
```

如您所见，我们不需要向处理程序方法传递一个`Model`对象。相反，我们通过传递模板文件名来创建一个`ModelAndView`实例，并通过`addObject()`方法添加数据。它的工作原理和以前的版本一样，只是风格不同。你可以选择你喜欢的那个。

除了百里香之外，Spring 还支持其他视图技术，包括 Groovy 标记、FreeMarker、Mustache 和传统的 JSP。如果你是 Velocity 的粉丝，目前，在最新版本的 Spring Boot 中没有对 Velocity 的现成支持。但是您可以通过一点额外的工作将 Velocity 与 Spring MVC 集成起来。

当 Spring Boot 与嵌入式应用服务器一起运行时，JSP 有许多限制。建议在使用 Spring Boot 时，应避免使用 JPS。在本书中，我们将使用百里香叶。

# 过滤

过滤器是 Java EE 的另一项好技术。它是责任链设计模式的实现。当您希望在 HTTP 请求到达 servlets 之前对其执行过滤任务时，这很有用。

让我们创建一个`AuditingFilter`来审计请求。出于演示目的，我们现在将简单地将请求信息写入日志。

要创建过滤器，我们需要实现`javax.servlet.Filter`接口。或者，我们可以扩展 Spring 的`org.springframework.web.filter.GenericFilterBean`，它提供了许多便利的特性。让我们和`GenericFilterBean`一起去吧。

下面是`AuditingFilter`出现的方式:

```java
package app.messages;
...
public class AuditingFilter extends GenericFilterBean {
  @Override
  public void doFilter(ServletRequest req, ServletResponse res, 
      FilterChain chain) throws IOException, ServletException { 
    long start = new Date().getTime();
    chain.doFilter(req, res);
    long elapsed = new Date().getTime() - start;
    HttpServletRequest request = (HttpServletRequest) req;
    logger.debug("Request[uri=" + request.getRequestURI() + ", method="         
      +
      request.getMethod() + "] completed in " + elapsed + " ms");
  }
}
```

如您所见，我们扩展了`GenericFilterBean`并覆盖了`doFilter()`方法，这是我们执行过滤任务的地方。在这个方法的开始，我们在调用`chain.doFilter()`之前标记时间，这允许链调用它后面的进一步的过滤器(如果有的话)。如果您忘记调用`chain.doFilter()`，将不会向客户端发送任何响应。在调用了`chain.doFilter()`方法之后，你仍然可以执行一些任务。在我们的过滤器中，我们计算运行时间并将其作为调试信息记录下来。

到目前为止，我们已经创建了`AuditingFilter`。但是，如果重新启动应用并刷新页面，输出中将不会显示任何内容。这是因为我们还没有注册。

在 Spring Boot 应用中注册滤镜有两种方法。可以通过在`web.xml`文件中添加`<filter>`和`<filter-mapping>`来注册，也可以创建`FilterRegistrationBean`在配置类`AppConfig`中注册。对于 web 应用来说，`web.xml`是作为一个`.war`文件部署到应用服务器上的。由于我们在嵌入式模式下运行 Tomcat，并且没有`web.xml`，所以我们将使用`FilterRegistrationBean`。

下面是更新后的`AppConfig.java`的样子:

```java
..
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
...
public class AppConfig {
  @Bean
  public FilterRegistrationBean<AuditingFilter> 
    auditingFilterRegistrationBean() {
    FilterRegistrationBean<AuditingFilter> registration = new 
      FilterRegistrationBean<>();
    AuditingFilter filter = new AuditingFilter();
    registration.setFilter(filter);
    registration.setOrder(Integer.MAX_VALUE);
    registration.setUrlPatterns(Arrays.asList("/messages/*"));
    return registration;
  }
}
```

我们将`@Bean`注释应用于`auditingFilterRegistrationBean()`方法，为`AuditingFilter`生成`FilterRegistrationBean`。从这个方法中可以看出，要注册`Filter`，我们需要创建一个`Filter`实例，并使用`setFilter()`方法来设置`Filter`。我们使用`setOrder()`方法在链中定位这个`Filter`。具有较小顺序值的那个将被放在前面。在我们的例子中，`AuditingFilter`将被放在链的末尾。`setUrlPatterns()`方法用于指定`Filter`将要注册的路径。在我们的例子中，`AuditingFilter`将只处理路径以`/messages/`开始的请求。

为了在输出中显示调试日志，我们需要打开`AuditingFilter`的调试级别日志。为此，让我们在`/src/main/resources/`目录下创建`.properties`文件`application.properties`。在这个文件中，我们将覆盖默认的日志记录级别`AuditingFilter`。到目前为止，我们只有一个自定义属性。

下面是`application.properties`的样子:

```java
logging.level.app.messages.AuditingFilter=DEBUG
```

`logging.level.`是属性的前缀。而`app.messages.AuditingFilter`是我们想要启用调试级别日志记录的类的路径。您可以使用一个包的路径，该路径将为该包中的所有类启用调试级别日志记录。

现在，如果您重新启动应用并刷新页面，您将在日志中看到类似于以下内容的调试信息:

```java
Request[uri=/messages/welcome,method=GET] completed in 337 ms
```

不要担心前面日志中显示的运行时间。用了`337 ms`，因为这是服务器启动后的第一个请求，Spring 需要初始化`DispatcherServlet`。如果您再次刷新页面，您将看到更短的持续时间。这有时被称为**服务器预热**。

Spring Framework 5 引入了一个新的 web 栈 Spring WebFlux。它是一个非阻塞的 web 框架，旨在处理大量并发连接。在本书中，我们将使用传统的 Spring MVC。

# 春季 JDBC 和 JPA

**JDBC**(**Java 数据库连接**的简称)。JDBC API 定义了我们如何访问存储在关系数据库中的数据。JDBC 驱动程序是针对特定类型的数据库的 JDBC API 的实现。例如，`com.mysql.jdbc.Driver`是 MySQL 数据库的驱动程序类名，`org.hsqldb.jdbcDriver`是 HSQLDB 的驱动程序类名，HSQLDB 是一个用纯 Java 编写的关系数据库。Spring JDBC 是 Spring 在 JDBC API 之上提供的一个抽象层，让我们更容易与数据库交互。

**JPA** (简称 **Java 持久化 API** )。它定义了 Java 对象持久化的 Java 标准方法，使用一种**对象关系映射** ( **ORM** )机制在面向对象模型和存储在关系数据库中的数据之间架起一座桥梁。Hibernate ORM 是 JPA 标准最流行的实现。除了标准的 API，Hibernate ORM 还有自己的本地 API。在本书中，我们将使用 Hibernate ORM 作为我们的持久化解决方案，使用单词 **Hibernate** 来表示 Hibernate ORM。

JDBC 和 JPA 是两套用于解决不同问题的 API。JDBC API 解决了与数据库的交互，而 JPA 以面向对象的方式解决了向数据库存储对象和从数据库检索对象的问题。在底层，JPA 实现依靠 JDBC 驱动程序来访问数据库。

在本节中，我们将采用三种不同的方法实现 messages 应用的消息持久性特性——直接使用 JDBC 驱动程序、使用 Spring JDBC 和使用 Hibernate。通过这种方式，您可以看到底层实现是如何工作的，以及使用 Spring JDBC 和 Hibernate 的好处。我们将使用 MySQL 社区服务器作为我们的数据库。

我们将消息存储在数据库的`messages`表中。该表有三列— `id`、`text`和`created_date`。我们在 Java 代码中有一个`Message`类，它有三个字段— `id`、`text`和`createdDate`。我们将为`MessageController`添加一个 API，用于使用 HTTP `POST`方法保存新消息。新消息将使用 JSON 格式。

下面显示了在 **Java 虚拟机** ( **JVM** )中的对象和数据库中的数据记录之间的对象/关系映射:

![](img/0cb02877-9981-4fe1-aa9a-fd73a50281c6.png)

图 3.4:对象/关系数据库映射

在我们开始之前，如果你没有安装 MySQL，你需要在 https://dev.mysql.com/downloads/mysql/的[下载并安装 MySQL。在撰写本文时，最新版本是 5.7。本书中的所有代码都适用于 MySQL 版本 5.6 及更高版本。一旦 MySQL 准备好了，就创建一个名为`app_messages`的数据库。之后，使用下面的 SQL 生成`messages`表:](https://dev.mysql.com/downloads/mysql/)

```java
DROP TABLE IF EXISTS `messages`;
CREATE TABLE `messages` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `text` varchar(128) COLLATE utf8_bin NOT NULL DEFAULT '',
  `created_date` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin;
```

# JDBC 司机

要使用 JDBC 驱动程序直接连接到 Spring Boot 应用中的数据库，我们需要将以下依赖项添加到`pom.xml`文件中:

```java
<dependencies>
  ...
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
  </dependency>
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
  </dependency>
</dependencies>
```

通过`spring-boot-starter-jdbc`模块，Spring Boot 将旋转一个`javax.sql.DataSource`的实例，并使其作为一个 bean 存在于 Spring 容器中。它还将配置一个数据库连接池。`mysql-connector-java`库是 MySQL 数据库的 JDBC 驱动程序，你可以看到为什么我们没有为`mysql-connector-java`指定`<version>`，这通常是必需的。在本章的后面，我们将讨论 Spring Boot 如何在幕后工作，以及它如何自动配置数据源 bean 和连接池。

接下来我们要做的是配置 Spring 实例化`DataSource`需要的参数。让我们给`application.properties`添加以下属性:

```java
spring.datasource.url=jdbc:mysql://localhost:3306/app_messages?useSSL=false
spring.datasource.username=<username>
spring.datasource.password=<password>
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
```

如您所见，`url`、`username`、`password`和`driver-class`对象是我们需要提供的最小设置。如果您需要确保连接使用 UTF-8 编码，您可以将 URL 更改为`jdbc:mysql://localhost:3306/app_messages?useUnicode=true&amp;characterEncoding=UTF-8`。你需要用你自己的来替换`<username>`和`<password>`。属性的`spring.datasource.`键的前缀是`spring-boot-starter-jdbc` starter 所必需的。

现在，让我们对`MessageRepository`类进行修改。我们需要请求 Spring 向`MessageRepository`注入一个`DataSource`实例，这样我们就可以从中获得一个数据库连接，如下所示:

```java
public class MessageRepository {
  private DataSource dataSource;
  public MessageRepository(DataSource dataSource) {
    this.dataSource = dataSource;
  }
  ...
}
```

接下来的事情就是实现`saveMessage()`方法。它看起来是这样的:

```java
1\. public Message saveMessage(Message message) {
2\.    Connection c = DataSourceUtils.getConnection(dataSource);
3\.    try {
4\.      String insertSql = "INSERT INTO message
        s (`id`, `text`, 
        `created_date`) VALUE (null, ?, ?)";
5\.      PreparedStatement ps = c.prepareStatement(insertSql, 
        Statement.RETURN_GENERATED_KEYS);
6\.      // Prepare the parameters for the SQL
7\.      ps.setString(1, message.getText()); 
8\.      ps.setTimestamp(2, new 
        Timestamp(message.getCreatedDate().getTime()));
9\.      int rowsAffected = ps.executeUpdate();
```

在第`1`行，我们改变我们的`saveMessage()`方法来返回新保存的`message`对象。在第`2`行中，我们使用 Spring 的助手类`DataSourceUtils`来获得数据库连接。然后，在第`4`行，我们准备插入 SQL。因为我们对`messages`表的`id`列使用了`AUTO_INCREMENT`，所以我们对它使用了`null`值，这样数据库将为 ID 生成一个值。在第`5`行，我们通过传递 SQL 创建`PreparedStatement`，并指定我们需要数据库返回生成的消息`id`。在第`7`到`8`行，我们设置了另外两个参数。在`9`行，我们使用`PreparedStatement`的`executeUpdate()`方法对数据库执行 SQL，该方法的返回值是执行所影响的行数:

```java
10\.     if (rowsAffected > 0) {
11\.       // Getting the newly saved message id
12\.       ResultSet result = ps.getGeneratedKeys();
13\.       if (result.next()) {
14\.         int id = result.getInt(1);
15\.         return new Message(id, message.getText(), 
            message.getCreatedDate());
16\.       } else {
17\.         logger.error("Failed to retrieve id. No row in result 
            set");
18\.         return null;
19\.       }
20\.     } else {
21\.       // Insert did not succeed
22\.       return null;
23\.     }
```

在第`10`到`20`行，我们检查是否有任何行受到影响。因为我们正在进行插入，没有任何错误，应该有一行受到影响，这是新插入的行。在`12`行中，我们调用`PreparedStatement`的`getGeneratedKeys()`方法从一个`ResultSet`对象中获取我们的`message`对象的 id。您需要调用它的`next()`方法来向前移动光标，这样您就可以读取`ResultSet`中的值。然后，我们用这三个字段创建一个新的`Message`对象。线`16`至`22`用于处理故障。如果没有受影响的行或者`ResultSet`为空，我们将返回一个`null`值，表明消息没有成功保存。到目前为止，我们已经完成了这个方法的大部分。最后一件事是，我们必须关闭我们在第`2`行中打开的连接，否则，该连接将不会被返回到连接池并被其他人重用:

```java
24\.   } catch (SQLException ex) {
25\.     logger.error("Failed to save message", ex);
26\.     try {
27\.       c.close();
28\.     } catch (SQLException e) {
29\.       logger.error("Failed to close connection", e);
30\.     }
31\.   } finally {
32\.     DataSourceUtils.releaseConnection(c, dataSource);
33\.   }
34\.   return null;
35\. }
```

在第`24`到`33`行中，都是关于清理连接的。而在`34`行，如果执行到这里，说明我们没有成功保存`message`对象。

正如你所看到的，JDBC API 是一个非常低级的 API，使用它需要大量的样板代码。除非别无选择，否则应该避免使用它。

在我们继续使用 Spring JDBC 实现之前，让我们更改我们的`MessageService`和`MessageController`来提供一个保存消息的 HTTP API。

下面是对`MessageService`的`save()`方法的修改:

```java
public Message save(String text) {
  return repository.saveMessage(new Message(text));
}
```

我们让它返回保存消息的结果。我们需要如下修改我们的`Message`类:

```java
1\. public class Message {
2\.    private Integer id;
3\.    private String text;
4\.    private Date createdDate;
5\.    public Message(String text) {
6\.      this.text = text;
7\.      this.createdDate = new Date();
8\.    }
9\.    public Message(int id, String text, Date createdDate) {
10\.     this.id = id;
11\.     this.text = text;
12\.     this.createdDate = createdDate;
13\.   }
14\.   public Integer getId() {return id;}
15\.   public String getText() {return text;}
16\.   public Date getCreatedDate() {return createdDate;}
17\.   // equals() and hashCode() omitted
18\. }
```

在第`2`和`4`行，我们添加了一个新的`id`字段和`createdDate`。将`id`字段声明为`Integer`类型的原因是，对于一个新的`Message`对象，它没有生成`id`，它的值将是`null`。第`5`到`8`行包含一个接受单个参数`text`的构造函数。这是用来创建新消息的。我们将为它生成`createdDate`。第`9`至`13`行包含另一个构造函数，用于从数据库中重构一个`message`对象。在第`14`到`16`行，这个类只提供 getters，所以你不能改变任何字段的值。目前，这对我们的应用来说已经足够好了。

现在，让我们在`MessageController`中添加一个处理程序，这样客户端就可以像下面这样发送一个 HTTP `POST`请求来保存消息:

```java
POST /messages
Content-Type: application/json
Request Body: {"text":"Add message here"}
```

这是我们的手柄的样子:

```java
@PostMapping("")
@ResponseBody
public ResponseEntity<Message> saveMessage(@RequestBody MessageData data){
  Message saved = messageService.save(data.getText());
  if (saved == null) {
    return ResponseEntity.status(500).build();
  }
  return ResponseEntity.ok(saved);
}
```

我们使用`@PostMapping`注释将其映射到`/messages`路径。处理程序的返回值是一个 Spring`ResponseEntity`，它允许我们设置响应状态、主体和标题。这个处理程序接受一个`MessageData`类型的参数，我们很快就会创建它。上面注有`@RequestBody`。这样 Spring 就会把 HTTP 请求体中传递的 JSON 格式`String`转换成`MessageData`的一个实例，这样我们就不需要自己去钻研 HTTP 请求来获取请求体了。在处理程序内部，我们简单地将`text`字段传递给`MessageService`，并使用`ResponseEntity.ok()`方法返回新保存的消息，或者，当它失败时，我们将`500`状态(一个内部服务器错误)返回给客户端，告诉他们服务器端有问题。

下面是`MessageData`类的样子:

```java
public class MessageData {
  private String text;
  public String getText() {return this.text;}
  public void setText(String text) {this.text = text;}
}
```

可以看到，它是一个**普通的老式 Java 对象** ( **POJO** )，只有一个`text`字段。这个`MessageData`是我们 API 的请求体的定义。如果您为`text`字段使用另一个名称，例如`message`，那么客户端发送的请求主体将相应地更改为`{"message":"Add message here"}`。

现在，如果您重新启动应用，我们就可以开始测试了。可以使用 API 测试工具发送 HTTP `POST`请求，例如邮差([https://www.getpostman.com/](https://www.getpostman.com/))，一个 UI 友好的免费应用:

![](img/1583f1aa-4cab-4026-9c58-ad58e4674a79.png)

图 3.5:邮递员邮件头选项卡

如*图 3*t 5 . 5 所示，在 Postman 中，当你创建一个新的请求，并为 API 的方法和 URL 选择`POST`后，记得添加带有`application/json`值的`Content-Type`头。这样，Spring 知道请求体是一个 JSON 格式的字符串:

![](img/ed337131-3164-43ff-87d8-8ea703b7e957.png)

图 3.6:邮递员正文选项卡

如*图 3.6* 所示，在**体**页签中，选择 Raw 和 JSON ( `application/json`)，然后放入 JSON 字符串`{"text":"Hello, Spring Boot!"}`。之后，点击发送按钮。你应该可以毫无困难地看到下面的结果，类似于截图中的结果。

在您尝试之前，确保您已经安装了 MySQL 数据库，创建了一个`app_messages`数据库和一个`messages`表。

# 春天的 JDBC

如前所述，Spring JDBC 在 JDBC API 之上提供了一个抽象层。`JdbcTemplate`类是这一层的核心。它帮助您管理连接，并提供与 JDBC API 交互的工作流。您需要做的就是准备语句并指定您希望如何处理结果集。`NamedParameterJdbcTemplate`类在其内部包装了一个`JdbcTemplate`对象，以提供使用命名参数而不是 JDBC `"?"`占位符的能力。

Spring JDBC 还提供了`SimpleJdbcInsert`和`SimpleJdbcCall`，通过利用数据库提供的元数据来简化 JDBC 操作。通过调用`connection.getMetaData()`方法来检索元数据，该方法返回一个`DatabaseMetaData`的实例。它包括数据库中定义了哪些表以及每个表包含的列等信息。当使用`SimpleJdbcInsert`和`SimpleJdbcCall`时，你不必担心元数据。春天会处理好的。

Spring JDBC 还提供了一种将 JDBC 操作建模为 Java 对象的方法。您可以创建一个`MappingSqlQuery`对象来执行数据库查询，一个`SqlUpdate`对象来执行插入/更新，一个`StoredProcedure`对象来调用数据库端的存储过程。这些对象是可重用的和线程安全的。

我们将在`MessageRepository`中使用`NamedParameterJdbcTemplate`。下面是它的样子(导入被省略):

```java
1\.  public class MessageRepository { 
2\.    private static final Log logger = 
      LogFactory.getLog(MessageRepository.class);
3\.    private NamedParameterJdbcTemplate jdbcTemplate;
4\.    @Autowired
5\.    public void setDataSource(DataSource dataSource) {
6\.      this.jdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
7\.    }
```

在第`3`行，我们定义了`NamedParameterJdbcTemplate`类型的`jdbcTemplate`字段。在第`4`到`7`行，我们使用 setter 方法请求 Spring 注入`DataSource`，这样我们就可以实例化`NamedParameterJdbcTemplate`实例:

```java
8\.    public Message saveMessage(Message message) {
9\.      GeneratedKeyHolder holder = new GeneratedKeyHolder();
10\.     MapSqlParameterSource params = new MapSqlParameterSource();
11\.     params.addValue("text", message.getText());
12\.     params.addValue("createdDate",message.getCreatedDate());
13\.     String insertSQL = "INSERT INTO messages (`id`, `text`, 
        `created_date`) VALUE (null, :text, :createdDate)";
14\.     try {
15\.       this.jdbcTemplate.update(insertSQL, params, holder);
16\.     } catch (DataAccessException e) {
17\.       logger.error("Failed to save message", e);
18\.       return null;
19\.     }
20\.     return new Message(holder.getKey().intValue(), 
        message.getText(), message.getCreatedDate());
21\.   }
22\. }
```

在`saveMessage()`方法中，在第`9`行，我们声明了`GeneratedKeyHolder`，它将保存新消息生成的`id`。在第`10`到`12`行，我们为第`13`行声明的插入 SQL 准备参数。如您所见，我们使用命名参数`text`和`createdDate`作为参数的占位符。它们的名称需要与我们在`11`和`12`行准备参数时使用的名称相匹配。在第`14`到`19`行中，我们要求`jdbcTemplate`在一个`try` - `catch`块中执行 SQL，因为`update()`方法可能会在出现 JDBC 操作错误时抛出`DataAccessException`。在第`20`行，我们返回新保存的消息。

如您所见，与直接使用 JDBC API 进行交互相比，使用 Spring JDBC 实现`saveMessage()`方法要简单得多。

# 冬眠

现在，让我们看看如何使用 Hibernate 实现`saveMessage()`方法。首先，让我们更新`pom.xml`文件，添加以下两个必需的依赖项:

```java
<dependencies>
  ...
  <dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-orm</artifactId>
  </dependency>
  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
  </dependency>
</dependencies>
```

`spring-orm`库是 Spring 的 ORM 支持，基于 Hibernate 等 ORM 技术。而`hibernate-core`库就是 Hibernate ORM 框架。

现在，让我们为 Hibernate 提供一些元数据，以便它知道如何将一个`Message`对象映射到`messages`表中的记录。这里，我们将使用 JPA 注释将这些元数据添加到`Message`类中。

下面是对`Message`类的更改:

```java
@Entity
@Table(name = "messages")
public class Message {
 @Id
 @GeneratedValue(strategy = GenerationType.IDENTITY)
 @Column(name = "id", nullable = false)
  private Integer id;

  @Column(name = "text", nullable = false, length = 128)
  private String text;

  @Column(name = "created_date", nullable = false)
 @Temporal(TemporalType.TIMESTAMP)
  private Date createdDate;

  public Message() {}
  ...
} 
```

`@javax.persistence.Entity`注释是将`Message`类标记为`Entity`类。而`@javax.persistence.Table`注释用于指定`Message`类映射到的`messages`表。

对于`id`字段，我们使用`@javax.persistence.Id`注释使其成为该实体的主键。而`@javax.persistence.GeneratedValue`注释是为了指定我们希望如何生成`id`的值。在我们的例子中，我们使用`GenerationType.IDENTITY`策略，这意味着数据库将为我们产生价值。这与我们的`id`列的`AUTO_INCREMENT`设置非常匹配。而`@javax.persistence.Column`注释是将`id`字段映射到`messages`表的`id`列。我们将它指定为不可空。

对于`text`字段，我们将其映射到`text`列，并将其标记为不可空，并将列的长度设置为`128`。

对于`createdDate`字段，我们将其映射到`created_date`列，并将其标记为不可空。注释`java.util.Date`或`java.util.Calendar`类型的字段需要`@javax.persistence.Temporal`注释。它的值`TemporalType.TIMESTAMP`是将`createdDate`字段映射到 JDBC 驱动程序理解的`java.sql.Timestamp`类型的值。

Hibernate 需要默认的`public Message(){}`构造函数。当 Hibernate 从数据库加载消息记录并重新构造`Message`对象时，它使用默认的构造函数来创建这些对象。

Hibernate 不会根据可空设置和`@Column`注释的长度属性来执行数据验证。它在它的`hbm2ddl`特性中使用这个元数据，从 Hibernate 映射(`hbm`)中生成**数据定义语言** ( **DDL** )。您可以使用 DDL 脚本在数据库中创建/更新/删除数据结构。前面提供的用于创建消息表的 SQL 是一个 DDL 脚本。另一方面，对于数据验证，我们可以使用 Bean Validation 2.0 (JSR 380)，我们将在本书的后面讨论。

在 Hibernate 中，`org.hibernate.Session`是存储/检索实体的主要接口。您可以从 Hibernate `SessionFactory`实例创建会话。用 Spring ORM 创建一个`SessionFactory`的实例，我们可以用 Spring 的`LocalSessionFactoryBean`，也就是 Spring `FactoryBean`，会产生一个`SessionFactory`的实例。

让我们更改`AppConfig`类来定义`LocalSessionFactoryBean`。

以下是对`AppConfig`所做的更改:

```java
...
@Configuration
@ComponentScan("app.messages")
public class AppConfig {

  private DataSource dataSource;

  public AppConfig(DataSource dataSource) {
    this.dataSource = dataSource;
  }
  ...
  @Bean
  public LocalSessionFactoryBean sessionFactory() {
    LocalSessionFactoryBean sessionFactoryBean = new 
    LocalSessionFactoryBean();
    sessionFactoryBean.setDataSource(dataSource);
    sessionFactoryBean.setPackagesToScan("app.messages");
    return sessionFactoryBean;
  }
}
```

创建`LocalSessionFactoryBean`需要一个`javax.sql.DataSource`的实例，我们要求 Spring 将它注入配置类。我们还需要使用`setPackagesToScan()`方法来指定 Hibernate 要扫描的包，以便找到实体类。

现在，一切准备就绪。让我们更改`MessageRepository`类，用 Hibernate 实现保存`message`对象。它看起来是这样的:

```java
import org.hibernate.Session;
import org.hibernate.SessionFactory;
...
public class MessageRepository {
  private SessionFactory sessionFactory;
  public MessageRepository(SessionFactory sessionFactory) {
    this.sessionFactory = sessionFactory;
  }
  public Message saveMessage(Message message) {
    Session session = sessionFactory.openSession();
 session.save(message);
    return message;
  }
}
```

正如你所看到的，我们要求 Spring 注入一个`SessionFactory`实例，然后在`saveMessage()`方法中，我们通过调用`sessionFactory`实例的`openSession()`方法获得一个`Session`实例，并使用`session`对象的`save()`方法存储`message`对象。有了 Hibernate，我们就不用担心获取生成的`message`对象的`id`了。Hibernate 会处理这些。我们现在需要做的只是在保存后返回`message`对象。

如您所见，Hibernate 将对象存储到 rational 数据库的方式要简单得多。它节省了大量样板代码，并帮助我们专注于实现应用本身的逻辑。

现在，如果您重新启动应用并再次运行测试，您可以看到消息已经成功保存。

在这一节中，我们只介绍了 Hibernate 的基础知识。当我们实现 TaskAgile 应用时，我们将讨论高级 Hibernate 主题。

那么，在这三种方式中，直接使用 JDBC API、使用 Spring JDBC 和使用 Hibernate——哪种方式更好呢？首先，除非别无选择，否则不要直接使用 JDBC API。在春天 JDBC 和冬眠之间，答案是视情况而定。有时，您可能会发现使用 Hibernate 更直接、更快速地完成工作。有时，您可能会发现 Hibernate 带来的开销会导致性能问题，因此您可能会希望使用 Spring JDBC 或其他框架，如 MyBatis([http://www.mybatis.org](http://www.mybatis.org))，这是一个用于 Java 的 SQL mapper 框架。或者，有时，您可能会在不同的场景中同时使用这两种方法。

我们不会在本书中涉及 MyBatis 的使用。如果你感兴趣的话，你可能想看看[https://github.com/mybatis/spring-boot-starter](https://github.com/mybatis/spring-boot-starter)，这是由 MyBatis 团队提供的 MyBatis 的 Spring Boot 入门模块。

# 面向方面编程

我们的消息应用是一个简化的演示应用。它没有很多典型的 web 应用应该具备的特性。例如，它缺乏安全检查。目前，我们允许任何人通过`/messages` ( `POST` ) API 发布消息。一个简单的解决方法是在 API 处理程序中添加安全检查逻辑，即`MessageController.saveMessage()`方法，如下所示:

```java
public ResponseEntity<Message> saveMessage(@RequestBody MessageData data) {
  checkSecurity();
  ...
}

private void checkSecurity() throws NotAuthorizedException {
  // Do security checking
  ...
}
```

在`saveMessage()`方法中，我们立即调用`checkSecurity()`方法，如果请求未被授权，将抛出`NotAuthorizedException`。

我们的“信息”应用没有用户系统。因此，我们无法检查请求是否来自经过身份验证的用户。然而，我们仍然可以在这里执行几种类型的安全检查。例如，我们只能允许来自特定 IP 地址的请求。来自所有其他 IP 地址的请求将被视为未经授权。或者，我们可以将凭证硬编码到代码中，客户端需要在请求头中传递它们以通过安全检查。鉴于本书的范围，我们将在 TaskAgile 应用中实现安全检查。

这将在我们的应用中很好地工作。然而，在有许多 API 需要执行安全检查的应用中，这会导致代码重复，因为您会在每个 API 处理程序的开头看到这种样板代码。

最好在一个中心位置执行安全性检查，当代码执行到达 API 处理程序时，安全性已经被检查过了。从这一点来看，它确实引起了进一步的关注。

我们可以创建`SecurityFilter`，它将负责针对请求的安全检查。在过滤器内部，我们可以使用`request.getRequestURI()`和`request.getMethod()`来知道请求的目标是哪个 API，然后检查请求是否被授权。当我们只希望在请求级别进行安全检查时，这种方法非常有效。

在复杂的应用中，您可能希望在方法级别检查安全性。例如，您可能想要对`MessageService.save()`方法执行额外的安全检查。在这种情况下，在`Filter`中执行安全检查将不起作用。您将需要使用 AOP 技术。

与面向对象编程相比，AOP 是考虑应用结构的一种不同方式。在我们的 Messages 应用中使用 AOP 实现安全检查之前，让我们先介绍一下 AOP 的基本概念。

# 关系

在 AOP 中，安全检查是一个安全问题，或者你可以把它看作是一个应用必须达到的目标。通常，关注点跨越多个类。其他类型的问题包括应用服务 API 的性能日志、事务管理，我们将在下一节中讨论。

# 方面

一个方面是这种关注的模块化。我们没有将代码分散在许多类中，而是将处理关注点的逻辑放在一个方面中。在 Spring AOP 中，可以在常规类中实现一个方面，并用`@Aspect`注释对其进行注释，该注释来自 AspectJ([https://www.eclipse.org/aspectj](https://www.eclipse.org/aspectj))。

假设我们在`ClassA`中有`methodA()`，在`ClassB`中有`methodB()`，在`ClassC`中有`methodC()`，我们需要在所有这些方法中进行安全检查。在使用 AOP 之前，我们需要添加代码来处理所有这些方法中的安全检查。如果我们还需要在其他方法中执行安全检查，我们也需要将`checkSecurity()`添加到这些方法中。使用 AOP 后，我们将安全检查逻辑提取到`SecurityChecker`方面，这是一个常规的 Java 类。在这个类中，`checkSecurity()`方法用`@Around`注释进行了注释，这是来自 AspectJ 的注释。`@Around`注释的值是一个表达式，用于指定何时执行`checkSecurity()`方法。在*图 3.7* 的例子中，该表达式表示每当执行`app.message`包内任何类的方法时:

![](img/bede4ce5-ace7-4a01-a9c6-ac0c51af53c1.png)

图 3.7:用于安全检查的 AOP

使用`@Around`注释，在运行时，代码执行将首先到达`SecurityChecker.checkSecurity()`方法。在这个方法中，您可以决定是否继续执行。如果应该继续，那么您将调用目标方法，一旦该方法完成，代码执行将返回到`checkSecurity()`方法。此时，通常您会将代码执行返回给调用者。另一方面，如果执行不应该继续，您可以抛出一个异常，目标方法将不会被执行。

正如你从图 3.7 中看到的，那些需要安全检查的方法不再需要样板代码。安全检查的所有逻辑都集中到了`SecurityChecker`方面。

# 连接点

在 AOP 中，`methodA()`、`methodB()`和`methodC()`是连接点——程序执行过程中的点。在 Spring AOP 中，连接点总是代表一个方法调用。AOP 的其他实现，比如 AspectJ，也支持字段访问和异常抛出的连接点。

# 建议

在 AOP 中，`SecurityChecker`中的`checkSecurity()`方法是一个通知，它是一个处理特定问题的动作，在本例中，是一个安全问题。有不同类型的建议，包括以下几种:

*   **Before advice** :在连接点之前执行的通知，除非抛出异常，否则不能阻止代码执行到达连接点。可以在建议前用`@Before`标注指定*。*
*   **返回建议后**:在一个连接点正常完成而没有抛出异常后要执行的建议。返回带有`@AfterReturning`注释的建议后，可以指定*。*
*   **抛出建议后**:当一个方法因抛出异常而退出时要执行的建议。你可以在抛出建议后用`@AfterThrowing`标注指定*。*

*   **后建议**:无论连接点是否执行都要执行的建议。这就像是一个`try...catch`中的最后一块。你可以在建议后用`@After`标注指定*。*
*   **围绕建议**:围绕连接点的建议。这种类型的建议可以完全控制代码的执行，因此是最强大的。您可以用`@Around`注释在建议周围指定*，就像前面的例子一样。*

# 切入点

在 AOP 中，切入点是匹配连接点的日期。前面例子中的`@Around`注释的值`"execution(* app.messages..*.*(..))"`是一个切入点表达式，它指定了何时应该触发通知周围的`checkSecurity()`。您还可以使用`@Pointcut`注释来声明一个切入点签名，如下所示:

```java
@Aspect
@Component
public class SecurityChecker {

  @Pointcut("execution(* app.messages..*.*(..))") 
 public void everyMessageMethod() {}

  @Around("everyMessageMethod()")
  public Object checkSecurity (ProceedingJoinPoint joinPoint) {
    ...
  }
}
```

在`SecurityChecker`方面，我们创建一个`everyMessageMethod()`公共方法，并用`@Pointcut`注释对其进行注释。因为我们在这里只定义了一个切入点签名，所以这个方法没有返回值，并且是空的。在`checkSecurity()`方法的`@Around`注释中，我们使用这个方法作为切入点表达式。

前面的切入点表达式中的执行是一个**切入点指示符** ( **PCD** )，它告诉 Spring AOP 匹配什么。另一个有用的 PCD 是`@annotation`。使用这个 PCD，您可以只匹配那些用特定注释注释的方法，而不是使用正则表达式来匹配连接点。

# AOP 代理

在我们的 *@SecurityCheck* 部分的安全检查示例中，`ClassA`、`ClassB`和`ClassC`的对象是`SecurityChecker`方面的目标对象或者被称为被通知对象。在 Spring AOP 中，框架将在运行时为这些对象创建代理对象，以履行`SecurityChecker`方面契约。默认情况下，Spring AOP 使用标准的 JDK 动态代理来创建 AOP 代理。JDK 动态代理只能通过接口进行代理。如果目标类没有实现接口，Spring AOP 将使用 CGLIB([https://github.com/cglib/cglib](https://github.com/cglib/cglib))通过子类化目标类来创建代理。在我们的安全检查示例中，Spring AOP 将使用 CGLIB 创建代理对象。

# 编织

在 AOP 中，编织是通过将方面与其他所需的对象相链接来创建通知对象的过程。在 Spring AOP 中，编织发生在运行时，而 AspectJ 在编译时或加载时执行编织。

# @安全检查

现在，让我们对我们的 Messages 应用实现一个简化的安全检查。我们将创建一个`@SecurityCheck`注释，它可以应用于任何执行安全检查的方法。

下面是`@SecurityCheck`注释的样子:

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface SecurityCheck {
}
```

如您所见，这是一个可以应用于方法的简单注释。

下面是`SecurityChecker`方面的表现:

```java
package app.messages;
...
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
...
@Aspect
@Component
public class SecurityChecker {
  ...
  @Pointcut("@annotation(SecurityCheck)")
  public void checkMethodSecurity() {}

  @Around("checkMethodSecurity()")
  public Object checkSecurity (ProceedingJoinPoint joinPoint) throws 
  Throwable {
    logger.debug("Checking method security...");
    // TODO Implement security check logics here
    Object result = joinPoint.proceed();
    return result;
  }
}
```

如您所见，`SecurityChecker`方面是一个普通的 Spring bean。它的特别之处在于它有`@Aspect`注释。Spring 通过`<aop:config>`元素支持 XML 定义的 AOP 配置，以及我们在这里使用的 AspectJ 注释定义。

在`SecurityChecker`方面内部，我们通过使用`@annotation` PCD 用于`@SecurityCheck`注释，创建一个带有`@Pointcut`注释的切入点签名`checkMethodSecurity()`。

在`checkSecurity()`建议中，我们使用`@Around`注释来指定建议是围绕建议的*，并带有切入点表达式`"checkMethodSecurity()"`。我们的建议仅用于演示目的，因此我们只在日志中写入一条消息。为了查看日志消息，您需要将以下配置添加到`application.properties`文件中:*

```java
logging.level.app.messages.SecurityChecker=DEBUG
```

现在，最后一步是将`@SecurityCheck`注释应用于我们想要执行安全检查的方法。让我们把它应用到`MessageService.save()`方法中。下面是该方法的显示方式:

```java
@SecurityCheck
public Message save(String text) {
  return repository.saveMessage(new Message(text));
}
```

如果您重新启动“信息”应用并调用`/messages` ( `POST` ) API，您将在日志中看到类似以下内容的调试信息:

```java
...
app.messages.SecurityChecker : Checking method security...
app.messages.AuditingFilter : Request[uri=/messages, method=POST] completed in 273 ms
```

Spring Security 通过使用`@Secure`注释，将`Filter`对象用于请求级访问控制，将 AOP 用于方法级访问控制。

# AOP 执行流程

在我们的安全检查器示例中，没有对`MessageService.save()`方法应用`@SecurityCheck`注释，代码执行直接从`MessageController.saveMessage()`方法流向`MessageService.save()`方法。在应用了`@SecurityCheck`注释之后，在运行时，代码执行从`MessageController.saveMessage()`方法流向 Spring AOP 创建的 AOP 代理对象。在我们的例子中，`MessageService`没有实现任何接口，所以 AOP `proxy`对象是 Spring AOP 用 CGLIB 创建的`MessageService`子类的一个实例。从 AOP `proxy`对象，执行流向`checkSecurity()`顾问。在顾问内部，调用了`MessageService.save()`目标方法。稍后，在`MessageService.save()`完成之后，执行流回到`MessageController.saveMessage()`方法。下图*图 3.8* 展示了 AOP 的执行流程:

![](img/d0acedb2-d2bd-465a-8989-f61a927ca70b.png)

图 3.8: AOP 执行流程

# Spring 事务管理

Spring 的事务支持提供了对不同事务 API 的抽象，包括处理全局事务的 **Java 事务 API** ( **JTA** )，以及 JDBC API、Hibernate 事务 API 和 JPA 事务 API。后三个 API 处理本地事务。

一个全局事务可以处理多个事务资源，通常是关系数据库和消息队列(JMS)。它是通过 JTA 管理全球事务的应用服务器。另一方面，本地事务是特定于资源的，例如，与 JDBC 连接相关联的事务。本地事务不能处理多个资源。

Spring 事务管理支持编程式和声明式事务管理。您可以使用 Spring 的`TransactionTemplate` API 以编程方式管理事务，或者直接使用`PlatformTransactionManager` API。对于声明式事务管理，您可以将`@Transactional`注释应用于需要事务管理的类或方法。Spring 的声明式事务管理的实现基于 Spring 的 AOP 框架，它可以在任何环境中工作，无论是全局还是局部事务。

编程式和声明式事务管理都支持回滚规则，换句话说，您可以声明哪些异常可以或不可以导致自动回滚。

# PlatformTransactionManager

Spring 的事务抽象是基于事务策略的。也就是说，对于不同的底层事务 API，有一个特定的实现。所有这些实现都实现了`org.springframework.transaction.PlatformTransactionManager`接口，它非常简单，如下所示:

```java
public interface PlatformTransactionManager {
  TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
  void commit(TransactionStatus status) throws TransactionException;
  void rollback(TransactionStatus status) throws TransactionException;
}
```

您可以使用带有一个`TransactionDefinition`对象的`getTransaction()`方法来获得一个`TransactionStatus`对象。当当前调用栈中存在匹配的事务时，返回的`TransactionStatus`对象可以表示新的事务或现有的事务。使用`TransactionStatus`对象，您可以执行提交或回滚。

而对于 Hibernate 来说，`PlatformTransactionManager`的实现就是`HibernateTransactionManager`。对 JDBC 来说，实现就是`DataSourceTransactionManager`。对于 JPA，实现是`JpaTransactionManager`。对 JTA 来说，实现的是`JtaTransactionManager`。而对于 JMS 来说，实现是`JmsTransactionManager`。对于不同的 API，需要创建相应的`PlatformTransactionManager`实现。

# 声明式事务管理

现在，让我们看看如何实现 Spring 声明式事务管理。

我们的 Messages 应用非常简单，不需要事务管理也能很好地工作。出于演示的目的，让我们向`/messages` ( `POST` ) API 添加另一个需求。假设我们想要一个报告来显示每小时发布的消息的统计数据。我们可以使用 SQL 查询来计算统计数据。或者，我们可以在保存消息后更新统计数据，并将其保存到一个表中，该表将在数据库中保存该信息。让我们采用第二种方法，这样我们就可以使用声明式事务管理。

在实践中，如果我们的消息应用有像 Disqus([https://disqus.com](https://disqus.com))这样的流量，您可能希望采用不同的方法来更新统计数据，例如，向 MQ 服务器发送一个事件，并异步处理统计数据的更新。

要使用声明式事务管理，我们需要更改`AppConfig`。变化如下:

```java
...
@EnableTransactionManagement
public class AppConfig {
  ...
  @Bean
  public HibernateTransactionManager transactionManager() {
    HibernateTransactionManager transactionManager = 
      new HibernateTransactionManager();
    transactionManager.setSessionFactory(sessionFactory().getObject());
    return transactionManager;
  }
}
```

如您所见，我们将`@EnableTransactionManagement`注释应用于`AppConfig`，并使用`transactionManager()`方法创建了一个`HibernateTransactionManager` bean。在这个方法中，我们为这个事务管理器设置了同一个`SessionFactory`实例。

到目前为止，我们已经在应用中添加了事务管理。让我们将`@Transactional`注释应用于`MessageService.save()`方法。下面是对`MessageService`类的修改:

```java
public class MessageService {
  ...
  @SecurityCheck
 @Transactional
  public Message save(String text) {
    Message message = repository.saveMessage(new Message(text));
    log.debug("New message[id={}] saved", message.getId());
    updateStatistics();
    return message;
  }

  private void updateStatistics() {
    throw new UnsupportedOperationException("This method is not 
    implemented yet");
  }
}
```

如您所见，我们将`@Transactional`注释应用于`save()`方法。并且我们重构方法来调用未实现的`updateStatistics()`方法，并将抛出`UnsupportedOperationException`。这将导致事务回滚。我们在日志中添加了一条调试消息，这样您就可以看到消息已被保存，然后被回滚。

如果您重启应用并调用`/messages` ( `POST` ) API，您将看到以下异常:

```java
java.lang.ClassCastException: org.springframework.orm.jpa.EntityManagerHolder cannot be cast to org.springframework.orm.hibernate5.SessionHolder
```

这是因为，默认情况下，Spring Boot 创建了`OpenEntityManagerInViewInterceptor`，它将来自 JPA 的接口`EntityManager`注册到当前线程。我们在资源库中使用了 Hibernate 的`SessionFactory`。并且，在交易建议中，Spring 会尽量把`EntityManager`投给`SessionFactory`。为了解决这个问题，我们可以改变我们的存储库来使用`EntityManager`而不是`SessionFactory`。或者我们可以通过改变`application.properties`来关闭这个特性。

以下是对`application.properties`的更改:

```java
logging.level.app.messages.MessageService=DEBUG
...
spring.jpa.open-in-view=false
```

我们打开`MessageService`的调试级别日志，这样我们就可以在输出中看到日志。我们将`spring.jpa.open-in-view`设置为`false`以覆盖默认设置，从而关闭`OpenEntityManagerInViewInterceptor`的创建。

在 Spring Boot 2 中，默认情况下，当`spring.jpa.open-in-view`未设置为`false`时，日志中会显示一条警告消息。有一些关于是否应该默认开启这个功能的讨论。如果你有兴趣，可以查看这里的讨论:【https://github.com/spring-projects/spring-boot/issues/7107[。](https://github.com/spring-projects/spring-boot/issues/7107)

现在，如果您重新启动应用，您将在控制台中看到类似于以下内容的日志信息:

```java
...
app.messages.SecurityChecker : Checking method security...
app.messages.MessageService : New message[id=6] saved
o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.UnsupportedOperationException: This method is not implemented yet] with root cause
...
```

如您所见，调用了`checkSecurity()`建议。之后，我们创建了一条消息，异常如预期的那样被抛出。但是，如果您检查`messages`表，`id=6`的`message`仍然在那里。它不会回滚！发生了什么事？

要找出问题所在，首先让我们回顾一下 Spring 的声明式事务管理，它是建立在 Spring AOP 之上的。如图*图 3.9* 所示，Spring 的事务顾问在控制从`checkSecurity()`顾问流入时创建事务，并在控制流回事务顾问后提交或回滚事务。如前所述，本地事务与 JDBC 连接相关联。因此，当创建事务时，从`DataSource`获得数据库连接:

![](img/8fb01bc5-510b-4f06-8b55-f11d7e7af4d0.png)

图 3.9:事务控制流

我们来看看`MessageRepository.saveMessage()`方法。在这个方法中，我们通过`sessionFactory.openSession()`获得一个 Hibernate 会话。`openSession()`方法将从`DataSource`获得一个 JDBC 连接。因此，从该方法获得的连接似乎与事务顾问获得的连接不同。

这现在说得通了。`MessageRepository.saveMessage()`方法使用不同的 JDBC 连接来保存消息，并且事务顾问不能回滚不相关连接的事务。

让我们将`MessageRepository.saveMessage()`方法更改如下:

```java
public Message saveMessage(Message message) {
 Session session = sessionFactory.getCurrentSession();
  ...
}
```

`sessionFactory.getCurrentSession()`将获得当前 Hibernate 上下文中的当前会话，该上下文与事务顾问共享。这样，事务顾问可以在抛出异常时回滚保存的消息。

现在，如果您重启应用并调用`/messages` ( `POST` ) API，您可以看到由于`updateStatistics()`方法抛出的异常，保存的消息被回滚。

如前所述，Spring 事务管理支持回滚规则。我们可以声明那些我们希望事务顾问回滚事务的异常，以及那些我们不希望回滚的异常。

使用声明式事务管理，我们可以用`@Transactional`注释来声明规则。现在，让我们改变它，使它不回滚`UnsupportedOperationException`。

下面是更新后的`MessageService.save()`方法:

```java
@Transactional(noRollbackFor = { UnsupportedOperationException.class })
public Message save(String text) {
  ...
}
```

现在，如果您重启应用并再次调用 API，您将看到消息如预期的那样保存在`messages`表中。

当我们创建 TaskAgile 应用时，我们将讨论更多关于 Spring 事务管理的内容。

# Spring Boot

到目前为止，你已经使用 Spring Boot 创建了邮件应用的后端。如您所见，使用 Spring Boot 创建 web 应用非常简单。现在，让我们仔细看看它是如何提高开发人员的生产力的。

Spring Boot 对构建生产就绪型应用有自己的看法。它的观点主要通过它的启动器和它的自动配置机制来表达。正因为如此，大多数 Spring Boot 应用比传统的 Spring 应用需要更少的 Spring 配置。

Spring Boot 应用通常继承自`spring-boot-starter-parent`项目，该项目提供 Maven 默认值和依赖项管理部分，因此您不需要指定 Spring Boot 支持的那些依赖项的版本。你所需要做的就是指定 Spring Boot 版本。另一方面，你仍然可以指定一个版本并忽略 Spring Boot 的建议。

如果你对 Spring Boot 默认支持的依赖项感兴趣，你可以去[https://github.com/spring-projects/spring-boot](https://github.com/spring-projects/spring-boot)查看`spring-boot-project/spring-boot-dependencies/pom.xml`文件。

此外，Spring Boot 支持各种各样的技术，几乎可以用来建造任何东西。要开始使用一种特定的技术，您需要做的只是将支持这种技术的启动器添加到您的依赖项中，Spring Boot 将负责您需要的 beans 的初始化。例如，在我们的 Messages 应用中，我们需要使用 JDBC，所以我们添加了`spring-boot-starter-jdbc`启动器，Spring Boot 将使用我们在`application.properties`中定义的数据源参数创建`DataSource` bean。

# 开胃菜

Spring Boot 启动器是一组方便的依赖描述符，它们只包含一个依赖描述符文件，即`pom.xml`文件。按照惯例，所有官方首发都遵循命名模式——`spring-boot-starter-*`，其中`*`是一种特定的技术，例如`jdbc`和`web`。Spring Boot 还有一个核心首发，就是`spring-boot-starter`。所有其他启动器都依赖于这个启动器，主要是因为它提供了自动配置支持。核心 starter 也是一个依赖描述符，它的自动配置能力来自于它的`spring-boot-autoconfigure`依赖。我们将很快讨论自动配置。

让我们仔细看看`spring-boot-starter-jdbc`启动器。在这个启动器的`pom.xml`文件中，列出的依赖项包括`spring-boot-starter`、`HikariCP`和`spring-jdbc`。而且，通过将这个启动器添加到我们的应用中，我们不需要担心`HikariCP`、`spring-jdbc`或者这两个库所依赖的依赖关系。您使用的构建系统，在我们的例子中，Maven，会处理这些。

除了官方启动器，您还可以使用社区提供的自定义启动器。比如需要用 MyBatis，可以用`mybatis-spring-boot-starter`。您也可以创建自己的启动器。所有定制启动器也需要依赖核心启动器。

由于本书的范围，我们不打算讨论如何创建一个定制的启动器。如果你感兴趣，你可能想看看 MyBatis 的首发([https://github.com/mybatis/spring-boot-starter](https://github.com/mybatis/spring-boot-starter))。

# 自动配置

如前所述，Spring Boot 启动器的自动配置能力来自于`spring-boot-autoconfigure`。这个项目是 Spring Boot 官方启动器的自动配置实现。

`@SpringBootApplication`注释是自动配置的触发器。此注释是这三个注释的组合:

*   `@SpringBootConfiguration`
*   `@EnableAutoConfiguration`
*   `@ComponentScan`

`@SpringBootConfiguration`注释表明一个类是 Spring Boot 应用配置类。顾名思义，`@EnableAutoConfiguration`注释实际上是启用自动配置的注释。`@ComponentScan`注释是为了启用 Spring 的组件扫描特性。

使用`@EnableAutoConfiguration`注释，`spring-boot-autoconfigure`将使用应用的类加载器从`META-INF/spring.factories`资源文件中加载元数据。应用依赖关系的所有`spring.factories`文件都将被加载，包括官方启动程序和定制启动程序。在`spring.factories`元数据文件中，自动配置通过`org.springframework.boot.autoconfigure.EnableAutoConfiguration`属性挂钩。

我们来看看`spring-boot-autoconfigure`的`spring.factories`文件，里面包含了所有官方首发的自动配置钩子。

以下是官方`spring.factories`文件的片段:

```java
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
...
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
...
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
...
```

如您所见，这个元数据文件与一个`.properties`文件具有相同的格式，它是一个键值对列表。`org.springframework.boot.autoconfigure.EnableAutoConfiguration`键的值是自动配置类的名称列表，用逗号分隔。`AopAutoConfiguration`和`DataSourceAutoConfiguration`是我们在“信息”应用中用过的两个。自动配置类也是用 Spring 的`@Configuration`注释进行注释的 Java 类。

在这些自动配置类中，Spring 将根据配置创建 beans。这些类的唯一特殊之处是它们的配置是有条件的。例如，如果您已经在应用的配置类中定义了一个`DataSource` bean，Spring Boot 将不会创建另一个`DataSource` bean。在我们的 Messages 应用中，我们让 Spring Boot 为我们自动配置一个`DataSource` bean 的定义为空。这称为条件配置。为了归档条件配置，Spring 提供了诸如`@Conditional`、`@ConditionalOnClass`、`@ConditionalOnMissingBean`和其他条件注释，您可以使用这些注释来指定在什么条件下应该应用自动配置。以`DataSourceAutoConfiguration`级为例；只有当类路径中有可用的`DataSource`类时，自动配置才会发生。当 Spring 容器中没有`DataSource`类型的用户定义 bean 时，连接池 HiKari 将被初始化。

我们不打算详细讨论条件自动配置的用法。有兴趣可以在这里查看`DataSourceAutoConfiguration`的源代码:[https://github . com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-auto configure/src/main/Java/org/spring framework/boot/auto configure/JDBC/data source auto configuration . Java](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java)。

定制启动器遵循与官方启动器相同的自动配置机制。

# 放在一起

现在，让我们把 Messages 应用的前端和后端放在一起。我们将通过从数据库中查询消息来填充 UI 中的消息列表，并在点击 UI 中的 **Add** 按钮后将新消息保存到数据库中。

下面是我们需要做的事情，以使集成工作:

*   将前端和后端代码放在同一个项目中
*   向后端添加 API 以获取消息和保存新消息
*   将与后端通信的能力添加到前端

# 将代码放在一起

在[第 2 章](02.html)，*vue . js 2——它以你期望的方式*工作，我们创建了前端，并使用`http-server`来服务`index.html`文件和静态`.js`资产。集成完成后，嵌入式 Tomcat 服务器将为这些文件提供服务。现在，让我们把前端代码移到后端。

除了将前端和后端放在一个项目中并作为一个整体进行部署之外，您还可以将它们分开并分别进行部署，这样当团队需要在每一端独立工作时，他们就可以从这种分离中受益。在本书中，我们将保持两端在一起。

正如之前在 Spring MVC 部分提到的，当请求进来时，它们会经过`Filter`和`DispatcherServlet`对象，然后到达`Controller`对象。在我们的 Messages 应用中，我们有两种类型的请求——一种是呈现 UI 的请求，另一种是 API 请求，比如检索 JSON 消息和保存新消息。

现在，让我们为`MessageController`添加一个`index()`处理程序方法来呈现 UI，这样您就可以通过`http://localhost:8080/messages`打开应用:

```java
@Controller
public class MessageController {
  ...
  @GetMapping("/messages")
  public String index() {
    return "index";
  }
  ...
}
```

如您所见，`index()`处理程序方法非常简单。它只是返回视图的名称。我们需要将前端代码中的`index.html`文件放到`resources/templates/index.html`中。对于那些静态的`.js`资产，我们需要把它们放到`resources/static`目录中。这样，当你请求`http://localhost:8080/vue.js`时，Spring Boot 就会为你服务`resources/static/vue.js`。

将静态的`.js`资产移入目录后，`resources/static`目录如下所示:

```java
resources/static/components
resources/static/directives
resources/static/filters
resources/static/mixins
resources/static/plugins
resources/static/axios.v0.18.0.min.js
resources/static/vue.js
```

而`resources/templates`目录看起来是这样的:

```java
resources/templates/index.html
resources/templates/welcome.html
```

# 添加 API

因为我们将从`http://localhost:8080/messages`开始提供 UI，所以我们最好将 API 的路径分开。让我们把 API 请求放在`/api/`下。

我们需要对`MessageController`进行以下更改:

*   将现有的`/messages` ( `POST`)改为`/api/messages` ( `POST`)，用于保存新消息
*   添加`/api/messages` ( `GET`)用于检索消息
*   从`MessageController`类级别中移除`@RequestMapping`注释

下面是更新后的`MessageController`:

```java
@Controller
public class MessageController {
  ...
 @GetMapping("/api/messages")
  @ResponseBody
  public ResponseEntity<List<Message>> getMessages() {
    List<Message> messages = messageService.getMessages();
    return ResponseEntity.ok(messages);
  }

 @PostMapping("/api/messages")
  @ResponseBody
  public ResponseEntity<Message> saveMessage(@RequestBody MessageData data) {
    ...
  }
}
```

用于`/api/messages` ( `GET` ) API 的`getMessages()`处理程序是我们在这里添加的新处理程序。在这个方法中，我们调用`MessageService.getMessages()`来获取消息。

下面是对`MessageService`的更改，添加了`getMessages()`方法:

```java
public class MessageService {
  ...
 @Transactional(readOnly = true)
  public List<Message> getMessages() {
    return repository.getMessages();
  }

  @SecurityCheck
  @Transactional
  public Message save(String text) {
    return repository.saveMessage(new Message(text));
  }
}
```

如您所见，我们在这里添加了`@Transactional`注释来创建一个事务，因为我们将使用`sessionFactory.getCurrentSession()`来获取存储库中的 Hibernate 会话。而且，因为它只是一个`read`操作，我们将其标记为只读。我们还需要改变`MessageService`的`save()`方法来删除`updateStatistics()`方法，因为我们在这里不需要它。

下面是对`MessageRepository`的修改:

```java
public class MessageRepository {
  ...
  public List<Message> getMessages() {
    Session session = sessionFactory.getCurrentSession(); 
    String hql = "from Message";
 Query<Message> query = session.createQuery(hql, Message.class);
 return query.list();
  }
}
```

在`getMessages()`方法中，在获得一个 Hibernate 会话后，我们创建一个 **Hibernate 查询语言** ( **HQL** )，来检索所有的消息。Hibernate 会将这个 HQL 翻译成类似下面的 SQL，并发送给数据库:

```java
select message0_.id as id1_0_, message0_.created_date as created_2_0_, message0_.text as text3_0_ from messages message0_
```

可以如下打开 Hibernate SQL 的调试日志，打印出 Hibernate 生成的 SQL:`logging.level.org.hibernate.SQL=DEBUG`

为了执行 HQL，我们需要创建一个 Hibernate `org.hibernate.query.Query`对象，并调用它的`.list()`方法来请求 Hibernate 执行查询并返回`messages`表中的所有记录。Hibernate 将负责关系到对象的映射，并为我们提供一个`Message`对象列表。

# HTTP 客户端–axios

现在，让我们进行最后一步，即使用 HTTP 客户端与后端进行通信。我们将使用 axios([https://github.com/axios/axios](https://github.com/axios/axios))作为其简单的基于承诺的 API。我们从 CDN([https://unpkg.com/axios/dist/axios.min.js](https://unpkg.com/axios/dist/axios.min.js))下载下来放到`resources/static/`目录下吧。我们这里用的版本是 v0.18.0。

打开消息页面(`https://localhost:8080/messages`)后，为了尽快显示现有的消息，我们需要将检索消息的逻辑添加到 Vue 实例的`created()`生命周期挂钩中。而且我们还需要修改`addMessage()`的方法。

以下是对`index.html`文件的更改:

```java
...
<body>
  ...
  <script src="../axios.v0.18.0.min.js"></script>
  <script type="module"> 
    window.vm = new Vue({
      ...
      created () {
        axios.get('api/messages?_=' + new Date().getTime())
        .then((response) => {
          this.messages = response.data
        })
        ...
      },
      methods: {
        addMessage (event) {
          if (!this.newMessage) return
          axios.post('api/messages', {text: this.newMessage})
          .then((response) => {
            this.messages.push(response.data)
            this.newMessage = ''
          })
          ...
        }
      }
    })
  </script>
</body>
...
```

如您所见，在`created()`钩子中，我们使用`axios.get()`发送检索消息`GET`请求。URL 中附加的`?_`参数旨在使浏览器不使用之前缓存的响应。一旦请求完成，消息 JSON 数据就被传递到参数`response`的`data`属性中。

在`addMessage()`方法中，我们使用`axios.post()`向后端发送新消息。请求完成后，我们将保存的消息添加到消息列表中。

到目前为止，我们已经完成了获取消息和保存新消息的集成。删除消息的逻辑留给您作为练习。

如果您重启应用并打开`http://localhost:8080/messages`，您将会看到您之前添加的消息出现在页面上。

# 打包 app.messages

在这一章的开始，我们决定把所有东西都放在`app.messages`包中。让我们来看看吧。这是里面的所有东西:

```java
AppConfig.java             // Root configuration class
Application.java           // Application bootstrap class
AuditingFilter.java        // Requests audit Filter
Message.java               // Message Entity class
MessageController.java     // Message Controller for HTTP API
MessageData.java           // Saving message request data structure
MessageRepository.java     // Repository class of Message
MessageService.java        // Service class of Message
SecurityCheck.java         // Security Check annotation
SecurityChecker.java       // Security Checker aspect
```

如你所见，这是一堆烂泥。如果我们要在这个应用中加入更多的功能，除非我们重新组织它，否则它会变得混乱。

让我们重新组织一下。因为我们的 Messages 应用非常小，所以根据类的角色将`app.messages`包分成子包就足够了。

下面是重构后的`app.messages`包的结构:

```java
app.messages /config
   /AppConfig.java
 /model
   /Message.java
 /repository
   /MessageRepository.java
 /service
   /MessageService.java
 /web
   /AuditingFilter.java
   /MessageController.java
   /MessageData.java
 /security
   /SecurityCheck.java
   /SecurityChecker.java
 /Application.java
```

如您所见，我们将所有配置类放入一个`app.messages.config`包中，将消息实体类放入一个`app.messages.model`包中，并将服务和存储库类放入它们自己的包中。由于`AuditingFilter`、`MessageController`和`MessageData`都处理 HTTP 请求，所以它们驻留在`app.messages.web`包中，而`app.messages.security`包用于与安全相关的项目。`Application.java`引导类保留在`app.message`包中。

这是分层应用的典型结构，通常包含三层——web 层、服务层和 DAO 层。这种类型的结构并不是所有应用的灵丹妙药。我们将在本书的后面讨论更多关于代码设计的内容。

# 摘要

在这一章中，你已经学习了 Spring IoC 和 DI、Spring MVC、Spring JDBC、JPA/Hibernate、Spring AOP、Spring 事务管理和 Spring Boot。您还集成了 Messages 应用的前端和后端。

在下一章，我们将介绍一个 TaskAgile 应用，这样你就知道我们要创建什么样的应用了。