# 八、通过 WebSockets 和 STOMP 通信

本章包括四种秘籍。他们都完全接受我们的 CloudStreet 市场应用。改善，他们使它更具反应性，更具互动性。

这些秘籍有以下标题:

*   流媒体社交活动
*   使用 RabbitMQ 作为多协议消息代理
*   用 AMQP 堆叠和消耗 RabbitMQ 中的任务
*   用 Spring Session 和 Redis 保护消息

# 简介

让我们快速回顾一下我们希望你在前面的章节中学到了什么。一章接一章，你一定发现了:

*   如何启动项目，以及如何依靠标准来保持代码库的可伸缩性和适应性。这些标准来自一些工具，比如 Maven 或 Java 持久性 API。所提出的标准还包含了一些常见的实践，例如在客户端，使用 AngularJS MVC 模式或 Bootstrap 框架 UI。
*   如何在面对现代挑战的同时充分利用 Spring MVC？Spring MVC 已经被演示为一个 web MVC 框架(包括它的请求流、内容协商、视图解析、模型绑定、异常处理等等)，而且还被演示为 Spring 环境中的一个集成的 Spring 组件。一个能够中继 Spring 安全认证或 Spring 社会抽象的集成框架。它还能够提供 Spring 数据分页工具以及极具竞争力的 HTTP 规范实现。
*   如何设计一个微服务架构，实现一个高级的无状态和超媒体 API，促进职责分离。前端和后端之间的职责分离，以及组件的功能划分(水平可伸缩性)到独立的 web 档案中的职责分离(`.war`)。

本章关注新兴的 WebSocket 技术，以及为我们的应用构建一个**面向消息的中间件** ( **MOM** )。这是一个罕见的展示，在 Spring 中实现了如此多的 WebSockets。从使用默认的嵌入式 WebSocket 消息代理到全功能的 RabbitMQ 代理(使用 STOMP 和 AMQP 协议)。我们将看到如何向多个客户端广播消息，并推迟耗时任务的执行，从而提供显著的可伸缩性优势。

有了一个新的 Java 项目，专门用于需要访问公共数据库服务器的 WebSockets，并且从类似生产环境的角度来看，我们将用 MySQL Server 替换 HSQLDB。

我们将看到如何动态创建私有队列，以及如何让经过身份验证的客户端从这些私有队列中发送和接收消息。我们将做所有这些，在我们的应用中实现真正的应用特性。

为了实现 WebSocket 认证和消息认证，我们将把 API 变成有状态的。对于有状态，这意味着 API 将使用 HTTP 会话来保持用户在其请求之间通过身份验证。在 Spring Session 的支持下，使用高度集群化的 Redis 服务器，会话将在多个 webapps 之间共享。

# 流媒体社交活动

在这个秘籍中，我们用 STOMP over SockJS 广播用户活动(事件)。SockJS 提供了 WebSocket 的自定义实现。

## 准备就绪

事先需要做一些配置工作，尤其是在 Apache HTTP 代理上。之后，我们将看到如何在客户端用 SockJS 和 AngularJS 启动 WebSocket。

我们的 WebSocket 将从`cloudstreetmarket-api`模块订阅一个通过 Spring 发布的主题(用于广播)。

## 怎么做……

1.  从 Eclipse 中的 **Git 视角**来看，签出分支`v8.1.x`的最新版本。
2.  在`zipcloud-parent`项目上运行 `Maven clean` 和`Maven install`命令(右击项目，选择**运行方式…** | **Maven Clean** ，然后选择**运行方式…** | **Maven Install)** 。在此之后，运行一个 **Maven | Update** **项目**来同步 Eclipse 与 Maven 配置(右键单击该项目，然后单击**Maven**|**Update Project…**)。
3.  类似地，在`cloudstreetmarket-parent`上运行 **Maven clean** 和 **Maven install** 命令，然后运行**Maven**|**Update Project…**(以便更新所有`cloudstreetmarket-parent`模块)。

### Apache HTTP 代理配置

1.  在 Apache`httpd.conf` 文件中，将`VirtualHost`定义更改为:

    ```java
    <VirtualHost cloudstreetmarket.com:80>
      ProxyPass        /portal http://localhost:8080/portal
      ProxyPassReverse /portal http://localhost:8080/portal
      ProxyPass        /api  	http://localhost:8080/api
      ProxyPassReverse /api  	http://localhost:8080/api
      RewriteEngine on
      RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC]
      RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC]
      RewriteRule .* ws://localhost:8080%{REQUEST_URI} [P]
      RedirectMatch ^/$ /portal/index
    </VirtualHost>
    ```

2.  仍然在`httpd.conf`中，取消注释该行:

    ```java
    LoadModule proxy_wstunnel_module modules/mod_proxy_wstunnel.so
    ```

### 前端

1.  In the `index.jsp` file (in the `cloudstreetmarket-webapp` module), two extra JavaScript files are imported:

    ```java
    <script src="js/util/sockjs-1.0.2.min.js"></script>
    <script src="js/util/stomp-2.3.3.js"></script> 
    ```

    ### 注意

    这两个文件都是本地拷贝的，但最初都是在网上找到的:

    [https://cdnjs . cloud flare . com/Ajax/libs/sock js-client/1 . 0 . 2/sock js . min . js](https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.0.2/sockjs.min.js)

    [https://cdnjs . cloud flare . com/Ajax/libs/stomp . js/2 . 3/stomp . js】](https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.js)

2.  对于这个菜谱，客户端上的所有更改都与文件`src/main/webapp/js/home/home_community_activity.js`相关(它驱动登陆页面上**用户活动**的提要)。该文件与模板`/src/main/webapp/html/home.html`相关联。
3.  作为`homeCommunityActivityController`的`init()`功能的一部分，追加了以下部分:

    ```java
    cloudStreetMarketApp.controller('homeCommunityActivityController', function ($scope, $rootScope, httpAuth, modalService, communityFactory, genericAPIFactory, $filter){
      var $this = this,
      socket = new SockJS('/api/users/feed/add'),
      stompClient = Stomp.over(socket);
      pageNumber = 0;
      $scope.communityActivities = {};
      $scope.pageSize=10;
      $scope.init = function () {
        $scope.loadMore();
        socket.onclose = function() {
          stompClient.disconnect();
        };
        stompClient.connect({}, function(frame) {
        stompClient.subscribe('/topic/actions', 	function(message){
         var newActivity = $this.prepareActivity( JSON.parse(message.body)
           );
            $this.addAsyncActivityToFeed(newActivity);
            $scope.$apply();
        });
        });
      ...
      }
    ...
    ```

4.  当到达滚动底部时，仍然调用`loadMore()`函数来拉取新的活动。然而现在，因为可以异步插入新的活动，所以`communityActivities`变量不再是一个数组，而是一个用作映射的对象，将活动 id 作为键。这样做允许我们合并同步结果和异步结果:

    ```java
      $scope.loadMore = function () {
        communityFactory.getUsersActivity(pageNumber, $scope.pageSize).then(function(response) {
          var usersData = response.data,
          status = response.status,
          headers  = response.headers,
          config = response.config;
          $this.handleHeaders(headers);
          if(usersData.content){
            if(usersData.content.length > 0){
              pageNumber++;
            }
            $this.addActivitiesToFeed(usersData.content);
          }
        });
      };
    ```

5.  As before (since the [Chapter4](4.html "Chapter 4\. Building a REST API for a Stateless Architecture"), *Building a REST API for a Stateless Architecture*), we loop over the community activities to build the activity feed. Now each activity carries a number of **likes** and **comments**. Currently, if a user is authenticated, he has the capability to see the number of **likes**:

    ![Frontend](img/B4049_08_01.jpg)

6.  绑定到向上滚动图像的三角形 HTML 如下:

    ```java
        <span ng-if="userAuthenticated() && value.amountOfLikes == 0">
        <img ng-src="{{image}}" class="like-img" 
          ng-init="image='img/icon-finder/1441189591_1_like.png'"
          ng-mouseover="image='img/icon-finder/1441188631_4_like.png'"
          ng-mouseleave="image='img/icon-finder/1441189591_1_like.png'"
          ng-click="like(value.id)"/>
      </span>
    ```

7.  在控制器中，`like()`范围函数支持这个 DOM 元素来创建一个新的`like`活动，该活动的目标是原来的活动:

    ```java
      $scope.like = function (targetActionId){
        var likeAction = {
          id: null,
          type: 'LIKE',
          date: null,
          targetActionId: targetActionId,
          userId: httpAuth.getLoggedInUser()
        };
        genericAPIFactory.post("/api/actions/likes", likeAction);
      }
    ```

8.  相反的逻辑也可以被发现为**不同于**的一种活动。

### Backend

1.  以下 Maven 依赖项的已被添加到`cloudstreetmarket-api` :

    ```java
        <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-websocket</artifactId>
          <version>${spring.version}</version>
       </dependency>
       <dependency>
          <groupId>org.springframework</groupId>
          <artifactId>spring-messaging</artifactId>
          <version>${spring.version}</version>
       </dependency>
    ```

2.  在`web.xml`文件(来自`cloudstreetmarket-api`的文件)中，必须将以下属性添加到我们的 servlet 及其每个过滤器中:

    ```java
    <async-supported>true</async-supported>
    ```

3.  The following dedicated configuration bean has been created:

    ```java
    @Configuration
    @ComponentScan("edu.zipcloud.cloudstreetmarket.api")
    @EnableWebSocketMessageBroker
    public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

       @Override
       public void registerStompEndpoints(final StompEndpointRegistry registry) {
             registry.addEndpoint("/users/feed/add")
                .withSockJS();
        }
       @Override
       public void configureMessageBroker(final MessageBrokerRegistry registry) {
          registry.setApplicationDestinationPrefixes("/app");
           registry.enableSimpleBroker("/topic");
        }
    }
    ```

    添加了一个新的控制器`ActivityFeedWSController`，如下所示:

    ```java
    @RestController
    public class ActivityFeedWSController extends CloudstreetApiWCI{
        @MessageMapping("/users/feed/add")
        @SendTo("/topic/actions")
        public UserActivityDTO handle(UserActivityDTO message) throws Exception{
            return message;
        }
        @RequestMapping(value="/users/feed/info", method=GET)
        public String infoWS(){
            return "v0";
        }
    }
    ```

4.  As Spring configuration, we have added the following bean to the `dispatcher-servlet.xml`:

    ```java
    <bean
      class="org.sfw.web.socket.server.support.OriginHandshakeInterceptor">
        <property name="allowedOrigins">
          <list>
          <value>http://cloudstreetmarket.com</value>
          </list>
        property>
    </bean>
    ```

    在`security-config.xml`中，以下配置被添加到 http Spring 安全名称空间中:

    ```java
        <security:http create-session="stateless" 
            entry-point-ref="authenticationEntryPoint" authentication-manager-ref="authenticationManager">
        ...
        <security:headers>
          <security:frame-options policy="SAMEORIGIN"/>
        </security:headers>
        ...
        </security:http>
    ```

现在让我们看看事件是如何产生的。

1.  When a new financial transaction is created, a message is sent to the topic `/topic/actions`. This is done in the `TransactionController`:

    ```java
    @RestController
    @ExposesResourceFor(Transaction.class)
    @RequestMapping(value=ACTIONS_PATH + TRANSACTIONS_PATH, produces={"application/xml", "application/json"})
    public class TransactionController extends CloudstreetApiWCI<Transaction> {
      @Autowired
      private SimpMessagingTemplate messagingTemplate;
      @RequestMapping(method=POST)
      @ResponseStatus(HttpStatus.CREATED)
      public TransactionResource post(@Valid @RequestBody Transaction transaction, HttpServletResponse response, BindingResult result) {
        ...
       messagingTemplate.convertAndSend("/topic/actions", new UserActivityDTO(transaction));
        ...
      }
    }
    ```

    类似地，当一个`like`活动被创建时，一条消息也被发送到`LikeActionController`中的`/topic/actions`主题:

    ```java
     @RequestMapping(method=POST)
    @ResponseStatus(HttpStatus.CREATED)
    public LikeActionResource post(@RequestBody LikeAction likeAction, HttpServletResponse response) {
       ...
        likeAction = likeActionService.create(likeAction);
       messagingTemplate.convertAndSend("/topic/actions", new UserActivityDTO(likeAction));
       ...
    }
    ```

2.  现在启动 Tomcat 服务器。使用 Yahoo！登录应用。Oauth2 和你的个人雅虎！帐户(如果您还没有帐户，请创建一个)。为`Cloudstreet Market`应用注册一个新用户。
3.  在您的 web 浏览器中，使用您登录的用户打开应用中的两个不同的选项卡。在登录页面上保留其中一个选项卡。
4.  使用另一个选项卡，导航到**价格和市场** | **所有价格搜索**菜单。搜索一个股票，比如说脸书，然后买它的三只股票。
5.  Wait to receive the information message:

    ![Backend](img/B4049_08_02.jpg)

    然后检查浏览器的第一个选项卡(您没有使用的选项卡)。

    ![Backend](img/B4049_08_03.jpg)

    您会注意到，活动提要的顶部有了一个新元素！

6.  Also, in the console you should have the following log trace:

    ![Backend](img/B4049_08_04.jpg)

7.  Similarly, **like** events are refreshed in real time:

    ![Backend](img/B4049_08_05.jpg)

## 它是如何工作的...

在这里，在介绍 Spring-WebSocket 支持工具之前，我们将先看几个关于 WebSockets、STOMP 和 SockJS 的一般概念。

### WebSockets 简介

WebSocket 是一种基于 TCP 的全双工通信协议。全双工通信系统允许两方通过双向信道同时*说*和*听到*。电话通话可能是全双工系统的最好例子。

这项技术对于需要利用新 HTTP 连接引起的开销的应用特别有用。自 2011 年以来，WebSocket 协议已经成为互联网标准([https://tools.ietf.org/html/rfc6455](https://tools.ietf.org/html/rfc6455))。

#### WebSocket 生命周期

在 WebSocket 连接建立之前，客户端发起一个握手 HTTP，服务器对此进行响应。握手请求还代表一个协议升级请求(从 HTTP 到 WebSocket)，用一个`Upgrade`头来形式化。服务器在其响应中用相同的`Upgrade`报头(和值)确认该协议升级。除了`Upgrade`头，从防止缓存代理攻击的角度来看，客户机还发送一个 base-64 编码的随机密钥。对此，服务器在一个`Sec-WebSocket-Accept` 头中发回这个键的散列。

下面是我们的应用中发生的一个握手示例:

![WebSocket Lifecycle](img/B4049_08_06.jpg)

协议的生命周期可以用下面的序列图来概括:

![WebSocket Lifecycle](img/B4049_08_07.jpg)

#### 两个专门的 URI 计划

协议为`WebSockets ws://` 和`wss://`定义了两种 URI 方案(其中`wss`允许加密连接)。

### STOMP 协议

**STOMP** 代表**简单面向文本的消息协议**。该协议提供了一种基于帧的互操作格式，允许 STOMP 客户端与 STOMP 消息代理进行通信。

它是一种消息协议，要求并信任更高级别的现有双向流网络协议。WebSocket 提供了基于帧的数据传输，WebSocket 帧确实可以是 STOMP 格式的帧。

以下是踏脚帧的示例:

```java
CONNECTED
session:session-4F_y4UhJTEjabe0LfFH2kg
heart-beat:10000,10000
server:RabbitMQ/3.2.4
version:1.1
user-name:marcus
```

框架的结构如下:

![The STOMP protocol](img/B4049_08_08.jpg)

STOMP 协议规范定义了一组客户端命令(`SEND`、`SUBSCRIBE`、`UNSUBSCRIBE`、`BEGIN`、`COMMIT`、`ABORT`、`ACK`、`NACK`、`DISCONNECT`、`CONNECT`和`STOMP`)和服务器命令(`CONNECTED`、`MESSAGE`、`RECEIPT`和`ERROR`)。

只有 `SEND`、`MESSAGE`和`ERROR`帧可以有主体。协议规范可以在网上找到:【http://stomp.github.io/stomp-specification-1.2.html。

在客户端，我们使用了 JavaScript 库 **STOMP Over WebSocket** ，用文件`stomp.js`标识。该库将 STOMP 格式的帧映射到 WebSocket 帧。默认情况下，它查找 web 浏览器`WebSocket`类，让 STOMP 客户端创建 WebSocket。

该库还可以从定制的`WebSocket`实现中创建 STOMP 客户端。从 SockJS WebSockets，我们像这样创建 STOMP 客户机:

```java
    var socket = new SockJS('/app/users/feed/add');
    var stompClient = Stomp.over(socket);
        stompClient.connect({}, function(frame) {
  ...
    });
    socket.onclose = function() {
    stompClient.disconnect();
  };
```

### 糖

如今几乎所有的浏览器都支持 WebSockets。然而，我们无法控制客户正在使用的版本。在许多情况下，对 7%到 15%的观众隐藏这样的技术根本不是一个选项。

在客户端，SockJS 提供了一个定制的实现，它可以被看作是浏览器本地`WebSocket`实现的装饰器。SockJS 有一个简单方便的库，可以确保跨浏览器的兼容性。通过一系列回退传输选项(`xhr-streaming`、`xdr-streaming`、`iframe-eventsource`、`iframe-htmlfile`、`xhr-polling`等等)，它尽可能地模仿 WebSockets。

对于服务器实现，为了匹配客户端的回退行为，SockJS 还定义了自己的协议:

[http://sock js . github . io/sock js-protocol/sock js-protocol-0 . 3 . 3 . html](http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html)

### Spring WebSocket 支持

根据 Java WebSocket API 规范(JSR-356)，Spring 4+提供了一个打包在模块`spring-websocket`和`spring-messaging`中的解决方案。但是 Spring 提供的不仅仅是 JSR-356 的实现。例如，基于以下事实:

*   不使用消息协议的 WebSockets 级别太低，不能直接用于没有自定义处理框架的应用中:Spring 团队选择提供并支持消息协议实现(STOMP)。
*   并非所有浏览器都支持 WebSockets:Spring 还通过 SockJS 协议的实现提供了 web socket 回退支持。

#### 一体式配置

我们已经启用了 WebSocket 引擎，并且只从一个配置 bean`WebSocketConfig`中为 SockJS 和 STOMP 进行了配置:

```java
@Configuration
@ComponentScan("edu.zipcloud.cloudstreetmarket.api")
@EnableWebSocketMessageBroker
public class WebSocketConfig extends   AbstractWebSocketMessageBrokerConfigurer {

  @Override
  public void registerStompEndpoints(final StompEndpointRegistry registry) {
        registry.addEndpoint("/users/feed/add")
        .withSockJS();
  }

  @Override
  public void configureMessageBroker(final MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
  }
}
```

为上下文路径`/users/feed/add`定义了 WebSocket 端点。它在客户端匹配已定义的 SockJS 客户端构造函数参数:

```java
var socket = new SockJS('/api/users/feed/add');
```

从端点(`clientInboundChannel`)，WebSocket 引擎需要选择将消息路由到哪里，对此我们有两个选项。根据具体情况和我们想要实现的目标，我们可以将应用内的消费者(消息处理程序)或直接消息代理作为目标，以便将消息分发到订阅的客户端。

这种分割是通过定义两个不同的目的地前缀来配置的。在我们的例子中，我们决定使用`/app`前缀将消息路由到相应的消息处理程序，并使用`/topic`前缀来标识准备发送给客户端的消息。

现在让我们看看如何定义消息处理程序以及如何使用它们。

#### 通过@MessageMapping 定义消息处理程序

在 Spring MVC 控制器方法中使用注释来标记它们作为消息处理程序方法。

从`clientInboundChannel`中的消息路由到消息处理程序，WebSocket 引擎根据它们的配置值缩小正确的`@MessageMapping`方法。

和 Spring MVC 中一样，这个值可以用 Ant 风格定义(例如`/targets/**`)。然而，与`@RequestParam`和`@PathVariable` 注释一样，模板变量也可以通过在方法参数上使用`@DestinationVariable`注释来传递(目标模板的定义如下:`/targets/{target}`)。

### 向调度发送消息

必须配置一个消息代理。在这个秘籍的例子中，我们使用的是从`MessageBrokerRegistry`启用的`simple`消息代理(`simpMessageBroker`)。当不需要外部代理(RabbitMQ、ActiveMQ 等)时，这种类型的内存中代理适合栈 STOMP 消息。当可以向 WebSocket 客户端发送消息时，这些消息被发送到`clientOutboundChannel`。

我们已经看到，当消息目的地以`/topic`为前缀时(就像我们的例子)，消息被直接发送到消息代理。但是，当我们在消息处理程序方法或后端代码中的其他地方时，发送消息进行分派又如何呢？为此，我们可以使用下一节中描述的`SimpMessagingTemplate`。

#### 简易短信模板

我们在 CSMReceiver 类中自动连接了一个`SimpMessagingTemplate`,稍后我们将使用它将 AMQP 消息的有效负载转发给 WebSocket 客户端。

A `SimpMessagingTemplate`的作用与 Spring `JmsTemplate`相同(如果你熟悉它的话)，但是它适合简单的消息协议(比如 STOMP)。

一个方便且继承的著名方法是`convertAndSend`方法，它试图识别并使用一个`MessageConverter`来序列化一个对象，并在将该消息发送到指定目的地之前将其放入新消息中:

```java
simpMessagingTemplate.convertAndSend(String destination, Object message);
```

这个想法是为一个消息代理确定一个目的地(在我们的例子中有一个 `/topic`前缀)。

#### @ send to 注释

这个注释让我们不必显式地使用`SimpMessagingTemplate`。目标被指定为注释值。这个方法也将处理从有效载荷到消息的转换:

```java
@RestController
public class ActivityFeedWSController extends CloudstreetApiWCI{

  @MessageMapping("/users/feed/add")
  @SendTo("/topic/actions")
  public UserActivityDTO handle(UserActivityDTO payload) throws Exception{
        return payload;
 }
}
```

## 还有更多……

在本节中，我们提供了与 SockJS 回退选项相关的额外信息来源。

正如前面介绍的, Spring 提供了 SockJS 协议实现。在`StompEndPoint`注册期间，使用`withSockJS()`函数方法很容易在 Spring 中配置 SockJS。仅这一小段配置就告诉 Spring 在我们的端点上激活 SockJS 回退选项。

SockJS 客户机对服务器的第一次调用是对端点路径的 HTTP 请求，该路径与`/info`连接在一起，以评估服务器配置。如果这个 HTTP 请求不成功，就不会尝试其他传输(甚至是 WebSocket)。

如果您想了解 SockJS 客户机如何查询服务器以获得合适的回退选项，您可以阅读 Spring 参考指南中的更多内容:

[http://docs . spring . io/spring/docs/current/spring-framework-reference/html/web socket . html # web socket-server-handshake](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-handshake)

## 参见

*   **JSR-356** :你可以在网上找到规范文档，了解更多关于 spring-websocket 所遵循的 Java API for WebSocket 规范:[https://jcp.org/en/jsr/detail?id=356](https://jcp.org/en/jsr/detail?id=356)

# 使用 RabbitMQ 作为多协议消息代理

安装并使用外部 RabbitMQ 作为全功能的消息代理，可以实现新的技术机会和类似生产的基础设施的设计。

## 准备就绪

在这个菜谱中，我们将把 RabbitMQ 安装为一个独立的服务器，并对其进行配置，使其支持 STOMP 消息。

我们还将更新我们的 WebSocket Spring 配置，以依赖这个全功能的消息代理，而不是内部的简单消息代理。

## 怎么做……

1.  从 Eclipse 中的 **Git 视角**来看，这次检查一下`v8.2.x`分支。
2.  添加了两个新的 Java 项目，它们必须被导入。从 Eclipse 中，选择**文件** | **导入…** 菜单。
3.  **导入**向导打开，您可以在层次结构中选择项目类型。打开 **Maven** 类别，选择**现有 Maven 项目**选项，点击**下一步**。
4.  **导入 Maven 项目**向导打开。作为根目录，选择(或键入)工作区位置(应为`<home-directory>/workspace`)。
5.  As shown in the following screenshot, select the following two **pom.xml** files: **cloudstreetmarket-shared/pom.xml** and **cloudstreetmarket-websocket/pom.xml**.

    ![How to do it…](img/B4049_08_09.jpg)

6.  两个项目`cloudstreetmarket-shared`和`cloudstreetmarket-websocket`必须出现在项目层次结构中。
7.  使用以下指令在 web 模块上定位一个运行时环境:在 Eclipse 中，右键单击 **cloudmarket-websocket** 项目，选择**属性**菜单，在导航面板中，选择**目标运行时**。在中央窗口中，检查服务器的勾选标记 **Apache Tomcat v8.0** 。
8.  在`/app`目录中，`cloudstreetmarket.properties`文件已经更新。在位于`<home-directory>/app/cloudstreetmarket.properties`的文件中反映这些变化。
9.  在`zipcloud-parent`上运行`Maven clean`和`Maven install`命令，然后在`cloudstreetmarket-parent`上运行，接着在所有模块上运行 **Maven** | **更新项目**。
10.  以我们想要的方式运行 RabbitMQ，要求我们下载并安装该产品作为独立产品。
11.  Depending upon the configuration of the local machine, different ways of proceeding apply. You will find the appropriate links and installation guides on the RabbitMQ website: [https://www.rabbitmq.com/download.html](https://www.rabbitmq.com/download.html)

    ### Tip

    如果你使用的是 Windows OS，请注意，下载并安装 Erlang([http://www.erlang.org/download.html](http://www.erlang.org/download.html))是先决条件。

12.  Once RabbitMQ is installed and once its service is running, open your favourite web browser in order to check that RabbitMQ is running as a web console at the URL: `http://localhost:15672` (like in the following screenshot).

    ![How to do it…](img/B4049_08_10.jpg)

    ### 注意

    我们稍后将回到这个问题来设置 RabbitMQ 配置。现在，只要记住这个控制台可以用来监视消息和管理连接、队列、主题和交换。

13.  RabbitMQ STOMP 插件需要激活。这是在`rabbitmq_server-x.x.x\sbin`目录中通过执行命令行来完成的:

    ```java
    rabbitmq-plugins enable rabbitmq_stomp
    ```

14.  添加了以下 Maven 依赖项:

    ```java
    <dependency>
      <groupId>org.springframework.amqp</groupId>
      <artifactId>spring-rabbit</artifactId>
      <version>1.4.0.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-core</artifactId>
      <version>2.0.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-net</artifactId>
      <version>2.0.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>io.projectreactor.spring</groupId>
      <artifactId>reactor-spring-context</artifactId>
      <version>2.0.5.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>io.netty</groupId>
      <artifactId>netty-all</artifactId>
      <version>4.0.31.Final</version>
    </dependency>
    ```

15.  在`cloudstreetmarket-api`模块的 `dispatcher-servlet.xml`中，使用`rabbit`名称空间添加了以下 beans】
16.  在`csmcore-config.xml` 文件中(在`cloudstreetmarket-core`中)，添加了以下名称空间为`task` 的 beans】
17.  仍然是在 Spring 配置方面的事情，我们的`AnnotationConfig` bean(主配置 bean 为`cloudstreetmarket-api`)已经增加了两个注解:

    ```java
    @EnableRabbit
    @EnableAsync
    public class AnnotationConfig {
    	...
    }
    ```

18.  最后，`WebSocketConfig` bean 也被更新了；尤其是经纪人注册。我们现在使用一个`StompBrokerRelay`来代替一个简单的代理:

    ```java
    @Configuration
    @ComponentScan("edu.zipcloud.cloudstreetmarket.api")
    @EnableWebSocketMessageBroker
    @EnableScheduling
    @EnableAsync
    public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {
    ...
        @Override
        public void configureMessageBroker(final MessageBrokerRegistry registry) {
         registry.setApplicationDestinationPrefixes( WEBAPP_PREFIX_PATH);
         registry.enableStompBrokerRelay(TOPIC_ROOT_PATH);
        }
    }
    ```

### Tip

就是这样！一切都设置为使用 RabbitMQ 作为我们系统的外部代理。但是，请注意，如果您现在尝试启动服务器，代码将期望安装 MySQL 以及 Redis 服务器。这两个第三方系统将在接下来的两个秘籍中详细介绍。

## 它是如何工作的...

### 使用全功能的消息代理

与简单的消息代理相比，使用 RabbitMQ 之类的全功能消息代理提供了有趣的好处，我们现在将对此进行讨论。

#### 集群能力–rabbit MQ

RabbitMQ 代理由一个或多个 Erlang 节点组成。每个节点都代表 RabbitMQ 的一个实例，可以独立启动。可以使用命令行工具`rabbitmqctl`将节点相互链接。例如，`rabbitmqctl join_cluster rabbit@rabbit.cloudstreetmarket.com`实际上将一个节点连接到一个现有的集群网络。RabbitMQ 节点使用 cookies 相互通信。要在同一个集群上连接，两个节点必须具有相同的 cookie。

#### 更多 STOMP 消息类型

功能全面的消息消息代理(与简单的消息代理相比)支持额外的 STOMP 帧命令。例如，`ACK`和`RECEIPT`是简单消息代理不支持的。

### StompMessageBrokerRelay

在前面的菜谱中，我们讨论了消息在 Spring WebSocket 引擎中传递的流程。如下图所示，当切换到外部 message broker 中继时，此流完全不受影响。

![StompMessageBrokerRelay](img/B4049_08_11.jpg)

只有 RabbitMQ 外部消息代理作为额外的一部分出现。`BrokerMessageHandler` ( `StompBrokerRelayMessageHandler`)只在幕后充当针对 RabbitMQ 节点的代理。在`StompBrokerRelay`和它的消息代理之间只维护一个 TCP 连接。`StompBrokerRelay`通过发送心跳消息来保持连接。

## 参见

*   **RabbitMQ guide and documentation**: This recipe is just an overview, however the RabbitMQ documentation is well done and very complete. It is a great source of information, and you can find it at:

    [http://www.rabbitmq.com/documentation.html](http://www.rabbitmq.com/documentation.html)

    [http://www.rabbitmq.com/stomp.html](http://www.rabbitmq.com/stomp.html)

# 用 RabbitMQ 和 AMQP 堆叠和消耗任务

这个秘籍将演示如何实现一个**面向消息的中间件** ( **妈妈**)。这个是基于组件间异步通信的可伸缩性中非常流行的技术。

## 准备就绪

我们已经介绍了新的`cloudstreetmarket-shared`和`cloudstreetmarket-websocket` Java 项目。WebSockets 现在从`cloudstreetmarket-api`中分离出来，但是`cloudstreetmarket-websocket`和`cloudstreetmarket-api`仍然会使用消息传递来相互通信。

为了将次要任务从请求线程中分离出来(次要任务如事件产生)，您需要学习如何通过 RabbitMQ 配置和使用 AMQP 消息模板和监听器。

## 怎么做……

1.  Access the RabbitMQ web console at `http://localhost:15672`.

    ### 注意

    如果由于某种原因无法访问 web 控制台，请返回到上一个方法，在那里可以找到下载和安装指南。

2.  In the **Queue** tab of the web console, create a new queue named `AMQP_USER_ACTIVITY`. Create it with the parameters **Durable** and **Auto-delete: "No"**:

    ![How to do it…](img/B4049_08_12.jpg)

### 发送方

当 API 被请求执行诸如**创建事务**或**创建类似活动**的操作时，我们产生事件。

### Tip

随着很少的调整变化，我们现在使用`RabbitTemplate`而不是以前的`SimpMessagingTemplate`，我们的目标是一个中间的 AMQP 队列，而不是最终的 STOMP 客户端。

在`TransactionController`中，POST 处理程序更新如下:

```java
import org.springframework.amqp.rabbit.core.RabbitTemplate;
@RestController
public class TransactionController extends CloudstreetApiWCI<Transaction> {
  @Autowired
  private RabbitTemplate messagingTemplate;

  @RequestMapping(method=POST)
  @ResponseStatus(HttpStatus.CREATED)
  public TransactionResource post(@Valid @RequestBody Transaction transaction, HttpServletResponse response, BindingResult result) {
   ...
   messagingTemplate.convertAndSend("AMQP_USER_ACTIVITY", new UserActivityDTO(transaction));
   ...
   return resource;
  }
}
```

在`LikeActionController`中，POST 处理程序更新如下:

```java
import org.springframework.amqp.rabbit.core.RabbitTemplate;

@RestController
public class LikeActionController extends CloudstreetApiWCI<LikeAction> {
  @Autowired
  private RabbitTemplate messagingTemplate;
  @RequestMapping(method=POST)
  @ResponseStatus(HttpStatus.CREATED)
  public LikeActionResource post(@RequestBody LikeAction likeAction, HttpServletResponse response) {
  ...
   messagingTemplate.convertAndSend("AMQP_USER_ACTIVITY", new UserActivityDTO(likeAction));
   ...
   return resource;
  }
}
```

### 消费者一方

正如前面解释的那样，`cloudstreetmarket-websocket`模块现在监听`AMQP_USER_ACTIVITY`队列。

1.  必要的配置设置在`displatcher-servlet.xml` ( `cloudstreetmarket-websocket`)中。在那里，我们创建了一个`rabbitConnectionFactory`和一个`rabbitListenerContainerFactory` bean:

    ```java
    <rabbit:connection-factory id="rabbitConnectionFactory" username="guest" host="localhost" password="guest"/>
    <bean id="rabbitListenerContainerFactory" class="org.sfw.amqp.rabbit.config.SimpleRabbitListenerContainerFactory">
        <property name="connectionFactory" ref="rabbitConnectionFactory"/>
        <property name="concurrentConsumers" value="3"/>
        <property name="maxConcurrentConsumers" value="10"/>
        <property name="prefetchCount" value="12"/>
    </bean>
    ```

2.  Finally, the listener bean is created as follows with a `CSMReceiver` class:

    ```java
    @Component
    public class CSMReceiver {
      @Autowired
      private SimpMessagingTemplate simpMessagingTemplate;

      @RabbitListener(queues = "AMQP_USER_ACTIVITY_QUEUE")
      public void handleMessage(UserActivityDTO payload) {
      simpMessagingTemplate.convertAndSend("/topic/actions", payload);
      }
    } 
    ```

    ### Tip

    您可以认出这里使用的`SimpMessagingTemplate`来将传入的消息有效负载转发到最终的 STOMP 客户端。

3.  在`cloudstreetmarket-websocket`中创建了一个新的`WebSocketConfig` bean。这个与我们在`cloudstreetmarket-api`的那个非常相似。

### 客户端

我们没有改变客户端(`cloudstreetmarket-webapp`)的很多东西，因为我们现在仍然专注于登陆页面(`home_community_activity.js`)。

主要的区别是 STOMP 端点现在以`/ws` 上下文路径为目标。WebSockets 在 5 秒钟的延迟后从`init()` 函数启动。此外，`SockJS`套接字和 STOMP 客户端现在集中在全局变量中(使用`Window`对象)以简化用户导航期间的 WebSockets 生命周期:

```java
var timer = $timeout( function(){ 
  window.socket = new SockJS('/ws/channels/users/broadcast');
  window.stompClient = Stomp.over(window.socket);
    window.socket.onclose = function() {
        window.stompClient.disconnect();
      };
  window.stompClient.connect({}, function(frame) {
    window.stompClient.subscribe('/topic/actions', function(message){
        var newActivity = $this.prepareActivity(JSON.parse(message.body));
        $this.addAsyncActivityToFeed(newActivity);
        $scope.$apply();
      });
    });
     $scope.$on(
      "$destroy",
        function( event ) {
          $timeout.cancel( timer );
          window.stompClient.disconnect();
          }
      );
                }, 5000);
```

## 它是如何工作的...

这种类型的基础设施以一种松散但可靠的方式将应用组件耦合在一起。

### 消息传递架构概述

在这个秘籍中，我们给了我们的应用一个 MoM。主要思想是尽可能地将流程从客户端请求生命周期中分离出来。

为了让我们的 REST API 专注于资源处理，一些业务逻辑显然是次要的，比如:

*   通知社区有新用户注册了帐户
*   通知社区用户已经执行了特定的交易
*   通知社区一个用户喜欢另一个用户的动作

我们决定创建一个新的专门处理 WebSockets 的 webapp。我们的 API 现在通过向 web 应用发送消息来与它通信。

消息有效负载是社区`Action`对象(来自`Action.java`超类)。从`cloudstreetmarket-api` web app 到`cloudstreetmarket-websocket` webapp，这些动作对象被序列化并包装在 AMQP 消息中。一旦发送出去，它们就堆积在一个单独的 RabbitMQ 队列中(`AMQP_USER_ACTIVITY`)。

发送方和接收方都是 AMQP 实现(`RabbitTemplate`和`RabbitListener`)。这个逻辑现在将以`websocket` web 应用能够承受的速度处理，而不会影响用户体验。当收到消息时(在`cloudstreetmarket-websocket`端)，消息有效负载作为 STOMP 消息被动态发送到 WebSocket 客户端。

这里的直接性能优势是有争议的(在本例中)。毕竟，我们已经用一个额外的消息层推迟了次要事件的发布。然而，设计清晰和业务组件分离的好处是无价的。

#### 可扩展的模型

我们已经谈了很多关于保持 web 应用无状态的好处。这就是我们到目前为止试图用 API 做的事情，我们对此感到自豪！

如果没有 HTTP 会话，我们很容易对`api` web 应用或`portal` web 应用上的流量激增做出反应。没有太多的麻烦，我们将能够在 Apache HTTP 代理上为 HTTP 连接设置一个带有`mod_proxy_balancer`的负载平衡器。

你可以在 Apache HTTP 文档中阅读更多关于这个的信息:[HTTP://httpd . Apache . org/docs/2.2/mod/mod _ proxy _ balancer . html](http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html)

![A scalable model](img/B4049_08_13.jpg)

对于 WebSocket web 应用，它在无状态下基本上是一样的。在 Apache HTTP 配置中，配置的`mod_proxy_wstunnel` 应该处理 WebSockets 上的负载平衡，并提供应用故障转移。

### AMQP 还是 JMS？

**高级** **消息队列协议** ( **AMQP** )定义了一个**线级**协议，保证发送者和消费者之间的互操作性。符合此协议的任何一方都可以创建和解释消息，从而与任何其他符合协议的组件进行互操作，而不管底层技术如何。

相比之下，JMS 是 Java 平台**企业版(EE)** 的一部分。随着 JSR-914 的到来，JMS 是 API 的标准，它定义了 API 应该如何创建、发送、接收和读取消息。JMS 不提供线级指导，也不保证各方之间的互操作性。

AMQP 控制消息的格式和这些消息经过的流程，而 JMS 控制边界(操作符)的技术实现。当我们在潜在的复杂环境中寻找通信一致性时，AMQP 似乎是 MoM 协议的一个好选择。

## 还有更多……

本节提供外部资源以扩展您对 AMQP 和事件发布方法的了解。

### pivotal 对 AMQP 的精彩介绍

如果你想更好地了解 AMQP 及其与 JMS 的差异，请查看 [spring.io](http://spring.io) 网站上的以下文章:

[https://spring.io/understanding/AMQP](https://spring.io/understanding/AMQP)

### 发布应用事件的更好方式

现在，我们没有实现一个合适的模式来发布事件。从下面的链接可以看到的文章来自于 [spring.io](http://spring.io) 博客。它介绍了使用 Spring 4.2+发布事件的最佳实践:

[https://spring . io/blog/2015/02/11/better-application-events-in-spring-framework-4-2](https://spring.io/blog/2015/02/11/better-application-events-in-spring-framework-4-2)

## 参见

*   **Load balancing WebSockets**: Read more about this topic in the following article by Arun Gupta (at Red Hat at the time):

    [http://blog . arungupta . me/load-balance-web sockets-Apache-httpd-tech tip 48](http://blog.arungupta.me/load-balance-websockets-apache-httpd-techtip48)

# 使用 Spring Session 和 Redis 保护消息

总结一下，到目前为止我们已经看到了如何向 StockJS 客户端广播 STOMP 消息，如何在外部多协议代理中堆叠消息，以及如何在 Spring 生态系统中与这个代理(RabbitMQ)交互。

## 准备就绪

这个方法是关于实现专用队列，而不是主题(广播)，以便用户可以接收与他们正在查看的特定内容相关的实时更新。它还演示了 SockJS 客户机如何将数据发送到它们的私有队列。

对于私有队列，我们必须保护消息和队列访问。我们打破了 API 使用 Spring Session 的无状态经验法则。这扩展了由`cloudstreetmarket-api`执行的认证，并在`cloudstreetmarket-websocket`中重用了 Spring 安全上下文。

## 怎么做……

### Apache HTTP 代理配置

因为`v8.2.x`分支引入了新的`cloudstreetmarket-websocket` web app，Apache HTTP 代理配置需要更新以完全支持我们的 WebSocket 实现。我们现在对`VirtualHost`的定义是:

```java
<VirtualHost cloudstreetmarket.com:80>
  ProxyPass        /portal http://localhost:8080/portal
  ProxyPassReverse /portal http://localhost:8080/portal
  ProxyPass        /api  	http://localhost:8080/api
  ProxyPassReverse /api  	http://localhost:8080/api
  ProxyPass        /ws  	http://localhost:8080/ws
  ProxyPassReverse /ws  	http://localhost:8080/ws
  RewriteEngine on
  RewriteCond %{HTTP:UPGRADE} ^WebSocket$ [NC]
  RewriteCond %{HTTP:CONNECTION} ^Upgrade$ [NC]
  RewriteRule .* ws://localhost:8080%{REQUEST_URI} [P]
  RedirectMatch ^/$ /portal/index
</VirtualHost>
```

### 重定向服务器安装

1.  If you are on a Linux-based machine, download the latest stable version (3+) at [http://redis.io/download](http://redis.io/download). The format of the archive to download is `tar.gz`. Follow the instructions on the page to install it (unpackage it, uncompress it, and build it with the make command).

    安装后，作为快速入门，请使用以下命令运行 Redis:

    ```java
    $ src/redis-server
    ```

2.  If you are on a Windows-based machine, we recommend this repository: [https://github.com/ServiceStack/redis-windows](https://github.com/ServiceStack/redis-windows). Follow the instructions on the `README.md` page. Running Microsoft's native port of Redis allows you to run Redis without any other third-party installations.

    要快速启动 Redis 服务器，请运行以下命令:

    ```java
    $ redis-server.exe redis.windows.conf
    ```

3.  When Redis is running, you should be able to see the following welcome screen:

    ![Redis server installation](img/B4049_08_14.jpg)

4.  Update your Tomcat configuration in Eclipse to use the local Tomcat installation. To do so, double-click on your current server (the **Servers** tab):

    ![Redis server installation](img/B4049_08_15.jpg)

5.  This should open the configuration panel as follows:

    ![Redis server installation](img/B4049_08_16.jpg)

    确保选中了**使用 Tomcat 安装**单选按钮。

    ### Tip

    如果面板变灰，再次右击你当前的服务器，然后点击**添加**，**删除**...从您的服务器中删除三个已部署的 web 应用，再次右键单击服务器，然后单击**发布**。

6.  Now, download the following jars:
    *   **jedis-2 . 5 . 2 . jar**:Java 客户端库小里兹
    *   commons-pool 2-2.2 . jar:Apache 公共对象池库

    可以分别从[http://central . maven . org/maven 2/redis/clients/jedis/2 . 5 . 2/jedis-2 . 5 . 2 . jar](http:// http://central.maven.org/maven2/redis/clients/jedis/2.5.2/jedis-2.5.2.jar)和[http://central . maven . org/maven 2/org/Apache/commons/commons-pool 2/2.2/commons-pool 2-2.2 . jar](http://central.maven.org/maven2/org/apache/commons/commons-pool2/2.2/commons-pool2-2.2.jar)下载

    您也可以在`chapter_8/libs`目录中找到这些 jar。

7.  在`chapter_8/libs`目录中，您还会找到**Tomcat-redis-session-manager-2.0-Tomcat-8 . jar**归档文件。将三个 jar`tomcat-redis-session-manager-2.0-tomcat-8.jar`、`commons-pool2-2.2.jar`和`jedis-2.5.2.jar`复制到 Eclipse 所引用的本地 Tomcat 安装的`lib`目录中。如果遵循了第 1 章、*企业 Spring 应用*的 [中的说明，这应该是`C:\tomcat8\lib or /home/usr/{system.username}/tomcat8/lib`。](1.html "Chapter 1\. Setup Routine for an Enterprise Spring Application")
8.  Now in your workspace, open the **context.xml** file of your **Server** project.

    ![Redis server installation](img/B4049_08_17.jpg)

9.  添加以下`Valve`配置:

    ```java
    <Valve asyncSupported="true" className="edu.zipcloud.catalina.session.RedisSessionHandlerValve"/>
    <Manager className="edu.zipcloud.catalina.session.RedisSessionManager"
          host="localhost" 
          port="6379" 
          database="0" 
          maxInactiveInterval="60"/>
    ```

### MySQL 服务器安装

在创建新的`cloudstreetmarket-websocket` web 应用的同时，我们还将数据库引擎从 HSQLDB 更改为 MySQL。这样做允许我们在`api`和`websocket`模块之间共享数据库。

1.  本节的第一步是从[http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)下载并安装 MySQL 社区服务器..下载适合您系统的通用版本。如果您使用的是 MS Windows，我们建议您安装安装程序。
2.  You can follow the installation instructions provided by the MySQL team at [http://dev.mysql.com/doc/refman/5.7/en/installing.html](http://dev.mysql.com/doc/refman/5.7/en/installing.html).

    我们现在将为模式用户和数据库名称定义一个公共配置。

3.  使用您选择的密码创建一个 root 用户。
4.  Create a technical user (with the administrator role) that the application will use. This user needs to be called `csm_tech` and needs to have the password `csmDB1$55`:

    ![MySQL server installation](img/B4049_08_18.jpg)

5.  Start the MySQL Client (the command line tool), as follows:
    *   在 MS Windows 上，启动 MySQL 服务器安装目录下的程序`mysql.exe`:`\MySQL Server 5.6\bin\mysql.exe`
    *   在 Linux 或 Mac OS 上，从终端调用`mysql`命令

    在这两个平台上，第一步是提供之前选择的 root 密码。

6.  使用 MySQL 工作台或 MySQL 客户端创建一个`csm`数据库:

    ```java
    mysql> CREATE DATABASE csm; 

    ```

7.  选择`csm`数据库作为当前数据库:

    ```java
    mysql> USE csm;

    ```

8.  从 Eclipse 启动本地 Tomcat 服务器。一旦启动，您可以再次关闭它；这一步只是让 Hibernate 生成模式。
9.  然后我们需要手动插入数据。为此，依次执行以下导入命令:

    ```java
    mysql> csm < <home-directory>\cloudstreetmarket-parent\cloudstreetmarket-core\src\main\resources\META-INF\db\currency_exchange.sql;
    mysql> csm < <home-directory>\cloudstreetmarket-parent\cloudstreetmarket-core\src\main\resources\META-INF\db\init.sql;
    mysql> csm < <home-directory>\cloudstreetmarket-parent\cloudstreetmarket-core\src\main\resources\META-INF\db\stocks.sql;
    mysql> csm < <home-directory>\cloudstreetmarket-parent\cloudstreetmarket-core\src\main\resources\META-INF\db\indices.sql;

    ```

### 应用级别的变化

1.  在 `cloudstreetmarket-api`和`cloudstreetmarket-websocket`中，以下过滤器被添加到`web.xml`文件中。该过滤器必须位于 Spring 安全链定义之前:

    ```java
    <filter>
      <filter-name>springSessionRepositoryFilter</filter-name>
      <filter-class>
      org.springframework.web.filter.DelegatingFilterProxy
      </filter-class>
      <async-supported>true</async-supported>
    </filter>
    <filter-mapping>
      <filter-name>springSessionRepositoryFilter</filter-name>
      <url-pattern>/*</url-pattern>
    </filter-mapping>
    ```

2.  几个 Maven 依赖项也被添加到了`cloudstreetmarket-api` :

    ```java
    <!-- Spring Session -->
    <dependency>
      <groupId>org.springframework.session</groupId>
      <artifactId>spring-session</artifactId>
      <version>1.0.2.RELEASE</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-pool2</artifactId>
      <version>2.2</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.session</groupId>
      <artifactId>spring-session-data-redis</artifactId>
      <version>1.0.2.RELEASE</version>
    </dependency>
    <!-- Spring Security -->
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-messaging</artifactId>
      <version>4.0.2.RELEASE</version>
    </dependency>
      <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.4</version>
      </dependency>
    ```

3.  在 `cloudstreetmarket-api`中，再次更新了`security-config.xml`以反映 Spring 安全过滤器链中的以下变化:

    ```java
    <security:http create-session="ifRequired" 
      authentication-manager-ref="authenticationManager" entry-point-ref="authenticationEntryPoint">
     <security:custom-filter ref="basicAuthenticationFilter" after="BASIC_AUTH_FILTER" />
       <security:csrf disabled="true"/>
     <security:intercept-url pattern="/oauth2/**" access="permitAll"/>
     <security:intercept-url pattern="/basic.html" access="hasRole('ROLE_BASIC')"/>
       <security:intercept-url pattern="/**" access="permitAll"/>
     <security:session-management session-authentication-strategy-ref="sas"/>
    </security:http>
    <bean id="sas" class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" />
    ```

4.  同样，这个`security-config.xml`文件以及`cloudstreetmarket-websocket`中的`security-config.xml`文件现在定义了三个额外的 bean:

    ```java
    <bean class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:port="6379"/>
    <bean class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"/>
    <bean class="edu.zipcloud.cloudstreetmarket.core.util.RootPath CookieHttpSessionStrategy"/>
    ```

5.  注意和 `cloudstreetmarket-webapp`不要创建会话。我们希望仅在`cloudstreetmarket-api`中创建会话。我们通过向`cloudstreetmarket-webapp`中的`web.xml`文件添加以下配置实现了这一点:

    ```java
    <session-config>
        <session-timeout>1</session-timeout>
        <cookie-config>
            <max-age>0</max-age>
        </cookie-config>
    </session-config>
    ```

6.  关于 Spring 安全，`cloudstreetmarket-websocket`有如下配置:

    ```java
    <bean id="securityContextPersistenceFilter" class="org.springframework.security.web.context.SecurityContextPersistenceFilter"/>
    <security:http create-session="never" 
    authentication-manager-ref="authenticationManager" entry-point-ref="authenticationEntryPoint">
      <security:custom-filter ref="securityContextPersistenceFilter" before="FORM_LOGIN_FILTER" />
      <security:csrf disabled="true"/>
      <security:intercept-url pattern="/channels/private/**" access="hasRole('OAUTH2')"/>
      <security:headers>
          <security:frame-options policy="SAMEORIGIN" />
      </security:headers>
    </security:http>
    <security:global-method-security secured-annotations="enabled" pre-post-annotations="enabled" authentication-manager-ref="authenticationManager"/>
    ```

7.  Two configuration-beans in `cloudstreetmarket-websocket` complete the XML configuration:

    edu . zip cloud . cloudstreetmarket . ws . config 中的 WebSocketConfig bean 定义如下:

    ```java
    @EnableScheduling
    @EnableAsync
    @EnableRabbit
    @Configuration
    @EnableWebSocketMessageBroker
    public class WebSocketConfig extends   AbstractSessionWebSocketMessageBrokerConfigurer<Expiring Session> {
      @Override
      protected void configureStompEndpoints(StompEndpointRegistry registry) {
              registry.addEndpoint("/channels/users/broadcast")
              .setAllowedOrigins(protocol.concat(realmName))
              .withSockJS()
              .setClientLibraryUrl( Constants.SOCKJS_CLIENT_LIB);

            registry.addEndpoint("/channels/private")
              .setAllowedOrigins(protocol.concat(realmName))
              .withSockJS()
              .setClientLibraryUrl( Constants.SOCKJS_CLIENT_LIB);
      }

      @Override
      public void configureMessageBroker(final MessageBrokerRegistry registry) {
            registry.enableStompBrokerRelay("/topic", "/queue");
            registry.setApplicationDestinationPrefixes("/app");
      }

      @Override
      public void configureClientInboundChannel(ChannelRegistration registration) {
            registration.taskExecutor() corePoolSize(Runtime.getRuntime().availableProcessors() *4);
      }

      @Override
      //Increase number of threads for slow clients
      public void configureClientOutboundChannel( 
         ChannelRegistration registration) {
            registration.taskExecutor().corePoolSize( Runtime.getRuntime().availableProcessors() *4);
      }
      @Override
      public void configureWebSocketTransport(  
        WebSocketTransportRegistration registration) {
            registration.setSendTimeLimit(15*1000) 
              .setSendBufferSizeLimit(512*1024); 
      }
    }
    ```

    `edu.zipcloud.cloudstreetmarket.ws.config` 中的`WebSocketSecurityConfig` bean 定义如下:

    ```java
    @Configuration
    public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {
        @Override
        protected void configureInbound( MessageSecurityMetadataSourceRegistry messages) {
        messages.simpMessageDestMatchers("/topic/actions", "/queue/*", "/app/queue/*").permitAll();
        }
        @Override
        protected boolean sameOriginDisabled() {
        return true;
        }
    }
    ```

8.  `ActivityFeedWSController`类已经被复制到`cloudstreetmarket-websocket`来广播用户活动。它仍然不需要任何特定的角色或认证:

    ```java
    @RestController
    public class ActivityFeedWSController extends CloudstreetWebSocketWCI{

        @MessageMapping("/channels/users/broadcast")
        @SendTo("/topic/actions")
        public UserActivityDTO handle(UserActivityDTO message) throws Exception {
            return message;
        }

        @RequestMapping(value="/channels/users/broadcast/info", produces={"application/json"})
        @ResponseBody
        public String info(HttpServletRequest request) {
          return "v0";
        }
    }
    ```

9.  一个额外控制器将消息(最新股票值)发送到私有队列:

    ```java
    @RestController
    public class StockProductWSController extends CloudstreetWebSocketWCI<StockProduct>{

      @Autowired
      private StockProductServiceOffline stockProductService;

      @MessageMapping("/queue/CSM_QUEUE_{queueId}")
      @SendTo("/queue/CSM_QUEUE_{queueId}")
      @PreAuthorize("hasRole('OAUTH2')")
      public List<StockProduct> sendContent(@Payload List<String> tickers, @DestinationVariable("queueId") String queueId) throws Exception {
          String username = extractUserFromQueueId(queueId);
          if(!getPrincipal().getUsername().equals(username)){
            throw new IllegalAccessError("/queue/CSM_QUEUE_"+queueId);
          }
          return stockProductService.gather(username,      tickers.toArray(new String[tickers.size()]));
      }

      @RequestMapping(value=PRIVATE_STOCKS_ENDPOINT+"/info", produces={"application/xml", "application/json"})
      @ResponseBody
      @PreAuthorize("hasRole('OAUTH2')")
      public String info(HttpServletRequest request) {
          return "v0";
      }

      private static String extractUserFromQueueId(String token){
            Pattern p = Pattern.compile("_[0-9]+$");
            Matcher m = p.matcher(token);
            String sessionNumber = m.find() ? m.group() : "";
            return token.replaceAll(sessionNumber, "");
    	}
    }
    ```

10.  在客户端，从股票搜索屏幕(股票结果列表)启动新的 WebSockets。特别是在`stock_search.js`和`stock_search_by_market.js`中，为了定期请求显示给认证用户的结果集的数据更新，添加了以下块:

    ```java
    if(httpAuth.isUserAuthenticated()){
      window.socket = new SockJS('/ws/channels/private');
      window.stompClient = Stomp.over($scope.socket);
      var queueId = httpAuth.generatedQueueId();

      window.socket.onclose = function() {
        window.stompClient.disconnect();
      };
      window.stompClient.connect({}, function(frame) {
        var intervalPromise = $interval(function() {
          window.stompClient.send( '/app/queue/CSM_QUEUE_'+queueId, {}, JSON.stringify($scope.tickers)); 
        }, 5000);

        $scope.$on(
            "$destroy",
            function( event ) {
              $interval.cancel(intervalPromise);
              window.stompClient.disconnect();
            }
        );

      window.stompClient.subscribe('/queue/CSM_QUEUE_'+queueId, function(message){
        var freshStocks = JSON.parse(message.body);
        $scope.stocks.forEach(function(existingStock) {
          //Here we update the currently displayed stocks
        });

        $scope.$apply();
        dynStockSearchService.fadeOutAnim(); //CSS animation   
          //(green/red backgrounds…)
         });
        });
    };
    ```

`httpAuth.generatedQueueId()`函数根据认证的用户名生成一个随机队列名(更多细节见`http_authorized.js`)。

### rabbitq 配置

1.  打开 rabbit MQ web 控制台，选择**管理**选项卡，然后选择**策略**菜单(也可以从`http://localhost:15672/#/policies` URL 访问)。
2.  Add the following policy:

    ![RabbitMQ configuration](img/B4049_08_19.jpg)

这个策略(名为`PRIVATE`)适用于所有自动生成的匹配模式`CSM_QUEUE_*`的队列，自动过期 24 小时。

### 结果

1.  让我们看一看...在启动 Tomcat 服务器之前，请确保:
    *   MySQL 正在运行加载的数据
    *   Redis 服务器正在运行
    *   RabbitMQ 正在运行
    *   Apache HTTP 已重新启动/重新加载
2.  当所有这些信号都是绿色时，启动 Tomcat 服务器。
3.  Log in to the application with your Yahoo! account, register a new user, and navigate to the screen: **Prices and markets** | **Search by markets**. If you target a market that is potentially open at your time, you should be able to notice real-time updates on the result list:

    ![The results](img/B4049_08_20.jpg)

## 它是如何工作的...

### 重定向服务器

Redis 是一个开放的源代码内存数据结构存储。日复一日，它作为 NoSQL 数据库和键值存储越来越受欢迎。

它能够存储具有可选到期时间的密钥，并具有非常高的可用性(通过其卓越的集群),这使它成为会话管理器实现的非常可靠的底层技术。这正是我们通过春季会议对它的利用。

### 春季会议

Spring Session 是一个相对较新的 Spring 项目，但它意味着成长并在 Spring 生态系统中占据相当大的空间，尤其是在最近的微服务和物联网趋势下。该项目由 Pivotal inc .的 Rob Winch 管理，如前所述，Spring Session 提供了一个 API 来管理来自不同 Spring 组件的用户会话。

Spring Session 最有趣和最显著的特性是它能够与容器(Apache Tomcat)集成，以提供自定义的`HttpSession`实现。

#### SessionRepositoryFilter

为了利用定制的`HttpSession`实现，Spring Session 用定制的包装器(`SessionRepositoryRequestWrapper`)完全替换了`HttpServletRequest`。这个操作在`SessionRepositoryFilter`内部执行，T3 是需要在`web.xml`中配置的 servlet 过滤器，用来拦截请求流(Spring MVC 之前)。

为了让完成它的工作，`SessionRepositoryFilter`必须有一个`HttpSession`实现。在某个时候，我们注册了`RedisHttpSessionConfiguration`豆。这个 bean 定义了几个其他 bean 的，其中有一个`sessionRepository`，它是一个`RedisOperationsSessionRepository`。

看看`SessionRepositoryFilter`对于跨越应用将所有已执行的会话操作连接到将执行这些操作的实际引擎实现是多么重要。

##### 重新连接工厂

一个 `RedisConnectionFactory`实现是必要的，以便产生到 Redis 的合适连接。选择一个`RedisConnectionFactory`实现，我们一直跟随 Spring 团队的选择，看起来是`JedisConnectionFactory`。这个`RedisConnectionFactory`依赖于 Jedis(一个轻量级 Redis Java 客户端)。[https://github.com/xetorthio/jedis](https://github.com/xetorthio/jedis)。

#### CookieHttpSessionStrategy

我们已经注册了一个`HttpSessionStrategy`实现:`RootPathCookieHttpSessionStrategy`。这个类是 Spring `CookieHttpSessionStrategy`的定制版本(在我们的代码库中)。

因为我们想将 cookie 从`cloudstreetmarket-api`传递到`cloudstreetmarket-websocket`，cookie 路径(cookie 的属性)需要设置为根路径(而不是 servlet 上下文路径)。Spring Session 1.1+应该提供一个可配置的路径特性。

[https://github . com/spring-projects/spring-session/issues/155](https://github.com/spring-projects/spring-session/issues/155)

现在，我们的`RootPathCookieHttpSessionStrategy`(基本上是`CookieHttpSessionStrategy`)生成并期待具有**会话**名称的 cookies:

![CookieHttpSessionStrategy](img/B4049_08_21.jpg)

目前，只有`cloudstreetmarket-api`产生这样的 cookie(其他两个 web 应用的 cookie 生成能力受到限制，因此它们不会扰乱我们的会话)。

#### 春季资料整理与春季作业阶段资料整理

还记得我们的好朋友春天数据 JPA 吗？现在，Spring Data Redis 遵循类似的目的，但是对于 Redis NoSQL 键值存储:

|  | *"Spring Data Redis(框架通过 Spring 出色的基础设施支持，消除了与存储交互所需的冗余任务和 boiler plate 代码，从而简化了编写使用 Redis 键值存储的 Spring 应用的工作。"* |  |
|  | - *SpringData Redis 参考* |

Spring 会话数据 Redis 是专门实现 Spring 数据 Redis 的 Spring 模块，用于 Spring 会话管理。

### Tomcat 的 Redis 会话管理器

Apache Tomcat 本身提供了集群和会话复制特性。但是，这些功能依赖于负载平衡器的粘性会话。粘性会话对可伸缩性有利也有弊。作为缺点，我们可以记住，当服务器停机时，会话可能会丢失。此外，当我们实际上需要响应流量激增时，会话的粘性会导致缓慢的加载时间。

我们还使用了 James Coleman 的开源项目，该项目允许 Tomcat 服务器在创建会话时立即将非粘性会话存储在 Redis 中，以供其他 Tomcat 实例使用。可以通过以下地址联系这个开源项目:

[https://github . com/jcleman/Tomcat-redis 会话管理器](https://github.com/jcoleman/tomcat-redis-session-manager)

然而，这个项目并不正式支持 Tomcat 8。因此，另一个分支在 Tomcat 发布过程中走得更远，更接近 Tomcat 8 的需求:

[https://github . com/rmohr/Tomcat 重定向会话管理器](https://github.com/rmohr/tomcat-redis-session-manager)

我们分叉了这个存储库，并在 https://github . com/Alex-bret et/Tomcat-redis-session-manager 中提供了对 Tomcat 8 的改编。

复制到`tomcat/lib`的 `tomcat-redis-session-manager-2.0-tomcat-8.jar`就来自这个资源库。

### 注意

Tomcat 8 还是最近的，外围工具需要时间来跟随发布。我们不提供`tomcat-redis-session-manager-2.0-tomcat-8.jar` 供生产使用。

### 在 Redis 中查看/刷新会话

在 Redis 的主安装目录中，可以找到一个命令行工具(`Cli`)的可执行文件。该可执行文件可以通过以下命令启动:

```java
$ src/redis-cli

```

或者:

```java
$ redis-cli.exe

```

该可执行文件提供对 Redis 控制台的访问。例如，从那里，`KEY *`命令列出了所有活动会话:

```java
127.0.0.1:6379> keys *
1) "spring:session:sessions:4fc39ce3-63b3-4e17-b1c4-5e1ed96fb021"
2) "spring:session:expirations:1418772300000"
```

`FLUSHALL`命令清除所有活动会话:

```java
redis 127.0.0.1:6379> FLUSHALL
OK
```

### Tip

了解 Redis 客户端语言及其在线教程，可在 [http://try.redis.io](http://try.redis.io) 访问。

### 安全性 ContextPersistenceFilter

我们在`cloudstreetmarket-websocket` Spring 安全过滤器链中使用了这个过滤器。它的作用包括将外部 Spring 安全上下文注入到来自已配置的`SecurityContextRepository`的`SecurityContextHolder`中:

```java
<bean id="securityContextPersistenceFilter" class="org.sfw.security.web.context.SecurityContextPersistence Filter">
    <constructor-arg name="repo" ref="httpSessionSecurityContextRepo" />
</bean>

<bean id="httpSessionSecurityContextRepo" class='org.sfw.security.web.context.HttpSessionSecurityContext Repository'>operty name='allowSessionCreation' value='false' />
</bean> 
```

一旦过滤器链完成，这个过滤器与`SecurityContextRepository`交互以保持上下文。结合 Spring Session，当您需要重用已经在另一个组件(在我们的例子中是另一个 web 应用)中执行的认证时，这个过滤器非常有用。

在这之后，我们还能够声明一个`global-method-security`元素(Spring 安全名称空间的)，允许我们在`@MessageMapping`注释方法(我们的消息处理方法)中使用`@PreAuthorize`注释:

```java
<global-method-security secured-annotations="enabled" pre-post-annotations="enabled" />
```

### 抽象 session websockmessagebroken config

这个是个很长的标题。我们使用了这个抽象类来赋予我们的`WebSocketConfig`这样的能力:

*   确保会话在传入的 web 套接字消息上保持活动
*   确保在会话终止时销毁 WebSocket 会话

### abstractsecuritywebsxmlsocket messagebroken config er

以一种类似的方式，这个抽象类为我们的`WebSocketSecurityConfig` bean 提供授权能力。多亏了它，`WebSocketSecurityConfig` bean 现在可以控制传入消息的目的地。

## 还有更多……

### 春季会议

再一次推荐 Spring Session 上的 Spring 参考文档，做得非常好。请查看:

[http://docs . spring . io/spring-session/docs/current/reference/html 5](http://docs.spring.io/spring-session/docs/current/reference/html5)

### Apache HTTP 代理额外配置

添加到`httpd.conf`中的几行是为了在 WebSocket 握手期间将 WebSocket 方案重写为`ws`。不这样做将导致 SockJS 退回到它的 **XHR** 选项(一个 WebSocket 仿真)。

### 春季数据重读

此外，我们建议您阅读更多关于 Spring Data Redis 项目的信息(在其参考文档中):

[http://docs . spring . io/spring-data/data-redis/docs/current/reference/html](http://docs.spring.io/spring-data/data-redis/docs/current/reference/html)

## 参见

*   **Deep-dive into Spring WebSockets** by Sergi Almar: This is the presentation that occurred at SpringOne2GX 2014:

    [http://www . slide share . net/sergialmar/web sockets-with-spring-4](http://www.slideshare.net/sergialmar/websockets-with-spring-4)

*   **Spring-websocket-portfolio, showcase application**: We must also highlight the Spring WebSocket showcase application from Rossen Stoyanchev:

    [https://github.com/rstoyanchev/spring-websocket-portfolio](https://github.com/rstoyanchev/spring-websocket-portfolio)