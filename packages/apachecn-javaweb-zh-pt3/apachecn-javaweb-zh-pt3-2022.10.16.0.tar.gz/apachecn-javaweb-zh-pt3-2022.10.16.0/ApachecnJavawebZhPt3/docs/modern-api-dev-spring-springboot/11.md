# 十一、基于 gRPC 的 API 开发与测试

在本章中，你将学习如何实现基于 gRPC 的 API。您将学习如何编写 gRPC 服务器和客户机，以及如何编写基于 gRPC 的 API。在本章的后半部分，将向您介绍微服务，并了解它们如何帮助您设计现代可扩展架构。在这里，您将经历两个服务的实现——gRPC 服务器和 gRPC 客户机。基于 gRPC 的 API 在基于微服务的系统中的服务间通信中更受欢迎和首选。因此，gRPC 开发技能是 API 领域的一个重要话题。

您将在本章中探索以下主题:

*   编写 API 接口
*   开发 gRPC 服务器
*   处理错误
*   开发 gRPC 客户端
*   学习微服务概念

完成本章后，您将具备以下技能——gRPC 服务器和客户端开发、基于 gRPC 的 API 测试自动化和微服务概念。

# 技术要求

本章涉及 gRPC 的理论。但是，对于基于 gRPC 的 web 服务的开发和测试，您需要以下内容:

*   任何 Java IDE，如 NetBeans、IntelliJ 或 Eclipse
*   Java 开发工具包(JDK) 15
*   一个互联网连接来克隆代码并下载依赖项和升级
*   Postman/cURL(用于 API 测试)

所以让我们开始吧！

请访问以下链接查看代码:[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter11)

# 编写 API 接口

在本节中，我们将使用协议缓冲区(Protobuf)为支付服务编写 API 接口。如果您还记得，这是您尚未实现示例电子商务应用的部分。

在编写 API 接口之前，我们先设置一下 Gradle 项目。

## 设置项目

本章的代码将包含`Chapter11`目录下的三个项目——API、服务器和客户端:

*   **API** :这是一个库项目，包含`.proto`文件及其生成的打包在 jar 文件中的 Java 类。您将在本地发布`library payment-gateway-api-0.0.1.jar`文件。然后，这个库将在服务器和客户端项目中使用。
*   **服务器**:这个项目包含 gRPC 服务器，它将实现 gRPC 服务并为 gRPC 请求提供服务。
*   **Client** :这个项目包含了将调用 gRPC 服务器的 gRPC 客户端。您将实现一个 REST 调用，该调用将在内部调用 gRPC 服务器来服务 HTTP 请求。

让我们首先创建服务器和客户机项目。

### 创建 gRPC 服务器和客户端项目

您可以使用来自一个克隆的 Git 库(https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot)的`Chapter 11`代码，或者您可以使用*Spring Initializer*(https://start.spring.io/)为服务器和客户端从头开始创建新的 Spring 项目，并具有以下选项(您将单独创建一个 gRPC `api`库项目):

*   项目→梯度项目
*   语言→ Java
*   Spring Boot → 2.4.4(如果没有，首选版本应该是 2.4+；以后可以在`build.gradle`文件中手动修改。
*   Project metadata:

    a.组:`com.packt.modern.api`

    b.神器:`chapter11`

    c.名称:`chapter11`

    d.描述:`Chapter 11 code of book Modern API Development with Spring and Spring Boot`

    e.包名:`com.packt.modern.api`

*   包装→罐子
*   Java → 15(后面可以在`build.gradle`文件里改成另一个版本，比如 16/17，如下代码块所示):

    ```java
    // update following build.gradle file
    sourceCompatibility = JavaVersion.VERSION_15
    // or for Java 16
    // sourceCompatibility = JavaVersion.VERSION_16
    // or for Java 17
    // sourceCompatibility = JavaVersion.VERSION_17
    ```

*   依赖性→ `org.springframework.boot:spring-boot-starter-web`

然后，你可以点击**生成**并下载项目。下载的项目可用于创建服务器和客户端。我们已经在 Git 存储库中的`Chapter11`目录下创建了单独的服务器和客户端项目，并复制了下载的压缩项目的摘录。

您可以稍后配置服务器和客户端项目。让我们首先创建 gRPC API 库项目。

### 创建 gRPC API 库项目

在`Chapter11`目录下创建一个新的目录`api`。然后，使用以下命令使用 Gradle 创建一个新的 Gradle 项目。它会询问一些选项。您应该选择下面代码块中突出显示的选项:

```java
$ mkdir api
$ cd api
(you can also use gradlew from other chapter's code)
$ ../server/gradlew init
Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4] 3
Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
Enter selection (default: Java) [1..6] 3
Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2] 1
Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit 4) [1..4] 4
Project name (default: demo): api
Source package (default: demo): com.packt.modern.api
BUILD SUCCESSFUL
2 actionable tasks: 2 executed
```

该项目由 Gradle 启动。接下来，您将配置`api`项目。

### 配置 gRPC API 库项目

作为关键步骤，您将在这一小节中配置插件部分、Protobuf 插件和 Maven 发布插件。让我们这样做:

1.  修改项目根目录

    ```java
    rootProject.name = 'payment-gateway-api'
    ```

    中的`settings.gradle`
2.  Next, you'll modify the `api/lib/build.gradle` file. You'll add the Protobuf and Maven Publish Gradle plugins. You'll also replace the `java-library` plugin with `java`, as shown next:

    ```java
    plugins {
        id 'java'
        id 'maven-publish'
        id "com.google.protobuf" version "0.8.15"
    }
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter11/api/lib/build.gradle

    Maven Publish 插件将用于将生成的`Jar`文件发布到本地 Maven 存储库中。

3.  在`build.gradle`中添加`group`名称、`version`和`source`兼容性，如下面的代码块所示。Maven Publish 插件将使用组和版本来命名发布的工件:

    ```java
    group = 'com.packt.modern.api'
    version = '0.0.1'
    sourceCompatibility = JavaVersion.VERSION_15
    ```

4.  接下来，添加 Protobuf 和 gRPC 所需的依赖项(检查突出显示的部分):

    ```java
    def grpcVersion = '1.37.0'
    dependencies {
        compile "io.grpc:grpc-protobuf:${grpcVersion}"
        compile "io.grpc:grpc-stub:${grpcVersion}"
        compile "io.grpc:grpc-netty:${grpcVersion}"
        compile 'javax.annotation:javax.annotation-
     api:1.3.2'
        testImplementation 'org.junit.jupiter:junit-
                            jupiter-api:5.6.2'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-
                         engine'
    }
    ```

5.  Next, let's configure the Protobuf Gradle plugin. This uses the command-line compiler `protoc`. It searches in the system path by default. However, you can add a Protobuf compiler artifact to the plugin, which will make the build file self-sufficient as far as the gRPC compile task is concerned. Let's configure it as shown in the following code block by adding a `protobuf` section to the `build.gradle` file:

    ```java
    // protobuf plugin configuration
    protobuf {
        generatedFilesBaseDir = "$projectDir/src"
        protoc {
            artifact = "com.google.protobuf:protoc:3.15.8"
        }
        plugins {
            grpc {
                artifact = "io.grpc:protoc-gen-grpc-
     java:1.36.1"
            }
        }
        generateProtoTasks {
            all()*.plugins {
                grpc {}
            }
        }
    }
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter11/api/lib/build.gradle

    这里，生成的文件将根据为`generatedFielsBaseDir`设置的值存储在`src`文件夹中。您还将配置 Protobuf 编译器(`protoc`)及其 Java 插件(`protoc-gen-grpc-java`)所使用的工件，它将基于`.proto`文件生成 Java 代码。

    当您第一次运行命令`gradlew build`时，Gradle 会下载基于操作系统的`protoc`和`protoc-gen-grpc-java`可执行文件，如下面的代码块所示:

    ```java
    > :generateProto > Resolve dependencies of :protobufToolsLocator_grpc > protoc-3.15.7-windows-x86_64.exe > 1.5 MiB/3.5 MiB downloaded
    > :generateProto > Resolve dependencies of :protobufToolsLocator_grpc > protoc-gen-grpc-java-1.36.1-windows-x86_64.exe > 662.7 KiB/1.5 MiB downloaded
    ```

6.  Protobuf Gradle 插件与迄今为止共享的配置一起工作。当您从命令行运行`build`命令时，它可以工作。但是，如果不在`build.gradle`文件中添加下面的代码块来添加`sourceSets`中生成的源文件，IDE 可能会给出一个编译错误:

    ```java
    sourceSets {
        main {
            proto {
                // In addition to the default 
                // "src/main/proto"
                srcDir "src/main/grpc"
                srcDir "src/main/java"
            }
        }
    }
    ```

7.  Protobuf 编译器及其 Java 插件生成的文件将存储在项目源目录中。因此，您需要添加以下配置，它将在执行 Gradle clean 任务时清理生成的文件:

    ```java
    task cleanProtoGen {
        doFirst {
            delete('src/main/grpc')
            delete('src/main/java')
        }
    }
    clean.dependsOn cleanProtoGen
    ```

8.  最后，您将添加以下块来配置 Maven 发布插件:

    ```java
    publishing {
        publications {
            mavenJava(MavenPublication) {
                artifactId = 'payment-gateway-api'
                from components.java
            }
        }
    }
    ```

您已经完成了`api`项目的配置。在我们继续在`.proto`文件中编写 gRPC 服务的契约之前，让我们在下一小节中了解一下 Protobuf Gradle 插件的源代码和为 Protobuf 文件生成的代码的默认位置。您可以根据项目要求使用它来调整位置。

### 源文件和生成文件的位置

您将按照上一小节中定义的配置使用源文件和生成文件的位置。但是，该插件允许您修改这些位置，如以下段落所示。

Protobuf 文件的`sourceSet`(`.proto`代码文件)的默认位置是`src/$sourceSetName/proto` ( `src/main/proto`)。您可以像处理 Java 源文件一样，将其他位置添加到 Protobuf 文件的`sourceSet`中，如以下配置所示:

```java
sourceSets {
  main {
    java {
      ...
    }
    proto {
      // 'src/main/proto' plus 
      // You can add multiple location like next line
      srcDir 'src/main/protobuf'
    }
  }
  test {
    proto {
      // 'src/test/proto' plus
      srcDir 'src/test/protobuf'
    }
  }
}
```

这里，您已经添加了 proto buf 文件的额外源代码和测试代码位置。除了缺省位置之外，Protobuf 编译器和 Java 代码生成器还会检查这两个位置。

接下来让我们看看如何定制生成文件的默认位置。

**生成的 Java 文件**的默认位置是使用`$generatedFilesBaseDir/$sourceSet/$builtinPluginName`形成的。这里，每个变量包含以下值:

*   `$generatedFilesBaseDir`设置为`$buildDir/generated/source/proto`。`$buildDir`指向项目根目录中的构建目录。您可以使用以下配置进行更改:

    ```java
    protobuf {
      …
      generatedFilesBaseDir = "$projectDir/src/generated"
      …
    }
    ```

*   将`$sourceSet`点设置为`main`。
*   默认情况下，`$builtinPluginName`的值为`grpc`或`java`。您可以通过以下命令更改这些值:

    ```java
    protobuf {
      … 
      generateProtoTasks {
        all()*.plugins {
          grpc {
            // generated files would be copied to
            // "$generatedFilesBaseDir/ 
            // $sourceSet/grpcjava"
            outputSubDir = 'grpcjava'
          }
        }
      }
    }
    ```

这就是你如何改变生成文件的位置。然而，我们将坚持使用前一小节中配置的位置。

现在，`api`项目设置已经完成。我们现在可以在下一小节中使用协议缓冲区编写服务定义了。您还没有为我们的示例电子商务应用实现支付功能。这是因为它需要与 Stripe 或 Paypal 等支付网关服务集成。因此，在下一节中，您将使用 gRPC 编写示例支付网关服务。

## 编写支付网关功能

在编写支付网关服务定义之前，让我们先通俗易懂地了解一下支付网关系统的基本功能。

支付网关提供了一种从客户处获取并向在线卖家转移支付的方式，然后向客户返回接受/拒绝作为响应。在这个操作过程中，它执行各种其他任务，例如验证、安全、加密以及与所有参与者的通信。

以下是参与此交易的参与者:

*   **支付网关**:允许处理在线支付并与所有其他参与者协调的网络界面。这与物理**销售点** ( **POS** )终端非常相似。
*   **商家**:商家是网上卖家或服务商，如亚马逊、优步、Airbnb 等。
*   **顾客**:这是你，顾客，进行产品或服务的购买/支付交易，使用信用卡/借记卡、数字钱包或网上银行。
*   **发卡行**:提供网上转账功能的一方，如 Visa/Master/Amex 卡、Paypal/Stripe 或传统银行。
*   **Acquirer or Acquiring Bank**: The institution that holds the merchant account of the merchant. It passes the transaction to the issuing bank to receive payment.

    您将创建两个 gRPC 服务—`ChargeService`和`SourceService`,作为支付网关服务的一部分。不要与 web 服务混淆，它是一个可执行/可部署的工件。`ChargeService`和`SourceService`是协议缓冲区**接口定义语言** ( **IDL** )文件的服务组件的一部分，这个和我们在上一章`EmployeeService`例子中了解到的一样(第十章*gRPC 基础*的*协议缓冲区*部分)。这两种服务都是受 Stripe 公共 REST APIs 的启发。

在开始创建基于 gRPC 的支付网关服务的服务组件之前，让我们先了解一下交易流。

### 在线支付工作流程步骤

当发生在线交易时，执行以下步骤:

1.  首先，客户应该在开始支付之前创建一个支付来源(读取方法)。如果没有，则客户创建一个源，如卡的详细信息。
2.  通过根据付款来源创建费用来启动付款(读取方法)。
3.  The payment gateway performs all the necessary validation and verification steps and then allows the charge to be captured. These steps trigger the fund transfer from the issuing bank to the merchant account.

    您可以观察到这个工作流中涉及到两个对象(资源)(也称为源和费用)。因此，您将围绕这两个对象编写两个服务。支付网关执行各种其他功能，如争议、退款和支出。然而，在这一章中，您将只实现两个服务，收费和来源。

    ### 编写支付网关服务定义

    编写一个基于缓冲区的协议 IDL 与您为 REST APIs 定义 OpenAPI 规范的方式非常相似。在 REST 中，您定义模型和 API 端点，而在 gRPC 中，您定义包装在服务中的消息和 RPC 过程。让我们按照以下步骤编写我们的支付网关服务 IDL:

    *   首先，让我们在`api`项目根目录下的`api/lib/src/main/proto`目录中创建一个新文件`PaymentGatewayService.proto`。
    *   创建新文件后，您可以添加元数据，如下面的代码块所示:

        ```java
        syntax = "proto3";                     // 1
        package com.packtpub.v1;               // 2
        option java_package = "com.packt.modern.api.grpc.v1"; 
        // 3
        option java_multiple_files = true;     // 4
        ```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto

*   这里，*第一行*通过使用`syntax`说明符告诉编译器使用协议缓冲区的版本 3。如果不指定，编译器将使用版本 2 的协议缓冲区。
*   *第 2 行*使用可选的`package`说明符将名称空间附加到消息类型上。这可以防止消息类型之间的名称冲突。*我们必须用一个允许你创建向后兼容的 API 新版本的软件包版本对其进行后缀*。
*   *第 3 行*使用了`java_package`–`option`说明符。它的值将在生成的 Java 文件中作为 Java 包使用。如果不使用这个`option`说明符并声明`package`说明符，那么`package`的值将被用作生成的 Java 文件中的 Java 包。
*   *第 4 行*声明了`java_multiple_files`–`option`说明符，这是一个布尔选项。默认设置为`false`。如果设置为`true`，那么它将为每个顶级消息类型、枚举(`enum`)和服务生成单独的 Java 文件。

接下来，让我们添加`ChargeService`服务，它包含由`rpc`表示的收费功能所需的操作。创建收费对象是为了给卡、银行账户或数字钱包收费。让我们将收费服务添加到 Protobuf ( `.proto`)文件中:

```java
service ChargeService {
  rpc Create(CreateChargeReq) returns (
 CreateChargeReq.Response);
  rpc Retrieve(ChargeId) returns (ChargeId.Response);
  rpc Update(UpdateChargeReq) returns (
 UpdateChargeReq.Response);
  rpc Capture(CaptureChargeReq) returns 
                     (CaptureChargeReq.Response);
  rpc RetrieveAll(CustomerId) returns (
 CustomerId.Response);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto

`ChargeService`中的每个程序将执行以下操作:

*   **创建**:这个过程创建一个新的`Charge`对象。
*   **检索**:该程序根据先前创建的给定费用 ID 检索`Charge`对象。
*   **更新**:该程序通过设置传递的参数值，更新由给定费用 ID 标识的`Charge`对象。任何未提供的参数将保持不变。
*   **Capture** :这个过程捕获一个现有的、未捕获的费用的支付。这是付款工作流程的一个步骤，您首先创建一项费用，并将捕获选项设置为`false`。未捕获的付款在创建后正好 7 天到期。如果在该时间点之前没有捕获它们，它们将被标记为已退款，并且不再允许捕获。
*   **RetrieveAll**: This procedure returns the list of charges that belong to the given customer ID.

    空请求或响应类型

    您可以将`google.protobuf.Empty`用于 void/empty 请求和响应类型。这可以用在`.proto`文件中。您只需在定义任何消息/服务之前放置下面的`import`语句:

    `import "google/protobuf/timestamp.proto";`。

    然后，您可以如下所示使用它:

    `rpc delete(SourceId) returns (google.protobuf.Empty);`。

1.  The amount is charged on a source that could be a card, bank account, or digital wallet. A variety of payment methods can be used by the customer using a `Source` object. Therefore, you need a service that will allow you to perform operations on the source resource. Let's add the `source` service and its operations to the Protobuf (`.proto`) file:

    ```java
    service SourceService {
      rpc Create(CreateSourceReq) returns (
     CreateSourceReq.Response);
      rpc Retrieve(SourceId) returns (SourceId.Response);
      rpc Update(UpdateSourceReq) returns (
     UpdateSourceReq.Response);
      rpc Attach(AttachOrDetachReq) returns 
                      (AttachOrDetachReq.Response);
      rpc Detach(AttachOrDetachReq) returns 
                      (AttachOrDetachReq.Response);
     }
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto

    SourceService 中的每个过程都将执行以下操作:

    *   **创建**:这个过程创建一个新的`Source`对象。
    *   **检索**:这个过程允许您根据给定的源 ID 检索`Source`对象。
    *   **更新**:该程序允许您更新使用`UpdateSourceReq`对象传递的`Source`对象的某些字段。任何不属于`UpdateSourceReq`的字段将保持不变。
    *   **附加**:该程序将`Source`对象附加到客户。`AttachOrDetailReq`参数包含源和客户的 id。然而，要执行附加的操作，`Source`对象应该处于`CHARGEABLE`或`PENDING`状态。
    *   **Detach**: This procedure will detach the source object from the customer. It will also change the state of the `Source` object to `consumed` and it can no longer be used to create the charge. The `AttachOrDetailReq` parameter contains the IDs of both the source and the customer.

        定义请求和响应类型的推荐方法

        建议始终使用包装请求和响应类型。这允许您向请求或响应类型添加另一个字段。

2.  Now the service definitions are done. You can define the given parameters and the returned types of these procedures. Let's first define the parameters and returned types of `ChargeService`. First of all, you will define the `Charge` message type, as shown in the following code block:

    ```java
    message Charge {
      string id = 1;
      uint32 amount = 2;
      uint32 amountCaptured = 3;
      uint32 amountRefunded = 4;
      string balanceTransactionId = 5;
      BillingDetails billingDetails = 6;
      string calculatedStatementDescriptor = 7;
      bool captured = 8;
      uint64 created = 9;
      string currency = 10;
      string customerId = 11;
      string description = 12;
      bool disputed = 13;
      uint32 failureCode = 14;
      string failureMessage = 15;
      string invoiceId = 16;
      string orderId = 17;
      bool paid = 18;
      string paymentMethodId = 19;
      PaymentMethodDetails paymentMethodDetails = 20;
      string receiptEmail = 21;
      string receiptNumber = 22;
      bool refunded = 23;
      repeated Refund refunds = 24;
      string statementDescriptor = 25;
      enum Status {
        SUCCEEDED = 0;
        PENDING = 1;
        FAILED = 2;
      }
      Status status = 26;
      string sourceId = 27;
    }
    ```

    这里，`Charge`消息包含以下字段:

    *   `id`:`Charge`对象的唯一标识符。
    *   `amount`:金额为正数或零，表示该笔款项将被收取。
    *   `amountCaptured`:这是抓取的数量(正数或零)。如果进行了部分捕获，它可以小于“金额”字段的值。
    *   `amountRefunded`:退款金额(正数或零)。如果发放部分退款，它可以小于金额字段的值。
    *   `balanceTransactionId`:余额交易的 ID，描述该费用对您账户余额的影响(不包括退款或争议)。
    *   `billingDetails`:`BillingDetails`消息类型的对象，包含与交易时的支付方式相关的计费信息。
    *   `calculatedStatementDescriptor`:传送到卡网络的对账单描述，显示在客户的信用卡和银行对账单上。
    *   `captured`:布尔型字段，表示此后是否已经捕获了电荷(可以不捕获而创建电荷)。
    *   `created`:创建对象的时间戳(从 Unix 纪元开始以秒为单位)。
    *   `currency`:三个字母的 ISO 货币代码。
    *   `customerId`:拥有收费的客户的 ID。
    *   `description`:显示给用户的费用说明。
    *   `disputed`:表示收费是否有争议的布尔型字段。
    *   `failureCode`:故障的错误代码。
    *   `failureMessage`:失败的描述。如果该选项可用，可以说明原因。
    *   `invoiceId`:该笔费用发票的 ID。
    *   `orderId`:本次收费的订单 ID。
    *   `paid`:布尔值表示收费是否成功，或者是否被成功授权用于后续的捕获。
    *   `paymentMethodId`:支付方式的标识。
    *   `paymentMethodDetails:`包含付款方式细节的对象。
    *   `receiptEmail`:费用收据将发送到的电子邮件。
    *   `receiptNumber`:代表通过电子邮件发送的收费收据中的交易号。在发送收费收据之前，它应该保持为空。
    *   `refunded`:布尔型字段，表示费用是否已退款。
    *   `refunds`:包含已经发出的退款清单。关键字`repeated`用于创建一个`Refund`列表。
    *   `statementDescriptor`:对一张卡的费用的描述。
    *   `status`:一个`Status`枚举类型的对象(`SUCCEEDED`、`PENDING`、`FAILED`)，表示收费的状态。
    *   `sourceId`: Id of the `Source` object

        标量类型如`uint32`和`string`在上一章的*协议缓冲区*一节中讨论过( [*第 10 章*](10.html#_idTextAnchor210) 、 *gRPC 基础*)。你可以参考它获得更多的信息。

        预定义的已知类型

        除了标量类型，Protobuf 还提供预定义的类型，如`Empty`(在前面的*步骤 4* 中讨论过)、`Timestamp`和`Duration`。你可以在[https://developers . Google . com/protocol-buffers/docs/reference/Google . proto buf](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf)找到完整的列表。

3.  Now, you can define the remaining message types of the other parameters (`CreateChargeReq`, `ChargeId`, `UpdateChargeReq`, `CaptureChargeReq`, and `CustomerId`) and return the `ChargeList` type of `ChargeService`, as shown in the following code block:

    ```java
    message CreateChargeReq {
      uint32 amount = 1;
      string currency = 2;
      string customerId = 3;
      string description = 4;
      string receiptEmail = 5;
      Source source Id = 6;
      string statementDescriptor = 7;
      message Response {
        Charge charge = 1;
      }
    }
    message UpdateChargeReq {
      string sourceId = 1;
      string customerId = 2;
      string description = 3;
      string receiptEmail = 4;
      message Response {
        Charge charge = 1;
      }
    }
    message CaptureChargeReq {
      string sourceId = 1;
      uint32 amount = 2;
      string receiptEmail = 3;
      string statementDescriptor = 4;
      message Response {
        Charge charge = 1;
      }
    }
    message ChargeId {
      string id = 1;
      message Response {
        Charge charge = 1;
      }
    }
    message CustomerId {
      string id = 1;
      message Response {
        repeated Charge charge = 1;
      }
    }
    ```

    这里，`CreateChargeReq`类型包含所需属性的收费金额(`amount`)和`currency`。它还包含许多可选属性—`customerId`、`receiptEmail`、`source`和`statementDescriptor`。

    `UpdateChargeReq`包含所有可选的属性-`customerId`、`description`和`receiptEmail`。

    `CaptureChargeReq`包含所有可选属性—`amount`、 `receiptEmail`和 `statementDescriptor`。

    不太知名的谷歌常见类型

    `Money`和`Date`(不是`Timestamp`)是不太为人所知的常用类型，可以使用。然而，你必须复制定义而不是导入它们(你可以为`Empty`和`Timestamp`这样做)。可以从 Google 的 API 常用类型中复制:`Money`来自[https://github . com/Google APIs/Google APIs/blob/master/Google/type/money . proto](https://github.com/googleapis/googleapis/blob/master/google/type/money.proto)，以及`Date`来自[https://github . com/Google APIs/Google APIs/blob/master/Google/type/date . proto](https://github.com/googleapis/googleapis/blob/master/google/type/date.proto)。您可以使用存储库中的其他常见类型。

4.  Now, you can define the parameters and return the `SourceService` types. First of all, let's define the `Source` message type, as shown in the following code.

    源使用的流量值可以是`REDIRECT`、`RECEIVER`、`CODE VERIFICATION`和`NONE`中的一个。类似地，使用值可以是`REUSABLE`或`SINGLEUSE`。因此，让我们首先使用`enum`创建`Flow`和`Usage`枚举:

    ```java
      enum Flow {
        REDIRECT = 0;
        RECEIVER = 1;
        CODEVERIFICATION = 2;
        NONE = 3;
      }
      enum Usage {
        REUSABLE = 0;
        SINGLEUSE = 1;
      }
    ```

    现在，您可以在`Source`消息中使用这个`Flow`枚举:

    ```java
    message Source {
      string id = 1;
      uint32 amount = 2;
      string clientSecret = 3;
      uint64 created = 4;
      string currency = 5;
      Flow flow = 6;
      Owner owner = 7;
      Receiver receiver = 8;
      string statementDescriptor = 9;
      enum Status {
        CANCELLED = 0;
        CHARGEABLE = 1;
        CONSUMNED = 2;
        FAILED = 3;
        PENDING = 4;
      }
      Status status = 10;
      string type = 11;
      Usage usage = 12;
    }
    ```

5.  现在，您可以定义`SourceService`-`CreateSourceReq`、`UpdateSourceReq`、`AttachOrDetachReq`、`SourceId`其他参数的剩余消息类型，如下面的代码块所示:

    ```java
    message CreateSourceReq {
      string type = 1;
      uint32 amount = 2;
      string currency = 3;
      Owner owner = 4;
      string statementDescriptor = 5;
      Flow flow = 6;
      Receiver receiver = 7;
      Usage usage = 8;
      message Response {
        Source source = 1;
      }
    }
    message UpdateSourceReq {
      string sourceId = 1;
      uint32 amount = 2;
      Owner owner = 3;
      message Response {
        Source source = 1;
      }
    }
    message SourceId {
      string id = 1;
      message Response {
        Source source = 1;
      }
    }
    message AttachOrDetachReq {
      string sourceId = 1;
      string customerId = 2;
      message Response {
        Source source = 1;
      }
    }
    ```

这些消息中使用的其他消息类型可以在位于[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 11/API/lib/src/main/proto/paymentgatewayservice . proto](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/api/lib/src/main/proto/PaymentGatewayService.proto)的支付网关定义文件中引用。

多个原型文件

您还可以为每个服务创建一个单独的定义文件，例如用于模块化的`ChargeService.proto`和`SourceService.proto`。然后您可以使用`import "SourceService.proto";`将这些文件导入到另一个 Protobuf 文件中。

你可以在[https://developers . Google . com/protocol-buffers/docs/proto # importing _ definitions](https://developers.google.com/protocol-buffers/docs/proto#importing_definitions)找到更多关于导入的信息。

现在您已经完成了`Protobuf`文件中的支付网关服务定义。现在，您可以使用这个文件为 gRPC 客户机生成 gRPC 服务器接口和存根。

接下来，您将发布从打包在`Jar`文件中的`Protobuf`文件生成的 Java 类。

### 发布支付网关服务 gRPC 服务器、存根和模型

您可以使用下面的命令，其中应该从`api`项目的根目录执行:

```java
$ gradlew clean publishToMavenLocal
```

此命令将首先删除现有文件。然后，它将从 Protobuf 文件生成 Java 文件(`generateProto` Gradle 任务)，构建它(`build` Gradle 任务)，然后将工件发布到您的本地 Maven 存储库(`publishToMavenLocal` Gradle 任务)。

Gradle 任务将在两个目录中生成两种类型的 Java 类，如下所示:

*   **Models** :这个 Protobuf Gradle 插件在`/api/lib/src/main/java`目录下的单独 Java 文件中生成消息(又名模型)和类，比如`Card.java`或`Address.java`。该目录还将包含操作契约中使用的请求和响应对象的 Java 文件，例如`CreateChargeReq`、`CreateSourceReq`、`Charge.java`和`Source.java`。
*   **gRPC classes**: This Protobuf Gradle plugin generates the service definitions of both services (`ChargeServiceGrpc.java` and `SourceServiceGrpc.java`) in the `/api/lib/src/main/grpc` directory. Each of these gRPC Java files contains a base class, stub classes, and methods for each operation defined in the service descriptor for the `Charge` and `Source` services.

    下面的关键*静态*类在`ChargeServiceGrpc`中定义:

    i. `ChargeServiceImplBase`(抽象基类)

    二。存根:`ChargeServiceStub`、`ChargeServiceBlockingStub`和`ChargeServiceFutureStub`

    类似地，下面的关键*静态*类在`SourceServiceGrpc`中定义:

    i. `SourceServiceImplBase`(抽象基类)

    二。存根:`SourceServiceStub`、`SourceServiceBlockingStub`和`SourceServiceFutureStub`

前面描述的的抽象基类包含了在 Protobuf 文件的服务块中定义的操作。您可以使用这些基类来实现这些服务所提供的操作的业务逻辑，就像您从 swagger 生成的 API 接口中实现 REST 端点一样。

应该实现这些抽象类，以便为 gRPC 服务器提供的服务提供业务逻辑实现。接下来让我们开发 gRPC 服务器。

# 开发 gRPC 服务器

在实现这些抽象类之前，您需要配置`Server`项目。让我们首先配置服务器项目。

服务器项目目录结构将如下所示。项目根目录包含 build.gradle 和 settings.gradle 文件:

```java
├───server
    ├───gradle
    │   └───wrapper
    └───src
        ├───main
        │   ├───java
        │   │   └───com
        │   │       └───packt
        │   │           └───modern
        │   │               └───api
        │   └───resources
        └───test
            └───java
```

resources 目录将包含`application.properties`文件。

为依赖项使用 gRPC 库

您可以使用两个 Spring Boot 入门项目。然而，为了简化解决方案和帮助理解 gRPC 概念，我们将坚持使用 gRPC 提供的库。这些库可从以下链接获得:

[https://github.com/LogNet/grpc-spring-boot-starter](https://github.com/LogNet/grpc-spring-boot-starter)。

[https://github.com/yidongnan/grpc-spring-boot-starter](https://github.com/yidongnan/grpc-spring-boot-starter)。

让我们执行以下步骤来配置项目:

1.  首先需要修改`Chapter11/server/settings.gradle`文件中的项目名来表示服务器，如下图:

    ```java
    rootProject.name = 'chapter11-server'
    ```

2.  Next, you can add the dependencies required for `Server` projects to the `Chapter11/server/build.gradle` file:

    ```java
    def grpcVersion = '1.37.0'
    dependencies {
     implementation 'com.packt.modern.api:payment-gateway-
     api:0.0.1'
     // gRPC dependencies
     implementation "io.grpc:grpc-protobuf:${grpcVersion}"
     implementation "io.grpc:grpc-stub:${grpcVersion}"
     implementation "io.grpc:grpc-netty:${grpcVersion}"
     implementation 'com.google.api.grpc:googleapis-
     common-protos:0.0.3'

     implementation 'org.springframework.boot:spring-boot-starter-web'
     testImplementation 'org.springframework.boot:spring-
                         boot-starter-test'
      testImplementation "io.grpc:grpc-
     testing:${grpcVersion}"
    }
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter11/server/build.gradle

3.  `payment-gateway-api`依赖项是在本地 Maven 库中发布的。因此，您需要将本地 Maven 存储库添加到存储库部分，如下面的代码块所示:

    ```java
    repositories {
         mavenCentral()
         mavenLocal()
    }
    ```

您已经完成了 Gradle 配置！现在，您可以编写 gRPC 服务器了。然而，在编写服务器之前，您需要实现由 Protobuf 生成的基本抽象类。一旦实现了源服务和收费服务(使用基类)，就可以编写 gRPC 服务器代码了。

## gRPC 基类的实现

您将使用内存数据库(`ConcurrentHashMap`)来存储和检索数据。如果您愿意，可以像在 REST web 服务中一样使用外部数据库。这样做是为了将重点放在 gRPC 服务器实现上。

首先，为费用和源数据存储创建内存数据库。创建一个新文件`server/src/main/java/com/packt/modern/api/server/repository/DbStore.java`，并添加代码，如下面的代码块所示:

```java
@Component
public class DbStore {
  private static final Map<String, Source> sourceEntities = 
      new ConcurrentHashMap<>();
  private static final Map<String, Charge> chargeEntities = 
      new ConcurrentHashMap<>();
  public DbStore() {
    // Seed Source for testing
    Source source = Source.newBuilder()
     .setId(RandomHolder.randomKey()).setType(
         "card").setAmount(100)
     .setOwner(createOwner()).setReceiver(createReceiver())
     .setCurrency("USD").setStatementDescriptor(
         "Statement Desc")
     .setFlow(Flow.RECEIVER).setUsage(Usage.REUSABLE)
     .setCreated(Instant.now().getEpochSecond()).build();
    sourceEntities.put(source.getId(), source);
    // Seed Charge for testing
    Charge charge = Charge.newBuilder()
      .setId(RandomHolder.randomKey()).setAmount(1000)
      .setCurrency("USD").setCustomerId("ab1ab2ab3ab4ab5")
      .setDescription("Charge Description")
      .setReceiptEmail("receipt@email.com")
      .setStatementDescriptor("Statement Descriptor")
      .setSourceId(source.getId())          
      .setCreated(Instant.now().getEpochSecond()).build();
    chargeEntities.put(charge.getId(), charge);
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java

这里，您创建了两个`ConcurrentHashMap`对象，分别用于存储电荷和存储对象。您可以使用构建器在构造函数中为每个对象创建两个种子对象，并将它们存储到各自的哈希映射中。

根据服务契约中定义的操作，您可以在数据库存储中创建方法来执行操作。这些操作是用基本的业务逻辑实现的，以保持流程和逻辑简明扼要。

现在我们添加`createSource()`方法来实现`Protobuf`文件中`SourceService`定义的的`create()`契约，如下面的代码块所示:

```java
public CreateSourceReq.Response createSource(
      CreateSourceReq req) {
  // validate request object
  // Owner and receiver should be taken from req. in the 
  // form of ID
  Source source = Source.newBuilder()
     .setId(
          RandomHolder.randomKey()).setType(req.getType())
     .setAmount(req.getAmount()).setOwner(createOwner())
     .setReceiver(createReceiver()).setCurrency(
         req.getCurrency())
     .setStatementDescriptor(req.getStatementDescriptor())            
     .setFlow(req.getFlow()).setUsage(req.getUsage())
     .setCreated(Instant.now().getEpochSecond()).build();
  sourceEntities.put(source.getId(), source);
  return CreateSourceReq.Response.newBuilder().setSource(
          source)
         .build();
}
```

这个方法根据从请求对象(`CreateSourceReq`)接收的值创建一个源对象。这个新创建的`Source`对象然后被保存在哈希映射`sourceEntities`中并返回给调用者。

类似地，这里可以实现用于源和电荷相关的数据存储逻辑的其他契约方法。在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 11/server/src/main/Java/com/packt/Modern/API/server/repository/db store . Java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java)中找到这个类的完整源代码。

现在，你有了内存中的 T1。接下来，让我们使用它的存储库类。

### 编写存储库类

内存中的`DbStore`可以在`ChargeRepositoryImpl`存储库类中使用，如下图所示的:

```java
@Repository
public class ChargeRepositoryImpl implements 
      ChargeRepository {
  private DbStore dbStore;
  public ChargeRepositoryImpl(DbStore dbStore) {
    this.dbStore = dbStore;
  }
  @Override
  public CreateChargeReq.Response create(
      CreateChargeReq req) {
    return dbStore.createCharge(req);
  }
  // Other methods removed for brevity
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepositoryImpl.java

首先，声明一个接口，该接口包含映射到收费服务的抽象基类的公共方法，该服务可在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 11/server/src/main/Java/com/packt/Modern/API/server/repository/charge repository . Java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/ChargeRepository.java)获得。

然后，`ChargeRepositoryImpl`实现`ChargeRepository`接口，并利用`DbStore`来执行操作。

类似地，您可以创建实现`SourceRespository`的`SourceRepositoryImpl`类，如下所示:

```java
@Repository
public class SourceRepositoryImpl implements 
      SourceRepository {
  private DbStore dbStore;
  public SourceRepositoryImpl(DbStore dbStore) {
    this.dbStore = dbStore;
  }
  @Override
  public UpdateSourceReq.Response update(UpdateSourceReq 
      req) {
    return dbStore.updateSource(req);
  }
  // Other methods removed for brevity
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepositoryImpl.java

`SourceRepository`包含映射到`SourceService`抽象基类的方法。可以在[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/chapter 11/server/src/main/Java/com/packt/Modern/API/server/repository/source repository . Java](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/SourceRepository.java)查阅。

这些存储库类可以从服务类中使用，服务类实现了抽象生成的基类。接下来就写这些吧。

### 实现服务类别

现在您已经有了以存储库和可用于实现 gRPC 服务基类的`DB store`类的形式准备好的底层实现。

让我们首先实现`Source`服务，如下所示:

1.  在`server/src/main/com/packt/modern/api/server/service`目录下创建一个新文件`SourceService.java`。
2.  Add the implementations to operations defined in the `SourceService` abstract base class, as shown next:

    ```java
    @Service
    public class SourceService extends       SourceServiceImplBase {
      private SourceRepository repository;
      public SourceService(SourceRepository repository) {
        this.repository = repository;
      }
      @Override
      public void create(CreateSourceReq req,       StreamObserver<CreateSourceReq.Response>            resObserver) {
        CreateSourceReq.Response resp =           repository.create(req);
        resObserver.onNext(resp);
        resObserver.onCompleted();
      }
      // Other methods removed for brevity
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java

    这里，`SourceServiceImplBase`抽象类是由包含`Source`服务的契约方法的`Protobuf`插件自动生成的。生成的方法签名的一个非常独特的部分是第二个参数，`StreamObserver`。`StreamObserver`接收来自可观察流的通知。它在这里被用于服务实现。类似地，它也用在客户端存根中。gRPC 库为传出消息提供了`StreamObserver`参数。但是，您还必须为传入的消息实现它。

    参数不是线程安全的，所以你必须注意多线程，并且应该使用同步调用。

3.  `StreamObserver`有三种主要方法:
    *   `onNext()`:这个方法从流中接收值。可以多次调用。但是，它不应该在`onCompleted()`或`onError()`之后被调用。当多个数据被发送到客户端时，流需要多个`onNext()`调用。
    *   `onCompleted()`:这标志着流的完成，在此之后不允许进一步的方法调用。只能调用一次。
    *   `onError()`:该方法接收来自流的终止错误。和`onCompleted()`一样，它只能被调用一次，不允许进一步的方法调用。
4.  同样，您可以实现抽象类的其他方法。

接下来，以与实现`Source`服务相同的方式，类似地，您可以实现`Charge`服务。

让我们首先实现`Source`服务，如下所示:

1.  在`server/src/main/com/packt/modern/api/server/service`目录下创建一个新文件`ChargeService.java`。
2.  Add the implementations to operations defined in the `SourceService` abstract base class, as shown here:

    ```java
    @Service
    public class ChargeService extends 
          ChargeServiceImplBase {
      private ChargeRepository repository;
      public ChargeService(ChargeRepository repository) {
        this.repository = repository;
      }
      @Override
      public void create(CreateChargeReq req,
           StreamObserver<CreateChargeReq.Response> 
           resObserver) {
        CreateSourceReq.Response resp = 
          repository.create(req);
        resObserver.onNext(resp);
        resObserver.onCompleted();
      }
      // Other methods removed for brevity
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/service/ChargeService.java

    这与实现`SourceService` `create`方法的方式是一样的。

3.  同样，您可以实现抽象类的其他方法。请参考前面代码块中显示的源代码链接，了解完整的代码实现。

现在，您已经准备好了 gRPC 服务实现。接下来让我们实现服务器。

## gRPC 服务器的实现

Spring Boot 应用运行在自己的服务器上。但是，我们希望运行 gRPC 服务器，它在内部使用 Netty web 服务器。因此，我们首先需要修改 Spring Boot 配置以停止运行其 web 服务器。您可以通过修改`application.properties`文件来实现，如下面的代码块所示:

```java
spring.main.web-application-type=none
grpc.port=8080
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/resources/application.properties

接下来，让我们创建 gRPC 服务器。它将有三种方法——`start()`、`stop()`和`block()`,分别用于启动服务器、停止服务器和服务请求，直到收到终止请求。

在`server/src/main/com/packt/modern/api/server`目录和代码中创建一个新文件`GrpcServer.java`，如以下代码块所示:

```java
@Component
public class GrpcServer {
  private final Logger LOG = 
      LoggerFactory.getLogger(getClass());
  @Value("${grpc.port:8080}")
  private int port;
  private Server server;
  private ChargeService chargeService;
  private SourceService sourceService;
  private ExceptionInterceptor exceptionInterceptor;
  public GrpcServer(…) {
    // code removed for brevity
  }
  public void start() throws IOException, 
    InterruptedException {
    server = ServerBuilder.forPort(port)
        .addService(sourceService).addService(chargeService)
        .intercept(exceptionInterceptor).build().start();
    server.getServices().stream().forEach(s -> LOG.info(
        "Service Name: {}", s.getServiceDescriptor().
          getName()));
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
     GrpcServer.this.stop();
    }));
  }
  private void stop() {
    if (server != null) {
      server.shutdown();
    }
  }
  public void block() throws InterruptedException {
    if (server != null) {
      // received the request until application is 
      // terminated
      server.awaitTermination();
    }
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServer.java

gRPC 的服务器库提供了构建服务器的服务器构建器。您可以看到这两个服务都添加到了服务器中。构建器还允许您添加拦截器来拦截传入的请求和响应。我们将在*处理错误*部分使用拦截器。

`GrpcServer` `start()`方法还添加了一个调用`stop()`方法的关闭挂钩，它在内部调用`server.shutdown()`方法。

服务器代码准备好了。现在，您需要一个界面来启动服务器。您将使用`CommandLineRunner`函数界面来运行服务器。

在创建`GrpcServer.java`文件的同一目录下创建一个新文件`GrpcServerRunner.java`，并添加以下代码:

```java
@Profile("!test")
@Component
public class GrpcServerRunner implements CommandLineRunner {
  private GrpcServer grpcServer;
  public GrpcServerRunner(GrpcServer grpcServer) {
    this.grpcServer = grpcServer;
  }
  @Override
  public void run(String... args) throws Exception {
    grpcServer.start();
    grpcServer.block();
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/GrpcServerRunner.java

在这里，您重写了`CommandLineRunner` `run()`方法，并调用了`start`和`block`方法。因此，当您执行`jar`文件时，`GrpcServerRunner`将使用它的`run()`方法来执行，并将启动 gRPC 服务器。

另一件要记住的事情是，您已经用带有`"!test"`值的`@Profile`注释标记了`GrpcServerRunner`类，这意味着当`test`概要文件被激活时，这个类将不会被加载，因此也不会被执行。

您现在已经完成了服务和服务器实现，所以让我们在下一小节中测试它。

## 测试 gRPC 服务器

首先，您需要将设置为测试类中要测试的活动概要文件，因为它将禁用`GrpcServerRunner`。让我们这样做并测试它，如下面的代码块所示:

```java
@ActiveProfiles("test")
@SpringBootTest
@TestMethodOrder(OrderAnnotation.class)
class ServerAppTests {
  @Autowired
  private ApplicationContext context;
  @Test
  @Order(1)
  void beanGrpcServerRunnerTest() {
    assertNotNull(context.getBean(GrpcServer.class));
    assertThrows(NoSuchBeanDefinitionException.class,
        () -> context.getBean(GrpcServerRunner.class),
        "GrpcServerRunner should not be loaded during 
             test");
  }
  // continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/test/java/com/packt/modern/api/ServerAppTests.java

`beanGrpcServerRunnerTest()`方法测试`GrpcServer`类和`GrpcServerRunner`的加载，如果配置文件设置正确，测试应该通过。

现在，让我们继续测试 gRPC 服务。

gRPC 测试库提供了一个特殊的类`GrpcCleanupRule`，它可以很好地管理注册服务器和通道的关闭。您需要用 JUnit `@Rule`进行注释以使其有效。gRPC 测试库还提供了`InProcessServerBuilder`构建器类，允许您构建服务器，以及`InProcessChannelBuilder`构建器类，允许您构建通道。这三个类是构建和管理服务器和通道所需要的全部。

因此，首先需要声明所需的实例，然后设置方法，以便在向 gRPC `Source`服务发出请求之前执行环境可用。

让我们在下面的代码中添加所需的类实例并测试`setup()`方法:

```java
  @Rule
  private final static GrpcCleanupRule grpcCleanup = new 
      GrpcCleanupRule();
  private static SourceServiceGrpc.
      SourceServiceBlockingStub blockingStub;
  private static String newlyCreatedSourceId = null;
  @BeforeAll
  public static void setup(@Autowired SourceService 
      sourceService,
      @Autowired ChargeService chargeService,
      @Autowired ExceptionInterceptor exceptionInterceptor)
      throws IOException {
    String serverName =
               InProcessServerBuilder.generateName(); // 1
    grpcCleanup.register(InProcessServerBuilder
        .forName(serverName)
        .directExecutor().addService(sourceService)
        .intercept(exceptionInterceptor).build().start());
                                                      // 2
    blockingStub =
        SourceServiceGrpc.newBlockingStub(grpcCleanup
        .register(InProcessChannelBuilder.forName(serverName)
        .directExecutor().build()));                    
                                                    // 3
  }
```

这里，setup 方法使用`Source`服务创建服务器和通道。让我们理解一下`setup()`方法中提到的每一行:

*   *第 1 行*生成服务器的唯一名称。
*   *第 2 行*注册新创建的服务器，并向其中添加源服务和服务器拦截器。我们将在*处理错误*部分讨论`ExceptionInterceptor`。然后，它启动服务器来处理请求。
*   *第 3 行*创建阻塞存根，它将被用作客户机对服务器进行调用。这里再次使用`GrpcCleanUpRule`来创建客户端通道。

一旦设置被执行，它就为我们提供了执行测试的环境。让我们测试我们的第一个请求，如下面的代码块所示:

```java
  @Test
  @Order(2)
  @DisplayName("Creates the source object using create RPC       call")
  public void SourceService_Create() {
    CreateSourceReq.Response response =         blockingStub.create(
              CreateSourceReq.newBuilder().setAmount(100)
              .setCurrency("USD").build());
    assertNotNull(response);
    assertNotNull(response.getSource());
    newlyCreatedSourceId = response.getSource().getId();
    assertEquals(100, response.getSource().getAmount());
    assertEquals("USD", response.getSource().getCurrency());
  }
```

`setup()`方法的所有复杂方面都已完成。这些测试现在看起来非常简单。你只需使用阻塞存根打一个电话。您创建请求对象并使用存根调用服务器。最后，验证服务器响应。

同样，您可以测试验证错误，如下面的代码块所示:

```java
  @Test
  @Order(3)
  @DisplayName("Throws the exception when invalid source id 
               is passed to retrieve RPC call")
  public void SourceService_RetrieveForInvalidId() {
    Throwable throwable = assertThrows(
        StatusRuntimeException.class, () -> blockingStub
           .retrieve(
               SourceId.newBuilder().setId("").build()));
    assertEquals("INVALID_ARGUMENT: Invalid Source ID is 
                 passed.", throwable.getMessage());
  }
```

您还可以测试源代码检索的有效响应，如下面的代码块所示:

```java
  @Test
  @Order(4)
  @DisplayName("Retrieves source obj created using create       RPC call")
  public void SourceService_Retrieve() {
    SourceId.Response response = 
        blockingStub.retrieve(SourceId
                .newBuilder().setId(newlyCreatedSourceId).                 build());
    assertNotNull(response);
    assertNotNull(response.getSource());
    assertEquals(100, response.getSource().getAmount());
    assertEquals("USD", response.getSource().getCurrency());
  }
```

这是为 gRPC 服务器编写测试并测试公开的 RPC 调用的方法。您可以使用相同的方法来编写剩余的测试用例。

编写完测试后，您可能对客户机如何向服务器发送请求有了一个概念。

我们还没有讨论我们在服务器代码和测试中使用的异常拦截器。让我们在下一节讨论这个问题。

# 处理错误

您可能已经在 [*第 10 章*](10.html#_idTextAnchor210) 、 *gRPC 基础*中的*处理错误*部分学习过了，其中讨论了`google.rpc.Status`和 gRPC 状态代码。在阅读本节内容之前，您可能想重温一下本节内容。

`io.grpc.ServerInterceptor`是一个线程安全的接口，用于拦截传入调用，可用于跨领域调用，如身份验证和授权、日志记录和监控。让我们用它来编写`ExceptionInterceptor`，如下面的代码块所示:

```java
@Component
public class ExceptionInterceptor implements ServerInterceptor {
  @Override
  public <RQT, RST> ServerCall.Listener<RQT> interceptCall(          ServerCall<RQT, RST> serverCall, Metadata metadata,          ServerCallHandler<RQT, RST> serverCallHandler) {
     ServerCall.Listener<RQT> listener = serverCallHandler                           .startCall(serverCall, metadata);
     return new ExceptionHandlingServerCallListener
<>(listener, serverCall, metadata);  }
  // continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java

这里，`RQT`表示请求类型，`RST`表示响应类型。

我们将使用它进行异常拦截。拦截器将把调用传递给服务器监听器(`ExceptionHandlingServerCallListener`)。`ExceptionHandlingServerCallListener`是`ExceptionInterceptor`中的私有类，它扩展了`ForwardingServerCallListener.SimpleForwardingServerCallListener`抽象类。

它(私有监听器类)已经覆盖了事件`onHalfClose()`和`onReady()`，它们将捕获异常并将调用传递给`handleException()`方法。`handleException()`方法将使用`ExceptionUtils`方法来跟踪实际的异常，并用错误细节进行响应。返回`StatusRuntimeException`，用于关闭错误状态的服务器调用。

让我们看看这个流程在下一个代码块中是怎样的:

```java
private class ExceptionHandlingServerCallListener<RQT, RST>      extends ForwardingServerCallListener               .SimpleForwardingServerCallListener<RQT> {
  private final ServerCall<RQT, RST> serverCall;
  private final Metadata metadata;
  ExceptionHandlingServerCallListener(
      ServerCall.Listener<RQT> 
      listener,ServerCall<RQT, RST> serverCall, Metadata 
          metadata) {
    super(listener);
    this.serverCall = serverCall;
    this.metadata = metadata;
  }
  @Override
  public void onHalfClose() {
    try { super.onHalfClose();}
    catch (RuntimeException e) {
      handleException(e, serverCall, metadata);
      throw e;
    }
  }
  @Override
  public void onReady() {
    try { super.onReady();}
    catch (RuntimeException e) {
      handleException(e, serverCall, metadata);
      throw e;
    }
  }
  private void handleException(RuntimeException e, 
             ServerCall<RQT, RST> serverCall, Metadata 
             metadata) {
   StatusRuntimeException status =        ExceptionUtils.traceException(e);
    serverCall.close(status.getStatus(), metadata);
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/interceptor/ExceptionInterceptor.java

接下来让我们编写`ExceptionUtils`类来完成异常处理核心组件。然后，您可以在服务实现中使用这些组件来引发异常。

`ExceptionUtils`类有两种类型的重载方法:

*   `observerError()`:这个方法将使用`StreamObserver`来引发`onError()`事件。
*   `traceException()`:该方法将从`Throwable`开始追踪错误，并返回`StatusRuntimeException`实例。

您可以使用下面的代码来编写`ExceptionUtils`类:

```java
@Component
public class ExceptionUtils {
  public static StatusRuntimeException       traceException(Throwable e) {
    return traceException(e, null);
  }
  public static <T extends GeneratedMessageV3> void       observeError(        StreamObserver<T> responseObserver, Throwable e) {
    responseObserver.onError(traceException(e));
  }
  public static <T extends GeneratedMessageV3> void       observeError(          StreamObserver<T> responseObserver, Exception e,                                       T defaultInstance) {
    responseObserver.onError(traceException(e,         defaultInstance));
  }
  // continue…
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/exception/ExceptionUtils.java

您可以看到，`observerError()`方法也在内部为`onError`事件调用了`traceException()`。下面让写最后一个重载方法`traceException()`，接下来:

```java
public static <T extends com.google.protobuf.        GeneratedMessageV3>        StatusRuntimeException traceException(Throwable e,        T defaultInstance) {
    com.google.rpc.Status status;
    StatusRuntimeException statusRuntimeException;
    if (e instanceof StatusRuntimeException) {
      statusRuntimeException = (StatusRuntimeException) e;
    } else {
      Throwable cause = e;
      if (cause != null && cause.getCause() != null
                                  && cause.getCause() != 
                                  cause) {
        cause = cause.getCause();
      }
      if (cause instanceof SocketException) {
        String errorMessage = "Sample exception message";
        status = com.google.rpc.Status.newBuilder()
            .setCode(com.google.rpc.Code.UNAVAILABLE_VALUE)
            .setMessage(errorMessage + cause.getMessage())
            .addDetails(Any.pack(defaultInstance)).build();
      } else {
        status = com.google.rpc.Status.newBuilder()
            .setCode(com.google.rpc.Code.INTERNAL_VALUE)
            .setMessage("Internal server error")
            .addDetails(Any.pack(defaultInstance)).build();
      }
      statusRuntimeException =
                     StatusProto.toStatusRuntimeException(
                         status);
    }
    return statusRuntimeException;
  }
```

`SocketException`以举例的方式示出。您可以在这里添加对另一种异常的检查。您可能会注意到，这里我们使用`com.google.rpc.Status`来构建状态。然后，这个状态实例被传递给`StatusProto`的`toStatusRuntimeException()`，后者将状态转换为`StatusRuntimeException`。

让我们在`DbStore`类中添加验证错误，以利用这些异常处理组件，如下面的代码块所示:

```java
public SourceId.Response retrieveSource(String sourceId) {
 if (Strings.isBlank(sourceId)) {
   com.google.rpc.Status status = 
          com.google.rpc.Status.newBuilder()
      .setCode(Code.INVALID_ARGUMENT.getNumber())
      .setMessage("Invalid Source ID is passed.")
 .addDetails(Any.pack(          SourceId.Response.getDefaultInstance())).build();
   throw StatusProto.toStatusRuntimeException(status);
 }
 Source source = sourceEntities.get(sourceId);
 if (Objects.isNull(source)) {
   com.google.rpc.Status status = 
          com.google.rpc.Status.newBuilder()
      .setCode(Code.INVALID_ARGUMENT.getNumber())
      .setMessage("Requested source is not                   available").build();
   throw StatusProto.toStatusRuntimeException(status);
 }
 return SourceId.Response.newBuilder().setSource(source)    .build();
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/repository/DbStore.java

您可以类似地在服务实现的任何部分引发`StatusRuntimeException`。您还可以使用`com.google.rpc.Status`的`addDetails()`方法向错误状态添加更多细节，如`traceException(Throwable e, T defaultInstance)`代码所示。

最后，您可以捕获由服务实现类中`SourceService`的`retrieve()`方法引发的错误，如下所示:

```java
@Override
public void retrieve(SourceId sourceId,
                   StreamObserver<SourceId.Response> resObserver) {
  try {
    SourceId.Response resp = 
        repository.retrieve(sourceId.getId());
    resObserver.onNext(resp);
    resObserver.onCompleted();
  } catch (Exception e) {
    ExceptionUtils.observeError(resObserver, e,
                            SourceId.Response.
                                getDefaultInstance());
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/server/src/main/java/com/packt/modern/api/server/service/SourceService.java

本章简单而有建设性地解释了异常处理。您可以根据您的应用需求进一步增强它。

现在，让我们在下一节编写 gRPC 客户机。

# 开发 gRPC 客户端

客户端项目的目录结构如下所示。项目根目录包含`build.gradle`和`settings.gradle`文件:

客户端项目的项目目录结构

```java
├───client
    ├───gradle
    │   └───wrapper
    └───src
        ├───main
        │   ├───java
        │   │   └───com
        │   │       └───packt
        │   │           └───modern
        │   │               └───api
        │   └───resources
        └───test
            └───java
```

资源目录将包含`application.properties`文件。

让我们执行以下步骤来配置项目:

1.  首先需要修改`Chapter11/client/settings.gradle`文件中的项目名来表示服务器，如下图:

    ```java
    rootProject.name = 'chapter11-client'
    ```

2.  Next, you can add the dependencies required for client projects in the `Chapter11/client/build.gradle` file. The `grpc-stub` library provides the stubs-related APIs, and `protobuf-java-util` provides the utility methods for Protobuf and JSON conversions:

    ```java
    def grpcVersion = '1.37.0'
    dependencies {
     implementation 'com.packt.modern.api:payment-gateway-
     api:0.0.1'
     // gRPC dependencies
     implementation "io.grpc:grpc-stub:${grpcVersion}"
     implementation "com.google.protobuf:protobuf-java-
     util:3.15.8"
     implementation 'org.springframework.boot:spring-
                     bootstarter-web'
     testImplementation 'org.springframework.boot:spring-
                         boot-starter-test'
    }
    ```

    https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter11/client/build.gradle

3.  `payment-gateway-api`依赖关系发布在本地 Maven 存储库中。因此，需要将本地 Maven 存储库添加到存储库部分，如下面的代码块所示:

    ```java
    repositories {
         mavenCentral()
         mavenLocal()
    }
    ```

您已经完成了 Gradle 配置。现在，您可以编写 gRPC 客户机了。

## 实现 gRPC 客户端

如您所知，Spring Boot 应用运行在自己的服务器上。因此，客户端的应用端口应该不同于 gRPC 服务器端口。此外，我们需要提供 gRPC 服务器主机和端口。这些可以在`application.properties`中配置:

```java
server.port=8081
grpc.server.host=localhost
grpc.server.port=8080
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/client/src/main/resources/application.properties

接下来，让我们创建 gRPC 客户端。该客户端将用于配置 gRPC 服务存根和通道。通道负责提供到概念端点的虚拟连接，以便执行 gRPC 调用。

在`client/src/main/com/packt/modern/api/client`目录下创建一个新文件`GrpcClient.java`，代码如所示，如下代码块所示:

```java
@Component
public class GrpcClient {
  @Value("${grpc.server.host:localhost}")
  private String host;
  @Value("${grpc.server.port:8080}")
  private int port;
  private ManagedChannel channel;
  private SourceServiceBlockingStub sourceServiceStub;
  private ChargeServiceBlockingStub chargeServiceStub;
  public void start() {
    channel = ManagedChannelBuilder.forAddress(host, port)
                                          .usePlaintext().
                                           build();
    sourceServiceStub = SourceServiceGrpc.newBlockingStub(        channel);
    chargeServiceStub = ChargeServiceGrpc.newBlockingStub(        channel);
  }
  public void shutdown() throws InterruptedException {
    channel.shutdown().awaitTermination(1,         TimeUnit.SECONDS);
  }
  public SourceServiceBlockingStub getSourceServiceStub() {
    return this.sourceServiceStub;
  }
  public ChargeServiceBlockingStub getChargeServiceStub() {
    return this.chargeServiceStub;
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClient.java

这里，`start()`是初始化`Source`和`Charge`服务存根的键。`ManagedChannelBuilder`用于建造`ManagedChannel`。`ManagedChannel`是一个也提供生命周期管理的渠道。这个托管通道被传递给存根。

您正在使用纯文本通信。但是，它也提供加密通信。

我们现在已经完成了客户端代码。现在，我们需要调用`start()`方法。你将像实现`GrpcServerRunner`类一样实现`CommandLineRunner`。

它可以通过如下所示的实现:

```java
@Profile("!test")
@Component
public class GrpcClientRunner implements CommandLineRunner {
  @Autowired
  GrpcClient client;
  @Override
  public void run(String... args) {
    client.start();
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
      try { client.shutdown();}
      catch (InterruptedException e) {
        // logging and handling
      }
    }));
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/client/src/main/java/com/packt/modern/api/client/GrpcClientRunner.java

这将在应用启动后启动存根实例化。然后，您可以调用存根方法。

现在，为了调用存根方法，让我们添加一个简单的 REST 端点。这将演示如何使用收费服务存根来调用其检索方法。

您可以在`src/main/java/com/packts/modern/api/controller`目录中为 REST 控制器创建一个新的`ChargeController.java`文件，并添加如下所示的代码:

```java
@RestController
public class ChargeController {
  private GrpcClient client;
  public ChargeController(GrpcClient client) {
    this.client = client;
  }
  @GetMapping("/charges")
  public String getSources(@RequestParam(
           defaultValue = "ab1ab2ab3ab4ab5") String 
               customerId)
             throws InvalidProtocolBufferException {
    var req = CustomerId.newBuilder().setId(
        customerId).build();
    CustomerId.Response resp = client
                          .getChargeServiceStub().
                              retrieveAll(req);
    var printer = JsonFormat
                          .printer().
                          includingDefaultValueFields();
    return printer.print(resp);
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter11/client/src/main/java/com/packt/modern/api/controller/ChargeController.java

在这里，我们已经创建了一个 REST 端点，`/charges`。这使用了`GrpcClient`实例来调用使用`ChargeServiceStub`的 Charge gRPC 服务的`retrieveAll()` RPC 方法。

然后，使用来自`protobuf-java-util`库的`JsonFormat`类将响应转换成 JSON 格式的字符串，并作为响应返回。生成的 JSON 格式的字符串也将包含带有默认值的字段。

我们完成了我们的发展。现在让我们在下一小节中测试完整的流程。

## 测试 gRPC 客户端

在测试客户端之前，确保您的 gRPC 服务器已经启动并正在运行。假设 gRPC `api`项目已经构建完成，并且它的最新工件已经发布到本地 Maven 存储库中:

1.  首先，使用以下命令启动服务器。从服务器项目的根目录运行:

    ```java
    // Server project root directory
    $ gradlew clean build
    $ java -jar build\libs\chapter11-server-0.0.1-SNAPSHOT.jar
     INFO …GrpcServer : gRPC server started and listening on port: 8080
    .INFO …GrpcServer : Following service are available:
     INFO …GrpcServer : Service Name: com.packtpub.v1.SourceService
     INFO …GrpcServer : Service Name: com.packtpub.v1.ChargeService
    ```

2.  接下来，在新的终端窗口中使用以下命令启动客户端。从客户端项目的根目录运行:

    ```java
    // Client project root directory
    $ gradlew clean build
    $ java -jar build\libs\chapter11-client-0.0.1-SNAPSHOT.jar
     INFO …GrpcServer : Tomcat started on port(s): 8081 (http) …
     INFO …GrpcServer : …
     INFO …GrpcServer : gRPC client connected to 
     localhost:8080
    ```

3.  打开一个新的终端窗口，执行以下命令(输出被截断):

    ```java
    $ curl http://localhost:8081/charges
    {
      "charge": [{
        "id": "3igf4pd8vi1e1oadflov5gcnce64h5i3",
        "amount": 1000,
        "amountCaptured": 0,
        …
        …
        "created": "1619461208",
        "currency": "USD",
        "customerId": "ab1ab2ab3ab4ab5",
        "description": "Charge Description",
        …
        …
        "receiptEmail": "receipt@email.com",
        "statementDescriptor": "Statement Descriptor",
        "status": "SUCCEEDED",
        "sourceId": "cb863hsulr0u0deh5et1hfatqapng2jj"
      }]
    }
    ```

REST 端点仅用于演示目的。类似地，您可以使用 gRPC 客户端来调用其他服务及其方法。gRPC 通常用于服务间通信，这对于基于微服务的应用来说至关重要。然而，它也可以用于基于网络的通信。

让我们在下一节了解一下微服务。

# 学习微服务概念

微服务是通过网络通信的独立轻量级流程。微服务为其消费者提供了专注的 API。这些 API 可以使用 REST、gRPC 或 events 来实现。

微服务并不新鲜，它们已经存在很多年了。例如，Stubby 是一个基于**远程过程调用** ( **RPC** )的通用基础设施，它在 21 世纪初被用于谷歌数据中心，以连接数据中心之间的若干服务。

它最近的崛起是由于它的受欢迎程度和知名度。在微服务流行之前，单片架构主要用于开发内部和基于云的应用。

单片架构允许开发不同的组件，如表示、应用逻辑、业务逻辑和**数据访问对象** ( **DAOs** )，然后您可以将组件捆绑在一个**企业存档** ( **EAR** )或 **Web 存档** ( **WAR** )中，或者将组件存储在一个目录层次结构中(如 Rails 或 Node.js)。

许多著名的应用，如网飞，都是使用微服务架构开发的。此外，易贝、亚马逊和 Groupon 已经从单一架构发展到微服务架构。现在基于微服务的应用开发非常普遍。我们在本章中开发的 gRPC 服务器可以被称为微服务(显然，如果您将服务器的范围保持在源服务或收费服务器)。

在下一小节中，我们来看看简单的单片和微服务应用设计。

## 单片系统和微服务系统的设计差异

在这里，您将看到不同的系统设计，它们是使用单片设计、SOA 单片设计和微服务设计来设计的。让我们依次讨论这些问题。

### 传统整体设计

下图描述了传统的单片应用设计。在 SOA 流行之前，这种设计已经被广泛使用:

![Figure 11.1 – Traditional monolithic application design ](img/Figure_11.1_B16561.jpg)

图 11.1–传统整体应用设计

在传统的整体设计中，所有的东西都被捆绑在同一个归档中(所有的表示代码都被捆绑在表示归档中，应用逻辑进入应用逻辑归档，等等)，而不管它们如何与数据库文件或其他源交互。

### 具有服务的整体设计

在 SOA 之后，应用开始基于服务开发，其中每个组件向其他组件或外部实体提供服务。下图描述了具有不同服务的整体式应用；这里，服务与表示组件一起使用。所有服务、演示组件或任何其他组件都捆绑在一起:

![Figure 11.2 – Monolithic design with services ](img/Figure_11.2_B16561.jpg)

图 11.2–带服务的整体设计

因此，所有的东西都以 EAR 的形式和模块方法捆绑在一起。然而，很少有 SOA 服务可以单独部署，但总的来说，它也将是一个整体。然而，数据库是共享的。

### 微服务设计

下图描述了微服务设计。在这里，每个组件都是独立的。每个组件都可以独立开发、构建、测试和部署。在这里，甚至应用的**用户界面** ( **UI** )组件也可以是客户端，并使用微服务。对于我们的示例，设计的层用于微服务中。

API gateway 提供了一个接口，不同的客户端可以通过这个接口访问各个服务并解决各种问题，例如当您想要为同一服务向不同的客户端发送不同的响应时该做什么。例如，预订服务可以向移动客户端(最少信息)和桌面客户端(详细信息)发送不同的响应，在向第三方客户端再次提供不同的信息之前，向每个客户端提供不同的详细信息。

响应可能需要从两个或更多服务获取信息:

![Figure 11.3 – Microservice design ](img/Figure_11.3_B16561.jpg)

图 11.3–微服务设计

每个 API 服务都将作为一个单独的过程来开发和部署，并且它们之间的通信将基于公开的 API 来进行。

对于一个示例电子商务应用，您可以根据域和有界上下文划分应用，然后为每个域开发一个单独的微服务。快速查看提供以下微服务:

*   客户
*   命令
*   演员表
*   船舶
*   货品计价
*   库存
*   收款等等

您可以分别开发这些组件，并使用流程间(服务间)通信将解决方案连接在一起。

# 总结

在本章中，您已经探索了协议缓冲区，即 Protobuf，以及基于 gRPC 的服务实现。您已经开发了 gRPC 服务器，然后通过开发 gRPC 客户机来使用它的服务。您已经学习了 gRPC 服务器的单元测试和基于 gRPC 的服务的异常处理，还学习了微服务的基本概念。

现在，您已经掌握了通过使用 Protobuf 定义服务来开发基于 gRPC 的服务(服务器)和客户机的技能。

在下一章中，你将学习 web 服务中的分布式日志和跟踪。

# 问题

1.  为什么应该使用 gRPC 通过 HTTP/2 传输二进制大对象？
2.  您已经使用`com.google.rpc.Status`实现了异常处理。你能不用这个做到吗？
3.  `com.google.rpc.Status`和`io.grpc.Status`有什么区别？

# 延伸阅读

*   协议缓冲区(Protobuf)版本 3 文档:[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3%20)
*   Protobuf 的知名类型:[https://developers . Google . com/protocol-buffers/docs/reference/Google . proto buf](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf%20)
*   实用 gRPC:[https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc%20)