# 六、安全（授权和认证）

在前面的章节中，我们已经使用命令式和反应式编码风格开发了 RESTful web 服务(其中 **REST** 代表**代表性状态转移**)。现在，您将了解如何使用 Spring Security 来保护这些 REST 端点。您将为 REST 端点实现基于令牌的身份验证和授权。一个成功的认证提供两种类型的令牌——一个作为访问令牌的**JavaScript Object Notation(JSON)Web 令牌** ( **JWT** )和一个作为响应的刷新令牌。这个基于 JWT 的访问令牌然后被用来访问安全的统一资源定位符。如果现有的 JWT 已经过期，则使用刷新令牌来请求新的 JWT，并且有效的请求令牌提供新的 JWT 来使用。

您将把用户与角色相关联，例如**管理员**、**用户**等等。这些角色将被用作授权，以确保 REST 端点只有在用户拥有特定角色的情况下才能被访问。我们也将简要讨论一下**跨站请求伪造** ( **CSRF** )和**跨产地资源共享** ( **CORS** )。本章的主题分为以下几个部分:

*   使用 Spring 安全和 JWT 实现认证
*   确保其余**应用编程接口**(**API**)与 JWT 的安全
*   配置 CORS 和 CSRF
*   了解授权
*   测试安全性

在本章结束时，你将学会如何使用 Spring Security 实现认证和授权。

# 技术要求

您需要以下内容来开发和执行本章中的代码:

*   任何 Java **集成开发环境** ( **IDE** )，如 NetBeans、IntelliJ IDEA 或 Eclipse
*   **Java 开发工具包** ( **JDK** ) 15
*   用于克隆代码和从 Gradle 下载依赖项的互联网连接
*   Postman/cURL(用于 API 测试)

请访问以下链接下载代码文件:

[https://github . com/packt publishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/chapter 06](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/tree/main/Chapter06)

# 使用 Spring Security 和 JWT 实现认证

Spring Security 是一个由库集合组成的框架，它允许您实现企业应用安全性，而不必担心编写样板代码。在本章中，我们将使用 Spring 安全框架来实现基于令牌(JWT)的认证和授权。在本章的整个过程中，我们还将了解 CORS 和 CSRF 配置。

知道 Spring Security 也支持类似 jwt 的不透明令牌是很有用的。它们之间的主要区别在于如何从令牌中读取信息。您不能像使用 JWT 那样从不透明令牌中读取信息，只有发行者知道如何这样做。

注意

令牌是一串字符，如`5rm1tc1obfshrm2354lu9dlt5reqm1ddjchqh81 7rbk37q95b768bib0jf44df6suk1638sf78cef7 hfolg4ap3bkighbnk7inr68ke780744fpej0gtd 9qflm999o8q`。它允许您使用各种授权流无状态地调用安全的**超文本传输协议** ( **HTTP** )端点或资源。

在 [*第二章*](02.html#_idTextAnchor047)*Spring 概念和 REST API*中你已经了解了`DispatcherServlet`。这是客户端请求和 REST 控制器之间的接口。因此，如果您想为基于令牌的身份验证和授权放置一个逻辑，您必须在请求到达`DispatcherServlet`之前这样做。Spring 安全库提供 servlet 预过滤器(作为过滤器链的一部分),在请求到达`DispatcherServlet`之前进行处理。预过滤器是一个 servlet 过滤器，它在到达实际的 servlet 之前被处理，在 Spring Security 中是`DispatcherServlet`。类似地，在 servlet/控制器处理了一个请求之后，会处理 post 过滤器。

有两种方法可以实现基于令牌的(JWT)认证:使用`spring-boot-starter-security`或`spring-boot-starter-oauth2-resource-server`。**我们打算用后者。**

前者包含以下库:

*   `spring-security-core`
*   `spring-security-config`
*   `spring-security-web`

`spring-boot-starter-oauth2-resource-server`提供了以下内容，以及前面提到的所有三个 **Java 归档**文件( **JARs** ):

*   `spring-security-oauth2-core`
*   `spring-security-oauth2-jose`
*   `spring-security-oauth2-resource-server`
*   当你开始这一章的代码时，你可以找到下面的日志。您可以看到，默认情况下，`DefaultSecurityFilterChain`是自动配置的。`log`语句列出了`DefaultSecurityFilterChain`中已配置的过滤器，如下面的代码块所示:

```java
INFO [Chapter06,,,]     [null] [null] [null]     [null] 24052 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Will secure any request with [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@413e8246, org.springframework.security.web.context.SecurityContextPersistenceFilter@659565ed, org.springframework.security.web.header.HeaderWriterFilter@770c3ca2, org.springframework.web.filter.CorsFilter@4c7b4a31, org.springframework.security.web.csrf.CsrfFilter@1de6f29d, org.springframework.security.web.authentication.logout.LogoutFilter@5bb90b89, org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter@732fa176, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@2ae0eb98, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@3f473daf, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@2df7766b, org.springframework.security.web.session.SessionManagementFilter@711261c7, org.springframework.security.web.access.ExceptionTranslationFilter@1a7f2d34, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@3390621a]
```

因此，当客户端发出 HTTP 请求时，它将在到达 REST 控制器之前通过以下所有安全过滤器(顺序可能因身份验证结果而异):

1.  `WebAsyncManagerIntegrationFilter`
2.  `SecurityContextPersistenceFilter`
3.  `HeaderWriterFilter`
4.  `CorsFilter`
5.  `CsrfFilter`
6.  `LogoutFilter`
7.  `BearerTokenAuthenticationFilter`
8.  `RequestCacheAwareFilter`
9.  `SecurityContextHolderAwareRequestFilter`
10.  `AnonymousAuthenticationFilter`
11.  `SessionManagementFilter`
12.  `ExceptionTranslationFilter`
13.  `FilterSecurityInterceptor`
14.  最终到达控制器

此过滤器链可能会在未来版本中更改。此外，如果您只是使用`spring-boot-starter-security`或更改配置，安全过滤器链会有所不同。你可以在[的 https://docs . spring . io/spring-security/site/docs/current/reference/html 5/# servlet-security-filters](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-security-filters)找到`springSecurityFilterChain`中所有可用的过滤器。让我们看看如何使用过滤器来执行身份验证。

## 学习如何使用过滤器进行认证

如果您已经知道基于过滤器的身份验证，您可以跳过这一节，跳到使用 OAuth 2.0 资源服务器的*身份验证一节。*

我们将使用`spring-boot-starter-oauth2-resource-server`依赖性来实现认证，这不需要手动配置过滤器。`oauth2-resource-server`使用`BearerTokenAuthenticationFilter`进行认证。然而，理解基于过滤器的认证实现及其配置将简化 Spring 安全概念。对于基于过滤器的认证和授权，您可以简单地添加`spring-boot-starter-spring-security`。

您可以在适当的预过滤器中添加身份验证逻辑。如果请求未能通过身份验证，那么将向客户端发送一个带有拒绝访问异常(`AccessDeniedException`)的响应，并产生一个`HTTP 401 Unauthorized error`状态响应代码。

### 使用过滤器的用户名/密码验证流程

使用用户名/密码进行身份验证的工作方式如下图所示。如果用户提交了有效的用户名/密码组合，则调用成功，用户将获得一个带有`200 OK`状态代码的令牌(成功响应)。如果由于用户名/密码组合无效而导致呼叫失败，您将收到一个带有`401 Unauthorized`状态代码的响应:

![Figure 6.1 – Username/password authentication flow ](img/Figure_6.1_B16561.jpg)

图 6.1–用户名/密码认证流程

现在，让我们看看使用过滤器的令牌授权流程。

### 使用过滤器的令牌授权流程

使用令牌进行授权的工作方式如下图所示。如果用户提交一个带有`Authorization`报头的有效承载令牌，那么调用成功并调用`FilterChain.doFilter(request,response)`。因此，呼叫通过`DispatcherServlet`路由到控制器。最后，客户端得到一个带有适当状态代码的响应。

如果调用由于无效令牌而失败，`AccessDeniedException`被引发，并且从`AuthenticationEntryPoint`发送带有 401 未授权状态代码的响应。您可以通过实现一个`AuthenticationEntryPoint`接口并覆盖它的`commence()`方法来覆盖这种行为:

![Figure 6.2 – Token authorization flow using BasicAuthenticationFilter ](img/Figure_6.2_B16561.jpg)

图 6.2–使用 BasicAuthenticationFilter 的令牌授权流程

让我们首先在 Gradle 构建文件中添加所需的依赖项。

## 添加所需的梯度依赖关系

让我们将以下依赖项添加到`build.gradle`文件中，如下所示:

```java
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
implementation 'com.auth0:java-jwt:3.12.0'
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/build.gradle

Spring Boot Starter OAuth 2.0 资源服务器依赖项将添加以下 jar:

*   `spring-security-core`
*   `spring-security-config`
*   `spring-security-web`
*   `spring-security-oauth2-core`
*   `spring-security-oauth2-jose`
*   `spring-security-oauth2-resource-server`

对于 JWT 实现，我们将使用来自[auth0.com](http://auth0.com)的`java-jwt`库。

现在，您可以探索如何编写这两个过滤器——基于登录和基于令牌的身份验证。

### 为登录功能的过滤器编码

通过提供有效的用户名/密码组合，客户端在成功登录后将收到一个 JWT 令牌。Spring Security 提供了`UsernamePasswordAuthenticationFilter`，我们可以扩展它，然后覆盖它的`attemptAuthentication()`和`successfulAuthentication()`方法。让我们首先创建一个`LoginFilter`类，如下所示:

```java
public class LoginFilter extends 
    UsernamePasswordAuthenticationFilter {
  private final AuthenticationManager 
    authenticationManager;
  private final JwtManager tokenManager;
  private final ObjectMapper mapper;
  public LoginFilter(AuthenticationManager       authenticationManager, JwtManager tokenManager,      ObjectMapper mapper) {
    this.authenticationManager = authenticationManager;
    this.tokenManager = tokenManager;
    this.mapper = mapper;
    super.setFilterProcessesUrl("/api/v1/auth/token");
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/UNUSED/LoginFilter.java

这里，`JwtManager`是一个类，它允许您基于给定的`org.springframework.security.core.userdetails.User`创建一个 JWT。我们将在*添加一个 JWT 到 REST API*一节中对此进行更多的探讨。这个构造函数还允许您使用`setFilterProcessesUrl()`来配置登录 URL。如果您没有看到这个，那么默认情况下它会使用`/login` URL。

让我们首先覆盖`attemptAuthentication()`方法，如下所示:

```java
@Override
public Authentication attemptAuthentication(
    HttpServletRequest req,HttpServletResponse res) 
    throws AuthenticationException {
  if (!req.getMethod().equals(HttpMethod.POST.name())) {
    throw new MethodNotAllowedException(req.getMethod(), 
        List.of(HttpMethod.POST));
  }
  try (InputStream is = req.getInputStream()) {
    SignInReq user = new ObjectMapper().readValue(          is, SignInReq.class);
    return authenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(
            user.getUsername(),
            user.getPassword(),
            Collections.emptyList())
    );
  } catch (IOException e) {
    throw new RuntimeException(e);
  }
}
```

`org.springframework.security.authentication.AuthenticationManager`是春安的组成部分。我们只是通过传递用户名、密码和权限来使用它进行身份验证。权限作为空列表传递；但是，如果授权是从请求有效负载接收的，或者是从数据库/内存存储中获取的，那么您也可以传递授权。`SignInReq`是一个**普通旧 Java 对象** ( **POJO** )，包含`username`和`password`字段。

一旦登录成功，我们需要返回一个 JWT 作为响应。出于同样的目的，`successfulAuthentication()`方法被覆盖，如下面的代码片段所示:

```java
@Override
protected void successfulAuthentication(
    HttpServletRequest req,
    HttpServletResponse res,
    FilterChain chain,
    Authentication auth) throws IOException {
  User principal = (User) auth.getPrincipal();
  String token = tokenManager.create(principal);
  SignedInUser user = new SignedInUser()
            .username(principal.getUsername()).accessToken(
                      token);
  res.setContentType(MediaType.APPLICATION_JSON_VALUE);
  res.setCharacterEncoding("UTF-8");
  res.getWriter().print(mapper.writeValueAsString(user));
  res.getWriter().flush();
}
```

这里，使用`tokenManager.create()`方法创建一个令牌。`SignedInUser`是一个包含`username`和`token`字段的 POJO。

成功认证后，客户端接收用户名和令牌作为响应，然后可以通过在令牌值前面加上`"Bearer"`在`Authorization`头中使用该令牌。让我们看看如何在 Spring 安全过滤器链中配置和添加这些新的过滤器。

### 配置 Spring 安全性

这里缺少了关于`AuthenticationManager.authenticate()`如何工作的最后一块。`AuthenticationManager`在内部使用`UserDetailsService`bean——它只有一个方法，如下所示:

```java
UserDetails loadUserByUsername(String username) throws 
                               UsernameNotFoundException
```

您只需创建一个`UserDetailsService`接口的实现，并将其作为 bean 公开，如下面的代码片段所示:

```java
@Bean
@Override
protected UserDetailsService userDetailsService() {
  return userService;
}
```

这个 bean 在扩展了`WebSecurityConfigurerAdapter`的`SecurityConfig`类中公开，如下面的代码片段所示:

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
```

这里，`@EnableWebSecurity`注释用于配置`WebSecurityConfigurer`或扩展`WebSecurityConfigurerAdapter`的类，并自定义`WebSecurity`类。这个类使用一些覆盖方法来自动配置安全性。`configure()`方法允许您将 HTTP 安全性配置为一种**特定于域的语言** ( **DSL** )，使用如下所示的方法:

```java
@Override
protected void configure(HttpSecurity http) throws      Exception {
   http.authorizeRequests()
        .antMatchers(HttpMethod.POST, SIGN_UP_URL).permitAll()
        .anyRequest().authenticated()
        .and()
        .addFilter(new LoginFilter(             super.authenticationManager(), mapper))
        .addFilter(new JwtAuthenticationFilter(             super.authenticationManager()))
        .sessionManagement().sessionCreationPolicy(             SessionCreationPolicy.STATELESS);
}
```

`configure()`方法演示了如何使用 DSL 配置 HTTP 安全性并覆盖其默认实现。让我们来理解代码，如下:

*   您可以看到，通过使用`antMatchers()`方法，登录 URL 是允许的，无需认证。如果不将 HTTP 方法传递给`antMatchers()`，它将适用于所有的 HTTP 方法。`permitAll()`取消对端点及其附加 HTTP 方法的限制。
*   您可以使用`addFilter()`添加自定义过滤器。所有其他网址都需要认证。
*   为登录操作和基于 JWT 令牌的身份验证添加了两个额外的过滤器。
*   最后，会话策略被设置为`STATELESS`，因为我们将使用 REST 端点。

我们已经在本节中编写了登录过滤器的代码。现在，让我们添加用于令牌验证的`JwtAuthenticationFilter`类。

### 编码用于令牌验证的过滤器

让我们来探索如何使用过滤器实现身份验证。如果您使用`spring-boot-starter-security`依赖项，那么您可以扩展`BasicAuthenticationFilter`类并覆盖用于令牌验证的`doFilterInternal`方法，如下面的代码块所示。

首先，创建一个扩展了`BasicAuthenticationFilter`类的新类，如下所示:

```java
public class JwtAuthenticationFilter extends 
                          BasicAuthenticationFilter {
  public JwtAuthenticationFilter(AuthenticationManager 
                                    authenticationManager) {
    super(authenticationManager);
  }
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/UNUSED/JwtAuthenticationFilter.java

现在，我们可以覆盖`doFilterInternal`方法。这里，我们检查请求是否包含带有承载令牌的`Authorization`报头。如果它有`Authorization`头，那么它执行认证，将令牌添加到安全上下文，然后将调用传递给下一个安全过滤器。代码如下面的代码片段所示:

```java
@Override
protected void doFilterInternal(HttpServletRequest req,        HttpServletResponse res, FilterChain chain) throws                    IOException, ServletException {
  String header = req.getHeader("Authorization");
  if (Objects.isNull(header) || !header.startsWith("Bearer ")) {
    chain.doFilter(req, res);
    return;
  }
  Optional<UsernamePasswordAuthenticationToken>     authentication = getAuthentication(req);
  authentication.ifPresentOrElse(e -> 
      SecurityContextHolder.getContext().setAuthentication(          e), SecurityContextHolder::clearContext);
  chain.doFilter(req, res);
}
```

`getAuthentication()`方法执行令牌认证逻辑，如下面的代码片段所示:

```java
private Optional<UsernamePasswordAuthenticationToken> 
         getAuthentication(HttpServletRequest request) {
  String token = request.getHeader("Authorization");
  if (Objects.nonNull(token)) {
    DecodedJWT jwt = JWT.require(Algorithm.HMAC512(
         SECRET_KEY.getBytes(StandardCharsets.UTF_8)))
        .build()
        .verify(token.replace(TOKEN_PREFIX, ""));
    String user = jwt.getSubject();
    @SuppressWarnings("unchecked")
    List<String> authorities = (List) 
        jwt.getClaim("roles");
    if (Objects.nonNull(user)) {
      return Optional.of(
              new UsernamePasswordAuthenticationToken(
          user, null, Objects.nonNull(authorities) ? 
          authorities.stream().map(SimpleGrantedAuthority::
              new)
          .collect(Collectors.toList()) : 
              Collections.emptyList()));
    }
  }
  return Optional.empty();
}
```

在这里，`JWT`和`DecodedJWT`是`com.auth0:java-jwt`库的一部分。调用`verify()`执行给定令牌的验证，并返回一个`DecodedJWT`实例。如果验证失败，则返回`JWTVerificationException`。一旦验证完成，我们只需创建并返回接受主体、凭证和`GrantedAuthority`对象集合的`UsernamePasswordAuthenticationToken`令牌。`GrantedAuthority`是表示与认证对象相关联的权限的接口。缺省情况下，OAuth2 资源服务器允许您添加*范围*权限。但是，您可以添加自定义权限，例如*角色*。

到目前为止，我们已经了解了使用 Spring 过滤器链的认证和令牌授权流程。接下来，我们将使用`spring-boot-starter-oauth2-resource-server`依赖关系来实现认证。在下一节中，我们将探索使用 OAuth 2.0 资源服务器的认证和授权流程。

## 使用 OAuth 2.0 资源服务器进行认证

Spring Security OAuth 2.0 资源服务器允许您使用`BearerTokenAuthenticationFilter`实现认证和授权。这包含不记名令牌认证逻辑。然而，您仍然需要编写 REST 端点来生成令牌。让我们探索一下 OAuth2.0 资源服务器中的身份验证流程是如何工作的。请看下图:

![Figure 6.3 – Token authentication flow using OAuth 2.0 Resource Server ](img/Figure_6.3_B16561.jpg)

图 6.3–使用 OAuth 2.0 资源服务器的令牌认证流程

让我们来理解*图 6.3* 中描绘的流程，如下:

1.  客户端向`/api/v1/addresses`发送一个`GET` HTTP 请求。
2.  `BearerTokenAuthenciationFilter`开始行动。如果请求不包含`Authorization`报头，那么`BearerTokenAuthenticationFilter`不会验证请求，因为它没有找到承载令牌。它将调用传递给进行授权的`FilterSecurityInterceptor`。它抛出一个`AccessDeniedException`异常(在*图 6.3* 中标记为 **2** )。`ExceptionTranslationFilter`春天开始行动。控制转移到`BearerTokenAuthenticationEntryPoint`，它以一个`401 Unauthorized`状态和一个带有`Bearer`值的`WWW-Authenticate`标题做出响应。如果客户端收到带有值`Bearer`的`WWW-Authenticate`报头作为响应，这意味着它必须使用保存有效承载令牌的`Authorization`报头重试。在这个阶段，由于安全原因，请求缓存为`NullRequestCache`(即空的)，因为客户端可以重放请求。
3.  让我们假设 HTTP 请求包含一个`Authorization`头。它从 HTTP 请求中提取了`Authorization`头，显然，还从`Authorization`头中提取了令牌。它使用令牌值创建了一个`BearerTokenAuthenticationToken`的实例。`BearerTokenAuthenticationToken`是一种`AbstractAuthenticationToken`类，它实现了一个`Authentication`接口，代表被认证请求的令牌/主体。
4.  HTTP 请求被传递给`AuthenticationManagerResolver`，它根据配置提供`AuthenticationManager`。`AuthenticationManager`验证`BearerTokenAuthenticationToken`令牌。
5.  如果认证成功，那么在`SecurityContext`实例上设置`Authentication`。这个实例然后被传递给`SecurityContextHolder.`T3。该请求被传递到剩余的过滤器进行处理，然后路由到`DispatcherServlet`，最后到`AddressController`。
6.  如果认证失败，那么调用`SecurityContextHolder.clearContext()`来清除上下文值。`ExceptionTranslationFilter`春天开始行动。控制被移动到`BearerTokenAuthenticationEntryPoint`，其以一个`401 Unauthorized`状态和一个`WWW-Authenticate`报头响应，该报头的值包含适当的错误消息，例如`Bearer error="invalid_token", error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2020-12-14T17:23:30Z", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"`。

## 探索 JWT 的基本面

你需要一个形式的权限或权利来执行任何活动或访问任何信息。这种权力被称为索赔。声明被表示为一个键值对。键包含声明名称，值包含可以是有效 JSON 值的声明。声明也可以是关于 JWT 的元数据。

JWT 怎么发音？

根据[https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)，JWT 的建议发音与英文单词 *jot* 相同。

一个 **JWT** 是一个包含一组声明的编码字符串。这些声明要么是由一个 **JSON 网页签名** ( **JWS** )数字签名，要么是由 **JSON 网页加密** ( **JWE** )加密。 *JWT 是在各方之间安全传输索赔的独立方式*。本章的*进一步阅读*部分提供了这些**征求意见** ( **RFC** )建议的标准的链接。

### JWT 结构

JWT 是一个编码字符串，如`aaa.bbb.ccc`，由以下三部分组成，由点(`.`)分隔:

*   页眉
*   有效载荷
*   签名

一些网站，如[、https://jwt.io/](https://jwt.io/)或[、https://www.jsonwebtoken.io/](https://www.jsonwebtoken.io/)允许你查看一个 JWT 的内容并生成一个 JWT。

让我们看看下面的 JWT 字符串样本。您可以将其粘贴到前面提到的网站之一，以解码内容:

```java
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJzY290dCIsInJvbGVzIjpbIlVTRVIiXSwiaX NzIjoiTW9kZXJuIEFQSSBEZXZlbG9wbWVudCB3aXRoIFNw cmluZyBhbmQgU3ByaW5nIEJvb3QiLCJleHAiOjE2MTA1Mj A2MjksImlhdCI6MTYxMDE5ODIzNywianRpIjoiMjk3ZGY4 YTctNTE4Zi00ZWQ3LWJhNjYtOTJkYTQ5NGRkZDc2In0.MW-QOgAcNwLoEYINzqnDSm73-N86yf29-RUJsrApDyg
```

这个示例令牌演示了 JWT 是如何形成的，以及如何使用点将它分成三个部分。

#### 页眉

一个头由一个 Base64URL 编码的 JSON 字符串组成，通常包含两个键值对:一种令牌(带有一个`typ`密钥)和一个签名算法(带有一个`alg`密钥)。

JWT 字符串示例包含以下标题:

```java
{
  "typ": "JWT",
  "alg": "HS256"
}
```

前面的头包含`typ`和`alg`字段，分别代表类型和算法。

#### 有效载荷

有效载荷是 JWT 的第二部分，包含声明。这也是一个 Base64URL 编码的 JSON 字符串。有三种类型的索赔——注册索赔、公开索赔和私人索赔。这些概述如下:

*   **Registered claims**: A few claims are registered in the **Internet Assigned Numbers Authority** (**IANA**) **JSON Web Token Claims** registry, therefore these claims are known as Registered claims. These are not mandatory but are recommended. Some Registered claims are listed here:

    a.发布者声明(`iss` key):该声明标识发布令牌的主体。

    b.主题声明(`sub` key):这应该是代表 JWT 主题的唯一值。

    c.过期时间声明(`exp`键):这是一个表示过期时间的数值，过期或过期的 JWT 将被拒绝。

    d.在索赔时签发(`iat` key):该索赔标识了 JWT 的签发时间。

    e.JWT ID 声明(`jti` key):该声明代表 JWT 的唯一标识符。

    f.受众声明(`aud` key):该声明标识了接收者，这是 JWT 的目标。

    g.不在索赔前(`nbf`键):表示必须拒绝 JWT 的时间。

*   **公共债权**:这些是由 JWT 发行人定义的，不得与注册债权冲突。因此，它们应该或者在 IANA JWT 声明注册中心注册，或者将定义为具有防冲突名称空间的**统一资源标识符** ( **URI** )。
*   **私有声明**:这些是由发布者和受众定义和使用的定制声明。它们既没有注册也没有公开。

这里是一个包含以下有效载荷的样本 JWT 字符串:

```java
{
  "sub": "scott",
  "roles": [
    "USER"
  ],
  "iss": "Modern API Development with Spring and Spring 
         Boot",
  "exp": 1610520629,
  "iat": 1610198237,
  "jti": "297df8a7-518f-4ed7-ba66-92da494ddd76"
}
```

前面的有效载荷包含`sub`(主题)、`iss`(发布者)、`roles`(自定义声明角色)、`exp`(过期)、`iat`(发布于)和`jti` (JWT ID)字段。

#### 签名

签名也是一个 Base64 编码的字符串——第三部分。签名是为了保护 JWT 的内容。内容可见，但如果令牌已签名，则无法修改。Base64 编码的标头和有效负载将传递给签名的算法，同时传递的还有一个密钥或一个公钥，以使令牌成为签名令牌。如果您希望在有效载荷中包含任何敏感或秘密的信息，那么最好在将其分配给有效载荷之前对其进行加密。

签名确保内容一旦被接收回来就不会被修改。公钥/私钥的使用通过验证发送者来增强安全步骤。

你可以使用 JWT 和 JWE 的组合。然而，推荐的方法是首先使用 JWE 加密有效负载，然后对其进行签名。

在本章中，我们将使用公钥/私钥对令牌进行签名。让我们直接进入代码。

# 用 JWT 保护 REST APIs

在本节中，您将保护在 [*第 4 章*](04.html#_idTextAnchor086) 、*为 API 编写业务逻辑*中公开的 REST 端点。因此，我们将使用第 4 章 *中的代码，为 API*编写业务逻辑，并增强它以保护 API。

REST APIs 应该受到以下特性的保护:

*   没有 JWT 就不能访问任何安全的 API。
*   可以使用登录/注册或刷新令牌来生成 JWT。
*   只应为有效用户的用户名/密码组合或有效用户注册提供 JWT 和刷新令牌。
*   应该使用`bcrypt`强散列函数以编码格式存储密码。
*   JWT 应该是用 **RSA** (对于 **Rivest，Shamir，Adleman** )密钥用强算法签名。
*   有效负载中的声明不应存储敏感或安全信息。如果是的话，那么这些应该被加密。
*   您应该能够为某些角色授权 API 访问。

我们需要为授权流包含新的 API。先补充一下。

## 学习新的 API 定义

您将通过添加四个新的 API 来增强现有的 API——注册、登录、注销和刷新令牌。注册、登录和注销操作是不言自明的。

一旦现有令牌过期，刷新令牌将提供新的访问令牌(JWT)。这就是注册/登录 API 提供两种类型的令牌(访问令牌和刷新令牌)作为其响应的一部分的原因。JWT 访问令牌会自行过期，因此注销操作只会删除刷新令牌。

让我们将这些 API 添加到`openapi.yaml`文档中。

## 修改 API 规范

除了添加新的 API，您还需要为这些 API 添加一个新的`user`标签，它将通过`UserApi`接口公开所有这些 API。让我们首先添加一个注册端点。

### 注册端点

在`openapi.yaml`中的注册端点的规范后增加:

```java
/api/v1/users:
  post:
    tags:
      - user
    summary: Signup the a new customer (user)
    description: Creates a new customer (user), who can 
                 login and do the shopping.
    operationId: signUp
    requestBody:
      content:
        application/xml:
          schema:
            $ref: '#/components/schemas/User'
        application/json:
          schema:
            $ref: '#/components/schemas/User'
    responses:
      201:
        description: For successful user creation.
        content:
          application/xml:
            schema:
              $ref: '#/components/schemas/SignedInUser'
          application/json:
            schema:
              $ref: '#/components/schemas/SignedInUser'
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/resources/api/openapi.yaml

将下面的新模型`SignedInUser`添加到模式中。这个包含`accessToken`、`refreshToken`、`username`和`user ID`字段。添加模型的代码如下面的代码片段所示:

```java
SignedInUser:
  description: Signed-in user information
  type: object
  properties:
    refreshToken:
      description: Refresh Token, a unique secure string
      type: string
    accessToken:
      description: JWT Token aka access token
      type: string
    username:
      description: User Name
      type: string
    userId:
      description: User Identifier
      type: string
```

现在，让我们用添加登录端点。

### 登录端点定义

在`openapi.yaml`中的规范后增加用于登录端点:

```java
/api/v1/auth/token:
  post:
    tags:
      - user
    summary: Signin the customer (user)
    description: Signin the customer (user) that generates 
                 the JWT (access token) and refresh token, 
                 which can be used for accessing APIs.
    operationId: signIn
    requestBody:
      content:
        application/xml:
          schema:
            $ref: '#/components/schemas/SignInReq'
        application/json:
          schema:
            $ref: '#/components/schemas/SignInReq'
    responses:
      200:
        description: For user sign-in. Once successful, 
                     user 
                     receives the access and refresh token.
        content:
          application/xml:
            schema:
              $ref: '#/components/schemas/SignedInUser'
          application/json:
            schema:
              $ref: '#/components/schemas/SignedInUser'
```

我们需要一个新的模型`SignInReq`，用于登录请求有效载荷。它只包含用户名和密码字段。我们来补充一下，如下:

```java
SignInReq:
  description: Request body for Sign-in
  type: object
  properties:
    username:
      description: username of the User
      type: string
    password:
      description: password of the User
      type: string
```

### 注销端点

在`openapi.yaml`中的规范后添加用于签出端点:

```java
# Under the /api/v1/auth/token
delete:
  tags:
    - user
  summary: Signouts the customer (user)
  description: Signouts the customer (user). It removes the 
               refresh 
               token from DB. Last issued JWT should be 
               removed from 
               client end that if not removed last for 
               given 
               expiration time.
  operationId: signOut
  requestBody:
    content:
      application/xml:
        schema:
          $ref: '#/components/schemas/RefreshToken'
      application/json:
        schema:
          $ref: '#/components/schemas/RefreshToken'
  responses:
    202:
      description: Accepts the request for logout.
```

在理想的场景中，您应该从请求中移除用户的刷新令牌。您可以从令牌中获取用户 ID，然后使用该 ID 将其从`USER_TOKEN`表中删除。但是，在这种情况下，您应该发送一个有效的访问令牌。

我们选择了一种简单的方法来删除令牌，即由用户将其作为有效载荷发送。因此，这个端点需要下面的新模型，`RefreshToken`。下面是添加模型的代码:

```java
RefreshToken:
  description: Contains the refresh token
  type: object
  properties:
    refreshToken:
      description: Refresh Token
      type: string
```

最后，让我们添加一个端点来刷新访问令牌。

### 刷新令牌端点

为`openapi.yaml`中的刷新令牌端点添加以下规范:

```java
/api/v1/auth/token/refresh:
  post:
    tags:
      - user
    summary: Provides new JWT based on valid refresh token.
    description: Provides new JWT based on valid refresh 
                 token.
    operationId: getAccessToken
    requestBody:
      content:
        application/xml:
          schema:
            $ref: '#/components/schemas/RefreshToken'
        application/json:
          schema:
            $ref: '#/components/schemas/RefreshToken'
    responses:
      200:
        description: For successful operation.
        content:
          application/xml:
            schema:
              $ref: '#/components/schemas/SignedInUser'
          application/json:
            schema:
              $ref: '#/components/schemas/SignedInUser'
```

这里，我们通过在形成代表刷新令牌资源的 URI 方面定义刷新端点，引发了一个异常。相反，它生成一个新的访问令牌。

在现有的代码中，我们没有存储刷新令牌的表。所以，我们再补充一个。

## 使用数据库表存储刷新令牌

您可以通过修改 Flyway 数据库脚本来添加一个新表，如下面的代码片段所示:

```java
create TABLE IF NOT EXISTS ecomm.user_token (
 id uuid NOT NULL DEFAULT random_uuid(),
 refresh_token varchar(128),
 user_id uuid NOT NULL,
 PRIMARY KEY(id),
 FOREIGN KEY (user_id)
  REFERENCES ecomm.user(id)
);
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/resources/db/migration/V1.0.0__Init.sql

现在，您可以开始为 JWT 编写实现代码了。

## 实现 JWT 经理

在我们实现 JWT 管理器类之前，让我们添加一个常量类，它包含所有与安全功能相关的常量，如下面的代码片段所示:

```java
public class Constants {
  public static final String ENCODER_ID = "bcrypt";
  public static final String API_URL_PREFIX = "/api/v1/**";
  public static final String H2_URL_PREFIX = "/h2-
    console/**";
  public static final String SIGNUP_URL = "/api/v1/users";
  public static final String TOKEN_URL = 
    "/api/v1/auth/token";
  public static final String REFRESH_URL = 
                              "/api/v1/auth/token/refresh";
  public static final String AUTHORIZATION = 
    "Authorization";
  public static final String TOKEN_PREFIX = "Bearer ";
  public static final String SECRET_KEY = "SECRET_KEY";
  public static final long EXPIRATION_TIME = 900_000;
  public static final String ROLE_CLAIM = "roles";
  public static final String AUTHORITY_PREFIX = "ROLE_";
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/Constants.java

这些常量是不言自明的，除了`EXPIRATION_TIME` long 值，它以 15 分钟为时间单位。

现在，我们可以定义 JWT 经理类— `JwtManager`。`JwtManager`是一个自定义类，负责生成一个新的 JWT。它使用来自 auth0.com[的`java-jwt`库。您将使用公钥/私钥对令牌进行签名。让我们定义这个类，如下所示:](http://auth0.com)

```java
@Component
public class JwtManager {
  private final RSAPrivateKey privateKey;
  private final RSAPublicKey pubKey;
  public JwtManager(RSAPrivateKey privateKey, RSAPublicKey         pubKey) {
    this.privateKey = privateKey;
    this.pubKey = pubKey;
  }
  public String create(UserDetails principal) {
    final long now = System.currentTimeMillis();
    return JWT.create()
        .withIssuer("Modern API Development with Spring…")
        .withSubject(principal.getUsername())
        .withClaim(ROLE_CLAIM, 
               principal.getAuthorities().stream()
           .map(GrantedAuthority::getAuthority).collect(               toList()))
        .withIssuedAt(new Date(now))
        .withExpiresAt(new Date(now + EXPIRATION_TIME))
        .sign(Algorithm.RSA256(pubKey, privateKey));
  }
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/JwtManager.java

在这里，JWT 是来自`java-jwt`库的一个类，它为生成令牌提供了一个流畅的 API。它添加了发行人(`"iss"`)、主体(`"sub"`)、发行日期(`"iat"`)和到期日期(`"exp"`)的索赔。

它还添加了一个自定义声明，`ROLE_CLAIMS` ( `"roles"`)，使用来自`UserDetails`的授权填充。`UserDetails`是 Spring Security 提供的接口。你可以使用`org.springframework.security.core.userdetails.User.builder()`方法来创建一个`UserBuilder`类。`UserBuilder`是一个最终的构建器类，允许您构建`UserDetails`的实例。

最后，它使用一个`SHA256withRSA`算法，使用提供的公钥和私钥对 JWT 进行签名。JWT 报头为算法(`"alg"`)声明指定了一个`HS256`值。

南非共和国(Republic of South Africa)

RSA 是一种被**联邦信息处理标准**(**FIPS**)(*FIPS 186*)批准用于数字签名和**特别出版物**(**SP**)(*SP 800-56B*)用于密钥建立的算法。

签名是使用公钥和私钥完成的。让我们在示例电子商务应用中添加 RSA 密钥管理的代码。

### 生成公钥/私钥

您可以使用 JDK 的`keytool`来创建一个密钥库并生成公钥/私钥，如下面的代码片段所示:

```java
$ keytool -genkey -alias "jwt-sign-key" -keyalg RSA -keystore jwt-keystore.jks -keysize 4096
Enter keystore password:
Re-enter new password:
What is your first and last name?
  [Unknown]:  Modern API Development
What is the name of your organizational unit?
  [Unknown]:  Org Unit
What is the name of your organization?
  [Unknown]:  Packt
What is the name of your City or Locality?
  [Unknown]:  City
What is the name of your State or Province?
  [Unknown]:  State
What is the two-letter country code for this unit?
  [Unknown]:  IN
Is CN=Modern API Development, OU=Org Unit, O=Packt, L=City,                               ST=State, C=IN correct?
  [no]:  yes
Generating 4,096 bit RSA key pair and self-signed certificate (SHA384withRSA) with a validity of 90 days
        for: CN=Modern API Development, OU=Org Unit, O=Packt,              L=City, ST=State, C=IN
```

生成的密钥存储库应该放在`src/main/resources`目录下。这些密钥仅在生成后的 90 天内有效。因此，在运行本章代码之前，请确保在使用它时创建了一组新的公钥/私钥。

在`keytool`命令中使用的必需值也应该在`application.properties`文件中配置，如下所示:

```java
app.security.jwt.keystore-location=jwt-keystore.jks
app.security.jwt.keystore-password=password
app.security.jwt.key-alias=jwt-sign-key
app.security.jwt.private-key-passphrase=password
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/resources/application.properties

现在，我们可以在安全配置类中配置密钥库和公钥/私钥。

### 配置密钥库和密钥

让我们给添加一个`SecurityConfig`配置类来配置安全关系配置。这个类扩展了`WebSecurityConfigurerAdaptor`类。下面是执行此操作的代码:

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  @Value("${app.security.jwt.keystore-location}")
  private String keyStorePath;
  @Value("${app.security.jwt.keystore-password}")
  private String keyStorePassword;
  @Value("${app.security.jwt.key-alias}")
  private String keyAlias;
  @Value("${app.security.jwt.private-key-passphrase}")
  private String privateKeyPassphrase;
  …
  …
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java

我们在这里添加了所有在`application.properties`中定义的属性。

现在，我们可以利用`application.properties`中定义的属性来配置安全配置类中的`KeyStore`、`RSAPrivateKey`和`RSAPublicKey`bean，如下几节所示。

#### 密钥库 bean

您可以通过添加 following 方法并使用`@Bean`对其进行注释来为`KeyStore`创建一个新的 bean:

```java
@Bean
public KeyStore keyStore() {
  try {
    KeyStore keyStore =              KeyStore.getInstance(KeyStore.getDefaultType());
    InputStream resourceAsStream =              Thread.currentThread().getContextClassLoader()                 .getResourceAsStream(keyStorePath);
    keyStore.load(resourceAsStream,         keyStorePassword.toCharArray());
    return keyStore;
  } catch (IOException | CertificateException | 
                NoSuchAlgorithmException | 
                KeyStoreException e) {
    LOG.error("Unable to load keystore: {}", keyStorePath, e);
  }
  throw new IllegalArgumentException("Unable to load 
    keystore");
}
```

这使用来自`java.security`包的`KeyStore`类创建了一个`KeyStore`实例。它从`src/main/resources`包中加载密钥库，并使用`application.properties`文件中的密码配置。

#### RSAPrivateKey bean

通过添加以下方法并用`@Bean`对其进行注释，您可以为`RSAPrivateKey`创建一个新 bean:

```java
@Bean
public RSAPrivateKey jwtSigningKey(KeyStore keyStore) {
  try {
    Key key = keyStore.getKey(keyAlias,                 privateKeyPassphrase.toCharArray());
    if (key instanceof RSAPrivateKey) {
      return (RSAPrivateKey) key;
    }
  } catch (UnrecoverableKeyException |               NoSuchAlgorithmException |               KeyStoreException e) {
    LOG.error("Unable to load private key from keystore:               {}", keyStorePath, e);
  }
  throw new IllegalArgumentException("Unable to load         private key");
}
```

这个方法使用一个密钥别名和一个私钥密码来检索私钥，该私钥用于返回`RSAPrivateKey` bean。

#### RSAPublicKey bean

通过添加以下方法并用`@Bean`对其进行注释，您可以为`RSAPublicKey`创建一个新 bean:

```java
@Bean
public RSAPublicKey jwtValidationKey(KeyStore keyStore) {
  try {
    Certificate certificate = 
        keyStore.getCertificate(keyAlias);
    PublicKey publicKey = certificate.getPublicKey();
    if (publicKey instanceof RSAPublicKey) {
      return (RSAPublicKey) publicKey;
    }
  } catch (KeyStoreException e) {
    LOG.error("Unable to load private key from keystore: 
              {}", keyStorePath, e);
  }
  throw new IllegalArgumentException("Unable to load public 
        key");
}
```

同样，密钥别名用于从密钥库中检索证书。然后，从证书中检索并返回公钥。

如你所知，`JwtManager`使用这些公钥和私钥对 JWT 进行签名；因此，JWT 解码器应该使用相同的公钥来解码令牌。OAuth 2.0 资源服务器使用`org.springframework.security.oauth2.jwt.JwtDecoder`接口来解码令牌。因此，我们需要创建一个`JwtDecoder`实现的实例，并在其中设置相同的公钥来解码令牌。

Spring OAuth 2.0 资源服务器提供了一个`JwtDecoder`的`NimbusJwtDecoder`实现类。现在让我们用公钥创建一个 bean。

#### JwtDecoder Bean

您可以通过添加 following 方法并使用`@Bean`对其进行注释来为`JwtDecoder`创建一个新的 bean:

```java
@Bean
public JwtDecoder jwtDecoder(RSAPublicKey rsaPublicKey) {
  return NimbusJwtDecoder.withPublicKey(
    rsaPublicKey).build();
}
```

现在，我们可以实现新添加的 REST APIs。

## 实现新的 API

让我们实现使用`UserApi`公开的 API。`UserApi`是使用 OpenAPI Codegen 自动生成的代码的一部分。首先，我们需要向`user_token`表中添加一个新实体。

### 编码用户令牌功能

您可以基于`user_token`表创建一个`UserTokenEntity`，如下面的代码片段所示:

```java
@Entity
@Table(name = "user_token")
public class UserTokenEntity {
  @Id
  @GeneratedValue
  @Column(name = "ID", updatable = false, nullable = false)
  private UUID id;
  @NotNull(message = "Refresh token is required.")
  @Basic(optional = false)
  @Column(name = "refresh_token")
  private String refreshToken;
  @ManyToOne(fetch = FetchType.LAZY)
  private UserEntity user;
  …
  …
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/UserTokenEntity.java

类似地，我们可以用下面两种方法为`UserTokenEntity`公开下面的**创建、读取、更新和删除** ( **CRUD** )存储库:`deleteByUserId()`，它将根据给定的用户 ID 删除`UserToken`表记录，以及`findByRefreshToken()`，它将根据给定的刷新令牌查找`UserToken`表记录。下面的代码片段演示了该代码:

```java
public interface UserTokenRepository extends                    CrudRepository<UserTokenEntity, UUID> {
  Optional<UserTokenEntity> findByRefreshToken(    String refreshToken);
  Optional<UserTokenEntity> deleteByUserId(UUID userId);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserTokenRepository.java

现在，让我们将新的操作添加到`UserService`中。

### 增强用户服务类

我们还需要为`UserApi`接口在`UserService`中添加新方法。让我们将新方法添加到服务中，如下所示:

```java
UserEntity findUserByUsername(String username);
Optional<SignedInUser> createUser(User user);
SignedInUser getSignedInUser(UserEntity userEntity);
Optional<SignedInUser> getAccessToken(RefreshToken 
        refreshToken);
void removeRefreshToken(RefreshToken refreshToken);
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserService.java

这里，每个方法执行一个特定的操作，如下所示:

*   `findUserByUsername()`:根据给定的用户名查找并返回一个用户。
*   `createUser()`:向数据库添加一个新的注册用户。
*   `getSignedInUser()`:创建一个新的`SignedInUser`模型实例，它包含刷新令牌、访问令牌(JWT)、用户 ID 和用户名。
*   `getAcceessToken()`:为给定的有效刷新令牌生成并返回新的访问令牌(JWT)。
*   `removeRefreshToken()`:从数据库中删除刷新令牌。当用户想要注销时调用它。

让我们在`UserServiceImpl`类中实现这些方法。

#### findUserByUsername()实现

首先，您可以为`findUserByUsername()`添加实现，如下所示:

```java
@Override
public UserEntity findUserByUsername(String username) {
  if (Strings.isBlank(username)) {
    throw new UsernameNotFoundException("Invalid user.");
  }
  final String uname = username.trim();
  Optional<UserEntity> oUserEntity =               repository.findByUsername(uname);
  UserEntity userEntity = oUserEntity.orElseThrow(() -> 
              new UsernameNotFoundException(
                String.format("Given user(%s) not found.",                               uname)));
  return userEntity;
}
```

这是一个简单的操作。您根据给定的用户名查询数据库。如果找到，则返回用户，否则抛出一个`UsernameNotFoundException`异常。

#### createUser()实现

接下来，您可以为`createUser()`方法添加的实现，如下面的代码片段所示:

```java
@Override
@Transactional
public Optional<SignedInUser> createUser(User user) {
  Integer count = repository.findByUsernameOrEmail(
                         user.getUsername(), user.getEmail());
  if (count > 0) {
    throw new GenericAlreadyExistsException("
        Use different username and email.");
  }
  UserEntity userEntity = repository.save(toEntity(user));
  return Optional.of(createSignedUserWithRefreshToken(
    userEntity));
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserServiceImpl.java

这里，我们首先检查是否有任何现有用户在注册请求中被分配了相同的用户名或电子邮件。如果有，那么它只是引发一个异常，否则它在数据库中创建一个新用户，并使用`createSignedUserWithRefreshToken()`方法返回一个带有刷新和访问令牌的`SignedInUser`实例。

首先，我们可以在`UserServiceImpl`中添加一个私有的`createSignedUserWithRefreshToken()`方法，如下所示:

```java
private SignedInUser createSignedUserWithRefreshToken(
                                  UserEntity userEntity) {
  return createSignedInUser(userEntity)
         .refreshToken(createRefreshToken(userEntity));
}
```

这也使用了另一个私有方法`createSignedInUser()`，它返回`SignedInUser`；然后，它通过调用`createRefreshToken()`方法添加刷新标记。

让我们定义这两个`createSignedIn()`和`createSignedInUser()`私有方法，如下:

```java
private SignedInUser createSignedInUser(
    UserEntity userEntity) {
  String token = tokenManager.create(
       org.springframework.security.core.userdetails.User.
          builder()
      .username(userEntity.getUsername())
      .password(userEntity.getPassword())
      .authorities(Objects.nonNull(userEntity.getRole()) ? 
          userEntity.getRole().name() : "")
      .build());
  return new SignedInUser().username(
          userEntity.getUsername())
      .accessToken(token)
      .userId(userEntity.getId().toString());
}
private String createRefreshToken(UserEntity user) {
  String token = RandomHolder.randomKey(128);
  userTokenRepository.save(new UserTokenEntity()
                 .setRefreshToken(token).setUser(user));
  return token;
}
```

这里，`tokenManager`用于创建 JWT 的`createSignedIn()`方法中。`tokenManager`是`JwtManager`的一个实例。`User.builder()`方法用于创建一个`UserBuilder`类。`UserBuilder`是一个最终的构建器类，用于创建`UserDetails`的实例。`JwtManager.create()`方法使用这个`UserDetails`实例来创建一个令牌。

`createRefreshToken()`方法使用`RandomHolder`私有静态类来生成刷新令牌。这个令牌不是 JWT；然而，我们可以使用一个持续时间更长的有效令牌，比如一个一天有效的刷新令牌。将 JWT 作为刷新令牌保存在数据库中消除了使用 JWT 的唯一目的。因此，我们应该仔细考虑使用 JWT 作为刷新令牌，然后将其保存在数据库中。

让我们添加`RandomHolder`私有静态类，如下所示:

```java
// https://stackoverflow.com/a/31214709/109354
private static class RandomHolder {
  static final Random random = new SecureRandom();
  public static String randomKey(int length) {
    return String.format("%"+length+"s",
                  new BigInteger(
                      length*5/*base 32,2^5*/, random) 
        .toString(32)).replace('\u0020', '0');
  }
}
```

这个类使用一个`SecureRandom`实例来生成一个随机的`BigInteger`实例。然后，这个随机的`BigInteger`值被转换成基数为 32 的字符串。最后，如果在转换后的字符串中找到空格，空格将被替换为 0。

您还可以使用`org.apache.commons.lang3.RandomStringUtils.randomAlphanumeric()`方法来生成刷新令牌，或者使用任何其他安全的随机密钥生成器。

我们还需要修改`UserRepository`类来添加一个新的方法，该方法返回拥有给定用户名或电子邮件的用户的数量。

#### getSignedInUser()实现

`getSignedInUser()`方法的实现非常简单，如下面的代码片段所示:

```java
@Override
@Transactional
public SignedInUser getSignedInUser(UserEntity userEntity) {
  userTokenRepository.deleteByUserId(userEntity.getId());
  return createSignedUserWithRefreshToken(userEntity);
}
```

它首先从数据库中删除与给定用户相关联的现有令牌，然后返回使用`createSignedUserWithRefreshToken()`创建的`SignedInUser`的新实例，该实例先前在 *createUser()实现*小节中定义。

#### getAccessToken()实现

`getAccessToken()`方法的实现也很简单，如下面的代码片段所示:

```java
@Override
public Optional<SignedInUser> getAccessToken(                               RefreshToken refreshToken) {
  return userTokenRepository
      .findByRefreshToken(refreshToken.getRefreshToken())
      .map(ut -> Optional.of(createSignedInUser(             ut.getUser())
          .refreshToken(refreshToken.getRefreshToken())))
      .orElseThrow(() -> new InvalidRefreshTokenException(                                          "Invalid token."));
}
```

首先，它使用`UserTokenRepository`实例找到用户的令牌实体。然后，它使用检索到的`UserToken`实体填充`SignedInUser` POJO。`createSignedInUser()`方法不填充刷新令牌，因此我们将同样的刷新令牌分配给。如果它根据刷新令牌在数据库中找到了用户令牌条目，它将抛出一个异常。

您还可以为刷新令牌添加时间验证逻辑，例如，将刷新令牌创建时间存储在数据库中，并将配置的有效时间用于刷新令牌验证:一种 JWT 过期逻辑。

#### removeRefreshToken()实现

`removeRefreshToken()`方法的实现是，如下面的代码片段所示:

```java
@Override
public void removeRefreshToken(RefreshToken refreshToken) {
  userTokenRepository
    .findByRefreshToken(refreshToken.getRefreshToken())
      .ifPresentOrElse(userTokenRepository::delete, () -> {
        throw new InvalidRefreshTokenException(
                                         "Invalid token.");
      });
}
```

首先，它在数据库中找到给定的刷新令牌。如果没有找到，那么它抛出一个异常。如果在数据库中找到给定的刷新标记，那么它将删除它。

### 增强用户存储库类

让给`UserRepository`添加`findByUsername()`和`findByUsernameOrEmail()`方法，如下:

```java
public interface UserRepository 
                 extends CrudRepository<UserEntity, UUID> {
  Optional<UserEntity> findByUsername(String username);
  @Query(value = "select count(u.*) from ecomm.user u 
                 where u.username = :username or u.email = 
                 :email", 
                 nativeQuery = true
  Integer findByUsernameOrEmail(String username, String 
                                email);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserRepository.java

这将返回与给定用户名或电子邮件相匹配的记录数。

现在，我们可以实现`UserApi`接口来编写 REST 控制器。

## 实现 REST 控制器

您已经开发和增强了实现由 OpenAPI Codegen 在前一节中生成的`UserApi`接口中定义的 API 所需的服务和存储库。唯一待定的依赖项是`PasswordEncoder`。在存储和匹配作为登录请求的一部分给出的密码之前，需要使用`PasswordEncoder`对密码进行编码。

### 为 PasswordEncoder 添加 bean

您应该公开`PasswordEncoder` bean ,因为 Spring Security 需要知道您想要使用哪种编码进行密码编码，以及解码密码。让我们在`AppConfig`中添加一个`PasswordEncoder` bean，如下:

```java
@Bean
public PasswordEncoder passwordEncoder() {
  Map<String, PasswordEncoder> encoders = Map.of(
      "bcrypt", new BCryptPasswordEncoder(),
      "pbkdf2", new Pbkdf2PasswordEncoder(),
      "scrypt", new SCryptPasswordEncoder());
  return new DelegatingPasswordEncoder("bcrypt", encoders);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/AppConfig.java

你可以直接创建一个`BCryptPasswordEncoder`的新实例，并返回它进行`bcrypt`编码。然而，`DelegatingPasswordEncoder`的使用不仅允许你支持现有的密码，也方便了移植到一个新的，更好的编码器，如果将来有一个可用的话。这段代码使用 *Bcrypt* 作为默认的密码编码器，这是目前可用的编码器中最好的。

为了让`DelegatingPasswordEncoder`工作，您需要给编码的密码添加一个哈希算法前缀，比如`{bcrypt}`——例如，如果您在数据库中已经有了一个哈希密码，或者如果您正在数据库脚本中添加任何种子/测试用户，则在持久性存储中添加`{bcrypt}$2a$10$neR0EcYY5./tLVp4litNyuBy/kfrTsqEv8hiyqEKX0TXIQQwC/5Rm`。正如在`DelegatingPasswordEncoder`构造函数中配置的那样，新密码将存储带有前缀的密码。您已经将`bcrypt`传递给了构造函数，因此所有新密码都将以前缀`{bcrypt}`存储。

`PasswordEncoder`从持久性存储中读取密码，并在匹配前删除前缀。它使用相同的前缀来找出它需要使用哪个编码器来进行匹配。现在，您可以开始实现基于`UserApi`的新 API。

### 实现控制器类

首先，创建一个新的`AuthController`类，如下面的代码片段所示:

```java
@RestController
public class AuthController implements UserApi {
  private final UserService service;
  private final PasswordEncoder passwordEncoder;
  public AuthController(UserService service, 
                        PasswordEncoder passwordEncoder, ) {
    this.service = service;
    this.passwordEncoder = passwordEncoder;
  }
  …
  …
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/controller/AuthController.java

用`@RestController`注释了`AuthController`类，将其标记为 REST 控制器。然后，使用两个豆子，`UserService`和`PasswordEncoder`，它们将在`AuthController`建造的时候被注入。

我们先添加签到操作，如下:

```java
@Override
public ResponseEntity<SignedInUser> signIn(                              @Valid SignInReq signInReq) {
  UserEntity userEntity = service               .findUserByUsername(signInReq.getUsername());
  if (passwordEncoder.matches(
          signInReq.getPassword(), 
              userEntity.getPassword())) {
    return ok(service.getSignedInUser(userEntity));
  }
  throw new InsufficientAuthenticationException(        "Unauthorized.");
}
```

它首先使用`PasswordEncoder`实例找到用户并匹配密码。如果一切顺利，它返回带有刷新和访问令牌的`SignedInUser`实例；否则，它抛出一个异常。

让我们给`AuthController`添加其他的操作，如下:

```java
@Override
public ResponseEntity<Void> signOut(
                        @Valid RefreshToken refreshToken) {
  service.removeRefreshToken(refreshToken);
  return accepted().build();
}
@Override
public ResponseEntity<SignedInUser> signUp(
                              @Valid User user) {
  return status(HttpStatus.CREATED)
        .body(service.createUser(user).get());
}
@Override
public ResponseEntity<SignedInUser> getAccessToken(
                              @Valid RefreshToken refreshToken) {
  return ok(service.getAccessToken(refreshToken)
        .orElseThrow(InvalidRefreshTokenException::new));
}
```

所有操作如`signOut()`、`signUp()`和`getAccessToken()`都很简单，如下所示:

*   `signOut()`使用用户服务删除给定的刷新令牌。
*   `signUp()`创建一个有效的新用户并返回`SignedInUser`实例作为响应。
*   如果给定的刷新令牌有效，则`getAccessToken()`返回带有新访问令牌的`SignedInUser`。

我们已经完成了对控制器的编码。让我们在下一小节中配置安全性。

## 配置基于网络的安全性

您已经在前面的一个小节*配置 Spring 安全*中了解了如何配置 Spring 安全。在那个小节中，我们定义了一个新的类`SecurityConfig`，它扩展了`WebSecurityConfigurerAdaptor`，并且也用`@EnableWebSecurity`进行了注释。

让我们修改它被覆盖的`configure()`方法，这将允许我们使用 DSL (fluent 方法)配置`HttpSecurity`。让我们进行以下配置:

*   使用`httpBasic().disable()`禁用 HTTP **基本认证** ( **BA** )。
*   使用`formLogin().disable()`禁用表单登录。
*   使用`authorizeRequests()`基于 URL 模式限制访问。
*   使用`antMatchers()`配置 URL 模式和相应的 HTTP 方法，这允许您使用`ant`(构建工具)模式匹配样式。也可以使用`mvcMatchers()`，它使用与 Spring **模型-视图-控制器** ( **MVC** )相同的模式匹配风格。
*   除了那些由`authorizeRequests()`明确配置的 URL 之外，所有的 URL 都应该被任何认证用户允许(通过使用`anyRequest().authenticated()`)。
*   启用 OAuth 2.0 资源服务器的 JWT 承载令牌支持(`oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt)`)。
*   启用`STATELESS`会话创建策略(即不会创建任何`HTTPSession`)。

让我们将这些添加到`HttpSecurity`中，如下所示:

```java
@Override
protected void configure(HttpSecurity http) throws 
    Exception {
  http.httpBasic().disable().formLogin().disable()
      .and()
      .headers().frameOptions().sameOrigin() // for H2 
                                             // Console
      .and()
      .authorizeRequests()
      .antMatchers(HttpMethod.POST, TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.DELETE, 
          TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.POST, SIGNUP_URL).permitAll()
      .antMatchers(HttpMethod.POST, 
          REFRESH_URL).permitAll()
      .antMatchers(H2_URL_PREFIX).permitAll()      
      .anyRequest().authenticated()
      .and()
      .oauth2ResourceServer(OAuth2ResourceServerConfigurer:
 :jwt)
      .sessionManagement().sessionCreationPolicy(
             SessionCreationPolicy.STATELESS);
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java

在这里，我们为 H2 控制台应用添加了一个更重要的配置。H2 控制台**用户界面** ( **UI** )是基于 HTML 框架的。H2 控制台用户界面不会在浏览器中显示，因为默认情况下，安全标头(`X-Frame-Options`)不会与允许具有相同来源的帧的权限一起发送。所以需要配置`headers().frameOptions().sameOrigin()`。

现在，您可以配置 CORS 和 CSRF。

# 配置 CORS 和 CSRF

出于安全原因，浏览器限制来自脚本的跨来源请求。例如，从[http://mydomain.com](http://mydomain.com)打给[http://mydomain-2.com](http://mydomain-2.com)的电话不能使用脚本。此外，一个原点不仅表示一个域，事实上，它还包括一个方案和一个端口。

在到达任何端点之前，浏览器使用 HTTP 方法选项发送预检请求，以检查服务器是否允许实际的请求。该请求包含以下标题:

*   实际请求的标题(`Access-Control-Request-Headers`)
*   包含实际请求的 HTTP 方法的头(`Access-Control-Request-Method`)
*   包含请求来源(方案、域和端口)的`Origin`报头
*   如果来自服务器的响应是成功的，那么只有浏览器允许实际的请求触发。服务器用其他头来响应，比如`Access-Control-Allow-Origin`，它包含允许的起点(星号`*`值表示任何起点)、`Access-Control-Allow-Methods`(允许的方法)、`Access-Control-Allow-Headers`(允许的头)和`Access-Control-Max-Age`(以秒为单位的允许时间)。

你可以配置 CORS 来处理跨来源的请求。为此，您需要进行以下两项更改:

*   使用一个`CorsConfiguration`实例添加一个负责 CORS 配置的`CorsConfigurationSource` bean。
*   将`cors()`方法添加到`configure()`方法的`HTTPSecurity`中。如果添加了`corsFilter` bean，则使用`CorsFilter`，否则使用`CorsConfigurationSource`。如果两者都没有配置，那么它使用 Spring MVC 模式检查器处理程序。

现在让我们将`CorsConfigurationSource` bean 添加到`SecurityConfig`类中。

默认允许值(`new CorsConfiguraton().applyPermitDefaultValues()`)为任何来源(`*`)、所有标题和简单方法(`GET`、`HEAD`、`POST`)配置 CORS，允许的最大时限为 30 分钟。

您需要允许几乎所有的 HTTP 方法，包括`DELETE`方法，并且需要更多的定制配置；因此，我们将使用以下 bean 定义:

```java
@Bean
CorsConfigurationSource corsConfigurationSource() {
  CorsConfiguration configuration = new 
      CorsConfiguration();
  configuration.setAllowedOrigins(Arrays.asList("*"));
  configuration.setAllowedMethods(Arrays.asList("HEAD", 
      "GET", "PUT", "POST", "DELETE", "PATCH"));
   // For CORS response headers
  configuration.addAllowedOrigin("*");
  configuration.addAllowedHeader("*");
  configuration.addAllowedMethod("*");
  UrlBasedCorsConfigurationSource source = new 
      UrlBasedCorsConfigurationSource();
  source.registerCorsConfiguration("/**", configuration);
  return source;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java

这里，使用默认构造函数创建一个`CorsConfiguration`实例，然后设置允许的来源、允许的方法和响应头。最后，在将它注册到`UrlBasedCorsConfigurationSource`实例并返回时，您将它作为参数传递。

让我们把`cors()`加到`HttpSecurity`上，如下:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
  http.httpBasic().disable().formLogin().disable()
      .csrf().ignoringAntMatchers(API_URL_PREFIX, 
          H2_URL_PREFIX)
      .and()
      .headers().frameOptions().sameOrigin() // for H2 Console
      .and()
      .cors()
      .and()
      .authorizeRequests()
      .antMatchers(HttpMethod.POST, TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.DELETE, 
          TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.POST, SIGNUP_URL).permitAll()
      .antMatchers(HttpMethod.POST, 
          REFRESH_URL).permitAll()
      …
      …
}
```

这里，我们还使用`csrf()` DSL 对 CSRF 进行了配置。除了以`/api/v1`开头的网址和`/h2-console` H2 数据库控制台网址之外，我们对所有网址都应用了 CSRF 保护。您可以根据需要更改配置。

我们先来了解一下什么是 CSRF/XSRF。 **CSRF** 或 **XSRF** 代表**跨源请求伪造**，这是一个 web 安全漏洞。让我们假设你是一个银行客户，目前正在登录银行。您可能会收到一封电子邮件，然后单击邮件中的链接，或者单击任何可能包含恶意脚本的恶意网站的链接。然后，这个脚本向您的银行发送一个资金转账请求。然后，银行会将资金转移到犯罪人的账户，因为银行认为当您登录时，请求已经由您发出。这只是一个例子。

为了防止这种攻击，应用为每个新请求发送与登录用户相关联的新的唯一 CSRF 令牌。这些令牌存储在隐藏的表单字段中。当用户提交表单时，同样的令牌应该随请求一起返回。然后，应用验证 CSRF 令牌，并且仅在验证成功的情况下处理请求。这是因为恶意脚本由于相同的原始策略而无法读取令牌，

然而，如果一个攻击者也欺骗你透露 CSRF 令牌，那么就很难阻止这样的攻击。您可以通过使用`csrf().disable()`禁用此 web 服务的 CSRF 保护，因为它只提供 REST 端点。

现在，让我们继续到最后一部分，在这里您将基于用户的角色配置授权。

# 了解授权

您用于验证的有效用户名/密码或访问令牌允许您访问安全资源,如 URL、web 资源或安全网页。授权先行一步；它允许您使用范围(如读、写)或角色(如管理员、用户、经理等)来进一步配置访问安全性。Spring Security 允许您配置任何自定义权限。

我们将为我们的示例电子商务应用配置三种类型的角色——即客户(用户)、管理员和**客户支持代表** ( **CSR** )。显然，每个用户都会拥有自己特定的权限。例如，用户可以在线下订单和购物，但是不能访问 CSR 或管理资源。类似地，CSR 不应该能够访问仅限管理员使用的资源。允许基于权限或角色访问资源的安全配置称为授权。失败的身份验证应返回 HTTP(状态 401 未授权)，失败的授权应返回 HTTP 状态 403(禁止)，这意味着用户已通过身份验证，但不具有访问资源所需的权限/角色。

让我们在一个示例电子商务应用中介绍这三个角色，如下面的代码片段所示:

```java
public enum RoleEnum implements GrantedAuthority {
  USER(Const.USER), ADMIN(Const.ADMIN), CSR(Const.CSR);
  private String authority;
  RoleEnum(String authority) { this.authority = authority; }
  @Override
  @JsonValue
  public String getAuthority() { return authority; }
  @JsonCreator
  public static RoleEnum fromAuthority(String authority) {
    for (RoleEnum b : RoleEnum.values()) {
      if (b.authority.equals(authority)) { return b; }
    }
    throw new IllegalArgumentException("Unexpected value");
  }
  @Override
  public String toString() { return String.valueOf(authority); }
  public class Const {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String CSR = "ROLE_CSR";
  }
}
```

这里，我们已经声明了一个`enum`，它实现了 Spring Security 的`GrantedAuthority`接口来覆盖`getAuthority()`方法。`GrantedAuthority`是授予一个`Authentication`(接口)对象的权限。如您所知，`BearerTokenAuthenticationToken`是一种实现了`Authentication`接口的`AbstractAuthenticationToken`类，它代表了经过身份验证的请求的令牌/主体。我们在`enum`中为用户角色使用了`String`常量，因为我们在方法级别配置基于角色的限制时需要这些常量。

我们来详细讨论一下角色和权限。

## 角色和权力

您可以使用权限进行更细粒度的控制，而角色应该应用于大型权限集。角色是带有`ROLE_`前缀的权限。这个前缀在 Spring Security 中是可配置的。

Spring Security 提供了`hasRole()`和`hasAuthority()`方法来应用基于角色和权限的限制。`hasRole()`和`hasAuthority()`几乎相同，但是`hasRole()`方法映射的是不带`ROLE_`前缀的`Authority`。如果您使用`hasRole('ADMIN')`，您的管理员`enum`必须是`ROLE_ADMIN`而不是`ADMIN`，因为角色是一个权限，应该有一个`ROLE_`前缀，而如果您使用`hasAuthority('ADMIN')`，您的`ADMIN` `enum`必须只有`ADMIN`。

默认情况下，OAuth 2.0 资源服务器根据范围(`scp`)声明来填充权限。如果您提供对用户资源(如订单历史记录等)的访问权限，以便与其他应用集成，那么您可以在授予对第三方集成的其他应用的访问权限之前，限制应用对用户帐户的访问权限。第三方应用可以请求一个或多个作用域；该信息随后在同意屏幕中呈现给用户，并且颁发给应用的访问令牌将被限制在授予的范围内。然而，在这一章中，我们不提供 OAuth 2.0 授权流，而是限制对 REST 端点的安全访问。

如果 JWT 包含一个名为“scope”(`scp`)的声明，那么 Spring Security 将使用该声明中的值，通过在每个值前面加上前缀`"SCOPE_"`来构建权限。例如，如果一个有效载荷包含一个`scp=["READ","WRITE"]`声明，这意味着一个`Authority`列表将由`SCOPE_READ`和`SCOPE_WRITE`组成。

我们需要更改默认的权限映射行为，因为 scope ( `scp`)声明是 Spring 中 OAuth2.0 资源服务器的默认权限。我们可以通过在您的安全配置中为`OAuth2ResourceServer`中的`JwtConfigurer`添加一个定制的身份验证转换器来做到这一点。让我们添加一个返回转换器的方法，如下所示:

```java
private Converter<Jwt, AbstractAuthenticationToken>                                getJwtAuthenticationConverter() {
  JwtGrantedAuthoritiesConverter authorityConverter =                    new JwtGrantedAuthoritiesConverter();
  authorityConverter.setAuthorityPrefix(AUTHORITY_PREFIX);
  authorityConverter.setAuthoritiesClaimName(ROLE_CLAIM);
  JwtAuthenticationConverter converter =                         new JwtAuthenticationConverter();
  converter.setJwtGrantedAuthoritiesConverter(      authorityConverter);
  return converter;
}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java

这里，首先创建一个`JwtGrantedAuthorityConverter`的新实例，然后分配一个权限前缀(`ROLE_`)和权限声明名称(JWT 声明的关键字)为`roles`。

现在，我们可以使用这个私有方法来配置 OAuth 2.0 资源服务器。现在，您可以使用以下代码修改现有的配置。我们还可以在下面的代码片段中添加配置，以便在`POST /api/v1/addresses` API 调用上添加基于角色的限制:

```java
@Override
protected void configure(HttpSecurity http) throws 
    Exception {
  http.httpBasic().disable().formLogin().disable()
      .csrf().ignoringAntMatchers(API_URL_PREFIX, 
        H2_URL_PREFIX)
      .and()
      .headers().frameOptions().sameOrigin() // for H2 
                                             // Console
      .and()
      .cors()
      .and()
      .authorizeRequests()
      .antMatchers(HttpMethod.POST, TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.DELETE, 
        TOKEN_URL).permitAll()
      .antMatchers(HttpMethod.POST, SIGNUP_URL).permitAll()
      .antMatchers(HttpMethod.POST, 
         REFRESH_URL).permitAll()
      .antMatchers(H2_URL_PREFIX).permitAll()
      .mvcMatchers(HttpMethod.POST, "/api/v1/addresses/**")
      .hasAuthority(RoleEnum.ADMIN.getAuthority())
      .anyRequest().authenticated()
      .and()
      .oauth2ResourceServer(oauth2ResourceServer -> 
         oauth2ResourceServer.jwt(jwt ->
            jwt.jwtAuthenticationConverter(
               getJwtAuthenticationConverter())))
      .sessionManagement().sessionCreationPolicy(
         SessionCreationPolicy.STATELESS);
}
```

在设置此配置以添加地址(`POST /api/v1/addresses`)后，现在需要身份验证和授权。这意味着登录的用户必须拥有`ADMIN`角色才能成功调用这个端点。此外，我们已经将默认声明从`scope`更改为`role`。

现在，我们可以进一步处理方法级的基于角色的限制。Spring Security 提供了一个特性，允许您使用一组注释，比如`@PreAuthorize`、`@Secured`和`@RolesAllowed`，对 Spring beans 的公共方法进行基于权限/角色的限制。默认情况下，这些是禁用的，因此您需要显式启用它们。

让我们通过向 Spring 安全配置类添加`@EnableGlobalMethodSecurity(prePostEnabled = true)`注释来启用这些功能，如下所示:

```java
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
```

现在，您可以使用`@PreAuthorize`(给定的访问控制表达式将在方法调用之前进行评估)和`@PostAuthorize`(给定的访问控制表达式将在方法调用之后进行评估)注释来对 Spring beans 的公共方法进行限制，因为在启用全局方法级安全性时，您已经将`prePostEnabled`属性设置为`true`。

`@EnableGlobalMethodSecurity`还支持以下属性:

*   `securedEnabled`:这允许你在公共方法上使用`@Secured`注释。
*   `jsr250Enabled`:这允许你使用 JSR-250 注解，比如`@RolesAllowed`。`@RolesAllowed`可以应用于公共类和方法。顾名思义，您可以使用角色列表进行访问限制。

`@PreAuthorize` / `@PostAuthorize`比其他安全注释更强大，因为它们不仅可以针对权限/角色进行配置，还可以使用任何有效的 **Spring 表达式语言** ( **SpEL** )表达式。

出于演示目的，让我们将`@PreAuthorize`注释添加到`deleteAddressesById()`方法中，该方法与`AddressController`中的`DELETE /v1/auth/addresses/{id}`相关联，如以下代码片段所示:

```java
@PreAuthorize("hasRole('" + Const.ADMIN + "')")
@Override
public ResponseEntity<Void> deleteAddressesById(String id) {
  service.deleteAddressesById(id);
  return accepted().build();
}
```

*   这里，`hasRole()`是内置的`SpEL`表达式。我们需要传递一个有效的 *SpEL* 表达式，而且应该是一个`String`。用于形成这个 *SpEL* 表达式的任何变量都应该是 final。因此，我们在`RoleEnum`枚举中声明了最终字符串常量(例如，`Const.ADMIN`)。
*   现在，`DELETE /api/v1/addresses/{id}` REST API 只有在用户拥有`ADMIN`角色时才能被调用。
*   Spring Security provides various built-in SpEL expressions, such as `hasRole()`. Here are some others:

    a. `hasAnyRole(String… roles)`:如果委托人的角色与任何给定的角色匹配，则返回`true`。

    b `. hasAuthority(String authority)`:如果委托人已经授权，则返回`true`。同样，你也可以使用`hasAnyAuthority(String… authorities)`。

    `c. permitAll`:返回`true`。

    `d. denyAll`:返回`false`。

*   `isAnonymous()`:如果当前用户是匿名的，则返回`true`。
*   `isAuthenticated()`:如果当前用户不是匿名的，则返回`true`。

这些表达式的完整列表可在[https://docs . spring . io/spring-security/site/docs/current/reference/html 5/# El-access](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access)获得。

类似地，您可以对其他 API 应用访问限制。让我们在下一部分测试安全性。

# 测试安全性

您可以使用下面的命令克隆代码并构建它:

```java
Run it from project home
$ gradlew clean build
```

这段代码是用 Java 15 测试的。

重要的

确保再次生成密钥，因为由 JDK keytool 生成的密钥只有 90 天的有效期。

然后，您可以从项目主目录运行该应用，如下面的代码片段所示:

```java
$ java -jar build/libs/Chapter06-0.0.1-SNAPSHOT.jar
```

现在，你一定很期待测试。让我们测试我们的第一个用例。

让我们点击没有`Authorization`头的`GET /api/vi/addresses` API，如下面的代码片段所示:

```java
$ curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json'
< HTTP/1.1 401
< Vary: Origin
< Vary: Access-Control-Request-Method
< Vary: Access-Control-Request-Headers
< WWW-Authenticate: Bearer
< X-Content-Type-Options: nosniff
< X-XSS-Protection: 1; mode=block
< Cache-Control: no-cache, no-store, max-age=0, must-revalidate
< Other information is removed for brevity
```

这将返回 HTTP 状态 401(未授权)和一个`WWW-Authenticate: Bearer`响应头，其中建议请求应该用一个`Authorization`头发送。

让我们使用无效令牌再次发送请求，如下所示:

```java
$  curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9… rest of the JWT string removed for brevity'
< HTTP/1.1 401
< Vary: Origin
< Vary: Access-Control-Request-Method
< Vary: Access-Control-Request-Headers
< WWW-Authenticate: Bearer error="invalid_token", error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2021-01-09T14:19:49Z", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
< Other information is removed for brevity
```

服务器再次以 401(未授权)响应，但这次是一条错误消息和描述，告诉我们给定的令牌已经过期。它还可以根据给定的承载令牌发送带有 HTTP 状态 401 的`invalid_token`错误，如下所示:

*   如果令牌不是格式良好的 JWT，那么它会显示`An error occurred while attempting to decode the Jwt: Invalid JWT serialization: Missing dot delimiter(s).`
*   如果令牌没有有效的签名，那么它会显示`An error occurred while attempting to decode the Jwt: Signed JWT rejected: Invalid signature`。

我们使用 Flyway 数据库迁移脚本创建了两个用户:`scott/tiger`和`scott2/tiger`。现在，让我们使用用户名`scott`进行登录，以获得有效的 JWT，如下所示:

```java
$ curl -X POST 'http://localhost:8080/api/v1/auth/token' -H 'Content-Type: application/json' -H 'Accept: application/json' -d '{
    "username": "scott",
    "password": "tiger"
}'
{
    "refreshToken": "3i2tlrmdqnp60drl6i9c2kdm36s48qg5vm2ucgt flsk0cjo4dthhjan9aj1ck83det8m8hkl461cqkfl57puk81ct6j09ilpo ranf1jj414ht4ob7dkcakq6lk92cnct",
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJzY290dCIsInJvbGVzIjpbIlVTRVI iXSwiaXNzIjoiTW9kZXJuIEFQSSBEZXZlbG9wbW VudCB3aXRoIFNwcmluZyBhbmQgU3ByaW5nIEJvb 3QiLCJleHAiOjE2MTA5NTQ3NzMsImlhdCI6MTYxMDk1Mzg3M30.GOE2WwgN-1s82KqU2U-hd7rcrhdblrfV59HXTL9B7BL2eAgshjxtJGVhj9CtR_LQwA54fZo0yVwYFyMUrQBBFkn_2fDRU_8j1LD91N HDO1wqpiVx9kRzB9nUIR0OcpT2OdMaPD_HpmRiQOchwZSxsi7_c5dO59-URJn17ahXeBDJoAFrYQGmetjvuZtGwd9nLAvdSq9KKOL_gLle1wqsjJOYqJ9l_djLzeaO3Xgg-Kva5rmyZP0tWws7A95H2Si2tIqRGESZUCAQ3GbezpZB2OO_YgyCkQSuJkFTuQWc1MFbqtgeRcRiklX53BBngcHCfAeOAsBtKL17yXnd-IQSPn1GBLmCJh1-nMgrwAKS-lbx1k55FI93qGVoXDFFnVRUgjf_mA5aKNx9VECDtaXLDR7TA7LgjXiDXJ3ZPRNsF3-8fagHNKq42BjPdGH62XtWBve_Ide00DXNtSffHAlo2ukjGpN_zdmuZu7-UNeObg3g_dD6vvSnfupylJbVJooVDOQctR0u-ausMNKvh32NBG4-IQS2pW5Xo3i3l0GEtTP8AIy0vtafnFWBJI_OwTKVM8s966cgliswmeahLxIpLPeSo4Q0NxdE7MDnGg8wUbnzxoiq-ExcUjm_e7M2N7LMgdlsk0asQQYOJDe50EwMr2oE9ZDQepTtqwfSjcpKdKQ",
    "username": "scott",
    "userId": "a1b9b31d-e73c-4112-af7c-b68530f38222"
}
```

它返回一个刷新和一个访问令牌。让我们使用这个访问令牌再次调用`GET /api/v1/addresses` API(请注意，`Authorization`头中的`Bearer`令牌值取自之前`GET /api/v1/auth/token` API 调用的响应)。代码如下面的代码片段所示:

```java
$  curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.ey… rest of the JWT string removed for brevity'
< Response
[
    {
        "links": [
            {
                "rel": "self",
                "href": "http://localhost:8080/api/v1/                addresses/a731fda1-aaad-42ea-bdbc-a27eeebe2cc0"
            }
        ],
        "id": "a731fda1-aaad-42ea-bdbc-a27eeebe2cc0",
        "number": "9I-999",
        "residency": "Fraser Suites Le Claridge",
        "street": "Champs-Elysees",
        "city": "Paris",
        "state": "Île-de-France",
        "country": "France",
        "pincode": "75008"
    }
]
```

这一次，通话成功。现在，让我们使用刷新令牌来获得新的访问令牌，如下所示:

```java
$ curl -X POST 'http://localhost:8080/api/v1/auth/token/refresh'
 -H 'Content-Type: application/json' -H 'Accept: application/json'
 -d '{
    "refreshToken": "3i2tlrmdqnp60drl6i9c2kdm36s48qg5vm2ucgtflsk0cjo4dth hjan9aj1ck83det8m8hkl461cqkfl57puk81ct6j09ilporanf1j j414ht4ob7dkcakq6lk92cnct"
}'
< Response
{
    "refreshToken": "3i2tlrmdqnp60drl6i9c2kdm36s48qg5vm2ucgtflsk0cjo4dthhjan9 aj1ck83det8m8hkl461cqkfl57puk81ct6j09ilporanf1jj4 14ht4ob7dkcakq6lk92cnct",
    "accessToken": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9\. 
                    Rest of token truncated for brevity",
    "username": "scott",
    "userId": "a1b9b31d-e73c-4112-af7c-b68530f38222"
}
```

这一次，它返回一个新的访问令牌，与有效负载中给出的刷新令牌相同。

如果在调用刷新令牌 API 时传递无效的刷新令牌，它将提供以下响应:

```java
{"errorCode":"PACKT-0010",
"message":"Requested resource not found. Invalid token.", "status":404,"url":"http://localhost:8080/api/v1/auth/token/refresh","reqMethod":"POST","timestamp":"2021-01-18T07:20:35.846649200Z"}
```

在使用 JWT 测试了身份验证之后，我们现在可以测试授权了。让我们使用用户`SCOTT`创建的令牌创建一个地址。`SCOTT`有一个`USER`的角色。下面是执行此操作的代码:

```java
$ curl -v -X POST 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.ey
Rest of the token is truncated for brevity'
-d '{
    "number": "9I-999",
    "residency": "Fraser Suites Le Claridge",
    "street": "Champs-Elysees",
    "city": "Paris",
    "state": "Ile-de-France",
    "country": "France",
    "pincode": "75008"
}'
< HTTP/1.1 403
< Vary: Origin
< Vary: Access-Control-Request-Method
< Vary: Access-Control-Request-Headers
< WWW-Authenticate: Bearer error="insufficient_scope", error_description="The request requires higher privileges than provided by the access token.", error_uri="https://tools.ietf.org/html/r
fc6750#section-3.1"
< output truncated for brevity
```

API 用 403(禁止)响应了,因为`SCOTT`有一个`USER`角色，我们已经将这个 API 配置为只允许具有`ADMIN`角色的用户访问。

让我们使用拥有`ADMIN`角色的`SCOTT2`用户，用下面的代码再次创建一个令牌:

```java
$ curl -X POST 'http://localhost:8080/api/v1/auth/token' -H 'Content-Type: application/json' -H 'Accept: application/json' -d '{
    "username": "scott2",
    "password": "tiger"
}'
```

现在，让我们使用从`SCOTT2`登录接收的访问令牌再次调用`create address`API，如下面的代码片段所示:

```java
$ curl -X POST 'http://localhost:8080/api/v1/addresses' 
-H 'Content-Type: application/json' -H 'Accept: application/json' 
-H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9\.                          eyJzd
Rest of the token is truncated for brevity' -d '{
    "number": "9I-999",
    "residency": "Fraser Suites Le Claridge",
    "street": "Champs-Elysees",
    "city": "Paris",
    "state": "Ile-de-France",
    "country": "France",
    "pincode": "75008"
}'
< Response
{"_links":{"self":[{"href":"http://localhost:8080/b78d485e-16a0-4b11-98d2-6e4dadbc60e7"},{"href":"http://localhost:8080/api/v1/addresses/b78d485e-16a0-4b11-98d2-6e4dadbc60e7"}]},"id":"b78d48
5e-16a0-4b11-98d2-6e4dadbc60e7","number":"9I-999","residency":"Fraser Suites Le Claridge","street":"Champs-Elysees","city":"Paris","state":"Ile-de-France","country":"France","pincode":"75008
"}
```

https://github.com/PacktPublishing/Modern-API-Development-with-Spring-and-Spring-Boot/blob/main/Chapter06/Chapter06.postman_collection.json

同样，可以尝试使用 REST API 进行删除地址操作。这将只允许一个`ADMIN`角色执行操作。

您可以在以下位置找到本章 API 的 Postman (API 客户端)集合，该集合基于 Postman Collection 版。您可以导入它，然后测试 API。

# 总结

在本章中，您已经学习了 JWTs、Spring Security、使用过滤器的身份验证、使用过滤器的 JWT 令牌验证以及 Spring OAuth 2.0 Resource Server 的身份验证。您还了解了如何添加 CORS 和 CSRF 保护，以及这些保护的必要性。

您还了解了基于角色和权限的访问保护。现在，您已经掌握了实现 JWTs、Spring Security 和 Spring Security OAuth 2.0 资源服务器来保护 web 资源的技能。

在下一章中，您将使用本章中使用的 Spring 安全框架和 API 开发一个示例电子商务应用的 UI。这种集成将允许您理解 UI 流以及如何使用 JavaScript 使用 REST APIs。

# 问题

1.  什么是安全上下文和主体？
2.  签名或加密令牌是保护 JWT 的首选方式？
3.  使用 JWT 的最佳实践是什么？

# 延伸阅读

*   Hands-On Spring Security 5.x (video course):

    [https://www . packtpub . com/product/hands-on-spring-security-5-x-video/9781789802931](https://www.packtpub.com/product/hands-on-spring-security-5-x-video/9781789802931)

*   Spring Security documentation:

    [https://docs . spring . io/spring-security/site/docs/current/reference/html 5/](https://docs.spring.io/spring-security/site/docs/current/reference/html5/)

*   List of filters available in Spring Security:

    [https://docs . spring . io/spring-security/site/docs/current/reference/html 5/# servlet-security-filters](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-security-filters)

*   JWT:

    [https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)

*   JWS:

    [https://www.rfc-editor.org/info/rfc7515](https://www.rfc-editor.org/info/rfc7515)

*   JWE:

    [https://www.rfc-editor.org/info/rfc7516](https://www.rfc-editor.org/info/rfc7516)

*   Spring Security in-built SpEL expressions:

    [https://docs . spring . io/spring-security/site/docs/current/reference/html 5/# El-access](https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access)